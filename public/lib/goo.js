/* Goo Engine UNOFFICIAL
 * Copyright 2016 Goo Technologies AB
 */

/******/ (function(modules) { // webpackBootstrap
/******/ 	// install a JSONP callback for chunk loading
/******/ 	var parentJsonpFunction = window["webpackJsonp"];
/******/ 	window["webpackJsonp"] = function webpackJsonpCallback(chunkIds, moreModules) {
/******/ 		// add "moreModules" to the modules object,
/******/ 		// then flag all "chunkIds" as loaded and fire callback
/******/ 		var moduleId, chunkId, i = 0, callbacks = [];
/******/ 		for(;i < chunkIds.length; i++) {
/******/ 			chunkId = chunkIds[i];
/******/ 			if(installedChunks[chunkId])
/******/ 				callbacks.push.apply(callbacks, installedChunks[chunkId]);
/******/ 			installedChunks[chunkId] = 0;
/******/ 		}
/******/ 		for(moduleId in moreModules) {
/******/ 			modules[moduleId] = moreModules[moduleId];
/******/ 		}
/******/ 		if(parentJsonpFunction) parentJsonpFunction(chunkIds, moreModules);
/******/ 		while(callbacks.length)
/******/ 			callbacks.shift().call(null, __webpack_require__);
/******/ 		if(moreModules[0]) {
/******/ 			installedModules[0] = 0;
/******/ 			return __webpack_require__(0);
/******/ 		}
/******/ 	};

/******/ 	// The module cache
/******/ 	var installedModules = {};

/******/ 	// object to store loaded and loading chunks
/******/ 	// "0" means "already loaded"
/******/ 	// Array means "loading", array contains callbacks
/******/ 	var installedChunks = {
/******/ 		9:0
/******/ 	};

/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {

/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;

/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};

/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;

/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}

/******/ 	// This file contains only the entry chunk.
/******/ 	// The chunk loading function for additional chunks
/******/ 	__webpack_require__.e = function requireEnsure(chunkId, callback) {
/******/ 		// "0" is the signal for "already loaded"
/******/ 		if(installedChunks[chunkId] === 0)
/******/ 			return callback.call(null, __webpack_require__);

/******/ 		// an array means "currently loading".
/******/ 		if(installedChunks[chunkId] !== undefined) {
/******/ 			installedChunks[chunkId].push(callback);
/******/ 		} else {
/******/ 			// start chunk loading
/******/ 			installedChunks[chunkId] = [callback];
/******/ 			var head = document.getElementsByTagName('head')[0];
/******/ 			var script = document.createElement('script');
/******/ 			script.type = 'text/javascript';
/******/ 			script.charset = 'utf-8';
/******/ 			script.async = true;

/******/ 			script.src = __webpack_require__.p + "" + chunkId + ".out/" + ({"0":"ammopack","1":"animationpack","2":"box2dpack","3":"cannonpack","4":"debugpack","5":"fsmpack","6":"gamepadpack","7":"geometrypack","8":"gizmopack","10":"linerenderpack","11":"logicpack","12":"p2pack","13":"particlepack","14":"passpack","15":"physicspack","16":"quadpack","17":"scriptpack","18":"soundmanager2pack","19":"terrainpack","20":"timelinepack","21":"waterpack"}[chunkId]||chunkId) + ".js";
/******/ 			head.appendChild(script);
/******/ 		}
/******/ 	};

/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;

/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;

/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";

/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(300);


/***/ },
/* 1 */,
/* 2 */,
/* 3 */
/***/ function(module, exports, __webpack_require__) {

	var Scripts = __webpack_require__(4);
	var BoundingBox = __webpack_require__(7);
	var ObjectUtils = __webpack_require__(6);

	/**
	 * Utilities for entity creation etc
	 * Only used to define the class. Should never be instantiated.
	 */
	function EntityUtils() {}

	/**
	 * Returns a clone of the given SkeletonPose. Also stores the cloned poses into settings, in order not to
	 * clone multiple instances of the same SkeletonPose.
	 * @param {SkeletonPose} skeletonPose
	 * @param {Object} settings
	 */
	function cloneSkeletonPose(skeletonPose, settings) {
		settings.skeletonMap = settings.skeletonMap || {
			originals: [],
			clones: []
		};
		var idx = settings.skeletonMap.originals.indexOf(skeletonPose);
		var clonedSkeletonPose;
		if (idx === -1) {
			clonedSkeletonPose = skeletonPose.clone();
			settings.skeletonMap.originals.push(skeletonPose);
			settings.skeletonMap.clones.push(clonedSkeletonPose);
		} else {
			clonedSkeletonPose = settings.skeletonMap.clones[idx];
		}

		return clonedSkeletonPose;
	}

	//! AT: this is a huge mess
	// cloneEntity will only work for very few cases anyways, for very specific components
	function cloneEntity(world, entity, settings) {
		// settings is also used to store stuff on it, like animation skeletons
		var newEntity = world.createEntity(entity.name);

		newEntity._tags = ObjectUtils.cloneSet(entity._tags);
		newEntity._attributes = ObjectUtils.cloneMap(entity._attributes);
		newEntity._hidden = entity._hidden;
		newEntity.static = entity.static;

		for (var i = 0; i < entity._components.length; i++) {
			var component = entity._components[i];
			if (component.type === 'TransformComponent') {
				newEntity.transformComponent.transform.copy(component.transform);
			} else if (component.type === 'MeshDataComponent') {
				var clonedMeshDataComponent = component.clone(settings);
				if (component.currentPose) {
					clonedMeshDataComponent.currentPose = cloneSkeletonPose(component.currentPose, settings);
				}
				newEntity.setComponent(clonedMeshDataComponent);
			} else if (component.type === 'AnimationComponent') {
				var clonedAnimationComponent = component.clone();
				clonedAnimationComponent._skeletonPose = cloneSkeletonPose(component._skeletonPose, settings);
				newEntity.setComponent(clonedAnimationComponent);
			} else if (component.type === 'ScriptComponent') {
				var scriptComponent = new component.constructor();
				for (var j = 0; j < component.scripts.length; j++) {
					var newScript;
					var script = component.scripts[j];
					var key = script.externals ? script.externals.key || script.externals.name : null;
					if (key && Scripts.getScript(key)) { // Engine script
						newScript = Scripts.create(key, script.parameters);
					} else { // Custom script
						newScript = {
							externals: script.externals,
							name: (script.name || '') + '_clone',
							enabled: !!script.enabled
						};
						if (script.parameters) { newScript.parameters = ObjectUtils.deepClone(script.parameters); }

						if (script.setup) { newScript.setup = script.setup; }
						if (script.update) { newScript.update = script.update; }
						if (script.cleanup) { newScript.cleanup = script.cleanup; }
						if (script.fixedUpdate) { newScript.fixedUpdate = script.fixedUpdate; }
						if (script.lateUpdate) { newScript.lateUpdate = script.lateUpdate; }
						if (script.argsUpdated) { newScript.argsUpdated = script.argsUpdated; }
						if (script.enter) { newScript.enter = script.enter; }
						if (script.exit) { newScript.exit = script.exit; }

						scriptComponent.scripts.push(newScript);
					}
				}
				newEntity.setComponent(scriptComponent);
				if (world.getSystem('ScriptSystem').manualSetup && component.scripts[0].context) {
					scriptComponent.setup(newEntity);
				}
			} else if (component.clone) {
				newEntity.setComponent(component.clone(settings));
			} else {
				newEntity.setComponent(component);
			}
		}
		for (var j = 0; j < entity.transformComponent.children.length; j++) {
			var child = entity.transformComponent.children[j];
			var clonedChild = cloneEntity(world, child.entity, settings);
			newEntity.transformComponent.attachChild(clonedChild.transformComponent);
		}

		if (settings.callback) {
			settings.callback(newEntity);
		}

		return newEntity;
	}

	/**
	 * Clone entity hierarchy with optional settings for sharing data and callbacks.
	 * @param {World} world
	 * @param {Entity} entity The entity to clone
	 * @param {Object} [settings]
	 * @param {boolean} [settings.shareMeshData=false] Cloning entities clones their mesh data by default
	 * @param {boolean} [settings.shareMaterials=false] Cloning entities clones their materials by default
	 * @param {boolean} [settings.shareUniforms=false] Cloning entities clones their materials' uniforms by default
	 * @param {boolean} [settings.shareTextures=false] Cloning entities clones their materials' textures by default
	 * @param {function (entity: Entity)} [settings.callback] Callback to be run on every new entity. Takes entity as argument. Runs bottom to top in the cloned hierarchy.
	 * @returns {Entity} The cloned entity.
	 */
	EntityUtils.clone = function (world, entity, settings) {
		settings = settings || {};
		// REVIEW: It's bad style to modify the settings object provided by the caller.
		// I.e. if the caller does:
		//   var s = {};
		//   EntityUtils.clone(w, e, s);
		// ...he wouldn't expect s to have changed.
		// REVIEW: `settings.shareData || true` will evaluate to true if shareData is false,
		// which means that the setting will always be true.
		//settings.shareData = settings.shareData || true;
		//settings.shareMaterial = settings.shareMaterial || true;  // REVIEW: these are not used nor documented but would be great if they were
		//settings.cloneHierarchy = settings.cloneHierarchy || true;

		//! AT: why is everything here overridden anyways?
		// Why is this function just defaulting some parameters and then calling cloneEntity to do the rest?

		return cloneEntity(world, entity, settings);
	};

	/**
	 * Traverse the entity hierarchy upwards, returning the root entity
	 * @param {Entity} entity The entity to begin traversing from
	 * @returns {Entity} The root entity
	 */
	EntityUtils.getRoot = function (entity) {
		while (entity.transformComponent.parent) {
			entity = entity.transformComponent.parent.entity;
		}
		return entity;
	};

	/**
	 * @deprecated Deprecated with warning on 2016-04-06
	 */
	EntityUtils.updateWorldTransform = ObjectUtils.warnOnce('EntityUtils.updateWorldTransform is deprecated. Please use entity.transformComponent.sync instead', function (transformComponent) {
		transformComponent.updateWorldTransform();

		for (var i = 0; i < transformComponent.children.length; i++) {
			EntityUtils.updateWorldTransform(transformComponent.children[i]);
		}
	});

	/**
	 * Returns the merged bounding box of the entity and its children
	 * @param entity
	 */
	EntityUtils.getTotalBoundingBox = function (entity) {
		var mergedWorldBound = new BoundingBox();
		var first = true;
		entity.traverse(function (entity) {
			if (entity.meshRendererComponent) {
				if (first) {
					var boundingVolume = entity.meshRendererComponent.worldBound;
					if (boundingVolume instanceof BoundingBox) {
						mergedWorldBound.copy(boundingVolume);
					} else {
						mergedWorldBound.center.set(boundingVolume.center);
						mergedWorldBound.xExtent = mergedWorldBound.yExtent = mergedWorldBound.zExtent = boundingVolume.radius;
					}
					first = false;
				} else {
					mergedWorldBound.merge(entity.meshRendererComponent.worldBound);
				}
			}
		});

		// if the whole hierarchy lacked mesh renderer components return
		// a tiny bounding box centered around the coordinates of the parent
		if (first) {
			var translation = entity.transformComponent.worldTransform.translation;
			mergedWorldBound = new BoundingBox(translation.clone(), 0.001, 0.001, 0.001);
		}

		return mergedWorldBound;
	};

	module.exports = EntityUtils;


/***/ },
/* 4 */
/***/ function(module, exports, __webpack_require__) {

	var ScriptUtils = __webpack_require__(5);
	var ObjectUtils = __webpack_require__(6);

	// the collection of scripts
	var _scripts = {};

	// the static class which just holds the following methods
	var Scripts = {};

	Scripts.register = function (factoryFunction) {
		var key = factoryFunction.externals.key || factoryFunction.externals.name;
		if (_scripts[key]) {
			console.warn('Script already registered for key ' + key);
			return;
		}
		//! AT: this will modify the external object but that's ok
		ScriptUtils.fillDefaultNames(factoryFunction.externals.parameters);
		_scripts[key] = factoryFunction;
	};

	Scripts.addClass = ObjectUtils.warnOnce(
		'Scripts.addClass is deprecated; please consider using the global goo object instead',
		function (/* name, klass */) {
			// deprecated as of v0.15.3 and scheduled for removal in version 0.17.0
		}
	);

	Scripts.getClasses = ObjectUtils.warnOnce(
		'Scripts.getClasses is deprecated; please consider using the global goo object instead',
		function () {
			return window.goo;
		}
	);

	Scripts.getScript = function (key) {
		return _scripts[key];
	};

	Scripts.create = function (key, options) {
		var factoryFunction;
		if (typeof key === 'string') {
			factoryFunction = _scripts[key];
			if (!factoryFunction) {
				throw new Error('Script "' + key + '" is not registered');
			}
		} else if (typeof key === 'function') {
			factoryFunction = key;
		}

		var script = factoryFunction();
		script.parameters = {};
		script.environment = null;
		script.externals = factoryFunction.externals;

		if (factoryFunction.externals) {
			ScriptUtils.fillDefaultNames(script.externals.parameters);
			ScriptUtils.fillDefaultValues(script.parameters, factoryFunction.externals.parameters);
		}

		if (options) {
			ObjectUtils.extend(script.parameters, options);
		}

		return script;
	};

	Scripts.allScripts = function () {
		// REVIEW: Why not return _scripts? Document this function.
		var scripts = {};
		var keys = Object.keys(_scripts);
		for (var i = 0; i < keys.length; i++) {
			var key = keys[i];
			scripts[key] = _scripts[key];
		}
		return scripts;
	};

	module.exports = Scripts;


/***/ },
/* 5 */
/***/ function(module, exports, __webpack_require__) {

	var ObjectUtils = __webpack_require__(6);

	function ScriptUtils() {}

	ScriptUtils.DEFAULTS_BY_TYPE = {
		'array': [],
		'float': 0,
		'int': 0,
		'string': '',
		'vec2': [0, 0],
		'vec3': [0, 0, 0],
		'vec4': [0, 0, 0, 0],
		'boolean': false,
		'animation': null,
		'camera': null,
		'entity': null,
		'image': null,
		'sound': null,
		'texture': null,
		'json': null,
		'text': null
	};

	ScriptUtils.REF_TYPES = [
		'animation',
		'camera',
		'entity',
		'image',
		'sound',
		'texture',
		'json',
		'text'
	];

	ScriptUtils.isRefType = function (type) {
		return ObjectUtils.contains(ScriptUtils.REF_TYPES, type);
	};

	ScriptUtils.TYPE_VALIDATORS = (function () {
		var isVec = function (length) {
			return function (data) {
				return Array.isArray(data) && data.length === length;
			};
		};

		var isRef = function (type) {
			function isDirectRef(data) {
				return ObjectUtils.isString(data) && ObjectUtils.getExtension(data) === type;
			}

			// Checks for references passed like:
			// {
			//     entityRef: string
			//     enabled: boolean
			// }
			function isWrappedRef(data) {
				return data && isDirectRef(data[type + 'Ref']);
			}

			return function (data) {
				return isDirectRef(data) || isWrappedRef(data);
			};
		};

		return {
			'array': ObjectUtils.isArray,
			'float': ObjectUtils.isNumber,
			'number': ObjectUtils.isNumber,
			'string': ObjectUtils.isString,
			'boolean': ObjectUtils.isBoolean,
			'int': ObjectUtils.isInteger,
			'vec2': isVec(2),
			'vec3': isVec(3),
			'vec4': isVec(4),
			'animation': isRef('animation'),
			'camera': isRef('camera'),
			'entity': isRef('entity'),
			'image': isRef('image'),
			'sound': isRef('sound'),
			'texture': isRef('texture'),
			'json': isRef('json'),
			'text': isRef('text')
		};
	})();

	// The types that are allowed for script parameters.
	ScriptUtils.PARAMETER_TYPES = [
		'string',
		'int',
		'float',
		'vec2',
		'vec3',
		'vec4',
		'boolean',
		'texture',
		'sound',
		'camera',
		'entity',
		'animation',
		'json',
		'text'
	];

	// Specifies which controls can be used with each type.
	ScriptUtils.PARAMETER_CONTROLS = (function () {
		var typeControls = {
			'string': ['key'],
			'int': ['spinner', 'slider', 'jointSelector'],
			'float': ['spinner', 'slider'],
			'vec2': [],
			'vec3': ['color'],
			'vec4': ['color'],
			'boolean': ['checkbox'],
			'texture': [],
			'sound': [],
			'camera': [],
			'entity': [],
			'animation': [],
			'json': [],
			'text': []
		};

		// Add the controls that can be used with any type to the mapping of
		// controls that ca be used for each type.
		for (var type in typeControls) {
			Array.prototype.push.apply(typeControls[type], ['dropdown', 'select']);
		}

		return typeControls;
	})();

	// Types used to validate the properties of a script parameter config.
	ScriptUtils.PROPERTY_TYPES = [
		{
			prop: 'key',
			type: 'string',
			mustBeDefined: true,
			minLength: 1
		},
		{
			prop: 'type',
			type: 'string',
			mustBeDefined: true,
			minLength: 1,
			getAllowedValues: function () {
				return ScriptUtils.PARAMETER_TYPES;
			}
		},
		{
			prop: 'control',
			type: 'string',
			getAllowedValues: function (parameter) {
				// Allowed controls depend on the parameter type.
				return ScriptUtils.PARAMETER_CONTROLS[parameter.type];
			}
		},
		{ prop: 'name', type: 'string' },
		{ prop: 'min', type: 'number' },
		{ prop: 'max', type: 'number' },
		{ prop: 'scale', type: 'number' },
		{ prop: 'decimals', type: 'number' },
		{ prop: 'precision', type: 'number' },
		{ prop: 'exponential', type: 'boolean' }
	];

	/**
	 * Fill a passed parameters object with defaults from spec
	 * @hidden
	 * @param parameters {Object} The type of object passed as parameters to a script
	 * @param specs {Array<{key, name, default, description}>}
	 */
	ScriptUtils.fillDefaultValues = function (parameters, specs) {
		if (!(specs instanceof Array)) { return; }

		var keys = [];
		specs.forEach(function (spec) {
			if (!spec || typeof spec.key !== 'string') {
				return;
			}

			if (spec.default === null || spec.default === undefined) {
				spec.default = ObjectUtils.deepClone(ScriptUtils.DEFAULTS_BY_TYPE[spec.type]);
			}

			keys.push(spec.key);
			if (typeof parameters[spec.key] === 'undefined') {
				parameters[spec.key] = ObjectUtils.clone(spec.default);
			}
		});

		//! AT: when does this ever happen?
		for (var key in parameters) {
			if (keys.indexOf(key) === -1 && key !== 'enabled') {
				delete parameters[key];
			}
		}
	};

	/**
	 * Fills specs' names with their prettyprinted keys (x -> x, maxX -> Max X, myBluePanda -> My Blue Panda)
	 * @hidden
	 * @param specs {Array<{key, name, default, description}>}
	 */
	ScriptUtils.fillDefaultNames = function (specs) {
		if (!(specs instanceof Array)) { return; }

		function getNameFromKey(key) {
			if (typeof key !== 'string' || key.length === 0) { return ''; }
			var capitalisedKey = key[0].toUpperCase() + key.slice(1);
			return capitalisedKey.replace(/(.)([A-Z])/g, '$1 $2');
		}

		specs.forEach(function (spec) {
			if (!spec) { return; }
			if (typeof spec.name === 'undefined') {
				spec.name = getNameFromKey(spec.key);
			}
		});
	};

	// TODO Copied from FSMUtils. Should be put in another util
	// And keys should probably be defined ScriptUtil.keys.BackSpace = 'BackSpace';
	ScriptUtils.getKey = function (str) {
		if (ScriptUtils._keys[str]) {
			return ScriptUtils._keys[str];
		} else {
			return str.charCodeAt(0);
		}
	};

	ScriptUtils._keys = {
		'Backspace': 8,
		'Tab': 9,
		'Enter': 13,
		'Shift': 16,
		'Ctrl': 17,
		'Alt': 18,
		'Meta': 91,
		'Pause': 19,
		'Capslock': 20,
		'Esc': 27,
		'Space': 32,
		'Pageup': 33,
		'Pagedown': 34,
		'End': 35,
		'Home': 36,
		'Leftarrow': 37,
		'Uparrow': 38,
		'Rightarrow': 39,
		'Downarrow': 40,
		'Insert': 45,
		'Delete': 46,
		'0': 48,
		'1': 49,
		'2': 50,
		'3': 51,
		'4': 52,
		'5': 53,
		'6': 54,
		'7': 55,
		'8': 56,
		'9': 57,
		'a': 65,
		'b': 66,
		'c': 67,
		'd': 68,
		'e': 69,
		'f': 70,
		'g': 71,
		'h': 72,
		'i': 73,
		'j': 74,
		'k': 75,
		'l': 76,
		'm': 77,
		'n': 78,
		'o': 79,
		'p': 80,
		'q': 81,
		'r': 82,
		's': 83,
		't': 84,
		'u': 85,
		'v': 86,
		'w': 87,
		'x': 88,
		'y': 89,
		'z': 90,
		'A': 65,
		'B': 66,
		'C': 67,
		'D': 68,
		'E': 69,
		'F': 70,
		'G': 71,
		'H': 72,
		'I': 73,
		'J': 74,
		'K': 75,
		'L': 76,
		'M': 77,
		'N': 78,
		'O': 79,
		'P': 80,
		'Q': 81,
		'R': 82,
		'S': 83,
		'T': 84,
		'U': 85,
		'V': 86,
		'W': 87,
		'X': 88,
		'Y': 89,
		'Z': 90,
		'0numpad': 96,
		'1numpad': 97,
		'2numpad': 98,
		'3numpad': 99,
		'4numpad': 100,
		'5numpad': 101,
		'6numpad': 102,
		'7numpad': 103,
		'8numpad': 104,
		'9numpad': 105,
		'Multiply': 106,
		'Plus': 107,
		'Minus': 109,
		'Dot': 110,
		'Slash1': 111,
		'F1': 112,
		'F2': 113,
		'F3': 114,
		'F4': 115,
		'F5': 116,
		'F6': 117,
		'F7': 118,
		'F8': 119,
		'F9': 120,
		'F10': 121,
		'F11': 122,
		'F12': 123,
		'Equals': 187,
		'Comma': 188,
		'Slash': 191,
		'Backslash': 220
	};

	ScriptUtils._keyInverse = (function (assoc) {
		var inverseAssoc = {};

		var keys = Object.keys(assoc);
		for (var i = 0; i < keys.length; i++) {
			inverseAssoc[assoc[keys[i]]] = keys[i];
		}
		return inverseAssoc;
	}(ScriptUtils._keys));

	ScriptUtils.keyForCode = function (code) {
		return ScriptUtils._keyInverse[code];
	};

	module.exports = ScriptUtils;


/***/ },
/* 6 */
/***/ function(module, exports) {

	function ObjectUtils() {}

	/**
	 * Gets whether the specified array contains the specified value.
	 * @param {Array} array The array which is to be checked.
	 * @param {*} value The value which is to be found.
	 * @returns {boolean}
	 *         True if the value exists in the array and false otherwise.
	 */
	ObjectUtils.contains = function (array, value) {
		return array.indexOf(value) !== -1;
	};

	/**
	 * Gets the first item in an array that matches the specified predicate.
	 *
	 * @param {Array} array
	 *        The array which is to be searched.
	 * @param {Function} predicate
	 *        The preficate which will receive each item of the array and the
	 *        current index.
	 *
	 * @return {*}
	 *         The first item that matches the predicate or undefined if no
	 *         items matched the predicate.
	 */
	ObjectUtils.find = function (array, predicate) {
		for (var i = 0; i < array.length; ++i) {
			var item = array[i];
			if (predicate(item, i)) {
				return item;
			}
		}

		return undefined;
	};

	/**
	 * Copies properties from an object onto another object if they're not already present
	 * @param {Object} destination Destination object to copy to
	 * @param {Object} source Source object to copy from
	 * @returns {Object} Returns the destination object
	 */
	ObjectUtils.defaults = function (destination, source) {
		var keys = Object.keys(source);
		for (var i = 0; i < keys.length; i++) {
			var key = keys[i];
			if (typeof destination[key] === 'undefined' || destination[key] === null) {
				destination[key] = source[key];
			}
		}

		return destination;
	};

	/**
	 * Merges an options object and a defaults object into another object
	 * @param destination Object to attach properties to
	 * @param options A list of options; options must eb a subset of defaults
	 * @param defaults Defaults for options; if an option if not present this value is used instead
	 * @returns {Object} Returns the destination object
	 */
	ObjectUtils.copyOptions = function (destination, options, defaults) {
		var keys = Object.keys(defaults);

		if (options) {
			for (var i = 0; i < keys.length; i++) {
				var key = keys[i];
				var option = options[key];
				destination[key] = typeof option === 'undefined' || option === null ?
					defaults[key] :
					option;
			}
		} else {
			ObjectUtils.extend(destination, defaults);
		}

		return destination;
	};

	/**
	 * Copies properties from an object onto another object; overwrites existing properties
	 * @param {Object} destination Destination object to copy to
	 * @param {Object} source Source object to copy from
	 * @returns {Object} Returns the destination object
	 */
	ObjectUtils.extend = function (destination, source) {
		if (!source) { return; }

		var keys = Object.keys(source);
		for (var i = 0; i < keys.length; i++) {
			var key = keys[i];
			destination[key] = source[key];
		}

		return destination;
	};

	// Create a (shallow-cloned) duplicate of an object.
	ObjectUtils.clone = function (obj) {
		if (!ObjectUtils.isObject(obj)) { return obj; }
		return Array.isArray(obj) ? obj.slice() : ObjectUtils.extend({}, obj);
	};

	// Save bytes in the minified (but not gzipped) version:
	var nativeForEach = Array.prototype.forEach;

	// The cornerstone, an `each` implementation, aka `forEach`.
	// Handles objects with the built-in `forEach`, arrays, and raw objects.
	// Delegates to **ECMAScript 5**'s native `forEach` if available.
	ObjectUtils.each = ObjectUtils.forEach = function (obj, iterator, context, sortProp) {
		if (typeof obj === 'undefined' || obj === null) { return; }
		if (nativeForEach && obj.forEach === nativeForEach) {
			obj.forEach(iterator, context);
		} else if (obj.length === +obj.length) {
			for (var i = 0, l = obj.length; i < l; i++) {
				iterator.call(context, obj[i], i, obj);
			}
		} else {
			var keys = Object.keys(obj);
			if (sortProp !== undefined) {
				keys.sort(function (a, b) {
					return obj[a][sortProp] - obj[b][sortProp];
				});
			}
			for (var i = 0, length = keys.length; i < length; i++) {
				iterator.call(context, obj[keys[i]], keys[i], obj);
			}
		}
	};

	/**
	 * Creates an array of values by running each element in collection through
	 * iteratee. The iteratee is bound to context and invoked with three
	 * arguments: (value, index|key, collection).
	 *
	 * @param {(Array|Object|string)} collection
	 * @param {Function} iteratee
	 * @param {*} context
	 * @param {string} sortProp
	 *
	 * @returns {Array}
	 */
	ObjectUtils.map = function (collection, iteratee, context, sortProp) {
		var result = [];

		ObjectUtils.forEach(collection, function (value, key) {
			result.push(iteratee.call(context, value, key, collection));
		}, context, sortProp);

		return result;
	};

	/**
	 * Performs a deep clone. Can handle primitive types, arrays, generic
	 * objects, typed arrays and html nodes. Functions are shared. Does not
	 * handle circular references - also does not preserve original
	 * constructors/prototypes.
	 *
	 * @param {*} object Object to clone
	 * @returns {*}
	 */
	ObjectUtils.deepClone = function (object) {
		// handle primitive types, functions, null and undefined
		if (object === null || typeof object !== 'object') {
			return object;
		}

		// handle typed arrays
		if (Object.prototype.toString.call(object.buffer) === '[object ArrayBuffer]') {
			return new object.constructor(object);
		}

		// handle arrays (even sparse ones)
		if (object instanceof Array) {
			return object.map(ObjectUtils.deepClone);
		}

		// handle html nodes
		if (object.nodeType && typeof object.cloneNode === 'function') {
			return object.cloneNode(true);
		}

		// handle generic objects
		// prototypes and constructors will not match in the clone
		var copy = {};
		var keys = Object.keys(object);
		for (var i = 0; i < keys.length; i++) {
			var key = keys[i];
			copy[key] = ObjectUtils.deepClone(object[key]);
		}
		return copy;
	};

	ObjectUtils.shallowSelectiveClone = function (source, keys) {
		var clone = {};

		keys.forEach(function (key) {
			clone[key] = source[key];
		});

		return clone;
	};

	// probably not the best way to copy maps and sets
	ObjectUtils.cloneMap = function (source) {
		var clone = new Map();
		source.forEach(function (value, key) {
			clone.set(key, value);
		});
		return clone;
	};

	ObjectUtils.cloneSet = function (source) {
		var clone = new Set();
		source.forEach(function (value) {
			clone.add(value);
		});
		return clone;
	};

	ObjectUtils.warnOnce = function (message, fun) {
		var warned = false;
		return function () {
			if (!warned) {
				console.warn(message);
				warned = true;
			}

			return fun.apply(this, arguments);
		};
	};

	/**
	 * Creates a function which returns the provided value.
	 *
	 * @param {*} value Value which is to be returned by the created function.
	 *
	 * @returns {Function}
	 */
	ObjectUtils.constant = function (value) {
		return function () { return value; };
	};

	/**
	 * Creates a function which returns the specified property of any object
	 * passed to it.
	 *
	 * @param {string} propName Name of the property whose value is to be returned by the created function
	 *
	 * @returns {Function}
	 */
	ObjectUtils.property = function (propName) {
		return function (obj) { return obj[propName]; };
	};

	/**
	 * Gets whether the specified value is an array.
	 *
	 * @param {*} value Value which is to be tested.
	 *
	 * @returns {boolean} True if the value is an array and false otherwise.
	 */
	ObjectUtils.isArray = function (value) {
		return Array.isArray(value);
	};

	/**
	 * Gets whether the specified value is an object.
	 *
	 * @param {*} value Value which is to be tested.
	 *
	 * @returns {boolean} True if the value is an object and false otherwise.
	 */
	ObjectUtils.isObject = function (value) {
		return value === Object(value);
	};

	/**
	 * Gets whether the specified value is a string.
	 *
	 * @param {*} value Value which is to be tested.
	 *
	 * @returns {boolean} True if the value is a string and false otherwise.
	 */
	ObjectUtils.isString = function (value) {
		return typeof value === 'string';
	};

	/**
	 * Gets whether the specified value is an boolean value.
	 *
	 * @param {*} value Value which is to be tested.
	 *
	 * @returns {boolean} True if the value is a boolean and false otherwise.
	 */
	ObjectUtils.isBoolean = function (value) {
		return value === true || value === false;
	};

	/**
	 * Gets whether the specified value is a number.
	 *
	 * @param {*} value Value which is to be tested.
	 *
	 * @returns {boolean} True if the value is a number and false otherwise.
	 */
	ObjectUtils.isNumber = function (value) {
		return typeof value === 'number';
	};

	/**
	 * Gets whether the specified value is an integer number.
	 *
	 * @param {*} value Value which is to be tested.
	 *
	 * @returns {boolean} True if the value is an integer number and false otherwise.
	 */
	ObjectUtils.isInteger = function (value) {
		return ObjectUtils.isNumber(value) && value % 1 === 0;
	};

	/**
	 * Gets the extension of the specified string. The extension is anything
	 * after the last '.'
	 *
	 * @param {*} value Value whose extension is to be returned.
	 *
	 * @returns {string}
	 */
	ObjectUtils.getExtension = function (value) {
		if (ObjectUtils.isString(value)) {
			var dotIndex = value.lastIndexOf('.');
			if (dotIndex >= -1) {
				return value.substr(dotIndex + 1).toLowerCase();
			}
		}

		return '';
	};

	module.exports = ObjectUtils;


/***/ },
/* 7 */
/***/ function(module, exports, __webpack_require__) {

	var Vector3 = __webpack_require__(8);
	var BoundingVolume = __webpack_require__(12);
	var BoundingSphere = __webpack_require__(13);
	var MathUtils = __webpack_require__(9);

	/**
	 * <code>BoundingBox</code> defines an axis-aligned cube that defines a container for a group of vertices of a
	 * particular piece of geometry. This box defines a center and extents from that center along the x, y and z axis. <br>
	 *        <br>
	 *        A typical usage is to allow the class define the center and radius by calling either <code>containAABB</code> or
	 *        <code>averagePoints</code>. A call to <code>computeFramePoint</code> in turn calls <code>containAABB</code>.
	 */
	function BoundingBox(center, xExtent, yExtent, zExtent) {
		BoundingVolume.call(this, center);

		// x/y/z Extent is actually width/height/depth * 0.5
		this.xExtent = xExtent !== undefined ? xExtent : 1;
		this.yExtent = yExtent !== undefined ? yExtent : 1;
		this.zExtent = zExtent !== undefined ? zExtent : 1;

		// @ifdef DEBUG
		Object.seal(this);
		// @endif
	}

	var tmpVec1 = new Vector3();
	var tmpVec2 = new Vector3();
	var tmpVec3 = new Vector3();

	var tmpCorners = [];
	for (var i = 0; i < 8; i++) {
		tmpCorners.push(new Vector3());
	}

	BoundingBox.prototype = Object.create(BoundingVolume.prototype);
	BoundingBox.prototype.constructor = BoundingBox;

	BoundingBox.prototype.computeFromPoints = function (verts) {
		var l = verts.length;
		if (l < 3) {
			return;
		}

		var min = this.min;
		var max = this.max;
		var vec = tmpVec3;

		min.setDirect(verts[0], verts[1], verts[2]);
		max.setDirect(verts[0], verts[1], verts[2]);
		var x, y, z;
		for (var i = 3; i < l; i += 3) {
			x = verts[i + 0];
			y = verts[i + 1];
			z = verts[i + 2];
			min.x = x < min.x ? x : min.x;
			min.y = y < min.y ? y : min.y;
			min.z = z < min.z ? z : min.z;
			max.x = x > max.x ? x : max.x;
			max.y = y > max.y ? y : max.y;
			max.z = z > max.z ? z : max.z;
		}

		vec.set(max).sub(min).scale(0.5);
		this.xExtent = vec.x;
		this.yExtent = vec.y;
		this.zExtent = vec.z;

		this.center.set(max).add(min).scale(0.5);
	};

	/**
	 * Method to test whether a point is inside the bounding box or not
	 * @param {Vector3} point
	 * @returns {boolean}
	 */
	BoundingBox.prototype.containsPoint = function (point) {
		var center = this.center;
		var x = point.x - center.x;
		var y = point.y - center.y;
		var z = point.z - center.z;

		return x >= -this.xExtent && x <= this.xExtent &&
			y >= -this.yExtent && y <= this.yExtent &&
			z >= -this.zExtent && z <= this.zExtent;
	};

	var tmpArray = [];

	BoundingBox.prototype.computeFromPrimitives = function (data, section, indices, start, end) {
		if (end - start <= 0) {
			return;
		}

		var min = tmpVec1.setDirect(Infinity, Infinity, Infinity);
		var max = tmpVec2.setDirect(-Infinity, -Infinity, -Infinity);

		var store = tmpArray;
		store.length = 0;

		for (var i = start; i < end; i++) {
			store = data.getPrimitiveVertices(indices[i], section, store);
			for (var j = 0; j < store.length; j++) {
				BoundingBox.checkMinMax(min, max, store[j]);
			}
		}

		this.center.copy(min.add(max));
		this.center.scale(0.5);

		this.xExtent = max.x - this.center.x;
		this.yExtent = max.y - this.center.y;
		this.zExtent = max.z - this.center.z;
	};

	BoundingBox.checkMinMax = function (min, max, point) {
		if (point.x < min.x) {
			min.x = point.x;
		}
		if (point.x > max.x) {
			max.x = point.x;
		}

		if (point.y < min.y) {
			min.y = point.y;
		}
		if (point.y > max.y) {
			max.y = point.y;
		}

		if (point.z < min.z) {
			min.z = point.z;
		}
		if (point.z > max.z) {
			max.z = point.z;
		}
	};

	BoundingBox.prototype.transform = function (transform, box) {
		if (box === null) {
			box = new BoundingBox();
		}

		var corners = tmpCorners;
		this.getCorners(corners);

		// Transform all of these points by the transform
		for (var i = 0; i < 8; i++) {
			corners[i].applyPostPoint(transform.matrix);
		}
		// Now compute based on these transformed points
		var minX = corners[0].x;
		var minY = corners[0].y;
		var minZ = corners[0].z;
		var maxX = minX;
		var maxY = minY;
		var maxZ = minZ;
		for (var i = 1; i < 8; i++) {
			var curX = corners[i].x;
			var curY = corners[i].y;
			var curZ = corners[i].z;
			minX = Math.min(minX, curX);
			minY = Math.min(minY, curY);
			minZ = Math.min(minZ, curZ);
			maxX = Math.max(maxX, curX);
			maxY = Math.max(maxY, curY);
			maxZ = Math.max(maxZ, curZ);
		}

		var ctrX = (maxX + minX) * 0.5;
		var ctrY = (maxY + minY) * 0.5;
		var ctrZ = (maxZ + minZ) * 0.5;

		box.center.setDirect(ctrX, ctrY, ctrZ);
		box.xExtent = maxX - ctrX;
		box.yExtent = maxY - ctrY;
		box.zExtent = maxZ - ctrZ;

		return box;
	};

	BoundingBox.prototype.getCorners = function (store) {
		var xExtent = this.xExtent;
		var yExtent = this.yExtent;
		var zExtent = this.zExtent;
		var centerData = this.center;
		store[0].setDirect(centerData.x + xExtent, centerData.y + yExtent, centerData.z + zExtent);
		store[1].setDirect(centerData.x + xExtent, centerData.y + yExtent, centerData.z - zExtent);
		store[2].setDirect(centerData.x + xExtent, centerData.y - yExtent, centerData.z + zExtent);
		store[3].setDirect(centerData.x + xExtent, centerData.y - yExtent, centerData.z - zExtent);
		store[4].setDirect(centerData.x - xExtent, centerData.y + yExtent, centerData.z + zExtent);
		store[5].setDirect(centerData.x - xExtent, centerData.y + yExtent, centerData.z - zExtent);
		store[6].setDirect(centerData.x - xExtent, centerData.y - yExtent, centerData.z + zExtent);
		store[7].setDirect(centerData.x - xExtent, centerData.y - yExtent, centerData.z - zExtent);
		return store;
	};

	BoundingBox.prototype.whichSide = function (plane) {
		var planeData = plane.normal;
		var pointData = this.center;

		var radius = Math.abs(this.xExtent * planeData.x) +
			Math.abs(this.yExtent * planeData.y) +
			Math.abs(this.zExtent * planeData.z);

		var distance = planeData.x * pointData.x +
			planeData.y * pointData.y +
			planeData.z * pointData.z -
			plane.constant;

		if (distance < -radius) {
			return BoundingVolume.Inside;
		} else if (distance > radius) {
			return BoundingVolume.Outside;
		} else {
			return BoundingVolume.Intersects;
		}
	};

	BoundingBox.prototype._pseudoDistance = function (plane, point) {
		var planeData = plane.normal;
		var pointData = point;

		return planeData.x * pointData.x + planeData.y * pointData.y + planeData.z * pointData.z - plane.constant;
	};

	BoundingBox.prototype._maxAxis = function (scale) {
		return Math.max(Math.abs(scale.x), Math.max(Math.abs(scale.y), Math.abs(scale.z)));
	};

	BoundingBox.prototype.toString = function () {
		var x = Math.round(this.center.x * 10) / 10;
		var y = Math.round(this.center.y * 10) / 10;
		var z = Math.round(this.center.z * 10) / 10;

		return '[' + x + ',' + y + ',' + z + ']' + ' - ' + '[' + this.xExtent + ',' + this.yExtent + ',' + this.zExtent + ']';
	};

	BoundingBox.prototype.intersects = function (bv) {
		return bv.intersectsBoundingBox(this);
	};

	BoundingBox.prototype.intersectsBoundingBox = function (bb) {
		// TODO: use this.min/max instead of center-extent diffs
		if (this.center.x + this.xExtent < bb.center.x - bb.xExtent || this.center.x - this.xExtent > bb.center.x + bb.xExtent) {
			return false;
		} else if (this.center.y + this.yExtent < bb.center.y - bb.yExtent || this.center.y - this.yExtent > bb.center.y + bb.yExtent) {
			return false;
		} else if (this.center.z + this.zExtent < bb.center.z - bb.zExtent || this.center.z - this.zExtent > bb.center.z + bb.zExtent) {
			return false;
		} else {
			return true;
		}
	};

	BoundingBox.prototype.intersectsSphere = function (bs) {
		// this.min/max aren't updated properly; have to do it here for now
		this.min.x = this.center.x - this.xExtent;
		this.min.y = this.center.y - this.yExtent;
		this.min.z = this.center.z - this.zExtent;

		this.max.x = this.center.x + this.xExtent;
		this.max.y = this.center.y + this.yExtent;
		this.max.z = this.center.z + this.zExtent;

		var rs = Math.pow(bs.radius, 2);
		var dmin = 0;

		if (bs.center.x < this.min.x) {
			dmin += Math.pow(bs.center.x - this.min.x, 2);
		} else if (bs.center.x > this.max.x) {
			dmin += Math.pow(bs.center.x - this.max.x, 2);
		}

		if (bs.center.y < this.min.y) {
			dmin += Math.pow(bs.center.y - this.min.y, 2);
		} else if (bs.center.y > this.max.y) {
			dmin += Math.pow(bs.center.y - this.max.y, 2);
		}

		if (bs.center.z < this.min.z) {
			dmin += Math.pow(bs.center.z - this.min.z, 2);
		} else if (bs.center.z > this.max.z) {
			dmin += Math.pow(bs.center.z - this.max.z, 2);
		}

		return dmin <= rs;
	};

	BoundingBox.prototype.testStaticAABBAABB = function (bb, contact) {
		var a = this;
		var b = bb;

		// [Minimum Translation Vector]
		var mtvInfo = {
			mtvDistance: 10000000000, // Set current minimum distance (max float value so next value is always less)
			mtvAxis: new Vector3()
			// Axis along which to travel with the minimum distance
		};

		// [Axes of potential separation]
		// * Each shape must be projected on these axes to test for intersection:
		//
		// (1, 0, 0) A0 (= B0) [X Axis]
		// (0, 1, 0) A1 (= B1) [Y Axis]
		// (0, 0, 1) A1 (= B2) [Z Axis]

		// [X Axis]
		if (!this.testAxisStatic(Vector3.UNIT_X, a.center.x - a.xExtent, a.center.x + a.xExtent, b.center.x - b.xExtent, b.center.x + b.xExtent,
			mtvInfo)) {
			return false;
		}

		// [Y Axis]
		if (!this.testAxisStatic(Vector3.UNIT_Y, a.center.y - a.yExtent, a.center.y + a.yExtent, b.center.y - b.yExtent, b.center.y + b.yExtent,
			mtvInfo)) {
			return false;
		}

		// [Z Axis]
		if (!this.testAxisStatic(Vector3.UNIT_Z, a.center.z - a.zExtent, a.center.z + a.zExtent, b.center.z - b.zExtent, b.center.z + b.zExtent,
			mtvInfo)) {
			return false;
		}

		if (contact) {
			contact.isIntersecting = true;

			// Calculate Minimum Translation Vector (MTV) [normal * penetration]
			// contact.normal = mtvInfo.mtvAxis.normalize();
			contact.normal = mtvInfo.mtvAxis;

			// Multiply the penetration depth by itself plus a small increment
			// When the penetration is resolved using the MTV, it will no longer intersect
			contact.penetration = Math.sqrt(mtvInfo.mtvDistance) * 1.001;
			// contact.penetration = mtvInfo.mtvDistance * 1.001;
		}

		return true;
	};

	BoundingBox.prototype.testAxisStatic = function (axis, minA, maxA, minB, maxB, mtvInfo) {
		// [Separating Axis Theorem]
		// * Two convex shapes only overlap if they overlap on all axes of separation
		// * In order to create accurate responses we need to find the collision vector (Minimum Translation Vector)
		// * Find if the two boxes intersect along a single axis
		// * Compute the intersection interval for that axis
		// * Keep the smallest intersection/penetration value
		var axisLengthSquared = axis.dot(axis);

		// If the axis is degenerate then ignore
		if (axisLengthSquared < 0.000001) {
			return true;
		}

		// Calculate the two possible overlap ranges
		// Either we overlap on the left or the right sides
		var d0 = maxB - minA; // 'Left' side
		var d1 = maxA - minB; // 'Right' side

		// Intervals do not overlap, so no intersection
		if (d0 <= 0.0 || d1 <= 0.0) {
			return false;
		}

		// Find out if we overlap on the 'right' or 'left' of the object.
		var overlap = d0 < d1 ? d0 : -d1;

		// The mtd vector for that axis
		// var sep = axis * (overlap / axisLengthSquared);
		var sep = new Vector3().copy(axis).scale(overlap / axisLengthSquared);

		// The mtd vector length squared
		var sepLengthSquared = sep.dot(sep);

		// If that vector is smaller than our computed Minimum Translation Distance use that vector as our current MTV distance
		if (sepLengthSquared < mtvInfo.mtvDistance) {
			mtvInfo.mtvDistance = sepLengthSquared;
			// mtvInfo.mtvAxis = sep;
			mtvInfo.mtvAxis = axis;
		}

		return true;
	};

	BoundingBox.prototype.intersectsRay = function (ray) {
		var diff = tmpVec1.set(ray.origin).sub(this.center);
		var direction = ray.direction;

		var t = [0.0, Infinity];

		// Check for degenerate cases and pad using zero tolerance. Should give close enough result.
		var x = this.xExtent;
		if (x < MathUtils.ZERO_TOLERANCE && x >= 0) {
			x = MathUtils.ZERO_TOLERANCE;
		}
		var y = this.yExtent;
		if (y < MathUtils.ZERO_TOLERANCE && y >= 0) {
			y = MathUtils.ZERO_TOLERANCE;
		}
		var z = this.zExtent;
		if (z < MathUtils.ZERO_TOLERANCE && z >= 0) {
			z = MathUtils.ZERO_TOLERANCE;
		}

		var notEntirelyClipped = //
			BoundingBox.clip(direction.x, -diff.x - x, t) && //
				BoundingBox.clip(-direction.x, diff.x - x, t) && //
				BoundingBox.clip(direction.y, -diff.y - y, t) && //
				BoundingBox.clip(-direction.y, diff.y - y, t) && //
				BoundingBox.clip(direction.z, -diff.z - z, t) && //
				BoundingBox.clip(-direction.z, diff.z - z, t);

		if (notEntirelyClipped && (t[0] !== 0.0 || t[1] !== Infinity)) {
			return true;
		}

		return false;
	};

	BoundingBox.prototype.intersectsRayWhere = function (ray) {
		var diff = tmpVec1.copy(ray.origin).sub(this.center);
		var direction = ray.direction;

		var t = [0.0, Infinity];

		// Check for degenerate cases and pad using zero tolerance. Should give close enough result.
		var x = this.xExtent;
		if (x < MathUtils.ZERO_TOLERANCE && x >= 0) {
			x = MathUtils.ZERO_TOLERANCE;
		}
		var y = this.yExtent;
		if (y < MathUtils.ZERO_TOLERANCE && y >= 0) {
			y = MathUtils.ZERO_TOLERANCE;
		}
		var z = this.zExtent;
		if (z < MathUtils.ZERO_TOLERANCE && z >= 0) {
			z = MathUtils.ZERO_TOLERANCE;
		}

		var notEntirelyClipped = //
			BoundingBox.clip(direction.x, -diff.x - x, t) && //
				BoundingBox.clip(-direction.x, diff.x - x, t) && //
				BoundingBox.clip(direction.y, -diff.y - y, t) && //
				BoundingBox.clip(-direction.y, diff.y - y, t) && //
				BoundingBox.clip(direction.z, -diff.z - z, t) && //
				BoundingBox.clip(-direction.z, diff.z - z, t);

		if (notEntirelyClipped && (t[0] !== 0.0 || t[1] !== Infinity)) {
			if (t[1] > t[0]) {
				var distances = t;
				var points = [new Vector3(ray.direction).scale(distances[0]).add(ray.origin),
					new Vector3(ray.direction).scale(distances[1]).add(ray.origin)];
				return {
					distances: distances,
					points: points
				};
			}

			var distances = [t[0]];
			var points = [new Vector3(ray.direction).scale(distances[0]).add(ray.origin)];
			return {
				distances: distances,
				points: points
			};
		}

		return null;
	};

	BoundingBox.clip = function (denom, numer, t) {
		// Return value is 'true' if line segment intersects the current test
		// plane. Otherwise 'false' is returned in which case the line segment
		// is entirely clipped.
		if (denom > 0.0) {
			if (numer > denom * t[1]) {
				return false;
			}
			if (numer > denom * t[0]) {
				t[0] = numer / denom;
			}
			return true;
		} else if (denom < 0.0) {
			if (numer > denom * t[0]) {
				return false;
			}
			if (numer > denom * t[1]) {
				t[1] = numer / denom;
			}
			return true;
		} else {
			return numer <= 0.0;
		}
	};

	BoundingBox.prototype.merge = function (bv) {
		if (bv instanceof BoundingBox) {
			return this.mergeBox(bv.center, bv.xExtent, bv.yExtent, bv.zExtent, this);
		} else if (bv instanceof BoundingSphere) {
			return this.mergeBox(bv.center, bv.radius, bv.radius, bv.radius, this);
		} else {
			return this;
		}
	};

	BoundingBox.prototype.mergeBox = function (center, xExtent, yExtent, zExtent, store) {
		if (!store) {
			store = new BoundingBox();
		}

		var calcVec1 = tmpVec1;
		var calcVec2 = tmpVec2;

		calcVec1.x = this.center.x - this.xExtent;
		if (calcVec1.x > center.x - xExtent) {
			calcVec1.x = center.x - xExtent;
		}
		calcVec1.y = this.center.y - this.yExtent;
		if (calcVec1.y > center.y - yExtent) {
			calcVec1.y = center.y - yExtent;
		}
		calcVec1.z = this.center.z - this.zExtent;
		if (calcVec1.z > center.z - zExtent) {
			calcVec1.z = center.z - zExtent;
		}

		calcVec2.x = this.center.x + this.xExtent;
		if (calcVec2.x < center.x + xExtent) {
			calcVec2.x = center.x + xExtent;
		}
		calcVec2.y = this.center.y + this.yExtent;
		if (calcVec2.y < center.y + yExtent) {
			calcVec2.y = center.y + yExtent;
		}
		calcVec2.z = this.center.z + this.zExtent;
		if (calcVec2.z < center.z + zExtent) {
			calcVec2.z = center.z + zExtent;
		}

		store.center.set(calcVec2).add(calcVec1).scale(0.5);

		store.xExtent = calcVec2.x - store.center.x;
		store.yExtent = calcVec2.y - store.center.y;
		store.zExtent = calcVec2.z - store.center.z;

		return store;
	};

	/**
	 * Copies data from another bounding box
	 * @param {BoundingBox} source bounding box to copy from
	 * @returns {BoundingBox} Returns self to allow chaining
	 */
	BoundingBox.prototype.copy = function (source) {
		BoundingVolume.prototype.copy.call(this, source);
		this.xExtent = source.xExtent;
		this.yExtent = source.yExtent;
		this.zExtent = source.zExtent;
		return this;
	};

	// ---
	var warned = false;

	/**
	 * Returns a clone of this bounding box
	 * @returns {BoundingBox}
	 */
	BoundingBox.prototype.clone = function () {
		if (arguments.length > 0 && !warned) {
			warned = true;
			console.warn(
				'BoundingBox::clone no longer takes an optional "store" parameter; ' +
				'please use BoundingBox::copy instead'
			);
		}
		// center appears to be shared but it really isn't since the BoundingVolume constructor clones it
		// when/if that ever changes this needs adapted accordingly
		return new BoundingBox(this.center, this.xExtent, this.yExtent, this.zExtent);
	};

	module.exports = BoundingBox;

/***/ },
/* 8 */
/***/ function(module, exports, __webpack_require__) {

	var ObjectUtils = __webpack_require__(6);
	var MathUtils = __webpack_require__(9);
	var Vector = __webpack_require__(10);
	var Vector4 = __webpack_require__(11);

	/**
	 * Vector with 3 components.
	 * @extends Vector
	 * @param {number} x
	 * @param {number} y
	 * @param {number} z
	 * @example
	 * var zero = new Vector3();
	 * var a = new Vector3(1, 2, 3);
	 * var b = new Vector3([1, 2, 3]); // Create from array
	 * var c = new Vector3(otherVector); // Create from other Vector3
	 *
	 * // Methods return the self object and allows for chaining:
	 * a.add(b).sub(c); // a = a + b - c
	 */
	function Vector3(x, y, z) {
		// @ifdef DEBUG
		this._x = 0;
		this._y = 0;
		this._z = 0;
		// @endif

		if (arguments.length === 0) {
			// Nothing given
			this.x = 0;
			this.y = 0;
			this.z = 0;
		} else if (arguments.length === 1 && typeof arguments[0] === 'object') {
			if (arguments[0] instanceof Vector3) {
				// Vector3
				this.copy(arguments[0]);
			} else {
				// Array
				this.x = arguments[0][0];
				this.y = arguments[0][1];
				this.z = arguments[0][2];
			}
		} else {
			// Numbers
			this.x = x;
			this.y = y;
			this.z = z;
		}

		// @ifdef DEBUG
		Object.seal(this);
		// @endif
	}

	Vector3.prototype = Object.create(Vector.prototype);
	Vector3.prototype.constructor = Vector3;

	// @ifdef DEBUG
	Vector.setupAliases(Vector3.prototype, [['x'], ['y'], ['z']]);
	Vector.setupIndices(Vector3.prototype, 3);
	// @endif

	Vector.setupAliases(Vector3.prototype, [['u', 'r'], ['v', 'g'], ['w', 'b']]);

	/**
	 * Zero-vector (0, 0, 0)
	 * @type {Vector3}
	 */
	Vector3.ZERO = new Vector3(0, 0, 0);

	/**
	 * One-vector (1, 1, 1)
	 * @type {Vector3}
	 */
	Vector3.ONE = new Vector3(1, 1, 1);

	/**
	 * Unit-X (1, 0, 0)
	 * @type {Vector3}
	 */
	Vector3.UNIT_X = new Vector3(1, 0, 0);

	/**
	 * Unit-Y (0, 1, 0)
	 * @type {Vector3}
	 */
	Vector3.UNIT_Y = new Vector3(0, 1, 0);

	/**
	 * Unit-Z (0, 0, 1)
	 * @type {Vector3}
	 */
	Vector3.UNIT_Z = new Vector3(0, 0, 1);

	/**
	 * Returns the vector component associated with the given index.
	 * Vector components are numbered from 0 to 2 in this order: x, y, z.
	 * @param {number} index
	 * @returns {number}
	 */
	Vector3.prototype.getComponent = function (index) {
		switch (index) {
			case 0: return this.x;
			case 1: return this.y;
			case 2: return this.z;
		}
	};

	/**
	 * Sets the vector component associated with the given index to a given value.
	 * Vector components are numbered from 0 to 2 in this order: x, y, z.
	 * @param {number} index
	 * @param {number} value
	 * @returns {Vector3} Self to allow chaining
	 */
	Vector3.prototype.setComponent = function (index, value) {
		switch (index) {
			case 0: this.x = value; break;
			case 1: this.y = value; break;
			case 2: this.z = value; break;
		}
		return this;
	};

	/**
	 * Adds a vector to the current vector
	 * @param {Vector3} rhs
	 * @returns {Vector3} Self to allow chaining
	 * @example
	 * var a = new Vector3(1, 2, 3);
	 * var b = new Vector3(4, 5, 6);
	 * a.add(b); // a == (5, 7, 9)
	 */
	Vector3.prototype.add = function (rhs) {
		if (rhs instanceof Vector3) {
			this.x += rhs.x;
			this.y += rhs.y;
			this.z += rhs.z;
		} else if (rhs instanceof Vector4) {
			console.warn('Passing a Vector4 argument to Vector3.prototype.add is deprecated. Consider using .addDirect instead.');
			this.x += rhs.x;
			this.y += rhs.y;
			this.z += rhs.z;
		} else if (typeof (rhs) === 'object' && typeof (rhs.length) === 'number') {
			console.warn('Passing arrays to Vector3.prototype.add is deprecated - use Vector3.prototype.addDirect instead.');
			this.x += rhs[0];
			this.y += rhs[1];
			this.z += rhs[2];
		} else if (typeof (rhs) === 'number') {
			console.warn('Passing numbers to Vector3.prototype.add is deprecated - use Vector3.prototype.addDirect instead.');
			this.x += rhs;
			this.y += rhs;
			this.z += rhs;
		} else {
			console.warn('Vector3.prototype.add only supports vector arguments now.');
		}

		return this;
	};

	/**
	 * Adds numbers 'x', 'y', 'z' to the current Vector3 values
	 * @param {number} x
	 * @param {number} y
	 * @param {number} z
	 * @returns {Vector3} Self to allow chaining
	 * @example
	 * var v = new Vector3(1, 2, 3);
	 * v.addDirect(2, 4, 6); // v == (3, 6, 9)
	 */
	Vector3.prototype.addDirect = function (x, y, z) {
		this.x += x;
		this.y += y;
		this.z += z;

		return this;
	};

	/**
	 * Adds a vector from the current vector
	 * @param {Vector3} rhs
	 * @returns {Vector3} Self to allow chaining
	 * @example
	 * var a = new Vector3(4, 5, 6);
	 * var b = new Vector3(1, 2, 3);
	 * a.sub(b); // a == (3, 3, 3)
	 */
	Vector3.prototype.sub = function (rhs) {
		this.x -= rhs.x;
		this.y -= rhs.y;
		this.z -= rhs.z;

		return this;
	};

	/**
	 * Subtracts numbers 'x', 'y', 'z' from the current Vector3
	 * @param {number} x
	 * @param {number} y
	 * @param {number} z
	 * @returns {Vector3} Self to allow chaining
	 * @example
	 * var v = new Vector3(); // v == (0, 0, 0)
	 * v.subDirect(1, 2, 3); // v == (-1, -2, -3)
	 */
	Vector3.prototype.subDirect = function (x, y, z) {
		this.x -= x;
		this.y -= y;
		this.z -= z;

		return this;
	};

	/**
	 * Performs component-wise negation of the vector
	 * @returns {Vector3} Self to allow chaining
	 */
	Vector3.prototype.negate = function () {
		this.x = -this.x;
		this.y = -this.y;
		this.z = -this.z;

		return this;
	};

	/**
	 * Multiplies the current vector by another vector
	 * @param {Vector3} rhs
	 * @returns {Vector3} Self to allow chaining
	 * @example
	 * var a = new Vector3(4, 5, 6);
	 * var b = new Vector3(1, 2, 3);
	 * a.mul(b); // a == (4, 10, 18)
	 */
	Vector3.prototype.mul = function (rhs) {
		if (typeof (rhs) === 'number') {
			console.warn('Vector3.prototype.mul only accepts vector arguments now. Please use Vector3.prototype.scale instead.');
			this.x *= rhs;
			this.y *= rhs;
			this.z *= rhs;
		} else {
			this.x *= rhs.x;
			this.y *= rhs.y;
			this.z *= rhs.z;
		}

		return this;
	};

	/**
	 * Multiplies the current Vector3 by numbers 'x', 'y', 'z' as inputs
	 * @param {number} x
	 * @param {number} y
	 * @param {number} z
	 * @returns {Vector3} Self to allow chaining
	 * @example
	 * var v = new Vector3(1, 2, 3);
	 * v.mulDirect(2, 4, 6); // v == (2, 8, 18)
	 */
	Vector3.prototype.mulDirect = function (x, y, z) {
		this.x *= x;
		this.y *= y;
		this.z *= z;

		return this;
	};

	/**
	 * Scales the vector by a factor
	 * @param {number} factor
	 * @returns {Vector3} Self to allow chaining
	 * @example
	 * var v = new Vector3(1, 2, 3);
	 * v.scale(2); // v == (2, 4, 6)
	 */
	Vector3.prototype.scale = function (factor) {
		this.x *= factor;
		this.y *= factor;
		this.z *= factor;

		return this;
	};

	/**
	 * Divides the current Vector3 by another vector
	 * @param {Vector3} rhs
	 * @returns {Vector3} Self to allow chaining
	 * @example
	 * var v = new Vector3(2, 4, 6);
	 * v.div(1, 2, 3); // v == (2, 2, 2)
	 */
	Vector3.prototype.div = function (rhs) {
		if (typeof (rhs) === 'number') {
			console.warn('Passing a number argument to Vector3.prototype.div is deprecated. Use Vector3.prototype.divDirect instead.');
			this.x /= rhs;
			this.y /= rhs;
			this.z /= rhs;
		} else {
			this.x /= rhs.x;
			this.y /= rhs.y;
			this.z /= rhs.z;
		}

		return this;
	};

	/**
	 * Divides the current Vector3 by numbers 'x', 'y', 'z' as inputs
	 * @param {number} x
	 * @param {number} y
	 * @param {number} z
	 * @returns {Vector3} Self to allow chaining
	 * @example
	 * var v = new Vector3(2, 4, 6);
	 * v.divDirect(1, 2, 3); // v == (2, 2, 2)
	 */
	Vector3.prototype.divDirect = function (x, y, z) {
		this.x /= x;
		this.y /= y;
		this.z /= z;

		return this;
	};

	/**
	 * Computes the dot product between the current vector and another vector
	 * @param {Vector3} rhs
	 * @returns {number}
	 * @example
	 * var a = new Vector3(1, 0, 0);
	 * var b = new Vector3(0, 1, 0);
	 * a.dot(b) === 0; // true
	 */
	Vector3.prototype.dot = function (rhs) {
		return this.x * rhs.x +
			this.y * rhs.y +
			this.z * rhs.z;
	};

	/**
	 * Computes the dot product between the current vector and another vector given as 3 values
	 * @param {number} x
	 * @param {number} y
	 * @param {number} z
	 * @returns {number}
	 */
	Vector3.prototype.dotDirect = function (x, y, z) {
		return this.x * x +
			this.y * y +
			this.z * z;
	};

	/**
	 * Returns whether this vector is aproximately equal to a given vector
	 * @param rhs
	 * @returns {boolean}
	 */
	Vector3.prototype.equals = function (rhs) {
		var eps = MathUtils.EPSILON;
		return (Math.abs(this.x - rhs.x) <= eps) &&
			(Math.abs(this.y - rhs.y) <= eps) &&
			(Math.abs(this.z - rhs.z) <= eps);
	};

	/**
	 * Returns whether this vector is approximately equal to a given vector given as 3 values
	 * @param {number} x
	 * @param {number} y
	 * @param {number} z
	 * @returns {boolean}
	 */
	Vector3.prototype.equalsDirect = function (x, y, z) {
		var eps = MathUtils.EPSILON;
		return (Math.abs(this.x - x) <= eps) &&
			(Math.abs(this.y - y) <= eps) &&
			(Math.abs(this.z - z) <= eps);
	};

	/**
	 * Computes the cross product between the current Vector3 and another vector
	 * @param {Vector3} rhs
	 * @returns {Vector3} Self to allow chaining
	 * @example
	 * var a = new Vector3(0, 1, 0);
	 * var b = new Vector3(0, 0, -1);
	 * a.cross(b); // a == (-1, 0, 0)
	 */
	Vector3.prototype.cross = function (rhs) {
		var x = this.x;
		var y = this.y;
		var z = this.z;

		this.x = rhs.z * y - rhs.y * z;
		this.y = rhs.x * z - rhs.z * x;
		this.z = rhs.y * x - rhs.x * y;

		return this;
	};

	/**
	 * Computes the cross product between the current Vector3 and another vector given as 3 values
	 * @param {number} x
	 * @param {number} y
	 * @param {number} z
	 * @returns {Vector3} Self to allow chaining
	 * @example
	 * var a = new Vector3(0, 1, 0);
	 * var b = new Vector3(0, 0, -1);
	 * a.cross(b); // a == (-1, 0, 0)
	 */
	Vector3.prototype.crossDirect = function (x, y, z) {
		var thisX = this.x;
		var thisY = this.y;
		var thisZ = this.z;

		this.x = z * thisY - y * thisZ;
		this.y = x * thisZ - z * thisX;
		this.z = y * thisX - x * thisY;

		return this;
	};

	/**
	 * Linearly interpolates between the current Vector3 and an 'end' Vector3
	 * @param {Vector3} end End Vector3
	 * @param {number} factor Interpolation factor between 0.0 and 1.0
	 * @returns {Vector3} Self to allow chaining
	 * @example
	 * var from = new Vector3(1, 2, 3);
	 * var to = new Vector3(3, 4, 5);
	 * var midway = from.clone().lerp(to, 0.5); // midway == (2, 3, 4)
	 */
	Vector3.prototype.lerp = function (end, factor) {
		this.x += (end.x - this.x) * factor;
		this.y += (end.y - this.y) * factor;
		this.z += (end.z - this.z) * factor;

		return this;
	};

	(function () {
		var tmpVec = new Vector3();

		/**
		 * Reflects a vector relative to the plane obtained from the normal parameter.
		 * @param {Vector3} normal Defines the plane that reflects the vector. Assumed to be of unit length.
		 * @returns {Vector3} Self to allow chaining
		 */
		Vector3.prototype.reflect = function (normal) {
			tmpVec.copy(normal);
			tmpVec.scale(2 * this.dot(normal));
			this.sub(tmpVec);
			return this;
		};
	})();

	/**
	 * Sets the vector's values from another vector's values
	 * @param {Vector3} rhs
	 * @returns {Vector3} Self to allow chaining
	 * @example
	 * var v = new Vector3(); // v == (0, 0, 0)
	 * v.set(new Vector3(2, 4, 6)); // v == (2, 4, 6)
	 */
	Vector3.prototype.set = function (rhs) {
		if (rhs instanceof Vector3 || rhs instanceof Vector4) {
			this.x = rhs.x;
			this.y = rhs.y;
			this.z = rhs.z;
		} else {
			this.x = arguments[0];
			this.y = arguments[1];
			this.z = arguments[2];
		}

		return this;
	};

	/**
	 * Sets the vector's values from 3 numeric arguments
	 * @param {number} x
	 * @param {number} y
	 * @param {number} z
	 * @returns {Vector3} Self to allow chaining
	 * @example
	 * var v = new Vector3(); // v == (0, 0, 0)
	 * v.setDirect(2, 4, 6); // v == (2, 4, 6)
	 */
	Vector3.prototype.setDirect = function (x, y, z) {
		this.x = x;
		this.y = y;
		this.z = z;

		return this;
	};

	/**
	 * Calculates the squared length/magnitude of the current Vector3.
	 * Note: When comparing the relative distances between two points it is usually sufficient
	 * to compare the squared distances, thus avoiding an expensive square root operation.
	 * @returns {number} squared length
	 * @example
	 * var v = new Vector3(0, 9, 0);
	 * v.lengthSquared(); // 81
	 */
	Vector3.prototype.lengthSquared = function () {
		return this.x * this.x + this.y * this.y + this.z * this.z;
	};

	/**
	 * Calculates length squared of vector
	 * @returns {number} length squared
	 */
	Vector3.prototype.length = function () {
		return Math.sqrt(this.lengthSquared());
	};

	/**
	 * Normalizes the current vector
	 * @returns {Vector3} Self to allow chaining
	 */
	Vector3.prototype.normalize = function () {
		var length = this.length();

		if (length < MathUtils.EPSILON) {
			this.x = 0;
			this.y = 0;
			this.z = 0;
		} else {
			this.x /= length;
			this.y /= length;
			this.z /= length;
		}

		return this;
	};

	/**
	 * Normalizes the current vector; this method does not perform special checks for zero length vectors
	 * @returns {Vector3} Self to allow chaining
	 */
	Vector3.prototype.unsafeNormalize = function () {
		var length = this.length();

		this.x /= length;
		this.y /= length;
		this.z /= length;

		return this;
	};

	/**
	 * Computes the squared distance between the current Vector3 and another Vector3.
	 * Note: When comparing the relative distances between two points it is usually sufficient
	 * to compare the squared distances, thus avoiding an expensive square root operation.
	 * @param {Vector3} rhs Vector3
	 * @returns {number} distance squared
	 * @example
	 * var a = new Vector3(); // a == (0, 0, 0)
	 * var b = new Vector3(0, 9, 0);
	 * a.distanceSquared(b); // 81
	 */
	Vector3.prototype.distanceSquared = function (rhs) {
		var deltaX = this.x - rhs.x;
		var deltaY = this.y - rhs.y;
		var deltaZ = this.z - rhs.z;

		return deltaX * deltaX + deltaY * deltaY + deltaZ * deltaZ;
	};

	/**
	 * Computes the distance between the current Vector3 and another Vector3.
	 * Note: When comparing the relative distances between two points it is usually sufficient
	 * to compare the squared distances, thus avoiding an expensive square root operation.
	 * @param {Vector3} rhs Vector3
	 * @returns {number} distance
	 * @example
	 * var a = new Vector3(); // a == (0, 0, 0)
	 * var b = new Vector3(0, 9, 0);
	 * a.distance(b); // 9
	 */
	Vector3.prototype.distance = function (rhs) {
		return Math.sqrt(this.distanceSquared(rhs));
	};

	/**
	 * Multiplies this vector with a Matrix3
	 * @param {Matrix3} matrix
	 * @returns {Vector3} Self to allow chaining
	 */
	Vector3.prototype.applyPre = function (matrix) {
		var source = matrix.data;

		var x = this.x;
		var y = this.y;
		var z = this.z;

		this.x = source[0] * x + source[1] * y + source[2] * z;
		this.y = source[3] * x + source[4] * y + source[5] * z;
		this.z = source[6] * x + source[7] * y + source[8] * z;

		return this;
	};

	/**
	 * Multiplies a Matrix3 with this vector
	 * @param {Matrix3} matrix
	 * @returns {Vector3} Self to allow chaining
	 */
	Vector3.prototype.applyPost = function (matrix) {
		var source = matrix.data;

		var x = this.x;
		var y = this.y;
		var z = this.z;

		this.x = source[0] * x + source[3] * y + source[6] * z;
		this.y = source[1] * x + source[4] * y + source[7] * z;
		this.z = source[2] * x + source[5] * y + source[8] * z;

		return this;
	};

	/**
	 * Applies a Matrix4 (rotation, scale, translation) to this vector
	 * @param {Matrix4} matrix
	 * @returns {Vector3} Self to allow chaining
	 */
	Vector3.prototype.applyPostPoint = function (matrix) {
		var source = matrix.data;

		var x = this.x;
		var y = this.y;
		var z = this.z;

		this.x = source[0] * x + source[4] * y + source[ 8] * z + source[12];
		this.y = source[1] * x + source[5] * y + source[ 9] * z + source[13];
		this.z = source[2] * x + source[6] * y + source[10] * z + source[14];

		return this;
	};

	/**
	 * Applies a Matrix4 (rotation, scale) to this vector
	 * @param {Matrix4} matrix
	 * @returns {Vector3} Self to allow chaining
	 */
	Vector3.prototype.applyPostVector = function (matrix) {
		var source = matrix.data;

		var x = this.x;
		var y = this.y;
		var z = this.z;

		this.x = source[0] * x + source[4] * y + source[8] * z;
		this.y = source[1] * x + source[5] * y + source[9] * z;
		this.z = source[2] * x + source[6] * y + source[10] * z;

		return this;
	};

	/**
	 * Clones the vector
	 * @returns {Vector3} Clone of self
	 */
	Vector3.prototype.clone = function () {
		return new Vector3(this.x, this.y, this.z);
	};

	/**
	 * Copies the values of another vector to this vector; an alias for .setVector
	 * @param {Vector3} Source vector
	 * @returns {Vector3} Self to allow chaining
	 */
	Vector3.prototype.copy = Vector3.prototype.set;

	/**
	 * Copies this vector over another. Not equivalent to `target.copy(this)` when
	 * the target vector has more components than the source vector
	 * @param {Vector} target
	 * @returns {Vector3} Self to allow chaining
	 */
	Vector3.prototype.copyTo = function (target) {
		target.x = this.x;
		target.y = this.y;
		target.z = this.z;

		return this;
	};

	/**
	 * Returns the components of the vector in array form
	 * @returns {Array<number>}
	 */
	Vector3.prototype.toArray = function () {
		return [this.x, this.y, this.z];
	};

	/**
	 * Creates a Vector3 given an array
	 * @param {Array<number>} array
	 * @returns {Vector3}
	 */
	Vector3.fromArray = function (array) {
		return new Vector3(array[0], array[1], array[2]);
	};

	/**
	 * Creates a Vector3 given 3 numbers, an array, an {x, y, z} object or another Vector3
	 * @returns {Vector3}
	 */
	Vector3.fromAny = function () {
		if (arguments.length === 3) {
			return Vector3.fromArray(arguments);
		} else if (arguments[0] instanceof Array) {
			return Vector3.fromArray(arguments[0]);
		} else {
			var vectorLike = arguments[0];
			return new Vector3(vectorLike.x, vectorLike.y, vectorLike.z);
		}
	};

	/**
	 * Sets the vector content from an array of numbers.
	 * @param {Array<number>} array
	 */
	Vector3.prototype.setArray = function (array) {
		this.x = array[0];
		this.y = array[1];
		this.z = array[2];

		return this;
	};

	// SHIM START
	Object.defineProperty(Vector3.prototype, 'data', {
		get: ObjectUtils.warnOnce('The .data property of Vector3 was removed. Please use the .x, .y and .z properties instead.', function () {
			var data = [];
			var that = this;
			Object.defineProperties(data, {
				'0': {
					get: function () {
						return that.x;
					},
					set: function (value) {
						that.x = value;
					}
				},
				'1': {
					get: function () {
						return that.y;
					},
					set: function (value) {
						that.y = value;
					}
				},
				'2': {
					get: function () {
						return that.z;
					},
					set: function (value) {
						that.z = value;
					}
				}
			});
			return data;
		})
	});

	/**
	 * @hidden
	 * @deprecated
	 */
	Vector3.prototype.setVector = ObjectUtils.warnOnce('The setVector method of Vector3 is deprecated. Please use the set method instead.', function (rhs) {
		return this.set(rhs);
	});

	/**
	 * @hidden
	 * @deprecated
	 */
	Vector3.add = ObjectUtils.warnOnce('Vector3.add is deprecated. Use Vector3.prototype.add instead.', function (lhs, rhs, target) {
		if (typeof lhs === 'number') {
			lhs = [lhs, lhs, lhs];
		}

		if (typeof rhs === 'number') {
			rhs = [rhs, rhs, rhs];
		}

		if (!target) {
			target = new Vector3();
		}

		var ldata = lhs.data || lhs;
		var rdata = rhs.data || rhs;

		target.data[0] = ldata[0] + rdata[0];
		target.data[1] = ldata[1] + rdata[1];
		target.data[2] = ldata[2] + rdata[2];

		return target;
	});

	/**
	 * @hidden
	 * @deprecated
	 */
	Vector3.cross = ObjectUtils.warnOnce('Vector3.cross is deprecated. Use Vector3.prototype.cross instead.', function (lhs, rhs, target) {
		if (!target) {
			target = new Vector3();
		}

		var ldata = lhs.data || lhs;
		var rdata = rhs.data || rhs;

		var x = rdata[2] * ldata[1] - rdata[1] * ldata[2];
		var y = rdata[0] * ldata[2] - rdata[2] * ldata[0];
		var z = rdata[1] * ldata[0] - rdata[0] * ldata[1];

		target.data[0] = x;
		target.data[1] = y;
		target.data[2] = z;

		return target;
	});

	/**
	 * @hidden
	 * @deprecated
	 */
	Vector3.distance = ObjectUtils.warnOnce('Vector3.distance is deprecated. Use Vector3.prototype.distance instead.', function (lhs, rhs) {
		return Math.sqrt(Vector3.distanceSquared(lhs, rhs));
	});

	/**
	 * @hidden
	 * @deprecated
	 */
	Vector3.distanceSquared = ObjectUtils.warnOnce('Vector3.distanceSquared is deprecated. Use Vector3.prototype.distanceSquared instead.', function (lhs, rhs) {
		var x = lhs.x - rhs.x,
			y = lhs.y - rhs.y,
			z = lhs.z - rhs.z;
		return x * x + y * y + z * z;
	});

	/**
	 * @hidden
	 * @deprecated
	 */
	Vector3.div = ObjectUtils.warnOnce('Vector3.div is deprecated. Use Vector3.prototype.div instead.', function (lhs, rhs, target) {
		if (!target) {
			target = new Vector3();
		}

		if (typeof lhs === 'number') {
			var rdata = rhs.data || rhs;

			target.data[0] = lhs / rdata[0];
			target.data[1] = lhs / rdata[1];
			target.data[2] = lhs / rdata[2];
		} else if (typeof rhs === 'number') {
			var irhs = 1 / rhs;
			var ldata = lhs.data || lhs;

			target.data[0] = ldata[0] * irhs;
			target.data[1] = ldata[1] * irhs;
			target.data[2] = ldata[2] * irhs;
		} else {
			var ldata = lhs.data || lhs;
			var rdata = rhs.data || rhs;

			target.data[0] = ldata[0] / rdata[0];
			target.data[1] = ldata[1] / rdata[1];
			target.data[2] = ldata[2] / rdata[2];
		}

		return target;
	});

	/**
	 * @hidden
	 * @deprecated
	 */
	Vector3.dot = ObjectUtils.warnOnce('Vector3.dot is deprecated. Use Vector3.prototype.dot instead.', function (lhs, rhs) {
		if (typeof lhs === 'number') {
			lhs = [lhs, lhs, lhs];
		}

		if (typeof rhs === 'number') {
			rhs = [rhs, rhs, rhs];
		}

		var ldata = lhs.data || lhs;
		var rdata = rhs.data || rhs;

		return ldata[0] * rdata[0] +
			ldata[1] * rdata[1] +
			ldata[2] * rdata[2];
	});

	/**
	 * @hidden
	 * @deprecated
	 */
	Vector3.mul = ObjectUtils.warnOnce('Vector3.mul is deprecated. Use Vector3.prototype.mul instead.', function (lhs, rhs, target) {
		if (!target) {
			target = new Vector3();
		}

		if (typeof lhs === 'number') {
			var rdata = rhs.data || rhs;

			target.data[0] = lhs * rdata[0];
			target.data[1] = lhs * rdata[1];
			target.data[2] = lhs * rdata[2];
		} else if (typeof rhs === 'number') {
			var ldata = lhs.data || lhs;

			target.data[0] = ldata[0] * rhs;
			target.data[1] = ldata[1] * rhs;
			target.data[2] = ldata[2] * rhs;
		} else {
			var ldata = lhs.data || lhs;
			var rdata = rhs.data || rhs;

			target.data[0] = ldata[0] * rdata[0];
			target.data[1] = ldata[1] * rdata[1];
			target.data[2] = ldata[2] * rdata[2];
		}

		return target;
	});

	/**
	 * @hidden
	 * @deprecated
	 */
	Vector3.prototype.addVector = ObjectUtils.warnOnce('Vector3.prototype.addVector is deprecated. Use Vector3.prototype.add instead.', function (vector) {
		this.x += vector.x;
		this.y += vector.y;
		this.z += vector.z;

		return this;
	});

	/**
	 * @hidden
	 * @deprecated
	 */
	Vector3.prototype.mulVector = ObjectUtils.warnOnce('Vector3.prototype.mulVector is deprecated. Use .mul instead.', function (vec3) {
		this.x *= vec3.x;
		this.y *= vec3.y;
		this.z *= vec3.z;

		return this;
	});

	/**
	 * @hidden
	 * @deprecated
	 */
	Vector3.prototype.dotVector = ObjectUtils.warnOnce('Vector3.prototype.dotVector is deprecated. Use .dot instead.', function (rhs) {
		var ldata = this.data;
		var rdata = rhs.data;

		return ldata[0] * rdata[0] +
			ldata[1] * rdata[1] +
			ldata[2] * rdata[2];
	});

	/**
	 * @hidden
	 * @deprecated
	 */
	Vector3.prototype.invert = ObjectUtils.warnOnce('Vector3.prototype.invert is deprecated. Use .negate instead.', function () {
		this.x = 0.0 - this.x;
		this.y = 0.0 - this.y;
		this.z = 0.0 - this.z;

		return this;
	});

	/**
	 * @hidden
	 * @deprecated
	 */
	Vector3.prototype.subVector = ObjectUtils.warnOnce('Vector3.prototype.subVector is deprecated. Use .sub instead.', function (vector) {
		this.x -= vector.x;
		this.y -= vector.y;
		this.z -= vector.z;

		return this;
	});

	/**
	 * @hidden
	 * @deprecated
	 */
	Vector3.sub = ObjectUtils.warnOnce('Vector3.sub is deprecated. Use Vector3.prototype.sub instead.', function (lhs, rhs, target) {
		if (typeof lhs === 'number') {
			lhs = [lhs, lhs, lhs];
		}

		if (typeof rhs === 'number') {
			rhs = [rhs, rhs, rhs];
		}

		if (!target) {
			target = new Vector3();
		}

		var ldata = lhs.data || lhs;
		var rdata = rhs.data || rhs;

		target.data[0] = ldata[0] - rdata[0];
		target.data[1] = ldata[1] - rdata[1];
		target.data[2] = ldata[2] - rdata[2];

		return target;
	});
	// SHIM END

	// @ifdef DEBUG
	Vector.addReturnChecks(Vector3.prototype, [
		'dot', 'dotDirect',
		'length', 'lengthSquared',
		'distance', 'distanceSquared'
	]);
	// @endif

	module.exports = Vector3;


/***/ },
/* 9 */
/***/ function(module, exports) {

	/**
	 * A collection of useful math-related functions, constants and helpers.
	 * Only used to define the class. Should never be instantiated.
	 */
	function MathUtils() {}

	/** @type {number}
	 * @example
	 * // converts 75 degrees to radians
	 * var rot = 75 * MathUtils.DEG_TO_RAD;
	 */
	MathUtils.DEG_TO_RAD = Math.PI / 180.0;

	/** @type {number}
	 * @example
	 * // converts Math.PI to 180 degrees
	 * var rot = Math.PI  MathUtils.RAD_TO_DEG;
	 */
	MathUtils.RAD_TO_DEG = 180.0 / Math.PI;

	/** @type {number}
	 * @example
	 * // uses HALF_PI and converts it to degress
	 * var rot = MathUtils.HALF_PI * MathUtils.RAD_TO_DEG; // rot == 90
	 */
	MathUtils.HALF_PI = 0.5 * Math.PI;

	/** @type {number}
	 * @example
	 * // uses TWO_PI and converts it to degrees
	 * var rot = MathUtils.TWO_PI * RAD_TO_DEG; // rot == 360
	 */
	MathUtils.TWO_PI = 2.0 * Math.PI;

	/** @type {number}
	 * @example
	 * // uses EPSILON to approximate floating point equality
	 * if (Math.abs(a - b) > MathUtils.EPSILON) {
	 * 		// not equal
	 * }
	 */
	MathUtils.EPSILON = 0.00001; //! AT: unfortunately Matrix.invert is too unstable to use a smaller epsilon

	//! AT: why do we have both these functions and the constant above?
	// why are the constants named x_TO_y and and the functions y_FROM_x ?
	/**
	 * Converts an angle from degrees to radians.
	 * @param {Float} degrees Angle in degrees.
	 * @returns {Float} Angle in radians.
	 * @example
	 * // converts 70 degrees to a radian
	 * var a = MathUtils.radFromDeg(70);
	 */
	MathUtils.radFromDeg = function (degrees) {
		return degrees * MathUtils.DEG_TO_RAD;
	};

	/**
	 * Converts an angle from radians to degrees.
	 * @param {Float} radians Angle in radians.
	 * @returns {Float} Angle in degrees.
	 * @example
	 * // converts Math.PI to 180 degrees
	 * var a = MathUtils.degFromRad(Math.PI);
	 */
	MathUtils.degFromRad = function (radians) {
		return radians * MathUtils.RAD_TO_DEG;
	};

	/**
	 * Linearly interpolates between two values. Extrapolates if factor is smaller than zero or greater than one.
	 * @param {number} factor Factor of interpolation.
	 * @param {number} start Start value.
	 * @param {number} end End value.
	 * @returns {number} Interpolated value.
	 * @example
	 * // earlier in code (outside of the update loop)
	 * var x = 0;
	 * // inside the update loop
	 * x = MathUtils.lerp(tpf, x, 5);
	 */
	MathUtils.lerp = function (factor, start, end) {
		if (start === end) {
			return start;
		} else {
			return start + (end - start) * factor;
		}
	};

	/**
	 * Clamps a value to a given interval. The interval is defined by min and max where min should be smaller than max. If min is greater
	 * than max, the two parameters are reversed.
	 * @param {number} value Input value.
	 * @param {number} min Lower bound of interval (inclusive).
	 * @param {number} max Upper bound of interval (inclusive).
	 * @returns {number} Clamped value.
	 * @example
	 * var a = -1;
	 * a = Math.clamp(a, 0, 9); // a == 0
	 */
	MathUtils.clamp = function (value, min, max) {
		if (min < max) {
			return value < min ? min : value > max ? max : value;
		} else {
			return value < max ? max : value > min ? min : value;
		}
	};

	/**
	 * Clamps an angle to a given interval. The interval is defined by min and max. If min is larger than max, the clamp will wrap around.
	 * @param {number} value Input value.
	 * @param {number} min Lower bound of interval (inclusive).
	 * @param {number} max Upper bound of interval (inclusive).
	 * @returns {number} Clamped value.
	 * @example
	 * var a = -1;
	 * a = Math.radialClamp(a, 0, 9); // a == 0
	 */
	MathUtils.radialClamp = function (value, min, max) {
		// Rotating coordinates to be mirrored
		var zero = (min + max) / 2 + ((max > min) ? Math.PI : 0);
		var _value = MathUtils.moduloPositive(value - zero, MathUtils.TWO_PI);
		var _min = MathUtils.moduloPositive(min - zero, MathUtils.TWO_PI);
		var _max = MathUtils.moduloPositive(max - zero, MathUtils.TWO_PI);

		// Putting min, max and value on the same circle
		if (value < 0 && min > 0) { min -= MathUtils.TWO_PI; }
		else if (value > 0 && min < 0) { min += MathUtils.TWO_PI; }
		if (value > MathUtils.TWO_PI && max < MathUtils.TWO_PI) { max += MathUtils.TWO_PI; }

		return _value < _min ? min : _value > _max ? max : value;
	};


	/**
	 * Calculates the positive modulo
	 * @param {number} value
	 * @param {number} size
	 * @returns {number} Wrapped value
	 */
	MathUtils.moduloPositive = function (value, size) {
		var wrappedValue = value % size;
		wrappedValue += wrappedValue < 0 ? size : 0;
		return wrappedValue;
	};

	/**
	 * Computes a value on the c1-continuous cubic s-curve "y = -2x^3 + 3x^2".
	 * @param {number} x Input value in the range between zero and one.
	 * @returns {number} Value on curve.
	 */
	MathUtils.scurve3 = function (x) {
		return (-2.0 * x + 3.0) * x * x;
	};

	/**
	 * Computes a value on the c2-continuous quintic s-curve "y = 6x^5 - 15x^4 + 10x^3".
	 * @param {number} x Input value in the range between zero and one.
	 * @returns {number} Value on curve.
	 */
	MathUtils.scurve5 = function (x) {
		return ((6.0 * x - 15.0) * x + 10.0) * x * x * x;
	};

	/**
	 * Converts Spherical coordinates in radians to a Vector3 Cartesian point (using positive Y as up) and stores the results in the store var.
	 * @param {number} radius (distance)
	 * @param {number} azimuth (heading)
	 * @param {number} polar (elevation)
	 * @param {Vector3} store
	 * @example
	 * var distance = 5;
	 * var heading = 180;
	 * var elevation = 30;
	 * var position = new Vector3();
	 * MathUtils.sphericalToCartesian(distance, heading, elevation, position);
	 */
	MathUtils.sphericalToCartesian = function (radius, azimuth, polar, store) {
		var a = radius * Math.cos(polar);

		store.x = a * Math.cos(azimuth);
		store.y = radius * Math.sin(polar);
		store.z = a * Math.sin(azimuth);
	};

	/**
	 * Converts a point from Cartesian coordinates to Spherical radian coordinates (using positive Y as up) and stores the results in the store var.
	 * @param {number} x
	 * @param {number} y
	 * @param {number} z
	 * @param {Vector3} store
	 * @example
	 * var sphericalCoord = new Vector3();
	 * var pos = entity.transformComponent.transform.translation.
	 * MathUtils.cartesianToSpherical(pos.x, pos.y, pos.z, sphericalCoord);
	 */
	MathUtils.cartesianToSpherical = function (x, y, z, store) {
		var a = Math.sqrt(x * x + z * z);
		store.x = Math.sqrt(x * x + y * y + z * z); // radius
		store.y = Math.atan2(z, x); // azimuth
		store.z = Math.atan2(y, a); // polar
	};

	/**
	 * Computes the normal of a given triangle
	 * @param {number} P.x
	 * @param {number} P.y
	 * @param {number} P.z
	 * @param {number} Q.x
	 * @param {number} Q.y
	 * @param {number} Q.z
	 * @param {number} R.x
	 * @param {number} R.y
	 * @param {number} R.z
	 * @returns {Array<number>} The triangle's normal
	 */
	MathUtils.getTriangleNormal = function (p1x, p1y, p1z, p2x, p2y, p2z, p3x, p3y, p3z) {
		var ux = p2x - p1x;
		var uy = p2y - p1y;
		var uz = p2z - p1z;

		var vx = p3x - p1x;
		var vy = p3y - p1y;
		var vz = p3z - p1z;

		var nx = uy * vz - uz * vy;
		var ny = uz * vx - ux * vz;
		var nz = ux * vy - uy * vx;

		return [nx, ny, nz];
	};

	/**
	 * Checks if a value is power of two
	 * @param {number} value Number to check for power of two
	 * @returns {boolean} true if value is power of two
	 */
	MathUtils.isPowerOfTwo = function (value) {
		return (value & (value - 1)) === 0;
	};

	/**
	 * Gets the nearest higher power of two for a value
	 * @param {number} value Number to get the nearest power of two from
	 * @returns {number} Nearest power of two
	 */
	MathUtils.nearestPowerOfTwo = function (value) {
		value--;
		value |= value >> 1;
		value |= value >> 2;
		value |= value >> 4;
		value |= value >> 8;
		value |= value >> 16;
		value++;
		return value;
	};

	/**
	 * Gets the nearest higher power of two for a value
	 * @deprecated Deprecated as of v0.14.x and scheduled for removal in v0.16.0;
	 * Consider using MathUtils.nearestPowerOfTwo instead
	 * @param {number} value Number to get the nearest power of two from
	 * @returns {number} Nearest power of two
	 */
	MathUtils.nearestHigherPowerOfTwo = MathUtils.nearestPowerOfTwo;

	/**
	 * Returns true if the 2 values supplied are approximately the same
	 * @param v1
	 * @param v2
	 * @param tolerance
	 * @returns {boolean}
	 */
	MathUtils.closeTo = function (v1, v2, tolerance) {
		tolerance = typeof tolerance !== 'undefined' ? tolerance : 0.001;
		return Math.abs(v1 - v2) <= tolerance;
	};

	/**
	 * Returns the sign of the supplied parameter
	 * @param value
	 * @returns {number}
	 */
	MathUtils.sign = function (value) {
		return value < 0 ? -1 : value > 0 ? 1 : 0;
	};

	/**
	 * Computes the area of a 2D triangle
	 * @param {Vector2} t1 First point of the triangle
	 * @param {Vector2} t2 Second point of the triangle
	 * @param {Vector2} t3 Third point of the triangle
	 * @returns {number}
	 */
	MathUtils.triangleArea = function (t1, t2, t3) {
		return Math.abs(t1.x * t2.y + t2.x * t3.y + t3.x * t1.y
			- t2.y * t3.x - t3.y * t1.x - t1.y * t2.x) / 2;
	};

	/**
	 * Computes the height of a point located inside a triangle. Height is assumed to bound to the Z axis.
	 * @param {Vector3} t1 First point of the triangle
	 * @param {Vector3} t2 Second point of the triangle
	 * @param {Vector3} t3 Third point of the triangle
	 * @param {Vector3} p The point for which to compute the height
	 * @returns {Vector3}
	 */
	MathUtils.barycentricInterpolation = function (t1, t2, t3, p) {
		var t1Area = MathUtils.triangleArea(t2, t3, p);
		var t2Area = MathUtils.triangleArea(t1, t3, p);
		var t3Area = MathUtils.triangleArea(t1, t2, p);

		// assuming the point is inside the triangle
		var totalArea = t1Area + t2Area + t3Area;
		if (!totalArea) {
			if (p[0] === t1[0] && p[2] === t1[2]) {
				return t1;
			} else if (p[0] === t2[0] && p[2] === t2[2]) {
				return t2;
			} else if (p[0] === t3[0] && p[2] === t3[2]) {
				return t3;
			}
		}

		p.z = (t1Area * t1.z + t2Area * t2.z + t3Area * t3.z) / totalArea;
		return p;
	};

	/**
	 * Performs smooth Hermite interpolation between 0 and 1 when edge0 < x < edge1.
	 * This is useful in cases where a threshold function with a smooth transition is desired.
	 * @param {number} edge0 Specifies the value of the lower edge of the Hermite function.
	 * @param {number} edge1 Specifies the value of the upper edge of the Hermite function.
	 * @param {number} x Specifies the source value for interpolation.
	 * @returns {number}
	 */
	MathUtils.smoothstep = function (edge0, edge1, x) {
		x = MathUtils.clamp((x - edge0) / (edge1 - edge0), 0, 1);
		return x * x * (3 - 2 * x);
	};

	/** @type {number}
	* @example
	* // sets random seed to use with MathUtils.fastRandom()
	* MathUtils.randomSeed = 1337;
	*/
	MathUtils.randomSeed = 1337;

	/**
	 * Rough random generation with seeding. Set random seed through MathUtils.randomSeed = {new seed value}
	 * @returns {number} Random number between 0 and 1.
	 */
	MathUtils.fastRandom = function () {
		MathUtils.randomSeed = (MathUtils.randomSeed * 9301 + 49297) % 233280;
		return MathUtils.randomSeed / 233280;
	};

	/**
	 * Converts a float to half-float representation.
	 * @param {number} value The float value to convert
	 * @returns {number} the half-float representation
	 */
	MathUtils.floatToHalfFloat = (function () {
		var floatView = new Float32Array(1);
		var int32View = new Int32Array(floatView.buffer);

		return function (fval) {
			floatView[0] = fval;
			var fbits = int32View[0];
			var sign = (fbits >> 16) & 0x8000;
			var val = (fbits & 0x7fffffff) + 0x1000;

			if (val >= 0x47800000) {
				if ((fbits & 0x7fffffff) >= 0x47800000) {
					if (val < 0x7f800000) {
						return sign | 0x7c00;
					}
					return sign | 0x7c00 | (fbits & 0x007fffff) >> 13;
				}
				return sign | 0x7bff;
			}
			if (val >= 0x38800000) {
				return sign | val - 0x38000000 >> 13;
			}
			if (val < 0x33000000) {
				return sign;
			}
			val = (fbits & 0x7fffffff) >> 23;
			return sign | ((fbits & 0x7fffff | 0x800000) + (0x800000 >>> val - 102) >> 126 - val);
		};
	})();

	/**
	 * Defines a property on an object that throws an exception when NaN is being assigned to it.
	 * Useful for debugging.
	 * @hidden
	 * @param object
	 * @param property
	 */
	MathUtils.warnNaN = function (object, property) {
		var value = object[property];

		Object.defineProperty(object, property, {
			get: function () { return value; },
			set: function (_value) {
				if (isNaN(_value)) { throw new Error('Tried to assign NaN to ' + property); }
				value = _value;
			}
		});
	};

	module.exports = MathUtils;

/***/ },
/* 10 */
/***/ function(module, exports, __webpack_require__) {

	var ObjectUtils = __webpack_require__(6);
	var MathUtils = __webpack_require__(9);

	/**
	 * Abstract vector class
	 */
	function Vector(size) {

		/**
		 * @hidden
		 * @deprecated
		 */
		this._size = size;
	}

	var COMPONENT_NAMES = ['x', 'y', 'z', 'w'];
	// @ifdef DEBUG
	var COMPONENT_NAMES = ['_x', '_y', '_z', '_w'];
	// @endif

	/**
	 * Binds aliases to the different vector components.
	 * @hidden
	 * @param {Object} prototype The prototype to bind to.
	 * @param {Array<Array<string>>} aliases Array of component aliases for each component index.
	 */
	Vector.setupAliases = function (prototype, aliases) {
		aliases.forEach(function (aliasesPerComponent, index) {
			var componentName = COMPONENT_NAMES[index];

			aliasesPerComponent.forEach(function (alias) {
				Object.defineProperty(prototype, alias, {
					get: function () {
						return this[componentName];
					},
					set: function (value) {
						this[componentName] = value;

						// @ifdef DEBUG
						if (isNaN(this[componentName])) {
							throw new Error('Tried setting NaN to vector component ' + alias);
						}
						// @endif
					}
				});
			});
		});
	};

	// @ifdef DEBUG
	Vector.setupIndices = function (prototype, count) {
		var raise = function () {
			throw new Error('Vector component access through indices is not supported anymore');
		};

		for (var i = 0; i < count; i++) {
			Object.defineProperty(prototype, i, {
				get: raise,
				set: raise
			});
		}
	};

	/**
	 * Replaces the supplied method of object and wraps it in a integrity check
	 * @hidden
	 * @param {Object} object The object to attach the post-check to
	 * @param {string} methodName The name of the original method the check is attached to
	 */
	Vector.addReturnCheck = function (object, methodName) {
		var originalMethod = object[methodName];
		object[methodName] = function () {
			var ret = originalMethod.apply(this, arguments);
			if (isNaN(ret)) {
				throw new Error('Vector method ' + methodName + ' returned NaN');
			}

			return ret;
		};
	};

	/**
	 * Adds more validators at once
	 * @hidden
	 * @param {Object} object
	 * @param {Array<string>} methodNames
	 */
	Vector.addReturnChecks = function (object, methodNames) {
		methodNames.forEach(Vector.addReturnCheck.bind(null, object));
	};
	// @endif

	// SHIM START
	Object.defineProperty(Vector.prototype, 'data', {
		get: ObjectUtils.warnOnce('The .data property of Vector was removed, please use the .x, .y, .z, .w properties instead.', function () {
			var data = [];
			var that = this;
			Object.defineProperties(data, {
				'0': {
					get: function () {
						return that.x;
					},
					set: function (value) {
						that.x = value;
					}
				},
				'1': {
					get: function () {
						return that.y;
					},
					set: function (value) {
						that.y = value;
					}
				},
				'2': {
					get: function () {
						return that.z;
					},
					set: function (value) {
						that.z = value;
					}
				},
				'3': {
					get: function () {
						return that.w;
					},
					set: function (value) {
						that.w = value;
					}
				}
			});
			return data;
		})
	});

	/**
	 * @hidden
	 * @deprecated
	 */
	Vector.add = ObjectUtils.warnOnce('Vector.add is deprecated.', function (lhs, rhs, target) {
		var ldata = lhs.data || lhs;
		var rdata = rhs.data || rhs;
		var size = lhs._size;

		if (!target) {
			target = new Vector(size);
		}

		for (var i = 0; i < size; i++) {
			target.data[i] = ldata[i] + rdata[i];
		}

		return target;
	});

	/**
	 * @hidden
	 * @deprecated
	 */
	Vector.prototype.add = ObjectUtils.warnOnce('Vector.prototype.add is deprecated.', function (rhs) {
		return Vector.add(this, rhs, this);
	});

	/**
	 * @hidden
	 * @deprecated
	 */
	Vector.sub = ObjectUtils.warnOnce('Vector.sub is deprecated.', function (lhs, rhs, target) {
		var ldata = lhs.data || lhs;
		var rdata = rhs.data || rhs;
		var size = lhs._size;

		if (!target) {
			target = new Vector(size);
		}

		for (var i = 0; i < size; i++) {
			target.data[i] = ldata[i] - rdata[i];
		}

		return target;
	});

	/**
	 * @hidden
	 * @deprecated
	 */
	Vector.prototype.sub = ObjectUtils.warnOnce('Vector.prototype.sub is deprecated.', function (rhs) {
		return Vector.sub(this, rhs, this);
	});

	/**
	 * @hidden
	 * @deprecated
	 */
	Vector.mul = ObjectUtils.warnOnce('Vector.mul is deprecated.', function (lhs, rhs, target) {
		var ldata = lhs.data || lhs;
		var rdata = rhs.data || rhs;
		var size = lhs._size;

		if (!target) {
			target = new Vector(size);
		}

		for (var i = 0; i < size; i++) {
			target.data[i] = ldata[i] * rdata[i];
		}

		return target;
	});

	/**
	 * @hidden
	 * @deprecated
	 */
	Vector.prototype.mul = ObjectUtils.warnOnce('Vector.prototype.mul is deprecated.', function (rhs) {
		return Vector.mul(this, rhs, this);
	});

	/**
	 * @hidden
	 * @deprecated
	 */
	Vector.div = ObjectUtils.warnOnce('Vector.div is deprecated.', function (lhs, rhs, target) {
		var ldata = lhs.data || lhs;
		var rdata = rhs.data || rhs;
		var size = lhs._size;

		if (!target) {
			target = new Vector(size);
		}

		for (var i = 0; i < size; i++) {
			target.data[i] = ldata[i] / rdata[i];
		}

		return target;
	});

	/**
	 * @hidden
	 * @deprecated
	 */
	Vector.prototype.div = ObjectUtils.warnOnce('Vector.prototype.div is deprecated.', function (rhs) {
		return Vector.div(this, rhs, this);
	});

	/**
	 * @hidden
	 * @deprecated
	 */
	Vector.copy = ObjectUtils.warnOnce('Vector.copy is deprecated.', function (source, target) {
		var size = source._size;

		if (!target) {
			target = new Vector(size);
		}

		for (var i=0; i<size; i++) {
			target.data[i] = source.data[i];
		}

		return target;
	});

	/**
	 * @hidden
	 * @deprecated
	 */
	Vector.prototype.copy = ObjectUtils.warnOnce('Vector.prototype.copy  is deprecated.', function (source) {
		var size = source._size;
		for (var i=0; i<size; i++) {
			this.data[i] = source.data[i];
		}
		return this;
	});

	/**
	 * @hidden
	 * @deprecated
	 */
	Vector.dot = ObjectUtils.warnOnce('Vector.dot is deprecated.', function (lhs, rhs) {
		var ldata = lhs.data || lhs;
		var rdata = rhs.data || rhs;
		var size = lhs._size;

		var sum = 0;

		for (var i = 0; i < size; i++) {
			sum += ldata[i] * rdata[i];
		}

		return sum;
	});

	/**
	 * @hidden
	 * @deprecated
	 */
	Vector.prototype.dot = ObjectUtils.warnOnce('Vector.prototype.dot is deprecated.', function (rhs) {
		return Vector.dot(this, rhs);
	});

	/**
	 * @hidden
	 * @deprecated
	 */
	Vector.apply = ObjectUtils.warnOnce('Vector.apply is deprecated.', function (lhs, rhs, target) {
		var rows = lhs.rows;
		var cols = lhs.cols;
		var size = rhs._size;

		if (!target) {
			target = new Vector(rows);
		}

		if (target === rhs) {
			return Vector.copy(Vector.apply(lhs, rhs), target);
		}

		for (var c = 0; c < cols; c++) {
			var o = c * rows;

			for (var r = 0; r < rows; r++) {
				var sum = 0.0;

				for (var i = 0; i < size; i++) {
					sum += lhs.data[i * lhs.rows + r] * rhs.data[i];
				}

				target.data[o + r] = sum;
			}
		}

		return target;
	});

	/**
	 * @hidden
	 * @deprecated
	 */
	Vector.prototype.apply = ObjectUtils.warnOnce('Vector.prototype.apply is deprecated.', function (lhs) {
		return Vector.apply(lhs, this, this);
	});

	/**
	 * @hidden
	 * @deprecated
	 */
	Vector.equals = ObjectUtils.warnOnce('Vector.equals is deprecated.', function (lhs, rhs) {
		var lhsLength = lhs._size;
		if (lhsLength !== rhs._size) {
			return false;
		}

		for (var i = 0; i < lhsLength; i++) {
			// why the backwards check? because otherwise if NaN is present in either lhs or rhs
			// then Math.abs(NaN) is NaN which is neither bigger or smaller than EPSILON
			// which never satisfies the condition
			// NaN is not close to to NaN and we want to preserve that for vectors as well
			if (!(Math.abs(lhs.data[i] - rhs.data[i]) <= MathUtils.EPSILON)) {
				return false;
			}
		}

		return true;
	});

	/**
	 * @hidden
	 * @deprecated
	 */
	Vector.prototype.equals = ObjectUtils.warnOnce('Vector.prototype.equals is deprecated.', function (rhs) {
		return Vector.equals(this, rhs);
	});

	/**
	 * @hidden
	 * @deprecated
	 */
	Vector.distanceSquared = ObjectUtils.warnOnce('Vector.distanceSquared is deprecated.', function (lhs, rhs) {
		return Vector.sub(lhs, rhs).lengthSquared();
	});

	/**
	 * @hidden
	 * @deprecated
	 */
	Vector.prototype.distanceSquared = ObjectUtils.warnOnce('Vector.prototype.distanceSquared is deprecated.', function (rhs) {
		return Vector.sub(this, rhs).lengthSquared();
	});

	/**
	 * @hidden
	 * @deprecated
	 */
	Vector.distance = ObjectUtils.warnOnce('Vector.distance is deprecated.', function (lhs, rhs) {
		return Vector.sub(lhs, rhs).length();
	});

	/**
	 * @hidden
	 * @deprecated
	 */
	Vector.prototype.distance = ObjectUtils.warnOnce('Vector.prototype.distance is deprecated.', function (rhs) {
		return Vector.sub(this, rhs).length();
	});

	/**
	 * @hidden
	 * @deprecated
	 */
	Vector.prototype.lengthSquared = ObjectUtils.warnOnce('Vector.prototype.lengthSquared is deprecated.', function () {
		return Vector.dot(this, this);
	});

	/**
	 * @hidden
	 * @deprecated
	 */
	Vector.prototype.length = ObjectUtils.warnOnce('Vector.prototype.length is deprecated.', function () {
		return Math.sqrt(Vector.dot(this, this));
	});

	/**
	 * @hidden
	 * @deprecated
	 */
	Vector.prototype.scale = ObjectUtils.warnOnce('Vector.prototype.scale is deprecated.', function (factor) {
		for (var i = this._size - 1; i >= 0; i--) {
			this.data[i] *= factor;
		}
		return this;
	});

	/**
	 * @hidden
	 * @deprecated
	 */
	Vector.prototype.invert = ObjectUtils.warnOnce('Vector.prototype.invert is deprecated.', function () {
		for (var i = 0; i < this._size; i++) {
			this.data[i] = 0.0 - this.data[i];
		}

		return this;
	});

	/**
	 * @hidden
	 * @deprecated
	 */
	Vector.prototype.normalize = ObjectUtils.warnOnce('Vector.prototype.normalize is deprecated.', function () {
		var l = this.length();
		var dataLength = this._size;

		if (l < MathUtils.EPSILON) {
			for (var i = 0; i < dataLength; i++) {
				this.data[i] = 0;
			}
		} else {
			l = 1.0 / l;
			for (var i = 0; i < dataLength; i++) {
				this.data[i] *= l;
			}
		}

		return this;
	});

	/**
	 * @hidden
	 * @deprecated
	 */
	Vector.prototype.clone = ObjectUtils.warnOnce('Vector.prototype.clone is deprecated.', function () {
		return Vector.copy(this);
	});

	/**
	 * @hidden
	 * @deprecated
	 */
	Vector.prototype.set = ObjectUtils.warnOnce('Vector.prototype.set is deprecated.', function () {
		if (arguments.length === 1 && typeof arguments[0] === 'object') {
			if (arguments[0] instanceof Vector) {
				this.copy(arguments[0]);
			} else {
				for (var i = 0; i < arguments[0].length; i++) {
					this.data[i] = arguments[0][i];
				}
			}
		} else {
			for (var i = 0; i < arguments.length; i++) {
				this.data[i] = arguments[i];
			}
		}

		return this;
	});

	/**
	 * @hidden
	 * @deprecated
	 */
	Vector.prototype.toString = ObjectUtils.warnOnce('Vector.prototype.toString is deprecated.', function () {
		var string = '';

		string += '[';

		for (var i = 0; i < this._size; i++) {
			string += this.data[i];
			string += i !== this._size - 1 ? ', ' : '';
		}

		string += ']';

		return string;
	});
	// SHIM END

	module.exports = Vector;


/***/ },
/* 11 */
/***/ function(module, exports, __webpack_require__) {

	var ObjectUtils = __webpack_require__(6);
	var MathUtils = __webpack_require__(9);
	var Vector = __webpack_require__(10);

	/**
	 * Vector with 4 components
	 * @extends Vector
	 * @param {number} x
	 * @param {number} y
	 * @param {number} z
	 * @param {number} w
	 * @example
	 * var v1 = new Vector4(); // v1 == (0, 0, 0, 0)
	 * var v2 = new Vector4(1, 2, 3, 4); // v2 == (1, 2, 3, 4)
	 */
	function Vector4(x, y, z, w) {
		// @ifdef DEBUG
		this._x = 0;
		this._y = 0;
		this._z = 0;
		this._w = 0;
		// @endif

		if (arguments.length === 0) {
			// Nothing given
			this.x = 0;
			this.y = 0;
			this.z = 0;
			this.w = 0;
		} else if (arguments.length === 1 && typeof arguments[0] === 'object') {
			if (arguments[0] instanceof Vector4) {
				// Vector4
				this.copy(arguments[0]);
			} else {
				// Array
				this.x = arguments[0][0];
				this.y = arguments[0][1];
				this.z = arguments[0][2];
				this.w = arguments[0][3];
			}
		} else {
			// Numbers
			this.x = x;
			this.y = y;
			this.z = z;
			this.w = w;
		}

		// @ifdef DEBUG
		Object.seal(this);
		// @endif
	}

	Vector4.prototype = Object.create(Vector.prototype);
	Vector4.prototype.constructor = Vector4;

	// @ifdef DEBUG
	Vector.setupAliases(Vector4.prototype, [['x'], ['y'], ['z'], ['w']]);
	Vector.setupIndices(Vector4.prototype, 4);
	// @endif

	Vector.setupAliases(Vector4.prototype, [['r'], ['g'], ['b'], ['a']]);

	/**
	 * Zero-vector (0, 0, 0, 0)
	 * @type {Vector4}
	 */
	Vector4.ZERO = new Vector4(0, 0, 0, 0);

	/**
	 * One-vector (1, 1, 1, 1)
	 * @type {Vector4}
	 */
	Vector4.ONE = new Vector4(1, 1, 1, 1);

	/**
	 * Unit-X (1, 0, 0, 0)
	 * @type {Vector4}
	 */
	Vector4.UNIT_X = new Vector4(1, 0, 0, 0);

	/**
	 * Unit-Y (0, 1, 0, 0)
	 * @type {Vector4}
	 */
	Vector4.UNIT_Y = new Vector4(0, 1, 0, 0);

	/**
	 * Unit-Z (0, 0, 1, 0)
	 * @type {Vector4}
	 */
	Vector4.UNIT_Z = new Vector4(0, 0, 1, 0);

	/**
	 * Unit-W (0, 0, 0, 1)
	 * @type {Vector4}
	 */
	Vector4.UNIT_W = new Vector4(0, 0, 0, 1);

	/**
	 * Returns the vector component associated with the given index.
	 * Vector components are numbered from 0 to 3 in this order: x, y, z, w.
	 * @param {number} index
	 * @returns {number}
	 */
	Vector4.prototype.getComponent = function (index) {
		switch (index) {
			case 0: return this.x;
			case 1: return this.y;
			case 2: return this.z;
			case 3: return this.w;
		}
	};

	/**
	 * Sets the vector component associated with the given index to a given value.
	 * Vector components are numbered from 0 to 3 in this order: x, y, z, w.
	 * @param {number} index
	 * @param {number} value
	 * @returns {Vector4} Self to allow chaining
	 */
	Vector4.prototype.setComponent = function (index, value) {
		switch (index) {
			case 0: this.x = value; break;
			case 1: this.y = value; break;
			case 2: this.z = value; break;
			case 3: this.w = value; break;
		}
		return this;
	};

	/**
	 * Adds a vector to the current vector
	 * @param {Vector4} rhs
	 * @returns {Vector4} Self to allow chaining
	 * @example
	 * var v1 = new Vector4(1, 2, 3, 4);
	 * var v2 = new Vector4(4, 5, 6, 7);
	 * v1.add(v2); // v1 == (5, 7, 9, 11)
	 */
	Vector4.prototype.add = function (rhs) {
		this.x += rhs.x;
		this.y += rhs.y;
		this.z += rhs.z;
		this.w += rhs.w;

		return this;
	};

	/**
	 * Adds numbers 'x', 'y', 'z', 'w' to the current Vector4 values
	 * @param {number} x
	 * @param {number} y
	 * @param {number} z
	 * @param {number} w
	 * @returns {Vector4} Self to allow chaining
	 * @example
	 * var v = new Vector4(1, 2, 3, 4);
	 * v.addDirect(2, 4, 6, 8); // v == (3, 6, 9, 12)
	 */
	Vector4.prototype.addDirect = function (x, y, z, w) {
		this.x += x;
		this.y += y;
		this.z += z;
		this.w += w;

		return this;
	};

	/**
	 * Adds a vector from the current vector
	 * @param {Vector4} rhs
	 * @returns {Vector4} Self to allow chaining
	 * @example
	 * var v1 = new Vector4(4, 5, 6, 7);
	 * var v2 = new Vector4(1, 2, 3, 4);
	 * v1.sub(v2); // v1 == (3, 3, 3, 3)
	 */
	Vector4.prototype.sub = function (rhs) {
		this.x -= rhs.x;
		this.y -= rhs.y;
		this.z -= rhs.z;
		this.w -= rhs.w;

		return this;
	};

	/**
	 * Subtracts numbers 'x', 'y', 'z', 'w' from the current Vector4
	 * @param {number} x
	 * @param {number} y
	 * @param {number} z
	 * @param {number} w
	 * @returns {Vector4} Self to allow chaining
	 * @example
	 * var v = new Vector4(); // v == (0, 0, 0, 0)
	 * v.subDirect(1, 2, 3); // v == (-1, -2, -3, -4)
	 */
	Vector4.prototype.subDirect = function (x, y, z, w) {
		this.x -= x;
		this.y -= y;
		this.z -= z;
		this.w -= w;

		return this;
	};

	/**
	 * Performs component-wise negation of the vector
	 * @returns {Vector4} Self to allow chaining
	 */
	Vector4.prototype.negate = function () {
		this.x = -this.x;
		this.y = -this.y;
		this.z = -this.z;
		this.w = -this.w;

		return this;
	};

	/**
	 * Multiplies the current vector by another vector
	 * @param {Vector4} rhs
	 * @returns {Vector4} Self to allow chaining
	 * @example
	 * var v1 = new Vector4(4, 5, 6, 7);
	 * var v2 = new Vector4(1, 2, 3, 4);
	 * v1.mul(v2); // v1 == (4, 10, 18, 28)
	 */
	Vector4.prototype.mul = function (rhs) {
		this.x *= rhs.x;
		this.y *= rhs.y;
		this.z *= rhs.z;
		this.w *= rhs.w;

		return this;
	};

	/**
	 * Multiplies the current Vector4 by numbers 'x', 'y', 'z', 'w' as inputs
	 * @param {number} x
	 * @param {number} y
	 * @param {number} z
	 * @param {number} w
	 * @returns {Vector4} Self to allow chaining
	 * @example
	 * var v = new Vector4(1, 2, 3, 4);
	 * v.mulDirect(2, 4, 6, 8); // v == (2, 8, 18, 32)
	 */
	Vector4.prototype.mulDirect = function (x, y, z, w) {
		this.x *= x;
		this.y *= y;
		this.z *= z;
		this.w *= w;

		return this;
	};

	/**
	 * Scales the vector by a factor
	 * @param {number} factor
	 * @returns {Vector4} Self to allow chaining
	 */
	Vector4.prototype.scale = function (factor) {
		this.x *= factor;
		this.y *= factor;
		this.z *= factor;
		this.w *= factor;

		return this;
	};

	/**
	 * Divides the current Vector4 by another vector
	 * @param {Vector4} rhs
	 * @returns {Vector4} Self to allow chaining
	 * @example
	 * var v = new Vector4(2, 4, 6, 8);
	 * v.divDirect(1, 2, 3, 4); // v == (2, 2, 2, 2)
	 */
	Vector4.prototype.div = function (rhs) {
		this.x /= rhs.x;
		this.y /= rhs.y;
		this.z /= rhs.z;
		this.w /= rhs.w;

		return this;
	};

	/**
	 * Divides the current Vector4 by numbers 'x', 'y', 'z', 'w' as inputs
	 * @param {number} x
	 * @param {number} y
	 * @param {number} z
	 * @param {number} w
	 * @returns {Vector4} Self to allow chaining
	 * @example
	 * var v = new Vector4(4, 9, 16, 25);
	 * v.divDirect(2, 3, 4, 5); // v == (2, 3, 4, 5)
	 */
	Vector4.prototype.divDirect = function (x, y, z, w) {
		this.x /= x;
		this.y /= y;
		this.z /= z;
		this.w /= w;

		return this;
	};

	/**
	 * Computes the dot product between the current vector and another vector
	 * @param {Vector4} rhs
	 * @returns {number}
	 */
	Vector4.prototype.dot = function (rhs) {
		return this.x * rhs.x +
			this.y * rhs.y +
			this.z * rhs.z +
			this.w * rhs.w;
	};

	/**
	 * Computes the dot product between the current vector and another vector given as 3 values
	 * @param {number} x
	 * @param {number} y
	 * @param {number} z
	 * @param {number} w
	 * @returns {number}
	 */
	Vector4.prototype.dotDirect = function (x, y, z, w) {
		return this.x * x +
			this.y * y +
			this.z * z +
			this.w * w;
	};

	/**
	 * Returns whether this vector is aproximately equal to a given vector
	 * @param rhs
	 * @returns {boolean}
	 */
	Vector4.prototype.equals = function (rhs) {
		return (Math.abs(this.x - rhs.x) <= MathUtils.EPSILON) &&
			(Math.abs(this.y - rhs.y) <= MathUtils.EPSILON) &&
			(Math.abs(this.z - rhs.z) <= MathUtils.EPSILON) &&
			(Math.abs(this.w - rhs.w) <= MathUtils.EPSILON);
	};

	/**
	 * Returns whether this vector is approximately equal to a given vector given as 3 values
	 * @param {number} x
	 * @param {number} y
	 * @param {number} z
	 * @param {number} w
	 * @returns {boolean}
	 */
	Vector4.prototype.equalsDirect = function (x, y, z, w) {
		return (Math.abs(this.x - x) <= MathUtils.EPSILON) &&
			(Math.abs(this.y - y) <= MathUtils.EPSILON) &&
			(Math.abs(this.z - z) <= MathUtils.EPSILON) &&
			(Math.abs(this.w - w) <= MathUtils.EPSILON);
	};

	/**
	 * Linearly interpolates between the current Vector4 and an 'end' Vector4
	 * @param {Vector4} end End Vector4
	 * @param {number} factor Interpolation factor between 0.0 and 1.0
	 * @returns {Vector4} Self to allow chaining
	 * @example
	 * var from = new Vector4(1, 2, 3, 4);
	 * var to = new Vector4(3, 4, 5, 6);
	 * var midway = from.clone().lerp(to, 0.5); // midway == (2, 3, 4, 5)
	 */
	Vector4.prototype.lerp = function (end, factor) {
		this.x += (end.x - this.x) * factor;
		this.y += (end.y - this.y) * factor;
		this.z += (end.z - this.z) * factor;
		this.w += (end.w - this.w) * factor;

		return this;
	};

	(function () {
		var tmpVec = new Vector4();

		/**
		 * Reflects a vector relative to the plane obtained from the normal parameter.
		 * @param {Vector4} normal Defines the plane that reflects the vector. Assumed to be of unit length.
		 * @returns {Vector4} Self to allow chaining
		 */
		Vector4.prototype.reflect = function (normal) {
			tmpVec.copy(normal);
			tmpVec.scale(2 * this.dot(normal));
			this.sub(tmpVec);
			return this;
		};
	})();

	/**
	 * Sets the vector's values from another vector's values
	 * @param {Vector4} rhs
	 * @returns {Vector4} Self to allow chaining
	 * @example
	 * var v = new Vector4(); // v == (0, 0, 0, 0)
	 * v.set(new Vector4(2, 4, 6, 8)); // v == (2, 4, 6, 8)
	 */
	Vector4.prototype.set = function (rhs) {
		if (rhs instanceof Vector4) {
			this.x = rhs.x;
			this.y = rhs.y;
			this.z = rhs.z;
			this.w = rhs.w;
		} else {
			this.x = arguments[0];
			this.y = arguments[1];
			this.z = arguments[2];
			this.w = arguments[3];
		}

		return this;
	};

	/**
	 * Sets the vector's values from 4 numeric arguments
	 * @param {number} x
	 * @param {number} y
	 * @param {number} z
	 * @param {number} w
	 * @returns {Vector4} Self to allow chaining
	 * @example
	 * var v = new Vector4(); // v == (0, 0, 0, 0)
	 * v.setDirect(2, 4, 6, 8); // v == (2, 4, 6, 8)
	 */
	Vector4.prototype.setDirect = function (x, y, z, w) {
		this.x = x;
		this.y = y;
		this.z = z;
		this.w = w;

		return this;
	};

	/**
	 * Calculates the squared length/magnitude of the current Vector4.
	 * Note: When comparing the relative distances between two points it is usually sufficient
	 * to compare the squared distances, thus avoiding an expensive square root operation.
	 * @returns {number} squared length
	 * @example
	 * var v = new Vector4(0, 9, 0, 0);
	 * v.lengthSquared(); // 81
	 */
	Vector4.prototype.lengthSquared = function () {
		return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
	};

	/**
	 * Calculates length squared of vector
	 * @returns {number} length squared
	 */
	Vector4.prototype.length = function () {
		return Math.sqrt(this.lengthSquared());
	};

	/**
	 * Normalizes the current vector
	 * @returns {Vector4} Self to allow chaining
	 */
	Vector4.prototype.normalize = function () {
		var length = this.length();

		if (length < MathUtils.EPSILON) {
			this.x = 0;
			this.y = 0;
			this.z = 0;
			this.w = 0;
		} else {
			this.x /= length;
			this.y /= length;
			this.z /= length;
			this.w /= length;
		}

		return this;
	};

	/**
	 * Normalizes the current vector; this method does not perform special checks for zero length vectors
	 * @returns {Vector4} Self to allow chaining
	 */
	Vector4.prototype.unsafeNormalize = function () {
		var length = this.length();

		this.x /= length;
		this.y /= length;
		this.z /= length;
		this.w /= length;

		return this;
	};

	/**
	 * Computes the squared distance between the current Vector4 and another Vector4.
	 * Note: When comparing the relative distances between two points it is usually sufficient
	 * to compare the squared distances, thus avoiding an expensive square root operation.
	 * @param {Vector4} rhs Vector4
	 * @returns {number} distance squared
	 * @example
	 * var v1 = new Vector4(); // v1 == (0, 0, 0, 0)
	 * var v2 = new Vector4(0, 9, 0, 0);
	 * v1.distanceSquared(v2); // 81
	 */
	Vector4.prototype.distanceSquared = function (rhs) {
		var deltaX = this.x - rhs.x;
		var deltaY = this.y - rhs.y;
		var deltaZ = this.z - rhs.z;
		var deltaW = this.w - rhs.w;

		return deltaX * deltaX + deltaY * deltaY + deltaZ * deltaZ + deltaW * deltaW;
	};

	/**
	 * Computes the distance between the current Vector4 and another Vector4.
	 * Note: When comparing the relative distances between two points it is usually sufficient
	 * to compare the squared distances, thus avoiding an expensive square root operation.
	 * @param {Vector4} rhs Vector4
	 * @returns {number} distance
	 * @example
	 * var v1 = new Vector4(); // v1 == (0, 0, 0, 0)
	 * var v2 = new Vector4(0, 9, 0, 0);
	 * v1.distance(v2); // 9
	 */
	Vector4.prototype.distance = function (rhs) {
		return Math.sqrt(this.distanceSquared(rhs));
	};

	/**
	 * Multiplies this vector with a Matrix4
	 * @param {Matrix4} matrix
	 * @returns {Vector4} Self to allow chaining
	 */
	Vector4.prototype.applyPre = function (matrix) {
		var source = matrix.data;

		var x = this.x;
		var y = this.y;
		var z = this.z;
		var w = this.w;

		this.x = source[ 0] * x + source[ 1] * y + source[ 2] * z + source[ 3] * w;
		this.y = source[ 4] * x + source[ 5] * y + source[ 6] * z + source[ 7] * w;
		this.z = source[ 8] * x + source[ 9] * y + source[10] * z + source[11] * w;
		this.w = source[12] * x + source[13] * y + source[14] * z + source[15] * w;

		return this;
	};

	/**
	 * Multiplies a Matrix4 with this vector
	 * @param {Matrix4} matrix
	 * @returns {Vector4} Self to allow chaining
	 */
	Vector4.prototype.applyPost = function (matrix) {
		var source = matrix.data;

		var x = this.x;
		var y = this.y;
		var z = this.z;
		var w = this.w;

		this.x = source[0] * x + source[4] * y + source[ 8] * z + source[12] * w;
		this.y = source[1] * x + source[5] * y + source[ 9] * z + source[13] * w;
		this.z = source[2] * x + source[6] * y + source[10] * z + source[14] * w;
		this.w = source[3] * x + source[7] * y + source[11] * z + source[15] * w;

		return this;
	};

	/**
	 * Clones the vector
	 * @returns {Vector4} Clone of self
	 */
	Vector4.prototype.clone = function () {
		return new Vector4(this.x, this.y, this.z, this.w);
	};

	/**
	 * Copies the values of another vector to this vector; an alias for .setVector
	 * @param {Vector4} Source vector
	 * @returns {Vector4} Self to allow chaining
	 */
	Vector4.prototype.copy = Vector4.prototype.set;

	/**
	 * Copies this vector over another. Not equivalent to `target.copy(this)` when
	 * the target vector has more components than the source vector
	 * @param {Vector} target
	 * @returns {Vector4} Self to allow chaining
	 */
	Vector4.prototype.copyTo = function (target) {
		target.x = this.x;
		target.y = this.y;
		target.z = this.z;
		target.w = this.w;

		return this;
	};

	/**
	 * Creates a Vector4 given an array
	 * @param {Array<number>} array
	 * @returns {Vector4}
	 */
	Vector4.fromArray = function (array) {
		return new Vector4(array[0], array[1], array[2], array[3]);
	};

	/**
	 * Creates a Vector4 given 4 numbers, an array, an {x, y, z, w} object or another Vector4
	 * @returns {Vector4}
	 */
	Vector4.fromAny = function () {
		if (arguments.length === 4) {
			return Vector4.fromArray(arguments);
		} else if (arguments[0] instanceof Array) {
			return Vector4.fromArray(arguments[0]);
		} else {
			var vectorLike = arguments[0];
			return new Vector4(vectorLike.x, vectorLike.y, vectorLike.z, vectorLike.w);
		}
	};

	/**
	 * Sets the vector content from an array of numbers.
	 * @param {Array<number>} array
	 */
	Vector4.prototype.setArray = function (array) {
		this.x = array[0];
		this.y = array[1];
		this.z = array[2];
		this.w = array[3];
		return this;
	};

	/**
	 * Returns the components of the vector in array form
	 * @returns {Array<number>}
	 */
	Vector4.prototype.toArray = function () {
		return [this.x, this.y, this.z, this.w];
	};

	// @ifdef DEBUG
	Vector.addReturnChecks(Vector4.prototype, [
		'dot', 'dotDirect',
		'length', 'lengthSquared',
		'distance', 'distanceSquared'
	]);
	// @endif

	// SHIM START
	Object.defineProperty(Vector4.prototype, 'data', {
		get: ObjectUtils.warnOnce('The .data property of Vector4 was removed. Please use the .x, .y, .z and .w properties instead.', function () {
			var data = [];
			var that = this;
			Object.defineProperties(data, {
				'0': {
					get: function () {
						return that.x;
					},
					set: function (value) {
						that.x = value;
					}
				},
				'1': {
					get: function () {
						return that.y;
					},
					set: function (value) {
						that.y = value;
					}
				},
				'2': {
					get: function () {
						return that.z;
					},
					set: function (value) {
						that.z = value;
					}
				},
				'3': {
					get: function () {
						return that.w;
					},
					set: function (value) {
						that.w = value;
					}
				}
			});
			return data;
		})
	});

	/**
	 * @hidden
	 * @deprecated
	 */
	Vector4.prototype.setVector = ObjectUtils.warnOnce('The setVector method of Vector4 is deprecated. Please use the set method instead.', function (rhs) {
		return this.set(rhs);
	});

	/**
	 * @hidden
	 * @deprecated
	 */
	Vector4.add = ObjectUtils.warnOnce('Vector4.add is deprecated. Use Vector4.prototype.add instead.', function (lhs, rhs, target) {
		if (typeof lhs === 'number') {
			lhs = [lhs, lhs, lhs, lhs];
		}

		if (typeof rhs === 'number') {
			rhs = [rhs, rhs, rhs, rhs];
		}

		if (!target) {
			target = new Vector4();
		}

		var ldata = lhs.data || lhs;
		var rdata = rhs.data || rhs;

		target.data[0] = ldata[0] + rdata[0];
		target.data[1] = ldata[1] + rdata[1];
		target.data[2] = ldata[2] + rdata[2];
		target.data[3] = ldata[3] + rdata[3];

		return target;
	});

	/**
	 * @hidden
	 * @deprecated
	 */
	Vector4.sub = ObjectUtils.warnOnce('Vector4.sub is deprecated. Use Vector4.prototype.sub instead.', function (lhs, rhs, target) {
		if (typeof lhs === 'number') {
			lhs = [lhs, lhs, lhs, lhs];
		}

		if (typeof rhs === 'number') {
			rhs = [rhs, rhs, rhs, rhs];
		}

		if (!target) {
			target = new Vector4();
		}

		var ldata = lhs.data || lhs;
		var rdata = rhs.data || rhs;

		target.data[0] = ldata[0] - rdata[0];
		target.data[1] = ldata[1] - rdata[1];
		target.data[2] = ldata[2] - rdata[2];
		target.data[3] = ldata[3] - rdata[3];

		return target;
	});

	/**
	 * @hidden
	 * @deprecated
	 */
	Vector4.mul = ObjectUtils.warnOnce('Vector4.mul is deprecated. Use Vector4.prototype.mul instead.', function (lhs, rhs, target) {
		if (typeof lhs === 'number') {
			lhs = [lhs, lhs, lhs, lhs];
		}

		if (typeof rhs === 'number') {
			rhs = [rhs, rhs, rhs, rhs];
		}

		if (!target) {
			target = new Vector4();
		}

		var ldata = lhs.data || lhs;
		var rdata = rhs.data || rhs;

		target.data[0] = ldata[0] * rdata[0];
		target.data[1] = ldata[1] * rdata[1];
		target.data[2] = ldata[2] * rdata[2];
		target.data[3] = ldata[3] * rdata[3];

		return target;
	});

	/**
	 * @hidden
	 * @deprecated
	 */
	Vector4.div = ObjectUtils.warnOnce('Vector4.div is deprecated. Use Vector4.prototype.div instead.', function (lhs, rhs, target) {
		if (typeof lhs === 'number') {
			lhs = [lhs, lhs, lhs, lhs];
		}

		if (typeof rhs === 'number') {
			rhs = [rhs, rhs, rhs, rhs];
		}

		if (!target) {
			target = new Vector4();
		}

		var ldata = lhs.data || lhs;
		var rdata = rhs.data || rhs;

		target.data[0] = ldata[0] / rdata[0];
		target.data[1] = ldata[1] / rdata[1];
		target.data[2] = ldata[2] / rdata[2];
		target.data[3] = ldata[3] / rdata[3];

		return target;
	});

	/**
	 * @hidden
	 * @deprecated
	 */
	Vector4.dot = ObjectUtils.warnOnce('Vector4.dot is deprecated. Use Vector4.prototype.dot instead.', function (lhs, rhs) {
		if (typeof lhs === 'number') {
			lhs = [lhs, lhs, lhs, lhs];
		}

		if (typeof rhs === 'number') {
			rhs = [rhs, rhs, rhs, rhs];
		}

		var ldata = lhs.data || lhs;
		var rdata = rhs.data || rhs;

		return ldata[0] * rdata[0] +
			ldata[1] * rdata[1] +
			ldata[2] * rdata[2] +
			ldata[3] * rdata[3];
	});

	/**
	 * @hidden
	 * @deprecated
	 */
	Vector4.prototype.addVector = ObjectUtils.warnOnce('Vector4.prototype.addVector is deprecated. Use .add instead.', function (vector) {
		this.data[0] += vector.data[0];
		this.data[1] += vector.data[1];
		this.data[2] += vector.data[2];
		this.data[3] += vector.data[3];

		return this;
	});

	/**
	 * @hidden
	 * @deprecated
	 */
	Vector4.prototype.dotVector = ObjectUtils.warnOnce('Vector4.prototype.dotVector is deprecated. Use .dot instead.', function (rhs) {
		var ldata = this.data;
		var rdata = rhs.data;

		return ldata[0] * rdata[0] +
			ldata[1] * rdata[1] +
			ldata[2] * rdata[2] +
			ldata[3] * rdata[3];
	});

	/**
	 * @hidden
	 * @deprecated
	 */
	Vector4.prototype.mulVector = ObjectUtils.warnOnce('Vector4.prototype.mulVector is deprecated. Use .mul instead.', function (vector) {
		this.data[0] *= vector.data[0];
		this.data[1] *= vector.data[1];
		this.data[2] *= vector.data[2];
		this.data[3] *= vector.data[3];

		return this;
	});

	/**
	 * @hidden
	 * @deprecated
	 */
	Vector4.prototype.setVector = ObjectUtils.warnOnce('Vector4.prototype.setVector is deprecated. Use .set instead.', function (vector) {
		this.data[0] = vector.data[0];
		this.data[1] = vector.data[1];
		this.data[2] = vector.data[2];
		this.data[3] = vector.data[3];

		return this;
	});

	/**
	 * @hidden
	 * @deprecated
	 */
	Vector4.prototype.subVector = ObjectUtils.warnOnce('Vector4.prototype.subVector is deprecated. Use .sub instead.', function (vector) {
		this.data[0] -= vector.data[0];
		this.data[1] -= vector.data[1];
		this.data[2] -= vector.data[2];
		this.data[3] -= vector.data[3];

		return this;
	});

	// SHIM END

	module.exports = Vector4;


/***/ },
/* 12 */
/***/ function(module, exports, __webpack_require__) {

	var Vector3 = __webpack_require__(8);

	/**
	 * <code>BoundingVolume</code> Base class for boundings
	 */
	function BoundingVolume(center) {
		//! AT: this is one of the few classes that's cloning its input
		// I don't dare change the behaviour since there's no telling what will break
		this.center = new Vector3();
		if (center) {
			this.center.set(center);
		}

		//! AT: can these be private?
		// they are updated only by some methods and would therefore be useless for external use
		this.min = new Vector3(Infinity, Infinity, Infinity);
		this.max = new Vector3(-Infinity, -Infinity, -Infinity);
	}

	/**
	 * Copies data from another bounding volume
	 * @param {BoundingVolume} source
	 * @returns {BoundingVolume}
	 */
	BoundingVolume.prototype.copy = function (source) {
		this.center.copy(source.center);
		this.min.copy(source.min);
		this.min.copy(source.min);
		return this;
	};

	/**
	 * Intersection type
	 */
	BoundingVolume.Outside = 0;
	BoundingVolume.Inside = 1;
	BoundingVolume.Intersects = 2;

	module.exports = BoundingVolume;

/***/ },
/* 13 */
/***/ function(module, exports, __webpack_require__) {

	var Vector3 = __webpack_require__(8);
	var MathUtils = __webpack_require__(9);
	var BoundingVolume = __webpack_require__(12);
	var MeshData = __webpack_require__(14);

	/**
	 * <code>BoundingSphere</code> defines a sphere that defines a container for a group of vertices of a particular piece of geometry. This
	 *        sphere defines a radius and a center. <br>
	 *        <br>
	 *        A typical usage is to allow the class define the center and radius by calling either <code>containAABB</code> or
	 *        <code>averagePoints</code>. A call to <code>computeFramePoint</code> in turn calls <code>containAABB</code>.
	 */
	function BoundingSphere(center, radius) {
		BoundingVolume.call(this, center);
		this.radius = radius !== undefined ? radius : 1;

		// @ifdef DEBUG
		Object.seal(this);
		// @endif
	}

	var tmpVec = new Vector3();

	BoundingSphere.prototype = Object.create(BoundingVolume.prototype);
	BoundingSphere.prototype.constructor = BoundingSphere;

	BoundingSphere.prototype.computeFromPoints = function (verts) {
		var l = verts.length;
		if (l < 3) {
			return;
		}

		var min = this.min;
		var max = this.max;
		var vec = tmpVec;

		min.setDirect(verts[0], verts[1], verts[2]);
		max.setDirect(verts[0], verts[1], verts[2]);
		var x, y, z;
		for (var i = 3; i < l; i += 3) {
			x = verts[i + 0];
			y = verts[i + 1];
			z = verts[i + 2];
			min.x = x < min.x ? x : min.x;
			min.y = y < min.y ? y : min.y;
			min.z = z < min.z ? z : min.z;
			max.x = x > max.x ? x : max.x;
			max.y = y > max.y ? y : max.y;
			max.z = z > max.z ? z : max.z;
		}
		var newCenter = max.add(min).scale(1 / 2.0);
		var size = 0, test;
		for (var i = 0; i < l; i += 3) {
			vec.setDirect(verts[i], verts[i + 1], verts[i + 2]);
			test = vec.sub(newCenter).lengthSquared();
			if (test > size) {
				size = test;
			}
		}

		this.radius = Math.sqrt(size);
		this.center.set(newCenter);
	};

	(function () {
		var relativePoint = new Vector3();

		/**
		 * Method to test whether a point is inside the bounding box or not
		 * @param {Vector3} point
		 * @returns {boolean}
		 */
		BoundingSphere.prototype.containsPoint = function (point) {
			return relativePoint.set(point).sub(this.center).lengthSquared() <= Math.pow(this.radius, 2);
		};
	})();

	BoundingSphere.prototype.computeFromPrimitives = function (data, section, indices, start, end) {
		if (end - start <= 0) {
			return;
		}

		var vertList = [];
		var store = [];
		var vertsPerPrimitive = MeshData.getVertexCount(data.indexModes[section]);

		var count = 0;
		for (var i = start; i < end; i++) {
			store = data.getPrimitiveVertices(indices[i], section, store);
			for (var j = 0; j < vertsPerPrimitive; j++) {
				vertList[count++] = new Vector3().set(store[j]);
			}
		}

		this.averagePoints(vertList);
	};

	BoundingSphere.prototype.averagePoints = function (points) {
		this.center.set(points[0]);

		for (var i = 1; i < points.length; i++) {
			this.center.add(points[i]);
		}

		var quantity = 1.0 / points.length;
		this.center.scale(quantity);

		var maxRadiusSqr = 0.0;
		for (var i = 0; i < points.length; i++) {
			var diff = tmpVec.copy(points[i]).sub(this.center);
			var radiusSqr = diff.lengthSquared();
			if (radiusSqr > maxRadiusSqr) {
				maxRadiusSqr = radiusSqr;
			}
		}

		this.radius = Math.sqrt(maxRadiusSqr) + 0.00001;
	};

	BoundingSphere.prototype.transform = function (transform, bound) {
		if (bound === null) {
			bound = new BoundingSphere();
		}

		transform.applyForward(this.center, bound.center);

		var scale = transform.scale;
		bound.radius = Math.abs(this._maxAxis(scale) * this.radius);

		return bound;
	};

	BoundingSphere.prototype.whichSide = function (plane) {
		var planeData = plane.normal;
		var pointData = this.center;
		var distance = planeData.x * pointData.x + planeData.y * pointData.y + planeData.z * pointData.z - plane.constant;

		if (distance < -this.radius) {
			return BoundingVolume.Inside;
		} else if (distance > this.radius) {
			return BoundingVolume.Outside;
		} else {
			return BoundingVolume.Intersects;
		}
	};

	BoundingSphere.prototype._pseudoDistance = function (plane, point) {
		return plane.normal.x * point.x + plane.normal.y * point.y + plane.normal.z * point.z - plane.constant;
	};

	BoundingSphere.prototype._maxAxis = function (scale) {
		return Math.max(Math.abs(scale.x), Math.max(Math.abs(scale.y), Math.abs(scale.z)));
	};

	BoundingSphere.prototype.toString = function () {
		var x = Math.round(this.center.x * 10) / 10;
		var y = Math.round(this.center.y * 10) / 10;
		var z = Math.round(this.center.z * 10) / 10;
		var radius = Math.round(this.radius * 10) / 10;

		return '[' + x + ',' + y + ',' + z + ']' + ' - ' + radius;
	};

	BoundingSphere.prototype.intersects = function (bv) {
		return bv.intersectsSphere(this);
	};

	BoundingSphere.prototype.intersectsBoundingBox = function (bb) {
		// bb.min/max aren't updated properly; have to do it here for now
		bb.min.x = bb.center.x - bb.xExtent;
		bb.min.y = bb.center.y - bb.yExtent;
		bb.min.z = bb.center.z - bb.zExtent;

		bb.max.x = bb.center.x + bb.xExtent;
		bb.max.y = bb.center.y + bb.yExtent;
		bb.max.z = bb.center.z + bb.zExtent;

		var rs = Math.pow(this.radius, 2);
		var dmin = 0;

		if (this.center.x < bb.min.x) {
			dmin += Math.pow(this.center.x - bb.min.x, 2);
		} else if (this.center.x > bb.max.x) {
			dmin += Math.pow(this.center.x - bb.max.x, 2);
		}

		if (this.center.y < bb.min.y) {
			dmin += Math.pow(this.center.y - bb.min.y, 2);
		} else if (this.center.y > bb.max.y) {
			dmin += Math.pow(this.center.y - bb.max.y, 2);
		}

		if (this.center.z < bb.min.z) {
			dmin += Math.pow(this.center.z - bb.min.z, 2);
		} else if (this.center.z > bb.max.z) {
			dmin += Math.pow(this.center.z - bb.max.z, 2);
		}

		return dmin <= rs;
	};

	BoundingSphere.prototype.intersectsSphere = function (bs) {
		var diff = tmpVec.set(this.center).sub(bs.center);
		var rsum = this.radius + bs.radius;
		return diff.dot(diff) <= rsum * rsum;
		//return this.center.distanceSquared(bs.center) <= rsum * rsum;
	};

	BoundingSphere.prototype.intersectsRay = function (ray) {
		if (!this.center) {
			return false;
		}

		var diff = ray.origin.clone().sub(this.center);
		var a = diff.dot(diff) - this.radius * this.radius;
		if (a <= 0.0) {
			// in sphere
			return true;
		}

		// outside sphere
		var b = ray.direction.dot(diff);
		if (b >= 0.0) {
			return false;
		}
		return b * b >= a;
	};

	BoundingSphere.prototype.intersectsRayWhere = function (ray) {
		var diff = new Vector3().copy(ray.origin).sub(this.center);
		var a = diff.dot(diff) - this.radius * this.radius;
		var a1, discr, root;
		if (a <= 0.0) {
			// inside sphere
			a1 = ray.direction.dot(diff);
			discr = a1 * a1 - a;
			root = Math.sqrt(discr);
			var distances = [root - a1];
			var points = [new Vector3().copy(ray.direction).scale(distances[0]).add(ray.origin)];
			return {
				distances: distances,
				points: points
			};
		}

		a1 = ray.direction.dot(diff);
		if (a1 >= 0.0) {
			// No intersection
			return null;
		}

		discr = a1 * a1 - a;
		if (discr < 0.0) {
			return null;
		} else if (discr >= 0.00001) {
			root = Math.sqrt(discr);
			var distances = [-a1 - root, -a1 + root];
			var points = [new Vector3().copy(ray.direction).scale(distances[0]).add(ray.origin),
				new Vector3().copy(ray.direction).scale(distances[1]).add(ray.origin)];
			return {
				distances: distances,
				points: points
			};
		}

		var distances = [-a1];
		var points = [new Vector3().copy(ray.direction).scale(distances[0]).add(ray.origin)];
		return {
			distances: distances,
			points: points
		};
	};

	BoundingSphere.prototype.merge = function (bv) {
		if (bv instanceof BoundingSphere) {
			return this.mergeSphere(bv.center, bv.radius, this);
		} else {
			var boxRadius = tmpVec.setDirect(bv.xExtent, bv.yExtent, bv.zExtent).length();
			return this.mergeSphere(bv.center, boxRadius, this);
		}
	};

	BoundingSphere.prototype.mergeSphere = function (center, radius, store) {
		if (!store) {
			store = new BoundingSphere();
		}

		var diff = tmpVec.set(center).sub(this.center);
		var lengthSquared = diff.lengthSquared();
		var radiusDiff = radius - this.radius;
		var radiusDiffSqr = radiusDiff * radiusDiff;

		// if one sphere wholly contains the other
		if (radiusDiffSqr >= lengthSquared) {
			// if we contain the other
			if (radiusDiff <= 0.0) {
				store.center.set(this.center);
				store.radius = this.radius;
				return store;
			}
			// else the other contains us
			else {
				store.center.set(center);
				store.radius = radius;
				return store;
			}
		}

		// distance between sphere centers
		var length = Math.sqrt(lengthSquared);

		// init a center var using our center
		var rCenter = store.center;

		// if our centers are at least a tiny amount apart from each other...
		if (length > MathUtils.EPSILON) {
			// place us between the two centers, weighted by radii
			var coeff = (length + radiusDiff) / (2.0 * length);
			rCenter.add(diff.scale(coeff));
		}

		// Set radius
		store.radius = 0.5 * (length + this.radius + radius);

		return store;
	};

	/**
	 * Copies data from another bounding sphere
	 * @param {BoundingSphere} source bounding sphere to copy from
	 * @returns {BoundingSphere} Returns self to allow chaining
	 */
	BoundingSphere.prototype.copy = function (source) {
		BoundingVolume.prototype.copy.call(this, source);
		this.radius = source.radius;
		return this;
	};

	// ---
	var warned = false;

	/**
	 * Returns a clone of this bounding sphere
	 * @returns {BoundingSphere}
	 */
	BoundingSphere.prototype.clone = function () {
		if (arguments.length > 0 && !warned) {
			warned = true;
			console.warn(
				'BoundingSphere::clone no longer takes an optional "store" parameter; ' +
				'please use BoundingSphere::copy instead'
			);
		}
		// center appears to be shared but it really isn't since the BoundingVolume constructor clones it
		// when/if that ever changes this needs adapted accordingly
		return new BoundingSphere(this.center, this.radius);
	};

	module.exports = BoundingSphere;

/***/ },
/* 14 */
/***/ function(module, exports, __webpack_require__) {

	var BufferData = __webpack_require__(15);
	var RendererUtils = __webpack_require__(18);
	var BufferUtils = __webpack_require__(16);
	var Vector2 = __webpack_require__(19);
	var Vector3 = __webpack_require__(8);
	var Vector4 = __webpack_require__(11);
	var ObjectUtils = __webpack_require__(6);

	/**
	 * Stores all buffers for geometric data and similar attributes
	 * @param {Object} attributeMap Describes which buffers to use and their format/sizes
	 * @param {number} vertexCount Number of vertices in buffer
	 * @param {number} indexCount Number of indices in buffer
	 * @example
	 * // Constructing a quad entity
	 * var attributes = [MeshData.POSITION, MeshData.NORMAL, MeshData.TEXCOORD0];
	 * var attributeMap = MeshData.defaultMap(attributes);
	 * var vertexCount = 4;
	 * var indexCount = 6;
	 * var meshData = new MeshData(attributeMap, vertexCount, indexCount);
	 * meshData.getAttributeBuffer(MeshData.POSITION).set([
	 *     -1, -1, 0, // 0
	 *     -1, 1, 0,  // 1
	 *      1, 1, 0,  // 2
	 *      1, -1, 0  // 3
	 * ]);
	 * meshData.getAttributeBuffer(MeshData.NORMAL).set([
	 *     0,0,1,  0,0,1,  0,0,1,  0,0,1
	 * ]);
	 * meshData.getAttributeBuffer(MeshData.TEXCOORD0).set([
	 *     0,0,  0,1,  1,1,  1,0
	 * ]);
	 * meshData.getIndexBuffer().set([0,3,1, 1,3,2]);
	 *
	 * var quadEntity = world.createEntity(meshData, new Material(ShaderLib.textured)).addToWorld();
	 */
	function MeshData(attributeMap, vertexCount, indexCount) {
		this.attributeMap = attributeMap;

		/** The total number of vertices in the buffer.
		 * @type {number}
		 */
		this.vertexCount = this._vertexCountStore = vertexCount !== undefined ? vertexCount : 0;

		/** The total number of indices in the buffer.
		 * @type {number}
		 */
		this.indexCount = indexCount !== undefined ? indexCount : 0;

		this.primitiveCounts = [0];

		this.vertexData = null;
		this.indexData = null;
		this.dataViews = {};

		/** The number of indices used by each segment, or null to indicate only one segment that uses the whole index buffer.
		 * @type {?Array<number>}
		 */
		this.indexLengths = null;

		/** The primitive rendering types to use, for each segment. Default value of this property is ['Triangles'], but also TriangleStrip, TriangleFan, Lines, LineStrip, LineLoop and Points are available.
		 * @type {Array<string>}
		 */
		this.indexModes = ['Triangles'];

		this.type = MeshData.MESH;

		this.paletteMap = undefined;
		this.weightsPerVertex = undefined;
		this.boundingBox = undefined;
		this.store = undefined;
		this.wireframeData = undefined;
		this.flatMeshData = undefined;
		this.__boundingTree = undefined;

		this._attributeDataNeedsRefresh = false;
		this._dirtyAttributeNames = new Set();

		this.rebuildData(this.vertexCount, this.indexCount);


		// @ifdef DEBUG
		Object.seal(this);
		// @endif
	}

	MeshData.MESH = 0;
	MeshData.SKINMESH = 1;

	/**
	 * Rebuilds the mesh vertex and index data
	 * @param {number} vertexCount
	 * @param {number} indexCount
	 * @param {boolean} saveOldData
	 */
	MeshData.prototype.rebuildData = function (vertexCount, indexCount, saveOldData) {
		var savedAttributes = {};
		var savedIndices = null;

		if (saveOldData) {
			var keys = Object.keys(this.attributeMap);
			for (var i = 0; i < keys.length; i++) {
				var key = keys[i];
				var view = this.dataViews[key];
				if (view) {
					savedAttributes[key] = view;
				}
			}
			if (indexCount > 0 && this.indexData) {
				savedIndices = this.indexData.data;
			}
		}

		this.rebuildVertexData(vertexCount);

		this.rebuildIndexData(indexCount);

		if (saveOldData) {
			var keys = Object.keys(this.attributeMap);
			for (var i = 0; i < keys.length; i++) {
				var key = keys[i];
				var saved = savedAttributes[key];
				if (saved) {
					this.dataViews[key].set(saved);
				}
			}

			if (indexCount > 0 && savedIndices) {
				this.indexData.data.set(savedIndices);
			}
		}
	};

	/**
	 * Rebuilds the vertex data of a mesh
	 * @private
	 * @param {number} vertexCount
	 */
	MeshData.prototype.rebuildVertexData = function (vertexCount) {
		if (!isNaN(vertexCount)) {
			this.vertexCount = vertexCount;
			this._vertexCountStore = this.vertexCount;
		}
		if (this.vertexCount > 0) {
			var vertexByteSize = 0;
			var keys = Object.keys(this.attributeMap);
			for (var i = 0; i < keys.length; i++) {
				var attribute = this.attributeMap[keys[i]];
				vertexByteSize += RendererUtils.getByteSize(attribute.type) * attribute.count;
			}
			this.vertexData = new BufferData(new ArrayBuffer(vertexByteSize * this.vertexCount), 'ArrayBuffer');

			this.generateAttributeData();
		}
	};

	/**
	 * Rebuilds the index data
	 * @private
	 * @param {number} indexCount
	 */
	MeshData.prototype.rebuildIndexData = function (indexCount) {
		if (indexCount !== undefined) {
			this.indexCount = indexCount;
		}
		if (this.indexCount > 0) {
			var indices = BufferUtils.createIndexBuffer(this.indexCount, this.vertexCount);
			this.indexData = new BufferData(indices, 'ElementArrayBuffer');
		} else {
			this.indexData = null;
			this.indexLengths = null;
			this.indexModes = ['Triangles'];
		}
	};

	/**
	 * Requests a refresh on the vertex data
	 */
	MeshData.prototype.setVertexDataUpdated = function () {
		this.vertexData._dataNeedsRefresh = true;
	};

	/**
	 * Should be called if an attribute was updated during runtime.
	 * @example
	 * // Updating the vertex position during runtime
	 * var data = meshData.getAttributeBuffer(MeshData.POSITION);
	 * data.set([-1,-1,0, -1,1,0, 1,1,0, 1,-1,0]);
	 * meshData.setAttributeDataUpdated(MeshData.POSITION);
	 */
	MeshData.prototype.setAttributeDataUpdated = function (name) {
		this._dirtyAttributeNames.add(name);
		this._attributeDataNeedsRefresh = true;
	};

	/**
	 * @returns {number}
	 */
	MeshData.prototype.getSectionCount = function () {
		return this.indexLengths ? this.indexLengths.length : 1;
	};

	/**
	 * @returns {number}
	 */
	MeshData.prototype.getPrimitiveCount = function (section) {
		if (section >= 0 && section < this.primitiveCounts.length) {
			return this.primitiveCounts[section];
		}
		return 0;
	};

	/**
	 * @param {number} primitiveIndex
	 * @param {number} section
	 * @param {array} store
	 * @returns {array}
	 */
	MeshData.prototype.getPrimitiveVertices = function (primitiveIndex, section, store) {
		var count = this.getPrimitiveCount(section);
		if (primitiveIndex >= count || primitiveIndex < 0) {
			throw new Error("Invalid primitiveIndex '" + primitiveIndex + "'.  Count is " + count);
		}

		var mode = this.indexModes[section];
		var rSize = MeshData.getVertexCount(mode);
		var result = store || [];
		result.length = rSize;

		var verts = this.getAttributeBuffer(MeshData.POSITION);
		for (var i = 0; i < rSize; i++) {
			if (!result[i]) {
				result[i] = new Vector3();
			}
			if (this.getIndexBuffer()) {
				// indexed geometry
				var vert = this.getIndexBuffer()[this.getVertexIndex(primitiveIndex, i, section)];
				result[i].x = verts[vert * 3 + 0];
				result[i].y = verts[vert * 3 + 1];
				result[i].z = verts[vert * 3 + 2];
			} else {
				// non-indexed geometry
				var vert = this.getVertexIndex(primitiveIndex, i, section);
				result[i].x = verts[vert * 3 + 0];
				result[i].y = verts[vert * 3 + 1];
				result[i].z = verts[vert * 3 + 2];
			}
		}

		return result;
	};

	MeshData.prototype.getVertexIndex = function (primitiveIndex, point, section) {
		var index = 0;
		// move our offset up to the beginning of our section
		for (var i = 0; i < section; i++) {
			index += this.indexLengths[i];
		}

		// Ok, now pull primitive index based on indexmode.
		switch (this.indexModes[section]) {
			case 'Triangles':
				index += primitiveIndex * 3 + point;
				break;
			case 'TriangleStrip':
				// XXX: Do we need to flip point 0 and 1 on odd primitiveIndex values?
				// if (point < 2 && primitiveIndex % 2 == 1) {
				// index += primitiveIndex + (point == 0 ? 1 : 0);
				// } else {
				index += primitiveIndex + point;
				// }
				break;
			case 'TriangleFan':
				if (point === 0) {
					index += 0;
				} else {
					index += primitiveIndex + point;
				}
				break;
			case 'Points':
				index += primitiveIndex;
				break;
			case 'Lines':
				index += primitiveIndex * 2 + point;
				break;
			case 'LineStrip':
			case 'LineLoop':
				index += primitiveIndex + point;
				break;
			default:
				MeshData.logger.warning('unimplemented index mode: ' + this.indexModes[section]);
				return -1;
		}

		return index;
	};

	/**
	 * Get the total primitive count. Note that you need to run .updatePrimitiveCounts() before use.
	 * @returns {number}
	 */
	MeshData.prototype.getTotalPrimitiveCount = function () {
		var count = 0;
		for (var i = 0, max = this.primitiveCounts.length; i < max; i++) {
			count += this.primitiveCounts[i];
		}
		return count;
	};

	MeshData.prototype.updatePrimitiveCounts = function () {
		var maxIndex = this.indexData ? this.indexData.data.length : this.vertexCount;
		var maxSection = this.getSectionCount();
		if (this.primitiveCounts.length !== maxSection) {
			this.primitiveCounts = [];
		}
		for (var i = 0; i < maxSection; i++) {
			var size = this.indexLengths ? this.indexLengths[i] : maxIndex;
			var count = MeshData.getPrimitiveCount(this.indexModes[i], size);
			this.primitiveCounts[i] = count;
		}
	};

	MeshData.getPrimitiveCount = function (indexMode, size) {
		switch (indexMode) {
			case 'Triangles':
				return size / 3;
			case 'TriangleFan':
			case 'TriangleStrip':
				return size - 2;
			case 'Lines':
				return size / 2;
			case 'LineStrip':
				return size - 1;
			case 'LineLoop':
				return size;
			case 'Points':
				return size;
			default:
				throw new Error('unimplemented index mode: ' + indexMode);
		}
	};

	MeshData.getVertexCount = function (indexMode) {
		switch (indexMode) {
			case 'Triangles':
			case 'TriangleFan':
			case 'TriangleStrip':
				return 3;
			case 'Lines':
			case 'LineStrip':
			case 'LineLoop':
				return 2;
			case 'Points':
				return 1;
			default:
				throw new Error('unimplemented index mode: ' + indexMode);
		}
	};

	var ArrayTypes = {
		Byte: Int8Array,
		UnsignedByte: Uint8Array,
		UnsignedByteClamped: Uint8ClampedArray,
		Short: Int16Array,
		UnsignedShort: Uint16Array,
		Int: Int32Array,
		UnsignedInt: Uint32Array,
		Float: Float32Array
		// Double: Float64Array
	};

	MeshData.prototype.generateAttributeData = function () {
		var data = this.vertexData.data;
		var view;
		var offset = 0;
		for (var key in this.attributeMap) {
			var attribute = this.attributeMap[key];
			attribute.offset = offset;
			var length = this.vertexCount * attribute.count;
			offset += length * RendererUtils.getByteSize(attribute.type);

			var ArrayType = ArrayTypes[attribute.type];
			if (ArrayType) {
				view = new ArrayType(data, attribute.offset, length);
			} else {
				throw new Error('Unsupported DataType: ' + attribute.type);
			}

			this.dataViews[key] = view;

			attribute.hashKey = attribute.count + '_' + attribute.type + '_' +
				attribute.stride + '_' + attribute.offset + '_' + attribute.normalized;
		}
	};

	MeshData.prototype.deIndex = function () {
		var origI = this.getIndexBuffer();
		if (!origI) {
			return;
		}

		var data = {};
		var keys = Object.keys(this.attributeMap);
		for (var ii = 0, l = keys.length; ii < l; ii++) {
			var key = keys[ii];
			var map = this.attributeMap[key];
			var view = this.getAttributeBuffer(key);

			var array = data[key] = [];
			for (var i = 0; i < origI.length; i++) {
				var index = origI[i];
				for (var j = 0; j < map.count; j++) {
					array[i * map.count + j] = view[index * map.count + j];
				}
			}
		}

		this.rebuildData(this.indexCount, 0);

		for (var ii = 0, l = keys.length; ii < l; ii++) {
			var key = keys[ii];
			var view = this.getAttributeBuffer(key);
			view.set(data[key]);
		}

		this.setVertexDataUpdated();
	};

	//! AT: unused
	MeshData.prototype.makeInterleavedData = function () {
		var stride = 0;
		var offset = 0; // unused
		for (var key in this.attributeMap) {
			var attribute = this.attributeMap[key];
			attribute.offset = stride;
			stride += attribute.count * RendererUtils.getByteSize(attribute.type);
		}

		var newVertexData = new BufferData(new ArrayBuffer(stride * this.vertexCount), this.vertexData.target);
		newVertexData._dataUsage = this.vertexData._dataUsage;
		newVertexData._dataNeedsRefresh = true;

		var targetView = new DataView(newVertexData.data);
		for (var key in this.attributeMap) {
			var view = this.dataViews[key];
			var attribute = this.attributeMap[key];
			attribute.stride = stride;
			var offset = attribute.offset;
			var count = attribute.count;
			var size = RendererUtils.getByteSize(attribute.type);

			var method = this.getDataMethod(attribute.type);
			var fun = targetView[method];
			for (var i = 0; i < this.vertexCount; i++) {
				for (var j = 0; j < count; j++) {
					fun.apply(targetView, [(offset + stride * i + j * size), view[i * count + j], true]);
				}
			}
		}

		this.vertexData = newVertexData;
	};

	MeshData.prototype.getDataMethod = function (type) {
		switch (type) {
			case 'Byte':
				return 'setInt8';
			case 'UnsignedByte':
				return 'setUInt8';
			case 'Short':
				return 'setInt16';
			case 'UnsignedShort':
				return 'setUInt16';
			case 'Int':
				return 'setInt32';
			case 'HalfFloat':
				return 'setInt16';
			case 'Float':
				return 'setFloat32';
			// case 'Double':
				// return 'setFloat64';
		}
	};

	MeshData.prototype.getAttributeBuffer = function (attributeName) {
		return this.dataViews[attributeName];
	};

	//! schteppe: are simple getters like this really needed? Why not just use the property?
	MeshData.prototype.getIndexData = function () {
		return this.indexData;
	};

	MeshData.prototype.getIndexBuffer = function () {
		if (this.indexData !== null) {
			return this.indexData.data;
		}
		return null;
	};

	MeshData.prototype.getIndexLengths = function () {
		return this.indexLengths;
	};

	MeshData.prototype.getIndexModes = function () {
		return this.indexModes;
	};

	//! AT: unused and undocumented; remove?
	MeshData.prototype.resetVertexCount = function () {
		this.vertexCount = this._vertexCountStore;
	};

	/**
	 * Applies a transformation on a specified attribute buffer
	 * @param {string} attributeName
	 * @param {Transform} transform
	 * @returns {MeshData} Self to allow chaining
	 */
	MeshData.prototype.applyTransform = function (attributeName, transform) {
		var vert = new Vector3();
		var view = this.getAttributeBuffer(attributeName);
		var viewLength = view.length;

		if (attributeName === MeshData.POSITION) {
			for (var i = 0; i < viewLength; i += 3) {
				vert.setDirect(view[i + 0], view[i + 1], view[i + 2]);
				vert.applyPostPoint(transform.matrix);
				view[i + 0] = vert.x;
				view[i + 1] = vert.y;
				view[i + 2] = vert.z;
			}
		} else if (attributeName === MeshData.NORMAL) {
			for (var i = 0; i < viewLength; i += 3) {
				vert.setDirect(view[i + 0], view[i + 1], view[i + 2]);
				vert.applyPost(transform.rotation);
				view[i + 0] = vert.x;
				view[i + 1] = vert.y;
				view[i + 2] = vert.z;
			}
		} else if (attributeName === MeshData.TANGENT) {
			for (var i = 0; i < viewLength; i += 3) {
				vert.setDirect(view[i + 0], view[i + 1], view[i + 2]);
				vert.applyPost(transform.rotation);
				view[i + 0] = vert.x;
				view[i + 1] = vert.y;
				view[i + 2] = vert.z;
			}
		}

		return this;
	};

	/**
	 * Applies a function on the vertices of a specified attribute buffer
	 * @param {string} attributeName
	 * @param {Function} fun
	 * @returns {MeshData} Self to allow chaining
	 */
	MeshData.prototype.applyFunction = function (attributeName, fun) {
		//! AT: fun should return a vector3, not an array
		var vert;
		var outVert;
		var view = this.getAttributeBuffer(attributeName);
		var viewLength = view.length;

		var count = this.attributeMap[attributeName].count;

		switch (count) {
			case 1:
				for (var i = 0; i < viewLength; i++) {
					view[i] = fun(view[i]);
				}
				break;
			case 2:
				vert = new Vector2();
				for (var i = 0; i < viewLength; i += 2) {
					vert.setDirect(view[i + 0], view[i + 1]);

					outVert = fun(vert);

					view[i + 0] = outVert.x;
					view[i + 1] = outVert.y;
				}
				break;
			case 3:
				vert = new Vector3();
				for (var i = 0; i < viewLength; i += 3) {
					vert.setDirect(view[i + 0], view[i + 1], view[i + 2]);

					outVert = fun(vert);

					view[i + 0] = outVert.x;
					view[i + 1] = outVert.y;
					view[i + 2] = outVert.z;
				}
				break;
			case 4:
				vert = new Vector4();
				for (var i = 0; i < viewLength; i += 4) {
					vert.setDirect(view[i + 0], view[i + 1], view[i + 2], view[i + 3]);

					outVert = fun(vert);

					view[i + 0] = outVert.x;
					view[i + 1] = outVert.y;
					view[i + 2] = outVert.z;
					view[i + 3] = outVert.w;
				}
				break;
		}

		return this;
	};

	/**
	 * Creates a new MeshData object representing the normals of the current MeshData object
	 * @param {number} [size=1] The size of the normals
	 * @returns {MeshData}
	 */
	MeshData.prototype.getNormalsMeshData = function (size) {
		if (this.getAttributeBuffer('POSITION') === undefined) {
			return;
		}
		if (this.getAttributeBuffer('NORMAL') === undefined) {
			return;
		}

		size = size !== undefined ? size : 1;

		var verts = [];
		var indices = [];

		var nVertices = this.dataViews.POSITION.length / 3;
		for (var i = 0; i < nVertices; i++) {
			verts.push(
				this.dataViews.POSITION[i * 3 + 0],
				this.dataViews.POSITION[i * 3 + 1],
				this.dataViews.POSITION[i * 3 + 2],
				this.dataViews.POSITION[i * 3 + 0] + this.dataViews.NORMAL[i * 3 + 0] * size,
				this.dataViews.POSITION[i * 3 + 1] + this.dataViews.NORMAL[i * 3 + 1] * size,
				this.dataViews.POSITION[i * 3 + 2] + this.dataViews.NORMAL[i * 3 + 2] * size);
		}

		for (var i = 0; i < nVertices * 2; i += 2) {
			indices.push(i, i + 1);
		}

		var meshData = new MeshData(MeshData.defaultMap([MeshData.POSITION]), verts.length, indices.length);

		meshData.getAttributeBuffer(MeshData.POSITION).set(verts);
		meshData.getIndexBuffer().set(indices);

		meshData.indexModes[0] = 'Lines';

		return meshData;
	};

	/**
	 * Builds the wireframe MeshData from an existing mesh
	 * @returns {MeshData}
	 */
	MeshData.prototype.buildWireframeData = function () {
		var attributeMap = ObjectUtils.deepClone(this.attributeMap);
		var wireframeData = new MeshData(attributeMap, this.vertexCount, 0);
		wireframeData.indexModes[0] = 'Lines';

		var origI = this.getIndexBuffer();

		var that = this;
		var getIndex;
		if (origI) {
			getIndex = function (primitiveIndex, point, section) {
				return origI[that.getVertexIndex(primitiveIndex, point, section)];
			};
		} else {
			getIndex = function (primitiveIndex, point, section) {
				return that.getVertexIndex(primitiveIndex, point, section);
			};
		}

		var targetI = [];
		var indexCount = 0;
		this.updatePrimitiveCounts();
		for (var section = 0; section < this.getSectionCount(); section++) {
			var indexMode = this.indexModes[section];

			var primitiveCount = this.getPrimitiveCount(section);
			for (var primitiveIndex = 0; primitiveIndex < primitiveCount; primitiveIndex++) {
				switch (indexMode) {
					case 'Triangles':
					case 'TriangleFan':
					case 'TriangleStrip':
						var i1 = getIndex(primitiveIndex, 0, section);
						var i2 = getIndex(primitiveIndex, 1, section);
						var i3 = getIndex(primitiveIndex, 2, section);

						targetI[indexCount + 0] = i1;
						targetI[indexCount + 1] = i2;
						targetI[indexCount + 2] = i2;
						targetI[indexCount + 3] = i3;
						targetI[indexCount + 4] = i3;
						targetI[indexCount + 5] = i1;
						indexCount += 6;
						break;
					case 'Lines':
					case 'LineStrip':
						var i1 = getIndex(primitiveIndex, 0, section);
						var i2 = getIndex(primitiveIndex, 1, section);

						targetI[indexCount + 0] = i1;
						targetI[indexCount + 1] = i2;
						indexCount += 2;
						break;
					case 'LineLoop':
						var i1 = getIndex(primitiveIndex, 0, section);
						var i2 = getIndex(primitiveIndex, 1, section);
						if (primitiveIndex === primitiveCount - 1) {
							i2 = getIndex(0, 0, section);
						}

						targetI[indexCount + 0] = i1;
						targetI[indexCount + 1] = i2;
						indexCount += 2;
						break;
					case 'Points':
						// Not supported in wireframe
						break;
				}
			}
		}

		if (indexCount > 0) {
			wireframeData.rebuildIndexData(indexCount);
			for (var attribute in attributeMap) {
				wireframeData.getAttributeBuffer(attribute).set(this.getAttributeBuffer(attribute));
			}
			wireframeData.getIndexBuffer().set(targetI);
		}

		wireframeData.paletteMap = this.paletteMap;
		wireframeData.weightsPerVertex = this.weightsPerVertex;

		return wireframeData;
	};


	// Calculation helpers
	var v1 = new Vector3();
	var v2 = new Vector3();
	var v3 = new Vector3();
	/**
	 * Builds flat meshdata from mesh
	 * @returns {MeshData}
	 */
	MeshData.prototype.buildFlatMeshData = function () {
		var oldIdcs = this.getIndexBuffer();
		if (oldIdcs === null) {
			console.debug('No indices, probably a point mesh');
			return this;
		}

		var attributeMap = ObjectUtils.deepClone(this.attributeMap);
		var attribs = {};
		for (var key in attributeMap) {
			attribs[key] = {
				oldBuffer: this.getAttributeBuffer(key),
				values: []
			};
		}
		var indexCount = 0;
		this.updatePrimitiveCounts();
		for (var section = 0; section < this.getSectionCount(); section++) {
			var indexMode = this.indexModes[section];
			var primitiveCount = this.getPrimitiveCount(section);
			var flip = false;
			for (var primitiveIndex = 0; primitiveIndex < primitiveCount; primitiveIndex++) {
				switch (indexMode) {
					case 'TriangleStrip':
						flip = (primitiveIndex % 2 === 1) ? true : false;
						// fall through intended?
					case 'Triangles':
					case 'TriangleFan':
						var i1 = oldIdcs[this.getVertexIndex(primitiveIndex, 0, section)];
						var i2 = oldIdcs[this.getVertexIndex(primitiveIndex, 1, section)];
						var i3 = oldIdcs[this.getVertexIndex(primitiveIndex, 2, section)];
						if (flip) {
							var f = i3;
							i3 = i2;
							i2 = f;
						}
						for (var key in attribs) {
							if (key === MeshData.NORMAL) {
								continue;
							}
							var count = attributeMap[key].count;
							for (var i = 0; i < count; i++) {
								attribs[key].values[indexCount * count + i] = attribs[key].oldBuffer[i1 * count + i];
								attribs[key].values[(indexCount + 1) * count + i] = attribs[key].oldBuffer[i2 * count + i];
								attribs[key].values[(indexCount + 2) * count + i] = attribs[key].oldBuffer[i3 * count + i];
							}
							if (key === MeshData.POSITION) {
								v1.setDirect(
									attribs[key].values[indexCount * 3],
									attribs[key].values[indexCount * 3 + 1],
									attribs[key].values[indexCount * 3 + 2]
								);
								v2.setDirect(
									attribs[key].values[(indexCount + 1) * 3],
									attribs[key].values[(indexCount + 1) * 3 + 1],
									attribs[key].values[(indexCount + 1) * 3 + 2]
								);
								v3.setDirect(
									attribs[key].values[(indexCount + 2) * 3],
									attribs[key].values[(indexCount + 2) * 3 + 1],
									attribs[key].values[(indexCount + 2) * 3 + 2]
								);
								v2.sub(v1);
								v3.sub(v1);
								v2.cross(v3).normalize();

								if (attribs[MeshData.NORMAL]) {
									attribs[MeshData.NORMAL].values[(indexCount) * 3] = v2.x;
									attribs[MeshData.NORMAL].values[(indexCount) * 3 + 1] = v2.y;
									attribs[MeshData.NORMAL].values[(indexCount) * 3 + 2] = v2.z;

									attribs[MeshData.NORMAL].values[(indexCount + 1) * 3] = v2.x;
									attribs[MeshData.NORMAL].values[(indexCount + 1) * 3 + 1] = v2.y;
									attribs[MeshData.NORMAL].values[(indexCount + 1) * 3 + 2] = v2.z;

									attribs[MeshData.NORMAL].values[(indexCount + 2) * 3] = v2.x;
									attribs[MeshData.NORMAL].values[(indexCount + 2) * 3 + 1] = v2.y;
									attribs[MeshData.NORMAL].values[(indexCount + 2) * 3 + 2] = v2.z;
								}
							}
						}
						indexCount += 3;
				}
			}
		}
		if (indexCount === 0) {
			console.warn('Could not build flat data');
			return this;
		}
		var flatMeshData = new MeshData(attributeMap, indexCount);

		for (var key in attribs) {
			flatMeshData.getAttributeBuffer(key).set(attribs[key].values);
		}

		flatMeshData.paletteMap = this.paletteMap;
		flatMeshData.weightsPerVertex = this.weightsPerVertex;

		return flatMeshData;
	};

	/**
	 * Destroys all attached vertex and index data.
	 * @param {WebGLRenderingContext} context
	 */
	MeshData.prototype.destroy = function (context) {
		if (this.vertexData) {
			this.vertexData.destroy(context);
		}
		if (this.indexData) {
			this.indexData.destroy(context);
		}
	};

	/**
	 * Returns a clone of this mesh data
	 * @returns {MeshData}
	 */
	MeshData.prototype.clone = function () {
		var attributeMapClone = ObjectUtils.deepClone(this.attributeMap);

		var clone = new MeshData(attributeMapClone, this.vertexCount, this.indexCount);

		clone.primitiveCounts = this.primitiveCounts.slice(0); // an array

		clone.vertexData.copy(this.vertexData); // BufferData
		clone.indexData.copy(this.indexData); // BufferData

		clone.indexLengths = Array.isArray(this.indexLengths) ? this.indexLengths.slice(0) : this.indexLengths;
		clone.indexModes = this.indexModes.slice(0);

		clone.type = this.type;

		if (this.paletteMap) {
			clone.paletteMap = this.paletteMap.slice(0); // an array
		}

		clone.weightsPerVertex = this.weightsPerVertex; // a number

		return clone;
	};

	/**
	 * @type {string}
	 * @readonly
	 */
	MeshData.POSITION = 'POSITION';
	/**
	 * @type {string}
	 * @readonly
	 */
	MeshData.NORMAL = 'NORMAL';
	/**
	 * @type {string}
	 * @readonly
	 */
	MeshData.COLOR = 'COLOR';
	/**
	 * @type {string}
	 * @readonly
	 */
	MeshData.TANGENT = 'TANGENT';
	/**
	 * @type {string}
	 * @readonly
	 */
	MeshData.TEXCOORD0 = 'TEXCOORD0';
	/**
	 * @type {string}
	 * @readonly
	 */
	MeshData.TEXCOORD1 = 'TEXCOORD1';
	/**
	 * @type {string}
	 * @readonly
	 */
	MeshData.TEXCOORD2 = 'TEXCOORD2';
	/**
	 * @type {string}
	 * @readonly
	 */
	MeshData.TEXCOORD3 = 'TEXCOORD3';
	/**
	 * @type {string}
	 * @readonly
	 */
	MeshData.WEIGHTS = 'WEIGHTS';
	/**
	 * @type {string}
	 * @readonly
	 */
	MeshData.JOINTIDS = 'JOINTIDS';

	/**
	 * Creates a definition for a vertex attribute
	 *
	 * @param {number} count Tuple size of attribute
	 * @param {string} type Data type
	 * @param {boolean} [normalized=false] If data should be normalized (true) or converted direction (false)
	 * @returns {Object} Attribute definition
	 */
	MeshData.createAttribute = function (count, type, normalized) {
		return {
			count: count,
			type: type,
			stride: 0,
			offset: 0,
			normalized: normalized !== undefined ? normalized : false
		};
	};

	var defaults = {
		'POSITION': MeshData.createAttribute(3, 'Float'),
		'NORMAL': MeshData.createAttribute(3, 'Float'),
		'COLOR': MeshData.createAttribute(4, 'Float'),
		'TANGENT': MeshData.createAttribute(4, 'Float'),
		'TEXCOORD0': MeshData.createAttribute(2, 'Float'),
		'TEXCOORD1': MeshData.createAttribute(2, 'Float'),
		'TEXCOORD2': MeshData.createAttribute(2, 'Float'),
		'TEXCOORD3': MeshData.createAttribute(2, 'Float'),
		'WEIGHTS': MeshData.createAttribute(4, 'Float'),
		'JOINTIDS': MeshData.createAttribute(4, 'Float')
	};

	function buildMap(types) {
		var map = {};
		for (var i = 0; i < types.length; i++) {
			var type = types[i];
			if (defaults[type] !== undefined) {
				map[type] = ObjectUtils.deepClone(defaults[type]);
			} else {
				throw new Error('No default attribute named: ' + type);
			}
		}
		return map;
	}

	/**
	 * Creates an attribute given the types
	 * @param {Array<string>} [types] An array of default types. If not provided you get an attributeMap with all default attributes
	 * @returns {Object}
	 * @example var map = MeshData.defaultMap([MeshData.POSITION, MeshData.TEXCOORD0]);
	 */
	MeshData.defaultMap = function (types) {
		if (types === undefined) {
			return buildMap(Object.keys(defaults));
		} else {
			return buildMap(types);
		}
	};

	module.exports = MeshData;

/***/ },
/* 15 */
/***/ function(module, exports, __webpack_require__) {

	var BufferUtils = __webpack_require__(16);

	/**
	 * The purpose of this class is to hold additional information regarding a typedarray buffer, like vbo 'usage' flags
	 * @param {ArrayBuffer} data Data to wrap
	 * @param {string} target Type of data ('ArrayBuffer'/'ElementArrayBuffer')
	 * @property {ArrayBuffer} data Data to wrap
	 * @property {string} target Type of data ('ArrayBuffer'/'ElementArrayBuffer')
	 */
	function BufferData(data, target) {
		this.data = data;
		this.target = target;

		this.glBuffer = null;

		this._dataUsage = 'StaticDraw';
		this._dataNeedsRefresh = false;

		// @ifdef DEBUG
		Object.seal(this);
		// @endif
	}

	/**
	 * Set the usage type of this bufferdata.
	 * @param {string} dataUsage Usage Type
	 * <pre>
	 * Usage Type:
	 *  	'StaticDraw' - The data store contents will be speciﬁed once by the application,
	 *	  		and used many times as the source for GL drawing commands
	 *   	'DynamicDraw' - The data store contents will be respeciﬁed repeatedly by the application, and used many times as the source for GL drawing commands.
	 *    	'StreamDraw' - The data store contents will be speciﬁed once by the application,
	 *	    	and used at most a few times as the source of a GL drawing command
	 * </pre>
	 */
	BufferData.prototype.setDataUsage = function (dataUsage) {
		this._dataUsage = dataUsage;
	};

	/**
	 * Tell the engine that a buffer has been updated and needs to be refreshed.
	 */
	BufferData.prototype.setDataNeedsRefresh = function () {
		this._dataNeedsRefresh = true;
	};

	/**
	 * Releases the allocated buffer
	 * @param {WebGLRenderingContext} context
	 */
	BufferData.prototype.destroy = function (context) {
		if (this.glBuffer) {
			context.deleteBuffer(this.glBuffer);
			this.glBuffer = null;
		}
	};

	BufferData.prototype.copy = function (source) {
		if (this.data instanceof ArrayBuffer) {
			var sourceView = new Uint8Array(source.data);
			var destinationView = new Uint8Array(this.data);
			destinationView.set(sourceView);
		} else { // TypedArray
			this.data.set(source.data);
		}
		this.target = source.target;

		this.glBuffer = null;

		this._dataUsage = source._dataUsage;
		this._dataNeedsRefresh = false; //?

		return this;
	};

	BufferData.prototype.clone = function () {
		var clonedData;
		if (this.data instanceof ArrayBuffer) {
			clonedData = this.data.slice(0);
		} else { // TypedArray
			clonedData = BufferUtils.cloneTypedArray(this.data);
		}

		var clone = new BufferData(clonedData, this.target);
		clone._dataUsage = this._dataUsage;
		clone._dataNeedsRefresh = false; //?
		return clone;
	};

	module.exports = BufferData;

/***/ },
/* 16 */
/***/ function(module, exports, __webpack_require__) {

	var Capabilities = __webpack_require__(17);

	/**
	 * Utility for creating index buffers of appropriate type
	 */
	function BufferUtils() {}

	/**
	 * Creates an index buffer of a type appropriate to store the supplied number of vertices
	 * @param {number} indexCount Number of indices
	 * @param {number} vertexCount Number of vertices
	 * @returns {TypedArray} Index buffer
	 */
	BufferUtils.createIndexBuffer = function (indexCount, vertexCount) {
		var indices;
		if (vertexCount <= 256) { // 2^8
			if (BufferUtils.browserType === 'Trident') { // IE 11 case
				indices = new Uint16Array(indexCount);
			} else {
				indices = new Uint8Array(indexCount);
			}
		} else if (vertexCount <= 65536) { // 2^16
			indices = new Uint16Array(indexCount);
		} else if (Capabilities.ElementIndexUInt) { // 2^32
			indices = new Uint32Array(indexCount);
		} else {
			throw new Error('Maximum number of vertices is 65536. Got: ' + vertexCount);
		}
		return indices;
	};

	function storeBrowserType() {
		var aKeys = ['Trident', 'MSIE', 'Firefox', 'Safari', 'Chrome', 'Opera'],
			sUsrAg = typeof(navigator) !== 'undefined' && navigator.userAgent || '',
			nIdx = aKeys.length - 1;
		for (nIdx; nIdx > -1 && sUsrAg.indexOf(aKeys[nIdx]) === -1; nIdx--) {
			// nothing
		}
		BufferUtils.browserType = aKeys[nIdx];
	}

	storeBrowserType();

	/**
	 * Returns a clone of the supplied typed array
	 * @param {TypedArray} source
	 * @returns {TypedArray}
	 */
	BufferUtils.cloneTypedArray = function (source) {
		return new source.constructor(source);
	};

	module.exports = BufferUtils;

/***/ },
/* 17 */
/***/ function(module, exports) {

	/**
	 * Enabled and stores webgl extensions and capabilities

	 * Extensions
	 * @property {Object} CompressedTextureS3TC S3TC (DXT) compression, WEBGL_compressed_texture_s3tc
	 * @property {Object} TextureFloat Floating point textures, OES_texture_float
	 * @property {Object} TextureFloatLinear Linear filtering of floating point textures, OES_texture_float_linear
	 * @property {Object} TextureHalfFloat 16-bit floating point textures, OES_texture_half_float
	 * @property {Object} TextureHalfFloatLinear Linear filtering of 16-bit floating point textures, OES_texture_half_float_linear
	 * @property {Object} StandardDerivatives Enabled dFdx/dFdy/fwidth in fragment shaders, OES_standard_derivatives
	 * @property {Object} TextureFilterAnisotropic Anisotropic filtering of textures, EXT_texture_filter_anisotropic
	 * @property {Object} DepthTexture Depth textures, WEBGL_depth_texture
	 * @property {Object} ElementIndexUInt 32-bit index buffers, OES_element_index_uint
	 * @property {Object} InstancedArrays Instanced arrays, ANGLE_instanced_arrays
	 * @property {Object} BlendMinmax BlendMinmax, EXT_blend_minmax
	 * @property {Object} FragDepth FragDepth, EXT_frag_depth
	 * @property {Object} ShaderTextureLod ShaderTextureLod, EXT_shader_texture_lod
	 * @property {Object} VertexArrayObject VertexArrayObject, OES_vertex_array_object
	 * @property {Object} DrawBuffers Multiple rendertargets, WEBGL_draw_buffers

	 * Properties
	 * @property {number} maxTexureSize Maximum 2D texture size
	 * @property {number} maxCubemapSize Maximum cubemap size
	 * @property {number} maxRenderbufferSize Maximum renderbuffer size
	 * @property {Array<number>} maxViewPortDims Maximum viewport size [x, y]
	 * @property {number} maxVertexTextureUnits Maximum vertex shader texture units
	 * @property {number} maxFragmentTextureUnits Maximum fragment shader texture units
	 * @property {number} maxCombinedTextureUnits Maximum total texture units
	 * @property {number} maxVertexAttributes Maximum vertex attributes
	 * @property {number} maxVertexUniformVectors Maximum vertex uniform vectors
	 * @property {number} maxFragmentUniformVectors Maximum fragment uniform vectors
	 * @property {number} maxVaryingVectors Maximum varying vectors
	 * @property {number} aliasedPointSizeRange Point size min/max [min, max]
	 * @property {number} aliasedLineWidthRange Line width min/max [min, max]
	 * @property {number} samples Antialiasing sample size
	 * @property {number} sampleBuffers Sample buffer count
	 * @property {number} depthBits Depth bits
	 * @property {number} stencilBits Stencil bits
	 * @property {number} subpixelBits Sub-pixel bits
	 * @property {number} supportedExtensionsList Supported extension as an array
	 * @property {number} renderer Renderer name
	 * @property {number} vendor Vendor name
	 * @property {number} version Version string
	 * @property {number} shadingLanguageVersion Shadinglanguage version string
	 */
	function Capabilities() {}

	/**
	 * Initialize capabilities from rendering context.
	 * @param {WebGLRenderingContext} context WebGLRenderingContext
	 */
	Capabilities.init = function (context) {
		// Extensions
		Capabilities.CompressedTextureS3TC = context.getExtension('WEBGL_compressed_texture_s3tc')
										|| context.getExtension('MOZ_WEBGL_compressed_texture_s3tc')
										|| context.getExtension('WEBKIT_WEBGL_compressed_texture_s3tc');
		Capabilities.TextureFloat = context.getExtension('OES_texture_float');
		Capabilities.TextureFloatLinear = context.getExtension('OES_texture_float_linear');
		Capabilities.TextureHalfFloat = context.getExtension('OES_texture_half_float');
		Capabilities.TextureHalfFloatLinear = context.getExtension('OES_texture_half_float_linear');
		Capabilities.StandardDerivatives = context.getExtension('OES_standard_derivatives');
		Capabilities.TextureFilterAnisotropic = context.getExtension('EXT_texture_filter_anisotropic')
										|| context.getExtension('MOZ_EXT_texture_filter_anisotropic')
										|| context.getExtension('WEBKIT_EXT_texture_filter_anisotropic');
		Capabilities.DepthTexture = context.getExtension('WEBGL_depth_texture')
										|| context.getExtension('WEBKIT_WEBGL_depth_texture')
										|| context.getExtension('MOZ_WEBGL_depth_texture');
		Capabilities.ElementIndexUInt = context.getExtension('OES_element_index_uint');

		// verify these
		Capabilities.InstancedArrays = context.getExtension('ANGLE_instanced_arrays');
		Capabilities.BlendMinmax = context.getExtension('EXT_blend_minmax');
		Capabilities.FragDepth = context.getExtension('EXT_frag_depth');
		Capabilities.ShaderTextureLod = context.getExtension('EXT_shader_texture_lod');
		Capabilities.VertexArrayObject = context.getExtension('OES_vertex_array_object');
		Capabilities.DrawBuffers = context.getExtension('WEBGL_draw_buffers');
		// end verify

		// Parameters
		Capabilities.maxTexureSize = context.getParameter(context.MAX_TEXTURE_SIZE);
		Capabilities.maxCubemapSize = context.getParameter(context.MAX_CUBE_MAP_TEXTURE_SIZE);
		Capabilities.maxRenderbufferSize = context.getParameter(context.MAX_RENDERBUFFER_SIZE);
		Capabilities.maxViewPortDims = context.getParameter(context.MAX_VIEWPORT_DIMS); // [x, y]
		Capabilities.maxAnisotropy = Capabilities.TextureFilterAnisotropic ? context.getParameter(Capabilities.TextureFilterAnisotropic.MAX_TEXTURE_MAX_ANISOTROPY_EXT) : 0;

		Capabilities.maxVertexTextureUnits = context.getParameter(context.MAX_VERTEX_TEXTURE_IMAGE_UNITS);
		Capabilities.maxFragmentTextureUnits = context.getParameter(context.MAX_TEXTURE_IMAGE_UNITS);
		Capabilities.maxCombinedTextureUnits = context.getParameter(context.MAX_COMBINED_TEXTURE_IMAGE_UNITS);

		Capabilities.maxVertexAttributes = context.getParameter(context.MAX_VERTEX_ATTRIBS);
		Capabilities.maxVertexUniformVectors = context.getParameter(context.MAX_VERTEX_UNIFORM_VECTORS);
		Capabilities.maxFragmentUniformVectors = context.getParameter(context.MAX_FRAGMENT_UNIFORM_VECTORS);
		Capabilities.maxVaryingVectors = context.getParameter(context.MAX_VARYING_VECTORS);

		Capabilities.aliasedPointSizeRange = context.getParameter(context.ALIASED_POINT_SIZE_RANGE); // [min, max]
		Capabilities.aliasedLineWidthRange = context.getParameter(context.ALIASED_LINE_WIDTH_RANGE); // [min, max]

		Capabilities.samples = context.getParameter(context.SAMPLES);
		Capabilities.sampleBuffers = context.getParameter(context.SAMPLE_BUFFERS);

		Capabilities.depthBits = context.getParameter(context.DEPTH_BITS);
		Capabilities.stencilBits = context.getParameter(context.STENCIL_BITS);
		Capabilities.subpixelBits = context.getParameter(context.SUBPIXEL_BITS);
		Capabilities.supportedExtensionsList = context.getSupportedExtensions();

		Capabilities.renderer = context.getParameter(context.RENDERER);
		Capabilities.vendor = context.getParameter(context.VENDOR);
		Capabilities.version = context.getParameter(context.VERSION);
		Capabilities.shadingLanguageVersion = context.getParameter(context.SHADING_LANGUAGE_VERSION);

		Capabilities.vertexShaderHighpFloat = context.getShaderPrecisionFormat(context.VERTEX_SHADER, context.HIGH_FLOAT);
		Capabilities.vertexShaderMediumpFloat = context.getShaderPrecisionFormat(context.VERTEX_SHADER, context.MEDIUM_FLOAT);
		Capabilities.vertexShaderLowpFloat = context.getShaderPrecisionFormat(context.VERTEX_SHADER, context.LOW_FLOAT);
		Capabilities.fragmentShaderHighpFloat = context.getShaderPrecisionFormat(context.FRAGMENT_SHADER, context.HIGH_FLOAT);
		Capabilities.fragmentShaderMediumpFloat = context.getShaderPrecisionFormat(context.FRAGMENT_SHADER, context.MEDIUM_FLOAT);
		Capabilities.fragmentShaderLowpFloat = context.getShaderPrecisionFormat(context.FRAGMENT_SHADER, context.LOW_FLOAT);

		Capabilities.vertexShaderHighpInt = context.getShaderPrecisionFormat(context.VERTEX_SHADER, context.HIGH_INT);
		Capabilities.vertexShaderMediumpInt = context.getShaderPrecisionFormat(context.VERTEX_SHADER, context.MEDIUM_INT);
		Capabilities.vertexShaderLowpInt = context.getShaderPrecisionFormat(context.VERTEX_SHADER, context.LOW_INT);
		Capabilities.fragmentShaderHighpInt = context.getShaderPrecisionFormat(context.FRAGMENT_SHADER, context.HIGH_INT);
		Capabilities.fragmentShaderMediumpInt = context.getShaderPrecisionFormat(context.FRAGMENT_SHADER, context.MEDIUM_INT);
		Capabilities.fragmentShaderLowpInt = context.getShaderPrecisionFormat(context.FRAGMENT_SHADER, context.LOW_INT);
	};

	/**
	 * Gets a string representation of the current capabilities
	 * @returns {string} string representation of capabilities
	 */
	Capabilities.getCapabilitiesString = function () {
		var caps = [];
		var isArrayBufferView = function (value) {
			return value && value.buffer instanceof ArrayBuffer && value.byteLength !== undefined;
		};
		for (var name in Capabilities) {
			var cap = Capabilities[name];
			if (cap instanceof Function || (typeof cap === 'object' && !(cap instanceof Array || isArrayBufferView(cap)))) {
				continue;
			}
			var str = '';
			if (isArrayBufferView(cap)) {
				str += '[';
				for (var i = 0; i < cap.length; i++) {
					str += cap[i];
					if (i < cap.length - 1) {
						str += ',';
					}
				}
				str += ']';
			} else {
				str = cap;
			}
			caps.push(name + ': ' + str);
		}
		return caps.join('\n');
	};

	module.exports = Capabilities;

/***/ },
/* 18 */
/***/ function(module, exports, __webpack_require__) {

	var ObjectUtils = __webpack_require__(6);
	var MathUtils = __webpack_require__(9);
	var Capabilities = __webpack_require__(17);

	/**
	 * Renderer-related utilities
	 */
	function RendererUtils() {}

	/**
	 * Get size in bytes of a specific type.
	 *
	 * @param {string} type Type to retrieve bytesize for
	 */
	RendererUtils.getByteSize = function (type) {
		var byteSize;

		switch (type) {
			case 'Byte':
			case 'UnsignedByte':
				byteSize = 1;
				break;
			case 'Short':
			case 'UnsignedShort':
			case 'HalfFloat':
				byteSize = 2;
				break;
			case 'Int':
			case 'Float':
				byteSize = 4;
				break;
			case 'Double':
				byteSize = 8;
				break;

			default:
				throw new Error('Unknown type: ' + type);
		}

		return byteSize;
	};

	/**
	 * Check if the webgl context contains any errors in the current state
	 *
	 * @param {WebGLRenderingContext} gl A valid WebGL context
	 */
	RendererUtils.checkGLError = function (gl) {
		var error = gl.getError();
		var wasError = false;
		while (error !== gl.NO_ERROR) {
			wasError = true;
			if (error === gl.INVALID_ENUM) {
				console
					.error('An unacceptable value is specified for an enumerated argument. The offending command is ignored and has no other side effect than to set the error flag.');
			} else if (error === gl.INVALID_VALUE) {
				console
					.error('A numeric argument is out of range. The offending command is ignored and has no other side effect than to set the error flag.');
			} else if (error === gl.INVALID_OPERATION) {
				console
					.error('The specified operation is not allowed in the current state. The offending command is ignored and has no other side effect than to set the error flag.');
			} else if (error === gl.FRAMEBUFFER_COMPLETE) {
				console
					.error('The command is trying to render to or read from the framebuffer while the currently bound framebuffer is not framebuffer complete (i.e. the return value from glCheckFramebufferStatus is not GL_FRAMEBUFFER_COMPLETE). The offending command is ignored and has no other side effect than to set the error flag.');
			} else if (error === gl.OUT_OF_MEMORY) {
				throw new Error('There is not enough memory left to execute the command. The state of the GL is undefined, except for the state of the error flags, after this error is recorded.');
			}
			error = gl.getError();
		}

		if (wasError) {
			throw new Error('Stopping due to error');
		}
	};

	/**
	 * Checks if a value is power of two
	 * @deprecated Deprecated as of v0.14.x and scheduled for removal in v0.16.0; Consider using
	 * MathUtils.isPowerOfTwo instead
	 * @param {number} value Number to check for power of two
	 * @returns true if value is power of two
	 */
	RendererUtils.isPowerOfTwo = MathUtils.isPowerOfTwo;

	/**
	 * Converts input number to closest power of two
	 * @deprecated Deprecated as of v0.14.x and scheduled for removal in v0.16.0; Consider using
	 * MathUtils.nearestPowerOfTwo instead
	 * @param {number} number Number to convert to power of two
	 * @returns {number} Nearest power of two of input
	 */
	RendererUtils.nearestPowerOfTwo = MathUtils.nearestPowerOfTwo;

	/**
	 * Clones an object recursively
	 * @deprecated Deprecated as of 0.12.x and scheduled for removal in 0.14.0; Please use `ObjectUtils.deepClone` instead
	 * @param {*} object Object to clone
	 * @returns {*} Cloned object
	 */
	RendererUtils.clone = ObjectUtils.deepClone;

	RendererUtils._blankImages = {};
	RendererUtils.getBlankImage = function (texture, color, width, height, maxSize, index) {
		var newWidth = MathUtils.nearestPowerOfTwo(width);
		var newHeight = MathUtils.nearestPowerOfTwo(height);
		newWidth = Math.min(newWidth, maxSize);
		newHeight = Math.min(newHeight, maxSize);

		var strColor = color.length === 4 ? 'rgba(' + Number(color[0] * 255).toFixed(0) + ',' + Number(color[1] * 255).toFixed(0) + ',' + Number(color[2] * 255).toFixed(0) + ',' + Number(color[3]).toFixed(2) + ')' : 'rgb(' + Number(color[0] * 255).toFixed(0) + ',' + Number(color[1] * 255).toFixed(0) + ',' + Number(color[2] * 255).toFixed(0) + ')';
		var cacheKey = strColor + newWidth + 'x' + newHeight;
		var canvas = RendererUtils._blankImages[cacheKey];
		if (!canvas) {
			canvas = document.createElement('canvas');
			canvas.width = newWidth;
			canvas.height = newHeight;
			var ctx = canvas.getContext('2d');
			ctx.beginPath();
			ctx.rect(0, 0, newWidth, newHeight);
			ctx.fillStyle = strColor;
			ctx.fill();
			RendererUtils._blankImages[cacheKey] = canvas;
		}
		if (index === undefined) {
			texture.image = canvas;
		} else {
			texture.image.isData = false;
			texture.image.data[index] = canvas;
		}
	};

	function getImage(data, width, height) {
		var canvas = document.createElement('canvas');
		canvas.width = width;
		canvas.height = height;

		var context = canvas.getContext('2d');

		var imageData = context.createImageData(width, height);
		imageData.data.set(data);
		context.putImageData(imageData, 0, 0);

		return canvas;
	}

	RendererUtils.scaleImage = function (texture, image, width, height, maxSize, index) {
		var newWidth = MathUtils.nearestPowerOfTwo(width);
		var newHeight = MathUtils.nearestPowerOfTwo(height);
		newWidth = Math.min(newWidth, maxSize);
		newHeight = Math.min(newHeight, maxSize);

		if (image.width !== newWidth || image.height !== newHeight) {
			var canvas = document.createElement('canvas');
			canvas.width = newWidth;
			canvas.height = newHeight;
			if (image.getAttribute) {
				canvas.setAttribute('data-ref', image.getAttribute('data-ref'));
			}
			var ctx = canvas.getContext('2d');

			if (image.data) {
				// putImageData directly on this canvas will not resize
				// have to putImageData on another canvas and drawImage that afterwards
				ctx.drawImage(getImage(image.data, image.width, image.height), 0, 0, image.width, image.height, 0, 0, newWidth, newHeight);
			} else {
				//! AT: this will choke if fed with a manually created texture ([0, 0, 0, 255, ...])
				ctx.drawImage(image, 0, 0, image.width, image.height, 0, 0, newWidth, newHeight);
			}
			//document.body.appendChild(canvas);
			canvas.dataReady = true;
			canvas.src = image.src;
			canvas.originalWidth = width;
			canvas.originalHeight = height;
			if (index === undefined) {
				texture.image = canvas;
			} else {
				texture.image.data[index] = canvas;
			}
			//canvas.parentNode.removeChild(canvas);
		}
	};

	RendererUtils.getGLType = function (context, type) {
		var glType;

		switch (type) {
			case '2D':
				glType = context.TEXTURE_2D;
				break;
			case 'CUBE':
				glType = context.TEXTURE_CUBE_MAP;
				break;

			default:
				throw new Error('Invalid texture type: ' + type);
		}

		return glType;
	};

	RendererUtils.getGLWrap = function (context, wrap) {
		var glWrap;

		switch (wrap) {
			case 'Repeat':
				glWrap = context.REPEAT;
				break;
			case 'MirroredRepeat':
				glWrap = context.MIRRORED_REPEAT;
				break;
			case 'EdgeClamp':
				glWrap = context.CLAMP_TO_EDGE;
				break;

			default:
				throw new Error('Invalid WrapMode type: ' + wrap);
		}

		return glWrap;
	};

	RendererUtils.getGLInternalFormat = function (context, format) {
		var glInternalFormat;

		switch (format) {
			case 'RGBA':
				glInternalFormat = context.RGBA;
				break;
			case 'RGB':
				glInternalFormat = context.RGB;
				break;
			case 'Alpha':
				glInternalFormat = context.ALPHA;
				break;
			case 'Luminance':
				glInternalFormat = context.LUMINANCE;
				break;
			case 'LuminanceAlpha':
				glInternalFormat = context.LUMINANCE_ALPHA;
				break;

			default:
				throw new Error('Unsupported format: ' + format);
		}

		return glInternalFormat;
	};

	RendererUtils.getGLPixelDataType = function (context, type) {
		return RendererUtils.getGLDataType(context, type);
	};

	RendererUtils.getGLDataType = function (context, type) {
		var glDataType;

		switch (type) {
			case 'Float':
			case 'Double':
				glDataType = context.FLOAT;
				break;
			case 'Byte':
				glDataType = context.BYTE;
				break;
			case 'UnsignedByte':
				glDataType = context.UNSIGNED_BYTE;
				break;
			case 'Short':
				glDataType = context.SHORT;
				break;
			case 'UnsignedShort':
				glDataType = context.UNSIGNED_SHORT;
				break;
			case 'Int':
				glDataType = context.INT;
				break;
			case 'UnsignedInt':
				glDataType = context.UNSIGNED_INT;
				break;
			case 'UnsignedShort565':
				glDataType = context.UNSIGNED_SHORT_5_6_5;
				break;
			case 'UnsignedShort4444':
				glDataType = context.UNSIGNED_SHORT_4_4_4_4;
				break;
			case 'UnsignedShort5551':
				glDataType = context.UNSIGNED_SHORT_5_5_5_1;
				break;
			case 'HalfFloat':
				glDataType = Capabilities.TextureHalfFloat.HALF_FLOAT_OES;
				break;

			default:
				throw new Error('Unknown datatype: ' + type);
		}

		return glDataType;
	};

	RendererUtils.getFilterFallback = function (filter) {
		var filterFallback;

		switch (filter) {
			case 'NearestNeighborNoMipMaps':
			case 'NearestNeighborNearestMipMap':
			case 'NearestNeighborLinearMipMap':
				filterFallback = 'NearestNeighborNoMipMaps';
				break;
			case 'BilinearNoMipMaps':
			case 'Trilinear':
			case 'BilinearNearestMipMap':
				filterFallback = 'BilinearNoMipMaps';
				break;

			default:
				filterFallback = 'NearestNeighborNoMipMaps';
				break;
		}

		return filterFallback;
	};

	RendererUtils.getGLMagFilter = function (context, filter) {
		var glMagFilter;

		switch (filter) {
			case 'Bilinear':
				glMagFilter = context.LINEAR;
				break;
			case 'NearestNeighbor':
				glMagFilter = context.NEAREST;
				break;

			default:
				throw new Error('Invalid MagnificationFilter type: ' + filter);
		}

		return glMagFilter;
	};

	RendererUtils.getGLMinFilter = function (context, filter) {
		var glMinFilter;

		switch (filter) {
			case 'BilinearNoMipMaps':
				glMinFilter = context.LINEAR;
				break;
			case 'Trilinear':
				glMinFilter = context.LINEAR_MIPMAP_LINEAR;
				break;
			case 'BilinearNearestMipMap':
				glMinFilter = context.LINEAR_MIPMAP_NEAREST;
				break;
			case 'NearestNeighborNoMipMaps':
				glMinFilter = context.NEAREST;
				break;
			case 'NearestNeighborNearestMipMap':
				glMinFilter = context.NEAREST_MIPMAP_NEAREST;
				break;
			case 'NearestNeighborLinearMipMap':
				glMinFilter = context.NEAREST_MIPMAP_LINEAR;
				break;

			default:
				throw new Error('Invalid MinificationFilter type: ' + filter);
		}

		return glMinFilter;
	};

	RendererUtils.getGLBufferTarget = function (context, target) {
		if (target === 'ElementArrayBuffer') {
			return context.ELEMENT_ARRAY_BUFFER;
		}

		return context.ARRAY_BUFFER;
	};

	RendererUtils.getGLArrayType = function (context, indices) {
		var glArrayType = null;

		if (indices instanceof Uint8Array) {
			glArrayType = context.UNSIGNED_BYTE;
		} else if (indices instanceof Uint16Array) {
			glArrayType = context.UNSIGNED_SHORT;
		} else if (indices instanceof Uint32Array) {
			glArrayType = context.UNSIGNED_INT;
		} else if (indices instanceof Int8Array) {
			glArrayType = context.UNSIGNED_BYTE;
		} else if (indices instanceof Int16Array) {
			glArrayType = context.UNSIGNED_SHORT;
		} else if (indices instanceof Int32Array) {
			glArrayType = context.UNSIGNED_INT;
		}

		return glArrayType;
	};

	RendererUtils.getGLByteSize = function (indices) {
		return indices.BYTES_PER_ELEMENT || 1;
	};

	RendererUtils.getGLCubeMapFace = function (context, face) {
		var glCubeMapFace;

		switch (face) {
			case 'PositiveX':
				glCubeMapFace = context.TEXTURE_CUBE_MAP_POSITIVE_X;
				break;
			case 'NegativeX':
				glCubeMapFace = context.TEXTURE_CUBE_MAP_NEGATIVE_X;
				break;
			case 'PositiveY':
				glCubeMapFace = context.TEXTURE_CUBE_MAP_POSITIVE_Y;
				break;
			case 'NegativeY':
				glCubeMapFace = context.TEXTURE_CUBE_MAP_NEGATIVE_Y;
				break;
			case 'PositiveZ':
				glCubeMapFace = context.TEXTURE_CUBE_MAP_POSITIVE_Z;
				break;
			case 'NegativeZ':
				glCubeMapFace = context.TEXTURE_CUBE_MAP_NEGATIVE_Z;
				break;

			default:
				throw new Error('Invalid cubemap face: ' + face);
		}

		return glCubeMapFace;
	};

	RendererUtils.getGLBufferUsage = function (context, usage) {
		var glMode;

		switch (usage) {
			case 'StaticDraw':
				glMode = context.STATIC_DRAW;
				break;
			case 'DynamicDraw':
				glMode = context.DYNAMIC_DRAW;
				break;
			case 'StreamDraw':
				glMode = context.STREAM_DRAW;
				break;

			default:
				glMode = context.STATIC_DRAW;
				break;
		}

		return glMode;
	};

	RendererUtils.getGLIndexMode = function (context, indexMode) {
		var glMode;

		switch (indexMode) {
			case 'Triangles':
				glMode = context.TRIANGLES;
				break;
			case 'TriangleStrip':
				glMode = context.TRIANGLE_STRIP;
				break;
			case 'TriangleFan':
				glMode = context.TRIANGLE_FAN;
				break;
			case 'Lines':
				glMode = context.LINES;
				break;
			case 'LineStrip':
				glMode = context.LINE_STRIP;
				break;
			case 'LineLoop':
				glMode = context.LINE_LOOP;
				break;
			case 'Points':
				glMode = context.POINTS;
				break;

			default:
				glMode = context.TRIANGLES;
				break;
		}

		return glMode;
	};

	RendererUtils.getGLDepthFunc = function (context, depthFunc) {
		var glDepthFunc;

		switch (depthFunc) {
			case 'Never':
				glDepthFunc = context.NEVER;
				break;
			case 'Always':
				glDepthFunc = context.ALWAYS;
				break;
			case 'Less':
				glDepthFunc = context.LESS;
				break;
			case 'LessEqual':
				glDepthFunc = context.LEQUAL;
				break;
			case 'Equal':
				glDepthFunc = context.EQUAL;
				break;
			case 'GreaterEqual':
				glDepthFunc = context.GEQUAL;
				break;
			case 'Greater':
				glDepthFunc = context.GREATER;
				break;
			case 'NotEqual':
				glDepthFunc = context.NOTEQUAL;
				break;

			default:
				glDepthFunc = context.LEQUAL;
				break;
		}

		return glDepthFunc;
	};

	RendererUtils.getGLBlendParam = function (context, param) {
		var glBlendParam;

		switch (param) {
			case 'AddEquation':
				glBlendParam = context.FUNC_ADD;
				break;
			case 'SubtractEquation':
				glBlendParam = context.FUNC_SUBTRACT;
				break;
			case 'ReverseSubtractEquation':
				glBlendParam = context.FUNC_REVERSE_SUBTRACT;
				break;

			case 'ZeroFactor':
				glBlendParam = context.ZERO;
				break;
			case 'OneFactor':
				glBlendParam = context.ONE;
				break;
			case 'SrcColorFactor':
				glBlendParam = context.SRC_COLOR;
				break;
			case 'OneMinusSrcColorFactor':
				glBlendParam = context.ONE_MINUS_SRC_COLOR;
				break;
			case 'SrcAlphaFactor':
				glBlendParam = context.SRC_ALPHA;
				break;
			case 'OneMinusSrcAlphaFactor':
				glBlendParam = context.ONE_MINUS_SRC_ALPHA;
				break;
			case 'DstAlphaFactor':
				glBlendParam = context.DST_ALPHA;
				break;
			case 'OneMinusDstAlphaFactor':
				glBlendParam = context.ONE_MINUS_DST_ALPHA;
				break;

			case 'DstColorFactor':
				glBlendParam = context.DST_COLOR;
				break;
			case 'OneMinusDstColorFactor':
				glBlendParam = context.ONE_MINUS_DST_COLOR;
				break;
			case 'SrcAlphaSaturateFactor':
				glBlendParam = context.SRC_ALPHA_SATURATE;
				break;

			default:
				throw new Error('Unknown blend param: ' + param);
		}

		return glBlendParam;
	};

	module.exports = RendererUtils;


/***/ },
/* 19 */
/***/ function(module, exports, __webpack_require__) {

	var ObjectUtils = __webpack_require__(6);
	var MathUtils = __webpack_require__(9);
	var Vector = __webpack_require__(10);
	var Vector3 = __webpack_require__(8);
	var Vector4 = __webpack_require__(11);

	/**
	 * Vector with 2 components
	 * @extends Vector
	 * @param {number} x
	 * @param {number} y
	 * @example
	 * var v1 = new Vector2(); // v1 == (0, 0)
	 * var v2 = new Vector2(1, 2); // v2 == (1, 2)
	 */
	function Vector2(x, y) {
		// @ifdef DEBUG
		this._x = 0;
		this._y = 0;
		// @endif

		if (arguments.length === 0) {
			// Nothing given
			this.x = 0;
			this.y = 0;
		} else if (arguments.length === 1 && typeof arguments[0] === 'object') {
			if (arguments[0] instanceof Vector2) {
				// Vector2
				this.copy(arguments[0]);
			} else {
				// Array
				this.x = arguments[0][0];
				this.y = arguments[0][1];
			}
		} else {
			// Numbers
			this.x = x;
			this.y = y;
		}

		// @ifdef DEBUG
		Object.seal(this);
		// @endif
	}

	Vector2.prototype = Object.create(Vector.prototype);
	Vector2.prototype.constructor = Vector2;

	// @ifdef DEBUG
	Vector.setupAliases(Vector2.prototype, [['x'], ['y']]);
	Vector.setupIndices(Vector2.prototype, 2);
	// @endif

	Vector.setupAliases(Vector2.prototype, [['u'], ['v']]);

	/**
	 * Zero-vector (0, 0)
	 * @type {Vector2}
	 */
	Vector2.ZERO = new Vector2(0, 0);

	/**
	 * One-vector (1, 1)
	 * @type {Vector2}
	 */
	Vector2.ONE = new Vector2(1, 1);

	/**
	 * Unit-X (1, 0)
	 * @type {Vector2}
	 */
	Vector2.UNIT_X = new Vector2(1, 0);

	/**
	 * Unit-Y (0, 1)
	 * @type {Vector2}
	 */
	Vector2.UNIT_Y = new Vector2(0, 1);

	/**
	 * Returns the vector component associated with the given index.
	 * Vector components are numbered from 0 to 2 in this order: x, y.
	 * @param {number} index
	 * @returns {number}
	 */
	Vector2.prototype.getComponent = function (index) {
		switch (index) {
			case 0: return this.x;
			case 1: return this.y;
		}
	};

	/**
	 * Sets the vector component associated with the given index to a given value.
	 * Vector components are numbered from 0 to 2 in this order: x, y.
	 * @param {number} index
	 * @param {number} value
	 * @returns {Vector2} Self to allow chaining
	 */
	Vector2.prototype.setComponent = function (index, value) {
		switch (index) {
			case 0: this.x = value; break;
			case 1: this.y = value; break;
		}
		return this;
	};

	/**
	 * Adds a vector to the current vector
	 * @param {Vector2} rhs
	 * @returns {Vector2} Self to allow chaining
	 * @example
	 * var v1 = new Vector2(1, 2);
	 * var v2 = new Vector2(4, 5);
	 * v1.add(v2); // v1 == (5, 7)
	 */
	Vector2.prototype.add = function (rhs) {
		this.x += rhs.x;
		this.y += rhs.y;

		return this;
	};

	/**
	 * Adds numbers 'x', 'y' to the current Vector2 values
	 * @param {number} x
	 * @param {number} y
	 * @returns {Vector2} Self to allow chaining
	 * @example
	 * var v = new Vector2(1, 2);
	 * v.addDirect(2, 4); // v == (3, 6)
	 */
	Vector2.prototype.addDirect = function (x, y) {
		this.x += x;
		this.y += y;

		return this;
	};

	/**
	 * Adds a vector from the current vector
	 * @param {Vector2} rhs
	 * @returns {Vector2} Self to allow chaining
	 * @example
	 * var v1 = new Vector2(4, 5);
	 * var v2 = new Vector2(1, 2);
	 * v1.sub(v2); // v1 == (3, 3)
	 */
	Vector2.prototype.sub = function (rhs) {
		this.x -= rhs.x;
		this.y -= rhs.y;

		return this;
	};

	/**
	 * Subtracts numbers 'x', 'y' from the current Vector2
	 * @param {number} x
	 * @param {number} y
	 * @returns {Vector2} Self to allow chaining
	 * @example
	 * var v = new Vector2(); // v == (0, 0)
	 * v.subDirect(1, 2); // v == (-1, -2)
	 */
	Vector2.prototype.subDirect = function (x, y) {
		this.x -= x;
		this.y -= y;

		return this;
	};

	/**
	 * Performs component-wise negation of the vector
	 * @returns {Vector2} Self to allow chaining
	 */
	Vector2.prototype.negate = function () {
		this.x = -this.x;
		this.y = -this.y;

		return this;
	};

	/**
	 * Multiplies the current vector by another vector
	 * @param {Vector2} rhs
	 * @returns {Vector2} Self to allow chaining
	 * @example
	 * var v1 = new Vector2(4, 5);
	 * var v2 = new Vector2(1, 2);
	 * v1.mul(v2); // v1 == (4, 10)
	 */
	Vector2.prototype.mul = function (rhs) {
		this.x *= rhs.x;
		this.y *= rhs.y;

		return this;
	};

	/**
	 * Multiplies the current Vector2 by numbers 'x', 'y' as inputs
	 * @param {number} x
	 * @param {number} y
	 * @returns {Vector2} Self to allow chaining
	 * @example
	 * var v = new Vector2(1, 2);
	 * v.mulDirect(2, 4); // v == (2, 8)
	 */
	Vector2.prototype.mulDirect = function (x, y) {
		this.x *= x;
		this.y *= y;

		return this;
	};

	/**
	 * Scales the vector by a factor
	 * @param {number} factor
	 * @returns {Vector2} Self to allow chaining
	 */
	Vector2.prototype.scale = function (factor) {
		this.x *= factor;
		this.y *= factor;

		return this;
	};

	/**
	 * Divides the current Vector2 by another vector
	 * @param {Vector2} rhs
	 * @returns {Vector2} Self to allow chaining
	 * @example
	 * var v = new Vector2(4, 16);
	 * v.div(2, 4); // v == (2, 16)
	 */
	Vector2.prototype.div = function (rhs) {
		this.x /= rhs.x;
		this.y /= rhs.y;

		return this;
	};

	/**
	 * Divides the current Vector2 by numbers 'x', 'y' as inputs
	 * @param {number} x
	 * @param {number} y
	 * @returns {Vector2} Self to allow chaining
	 * @example
	 * var v = new Vector2(4, 9);
	 * v.divDirect(2, 3); // v == (2, 3)
	 */
	Vector2.prototype.divDirect = function (x, y) {
		this.x /= x;
		this.y /= y;

		return this;
	};

	/**
	 * Computes the dot product between the current vector and another vector
	 * @param {Vector2} rhs
	 * @returns {number}
	 */
	Vector2.prototype.dot = function (rhs) {
		return this.x * rhs.x +
			this.y * rhs.y;
	};

	/**
	 * Computes the dot product between the current vector and another vector given as 2 numeric values
	 * @param {number} x
	 * @param {number} y
	 * @returns {number}
	 */
	Vector2.prototype.dotDirect = function (x, y) {
		return this.x * x +
			this.y * y;
	};

	/**
	 * Returns whether this vector is aproximately equal to a given vector
	 * @param rhs
	 * @returns {boolean}
	 */
	Vector2.prototype.equals = function (rhs) {
		return (Math.abs(this.x - rhs.x) <= MathUtils.EPSILON) &&
			(Math.abs(this.y - rhs.y) <= MathUtils.EPSILON);
	};

	/**
	 * Returns whether this vector is approximately equal to a given vector given as 2 numeric values
	 * @param {number} x
	 * @param {number} y
	 * @returns {boolean}
	 */
	Vector2.prototype.equalsDirect = function (x, y) {
		return (Math.abs(this.x - x) <= MathUtils.EPSILON) &&
			(Math.abs(this.y - y) <= MathUtils.EPSILON);
	};

	/**
	 * Linearly interpolates between the current Vector2 and an 'end' Vector2
	 * @param {Vector2} end End Vector2
	 * @param {number} factor Interpolation factor between 0.0 and 1.0
	 * @returns {Vector2} Self to allow chaining
	 * @example
	 * var from = new Vector2(1, 2);
	 * var to = new Vector2(3, 4);
	 * var midway = from.clone().lerp(to, 0.5); // midway == (2, 3)
	 */
	Vector2.prototype.lerp = function (end, factor) {
		this.x += (end.x - this.x) * factor;
		this.y += (end.y - this.y) * factor;

		return this;
	};

	(function () {
		var tmpVec = new Vector2();

		/**
		 * Reflects a vector relative to the plane obtained from the normal parameter.
		 * @param {Vector2} normal Defines the plane that reflects the vector. Assumed to be of unit length.
		 * @returns {Vector2} Self to allow chaining
		 */
		Vector2.prototype.reflect = function (normal) {
			tmpVec.copy(normal);
			tmpVec.scale(2 * this.dot(normal));
			this.sub(tmpVec);
			return this;
		};
	})();

	/**
	 * Sets the vector's values from another vector's values
	 * @param {Vector2} rhs
	 * @returns {Vector2} Self to allow chaining
	 * @example
	 * var v = new Vector2(); // v == (0, 0)
	 * v.set(new Vector2(2, 4)); // v == (2, 4)
	 */
	Vector2.prototype.set = function (rhs) {
		if (rhs instanceof Vector2 || rhs instanceof Vector3 || rhs instanceof Vector4) {
			this.x = rhs.x;
			this.y = rhs.y;
		} else {
			this.x = arguments[0];
			this.y = arguments[1];
		}

		return this;
	};

	/**
	 * Sets the vector's values from 2 numeric arguments
	 * @param {number} x
	 * @param {number} y
	 * @returns {Vector2} Self to allow chaining
	 * @example
	 * var v = new Vector2(); // v == (0, 0)
	 * v.setDirect(2, 4); // v == (2, 4)
	 */
	Vector2.prototype.setDirect = function (x, y) {
		this.x = x;
		this.y = y;

		return this;
	};

	/**
	 * Calculates the squared length/magnitude of the current Vector2.
	 * Note: When comparing the relative distances between two points it is usually sufficient
	 * to compare the squared distances, thus avoiding an expensive square root operation.
	 * @returns {number} squared length
	 * @example
	 * var v = new Vector2(0, 9);
	 * v.lengthSquared(); // 81
	 */
	Vector2.prototype.lengthSquared = function () {
		return this.x * this.x + this.y * this.y;
	};

	/**
	 * Calculates length squared of vector
	 * @returns {number} length squared
	 */
	Vector2.prototype.length = function () {
		return Math.sqrt(this.lengthSquared());
	};

	/**
	 * Normalizes the current vector
	 * @returns {Vector2} Self to allow chaining
	 */
	Vector2.prototype.normalize = function () {
		var length = this.length();

		if (length < MathUtils.EPSILON) {
			this.x = 0;
			this.y = 0;
		} else {
			this.x /= length;
			this.y /= length;
		}

		return this;
	};

	/**
	 * Normalizes the current vector; this method does not perform special checks for zero length vectors
	 * @returns {Vector2} Self to allow chaining
	 */
	Vector2.prototype.unsafeNormalize = function () {
		var length = this.length();

		this.x /= length;
		this.y /= length;

		return this;
	};

	/**
	 * Computes the squared distance between the current Vector2 and another Vector2.
	 * Note: When comparing the relative distances between two points it is usually sufficient
	 * to compare the squared distances, thus avoiding an expensive square root operation.
	 * @param {Vector2} rhs Vector2
	 * @returns {number} distance squared
	 * @example
	 * var v1 = new Vector2(); // v1 == (0, 0)
	 * var v2 = new Vector2(0, 9);
	 * v1.distanceSquared(v2); // 81
	 */
	Vector2.prototype.distanceSquared = function (rhs) {
		var deltaX = this.x - rhs.x;
		var deltaY = this.y - rhs.y;

		return deltaX * deltaX + deltaY * deltaY;
	};

	/**
	 * Computes the distance between the current Vector2 and another Vector2.
	 * Note: When comparing the relative distances between two points it is usually sufficient
	 * to compare the squared distances, thus avoiding an expensive square root operation.
	 * @param {Vector2} rhs Vector2
	 * @returns {number} distance
	 * @example
	 * var v1 = new Vector2(); // v1 == (0, 0)
	 * var v2 = new Vector2(0, 9);
	 * v1.distance(v2); // 9
	 */
	Vector2.prototype.distance = function (rhs) {
		return Math.sqrt(this.distanceSquared(rhs));
	};

	/**
	 * Multiplies this vector with a Matrix2
	 * @param {Matrix2} matrix
	 * @returns {Vector2} Self to allow chaining
	 */
	Vector2.prototype.applyPre = function (matrix) {
		var source = matrix.data;

		var x = this.x;
		var y = this.y;

		this.x = source[0] * x + source[1] * y;
		this.y = source[2] * x + source[3] * y;

		return this;
	};

	/**
	 * Multiplies a Matrix2 with this vector
	 * @param {Matrix2} matrix
	 * @returns {Vector2} Self to allow chaining
	 */
	Vector2.prototype.applyPost = function (matrix) {
		var source = matrix.data;

		var x = this.x;
		var y = this.y;

		this.x = source[0] * x + source[2] * y;
		this.y = source[1] * x + source[3] * y;

		return this;
	};

	/**
	 * Clones the vector
	 * @returns {Vector2} Clone of self
	 */
	Vector2.prototype.clone = function () {
		return new Vector2(this.x, this.y);
	};

	/**
	 * Copies the values of another vector to this vector; an alias for .setVector
	 * @param {Vector2} Source vector
	 * @returns {Vector2} Self to allow chaining
	 */
	Vector2.prototype.copy = Vector2.prototype.set;

	/**
	 * Copies this vector over another. Not equivalent to `target.copy(this)` when
	 * the target vector has more components than the source vector
	 * @param {Vector} target
	 * @returns {Vector2} Self to allow chaining
	 */
	Vector2.prototype.copyTo = function (target) {
		target.x = this.x;
		target.y = this.y;

		return this;
	};

	/**
	 * Creates a Vector2 given an array
	 * @param {Array<number>} array
	 * @returns {Vector2}
	 */
	Vector2.fromArray = function (array) {
		return new Vector2(array[0], array[1]);
	};

	/**
	 * Creates a Vector2 given 3 numbers, an array, an {x, y} object or another Vector2
	 * @returns {Vector2}
	 */
	Vector2.fromAny = function () {
		if (arguments.length === 2) {
			return Vector2.fromArray(arguments);
		} else if (arguments[0] instanceof Array) {
			return Vector2.fromArray(arguments[0]);
		} else {
			var vectorLike = arguments[0];
			return new Vector2(vectorLike.x, vectorLike.y);
		}
	};

	/**
	 * Sets the vector content from an array of numbers.
	 * @param {Array<number>} array
	 */
	Vector2.prototype.setArray = function (array) {
		this.x = array[0];
		this.y = array[1];

		return this;
	};

	/**
	 * Returns the components of the vector in array form
	 * @returns {Array<number>}
	 */
	Vector2.prototype.toArray = function () {
		return [this.x, this.y];
	};

	// @ifdef DEBUG
	Vector.addReturnChecks(Vector2.prototype, [
		'dot', 'dotDirect',
		'length', 'lengthSquared',
		'distance', 'distanceSquared'
	]);
	// @endif

	// SHIM START
	Object.defineProperty(Vector2.prototype, 'data', {
		get: ObjectUtils.warnOnce('The .data property of Vector2 was removed. Please use the .x and .y properties instead.', function () {
			var data = [];
			var that = this;
			Object.defineProperties(data, {
				'0': {
					get: function () {
						return that.x;
					},
					set: function (value) {
						that.x = value;
					}
				},
				'1': {
					get: function () {
						return that.y;
					},
					set: function (value) {
						that.y = value;
					}
				}
			});
			return data;
		})
	});

	Vector2.prototype.setVector = ObjectUtils.warnOnce('The setVector method of Vector2 was removed. Please use the set method instead.', function (rhs) {
		return this.set(rhs);
	});

	/**
	 * @hidden
	 * @deprecated
	 */
	Vector2.add = ObjectUtils.warnOnce('Vector2.add is deprecated.', function (lhs, rhs, target) {
		if (typeof lhs === 'number') {
			lhs = [lhs, lhs];
		}

		if (typeof rhs === 'number') {
			rhs = [rhs, rhs];
		}

		if (!target) {
			target = new Vector2();
		}

		var ldata = lhs.data || lhs;
		var rdata = rhs.data || rhs;

		target.data[0] = ldata[0] + rdata[0];
		target.data[1] = ldata[1] + rdata[1];

		return target;
	});

	/**
	 * @hidden
	 * @deprecated
	 */
	Vector2.sub = ObjectUtils.warnOnce('Vector2.sub is deprecated.', function (lhs, rhs, target) {
		if (typeof lhs === 'number') {
			lhs = [lhs, lhs];
		}

		if (typeof rhs === 'number') {
			rhs = [rhs, rhs];
		}

		if (!target) {
			target = new Vector2();
		}

		var ldata = lhs.data || lhs;
		var rdata = rhs.data || rhs;


		target.data[0] = ldata[0] - rdata[0];
		target.data[1] = ldata[1] - rdata[1];

		return target;
	});

	/**
	 * @hidden
	 * @deprecated
	 */
	Vector2.mul = ObjectUtils.warnOnce('Vector2.mul is deprecated.', function (lhs, rhs, target) {
		if (typeof lhs === 'number') {
			lhs = [lhs, lhs];
		}

		if (typeof rhs === 'number') {
			rhs = [rhs, rhs];
		}

		if (!target) {
			target = new Vector2();
		}

		var ldata = lhs.data || lhs;
		var rdata = rhs.data || rhs;

		target.data[0] = ldata[0] * rdata[0];
		target.data[1] = ldata[1] * rdata[1];

		return target;
	});

	/**
	 * @hidden
	 * @deprecated
	 */
	Vector2.div = ObjectUtils.warnOnce('Vector2.div is deprecated.', function (lhs, rhs, target) {
		if (typeof lhs === 'number') {
			lhs = [lhs, lhs];
		}

		if (typeof rhs === 'number') {
			rhs = [rhs, rhs];
		}

		if (!target) {
			target = new Vector2();
		}

		var ldata = lhs.data || lhs;
		var rdata = rhs.data || rhs;

		target.data[0] = ldata[0] / rdata[0];
		target.data[1] = ldata[1] / rdata[1];

		return target;
	});

	/**
	 * @hidden
	 * @deprecated
	 */
	Vector2.dot = ObjectUtils.warnOnce('Vector2.dot is deprecated.', function (lhs, rhs) {
		if (typeof lhs === 'number') {
			lhs = [lhs, lhs];
		}

		if (typeof rhs === 'number') {
			rhs = [rhs, rhs];
		}

		var ldata = lhs.data || lhs;
		var rdata = rhs.data || rhs;

		return ldata[0] * rdata[0] +
			ldata[1] * rdata[1];
	});

	/**
	 * @hidden
	 * @deprecated
	 */
	Vector2.prototype.dotVector = ObjectUtils.warnOnce('Vector2.prototype.dotVector is deprecated.', function (rhs) {
		var ldata = this.data;
		var rdata = rhs.data;

		return ldata[0] * rdata[0] +
			ldata[1] * rdata[1];
	});

	/**
	 * @hidden
	 * @deprecated
	 */
	Vector2.prototype.addVector = ObjectUtils.warnOnce('Vector2.prototype.addVector is deprecated.', function (vector) {
		this.data[0] += vector.data[0];
		this.data[1] += vector.data[1];

		return this;
	});

	/**
	 * @hidden
	 * @deprecated
	 */
	Vector2.prototype.mulVector = ObjectUtils.warnOnce('Vector2.prototype.mulVector is deprecated.', function (vector) {
		this.data[0] *= vector.data[0];
		this.data[1] *= vector.data[1];

		return this;
	});

	/**
	 * @hidden
	 * @deprecated
	 */
	Vector2.prototype.subVector = ObjectUtils.warnOnce('Vector2.prototype.subVector is deprecated.', function (vector) {
		this.data[0] -= vector.data[0];
		this.data[1] -= vector.data[1];

		return this;
	});

	//!schteppe: not shimming Vector2.prototype.seta, it's been warned about forever
	//!schteppe: not shimming Vector2.prototype.setd, it's been warned about forever
	//!schteppe: not shimming Vector2.prototype.setv, it's been warned about forever

	// SHIM END

	module.exports = Vector2;


/***/ },
/* 20 */
/***/ function(module, exports, __webpack_require__) {

	var EntitySelection = __webpack_require__(21);

	/**
	 * Base class/module for all components. Should not be used directly.
	 */
	function Component() {
		/**
		 * If the component should be processed for containing entities.
		 * @type {boolean}
		 */
		this.enabled = true;

		/**
		 * The entity the component is added to.
		 * @type {Entity|null}
		 */
		this.entity = null;

		this.installedAPI = new Set();

		/**
		 * Debug level for the component. Can be 'none', 'normal' or 'full'.
		 * None will prevent the rendering of any debug meshes for the component.
		 * @type {string}
		 */
		this.debugLevel = 'normal';
	}

	/**
	 * Should be implemented in the same way in subclasses. Will be called by the World for each argument to world.createEntity(arg0, arg1, ...). If this function returns true, it indicates that the passed argument was used and should not be passed to other components. See World.prototype.createEntity.
	 * @param argument
	 * @param {Entity} entity
	 * @returns {boolean} True if the data was used.
	 */
	Component.applyOnEntity = function (/*argument, entity*/) {
		return false;
	};

	/**
	 * Called when the component was added to an entity
	 * @param {Entity} entity
	 */
	Component.prototype.attached = function (/*entity*/) {};

	/**
	 * Called when the component was removed from an entity
	 * @param {Entity} entity
	 */
	Component.prototype.detached = function (/*entity*/) {};

	/**
	 * Injects public methods of this component into the host entity.
	 * @param {Entity} entity
	 * @private
	 */
	Component.prototype.applyAPI = function (entity) {
		var api = this.api;
		if (!api) {
			return;
		}
		var keys = Object.keys(api);
		for (var i = 0; i < keys.length; i++) {
			var key = keys[i];
			if (typeof entity[key] === 'undefined') {
				entity[key] = api[key];
				this.installedAPI.add(key);
			} else {
				throw new Error('Could not install method ' + key + ' of ' + this.type + ' as it is already taken');
			}
		}
	};

	/**
	 * Removed any methods attached to the host entity that belong to this component's API.
	 * @param entity
	 * @private
	 */
	Component.prototype.removeAPI = function (entity) {
		this.installedAPI.forEach(function (key) {
			delete entity[key];
		});
	};

	Component.applyEntitySelectionAPI = function (entitySelectionAPI, componentType) {
		if (!entitySelectionAPI) { return; }

		var keys = Object.keys(entitySelectionAPI);
		for (var i = 0; i < keys.length; i++) {
			var key = keys[i];
			if (typeof EntitySelection[key] === 'undefined') {
				EntitySelection.installMethod(entitySelectionAPI[key], key, componentType);
			} else {
				throw new Error('Could not install method ' + key + ' on EntitySelection as it is already taken');
			}
		}
	};

	module.exports = Component;

/***/ },
/* 21 */
/***/ function(module, exports, __webpack_require__) {

	var Selection = __webpack_require__(22);

	/**
	 * A specialised selection object for entities
	 * @extends Selection
	 */
	function EntitySelection() {
		Selection.apply(this, arguments);
	}

	EntitySelection.prototype = Object.create(Selection.prototype);
	EntitySelection.prototype.constructor = EntitySelection;

	/**
	 * Adds entities to this selection. Any resulting duplicates are removed.
	 * @param {(Entity | Array<Entity> | EntitySelection)} entities The entities to add
	 * @returns {EntitySelection} Returns self to allow chaining
	 * @example-link http://code.gooengine.com/latest/examples/goo/entities/EntitySelection/EntitySelection-setOps-example.html Working example
	 */
	EntitySelection.prototype.and = function () {
		if (this.top === null) { return this; }

		var union;

		var entities = toArray.apply(null, arguments);

		//! AT: this long/short separation only minimizes the number of ifs performed
		// while costing more memory (which is allocated on the stack anyways since the hashTable array never leaves this function
		// would love to see a benchmark though
		var shortArray, longArray;
		if (entities.length > this.top.length) {
			shortArray = this.top;
			longArray = entities;
		} else {
			shortArray = entities;
			longArray = this.top;
		}

		var hashTable = [];
		for (var i = 0; i < longArray.length; i++) {
			var id = longArray[i].id;
			hashTable[id] = true;
		}

		union = longArray.concat([]);

		for (var i = 0; i < shortArray.length; i++) {
			if (!hashTable[shortArray[i].id]) {
				union.push(shortArray[i]);
			}
		}

		this.stack.push(union);
		this.top = union;

		return this;
	};

	/**
	 * Returns the common entities between this selection and the given parameter(s)
	 * @param {(Entity | Array<Entity> | EntitySelection)} entities
	 * @returns {EntitySelection} Returns self to allow chaining
	 * @example-link http://code.gooengine.com/latest/examples/goo/entities/EntitySelection/EntitySelection-setOps-example.html Working example
	 */
	EntitySelection.prototype.intersects = function () {
		if (this.top === null) { return this; }

		var intersection;

		var entities = toArray.apply(null, arguments);

		//! AT: this long/short separation only minimizes the number of ifs performed
		// while costing more memory (which is allocated on the stack anyways since the hashTable array never leaves this function
		// would love to see a benchmark though
		var shortArray, longArray;
		if (entities.length > this.top.length) {
			shortArray = this.top;
			longArray = entities;
		} else {
			shortArray = entities;
			longArray = this.top;
		}

		var hashTable = [];
		for (var i = 0; i < longArray.length; i++) {
			var id = longArray[i].id;
			hashTable[id] = true;
		}

		intersection = [];
		for (var i = 0; i < shortArray.length; i++) {
			if (hashTable[shortArray[i].id]) {
				intersection.push(shortArray[i]);
			}
		}

		this.stack.push(intersection);
		this.top = intersection;

		return this;
	};

	/**
	 * Removes entities from the current selection
	 * @param {(Entity | Array<Entity> | EntitySelection)} entities Entities to remove from the selection
	 * @returns {EntitySelection} Returns self to allow chaining
	 * @example-link http://code.gooengine.com/latest/examples/goo/entities/EntitySelection/EntitySelection-setOps-example.html Working example
	 */
	EntitySelection.prototype.without = function () {
		if (this.top === null) { return this; }

		var difference;

		var entities = toArray.apply(null, arguments);

		var hashTable = [];
		for (var i = 0; i < entities.length; i++) {
			var id = entities[i].id;
			hashTable[id] = true;
		}

		difference = [];
		for (var i = 0; i < this.top.length; i++) {
			if (!hashTable[this.top[i].id]) {
				difference.push(this.top[i]);
			}
		}

		this.stack.push(difference);
		this.top = difference;

		return this;
	};

	/**
	 * Adds the previous selection to the current selection. Resulting duplicates are removed.
	 * @returns {EntitySelection} Returns self to allow chaining
	 */
	EntitySelection.prototype.andSelf = function () {
		if (this.top === null) { return this; }

		if (this.stack.length <= 1) { return this; }

		var prev = this.stack[this.stack.length - 2];

		return this.and.apply(this, prev);
	};

	//! AT: the transform component/system should install these
	/**
	 * Returns the parents of all entities in this selection
	 * @returns {EntitySelection} Returns self to allow chaining
	 * @example-link http://code.gooengine.com/latest/examples/goo/entities/EntitySelection/EntitySelection-parent-example.html Working example
	 */
	EntitySelection.prototype.parent = function () {
		if (this.top === null) { return this; }

		var hashTable = [];

		var parents = this.top.filter(function (entity) {
			if (!entity.transformComponent.parent) {
				return false;
			} else if (hashTable[entity.transformComponent.parent.entity.id]) {
				return false;
			} else {
				hashTable[entity.transformComponent.parent.entity.id] = true;
				return true;
			}
		}).map(function (entity) {
			return entity.transformComponent.parent.entity;
		});
		this.stack.push(parents);
		this.top = parents;

		return this;
	};

	/**
	 * Returns the children of all entities in this selection
	 * @returns {EntitySelection} Returns self to allow chaining
	 * @example-link http://code.gooengine.com/latest/examples/goo/entities/EntitySelection/EntitySelection-children-example.html Working example
	 */
	EntitySelection.prototype.children = function () {
		// could use flatMap
		if (this.top === null) { return this; }

		var children = this.top.map(function (entity) {
			return entity.transformComponent.children.map(function (childTransform) {
				return childTransform.entity;
			});
		});
		var flatChildren = children.reduce(function (prev, cur) { return prev.concat(cur); }, []);
		this.stack.push(flatChildren);
		this.top = flatChildren;

		return this;
	};

	/**
	 * Installs a method that acts upon entities on the prototype of EntitySelection
	 * @hidden
	 * @param method
	 * @param name
	 * @param dependentComponent
	 */
	EntitySelection.installMethod = function (method, name, dependentComponent) {
		EntitySelection.prototype[name] = function () {
			if (this.top === null) { return this; }

			for (var i = 0; i < this.top.length; i++) {
				var entity = this.top[i];

				if (entity.hasComponent(dependentComponent)) {
					method.apply(entity, arguments);
				}
			}

			return this;
		};
	};

	/**
	 * Converts anything (nothing, an EntitySelection, an array or more arguments) to an array
	 * @memberOf EntitySelection#
	 * @private
	 * @returns {*}
	 */
	function toArray() {
		if (arguments.length === 1) {
			var argument = arguments[0];
			if (argument instanceof EntitySelection) {
				if (argument.top) {
					return argument.top;
				} else {
					return [];
				}
			} else if (Array.isArray(argument)) {
				return argument;
			} else {
				return [argument];
			}
		} else if (arguments.length > 1) {
			return Array.prototype.slice.call(arguments, 0);
		} else {
			return [];
		}
	}

	module.exports = EntitySelection;

/***/ },
/* 22 */
/***/ function(module, exports) {

	/**
	 * Generic selection class
	 */
	function Selection() {
		this.stack = [];

		//! AT: may rather use toArray
		if (arguments.length === 1) {
			var argument = arguments[0];
			if (argument instanceof Selection) {
				if (argument.top) {
					this.stack.push(argument.top);
				}
			} else if (Array.isArray(argument)) {
				this.stack.push(argument);
			} else {
				this.stack.push([argument]);
			}
		} else if (arguments.length > 1) {
			this.stack.push(Array.prototype.slice.call(arguments, 0));
		}

		if (this.stack.length > 0) {
			this.stack[0] = removeDuplicates(this.stack[0]);
		}

		this.top = this.stack.length === 0 ? null : this.stack[0];
	}

	/**
	 * Empty selection
	 * @type {Selection}
	 */
	Selection.EMPTY = new Selection();

	/**
	 * Returns true if the selection contains a specific element
	 * @param element
	 * @returns {boolean}
	 */
	Selection.prototype.contains = function (element) {
		if (this.top === null) { return false; }

		return this.top.indexOf(element) !== -1;
	};

	/**
	 * Returns the size of this selection
	 * @returns {number}
	 */
	Selection.prototype.size = function () {
		if (this.top === null) { return 0; }

		return this.top.length;
	};

	/**
	 * Applies a function on each element until `false` is returned
	 * @param {Function} fun The function to apply
	 * @returns {Selection} Returns self to allow chaining
	 */
	Selection.prototype.each = function (fun) {
		//! AT: this check should be done automatically before each method
		if (this.top === null) { return this; }

		for (var i = 0; i < this.top.length; i++) {
			if (fun(this.top[i], i) === false) {
				break;
			}
		}

		return this;
	};

	/**
	 * Alias for `each`
	 * @type {Function}
	 */
	Selection.prototype.forEach = Selection.prototype.each;

	/**
	 * Applies a filter on the elements of this selection
	 * @param predicate The filter used for filtering
	 * @returns {Selection} Returns self to allow chaining
	 */
	Selection.prototype.filter = function (predicate) {
		//! AT: this check should be done automatically before each method
		if (this.top === null) { return this; }

		var top = this.top.filter(predicate);
		this.stack.push(top);
		this.top = top;

		return this;
	};

	/**
	 * Applies a function on the elements of this selection producing a new collection
	 * @param fun The function to apply to each element
	 * @returns {Selection} Returns self to allow chaining
	 */
	Selection.prototype.map = function (fun) {
		//! AT: this check should be done automatically before each method
		if (this.top === null) { return this; }

		var top = this.top.map(fun);
		this.stack.push(top);
		this.top = top;

		return this;
	};

	/**
	 * @private
	 * @param fun
	 * @returns {Selection} Returns self to allow chaining
	 */
	Selection.prototype.flatMap = function (fun) {
		//! AT: this check should be done automatically before each method
		if (this.top === null) { return this; }

		var map = this.top.map(fun);
		var flatMap = map.reduce(function (prev, cur) { return prev.concat(cur); }, []);
		this.stack.push(flatMap);
		this.top = flatMap;

		return this;
	};

	/**
	 * Reduces the entire selection to a single element by applying a function on every element and an accumulated value
	 * @param fun The function used to reduce the selection
	 * @param initialValue The value used for the first call of `fun`
	 * @returns {Selection} Returns self to allow chaining
	 */
	Selection.prototype.reduce = function (fun, initialValue) {
		//! AT: this check should be done automatically before each method
		if (this.top === null) { return this; }

		var top = [this.top.reduce(fun, initialValue)];
		this.stack.push(top);
		this.top = top;

		return this;
	};

	/**
	 * Adds elements to this selection. Any resulting duplicates are removed.
	 * @param {(Element | Array<Element> | Selection)} elements The element(s) to add
	 * @returns {Selection} Returns self to allow chaining
	 */
	Selection.prototype.and = function () {
		if (this.top === null) { return this; }

		var elements = toArray.apply(null, arguments);

		var union = this.top.concat(elements);
		union = removeDuplicates(union);
		this.stack.push(union);
		this.top = union;

		return this;
	};

	/**
	 * Returns the common elements between this selection and the given parameter(s)
	 * @param {(Element | Array<Element> | Selection)} elements
	 * @returns {Selection} Returns self to allow chaining
	 */
	Selection.prototype.intersects = function () {
		if (this.top === null) { return this; }

		var elements = toArray.apply(null, arguments);

		var intersection = [];

		//! AT: when searching for arbitrary objects in an array searching by pointer (reference) is the only way
		// hopefully, if longArray is represented as some tree/hash with fast .indexOf()
		// so that I can iterate over the shorter array and do query the long array
		// best case: short array has one element and if indexOf takes O(log(longArray.length)) (or even better) time
		// worst case scenario: both arrays are of the same length and this optimisation is useless - it takes
		// O(shortArray.length * log(longArray.length)) time
		var shortArray, longArray;
		if (elements.length > this.top.length) {
			shortArray = this.top;
			longArray = elements;
		} else {
			shortArray = elements;
			longArray = this.top;
		}

		for (var i = 0; i < shortArray.length; i++) {
			var element = shortArray[i];
			if (longArray.indexOf(element) !== -1) {
				intersection.push(element);
			}
		}

		this.stack.push(intersection);
		this.top = intersection;

		return this;
	};

	/**
	 * Removes elements from the current selection
	 * @param elements {(Element | Array<Element> | Selection)} Elements to remove from the selection
	 * @returns {Selection} Returns self to allow chaining
	 */
	Selection.prototype.without = function () {
		if (this.top === null) { return this; }

		var elements = toArray.apply(null, arguments);

		var difference = [];

		for (var i = 0; i < this.top.length; i++) {
			var element = this.top[i];
			if (elements.indexOf(element) === -1) {
				difference.push(element);
			}
		}

		this.stack.push(difference);
		this.top = difference;

		return this;
	};

	/**
	 * Adds the previous selection to the current selection. Resulting duplicates are removed.
	 * @returns {Selection} Returns self to allow chaining
	 */
	Selection.prototype.andSelf = function () {
		if (this.top === null) { return this; }

		if (this.stack.length <= 1) { return this; }

		var prev = this.stack[this.stack.length - 2];

		var union = prev.concat(this.top);
		union = removeDuplicates(union);
		this.stack.push(union);
		this.top = union;

		return this;
	};

	/**
	 * Discards the last operation done on the selection
	 * @returns {Selection} Returns self to allow chaining
	 */
	Selection.prototype.end = function () {
		if (this.top === null) { return this; }

		this.stack.pop();

		if (this.stack.length === 0) {
			this.top = null;
		} else {
			this.top = this.stack[this.stack.length - 1];
		}

		return this;
	};

	/**
	 * Returns the first object of the selection
	 * @returns {Element}
	 */
	//! AT: this may not be so crucial to have // might as well just use .get
	Selection.prototype.first = function () {
		return this.top === null ? null : this.top[0];
	};

	/**
	 * Clones the selection and its history
	 * @returns {Selection} Returns a copy of this selection object
	 */
	Selection.prototype.clone = function () {
		var clone = new Selection();

		//! AT: the array pointed by top is read only it can be shallow copied
		clone.top = this.top;

		// this array however is modified
		clone.stack = this.stack.concat([]);

		return clone;
	};

	/**
	 * Returns the element on the specified position or the whole selection as an array if position is not given
	 * @param {number} [index] Index of the desired element; can handle negative indices (Ex: -1 is the last element)
	 * @returns {Array}
	 */
	Selection.prototype.get = function (index) {
		if (typeof index !== 'number') {
			return this.top === null ? [] : this.top.concat([]);
		}
		if (index < 0) {
			return this.top === null ? undefined : this.top[this.top.length + index];
		} else {
			return this.top === null ? undefined : this.top[index];
		}
	};

	/**
	 * Returns the selection as an array
	 * @returns {Array}
	 */
	Selection.prototype.toArray = function () {
		return this.top === null ? [] : this.top.concat([]);
	};

	//! AT: slow //will be faster for EntitySelection
	function removeDuplicates(array) {
		var newArray = [];

		for (var i = 0; i < array.length; i++) {
			var element = array[i];
			// hopefully lastIndexOf is faster than O(n)
			if (array.lastIndexOf(element) === i) {
				newArray.push(element);
			}
		}

		return newArray;
	}

	/**
	 * Converts anything (nothing, a Selection, an array or more arguments) to an array
	 * @memberOf Selection#
	 * @private
	 * @returns {*}
	 */
	function toArray() {
		if (arguments.length === 1) {
			var argument = arguments[0];
			if (argument instanceof Selection) {
				if (argument.top) {
					return argument.top;
				} else {
					return [];
				}
			} else if (Array.isArray(argument)) {
				return argument;
			} else {
				return [argument];
			}
		} else if (arguments.length > 1) {
			return Array.prototype.slice.call(arguments, 0);
		} else {
			return [];
		}
	}

	module.exports = Selection;

/***/ },
/* 23 */
/***/ function(module, exports, __webpack_require__) {

	var Vector = __webpack_require__(10);
	var Vector3 = __webpack_require__(8);
	var Vector4 = __webpack_require__(11);
	var Matrix3 = __webpack_require__(24);
	var MathUtils = __webpack_require__(9);
	var ObjectUtils = __webpack_require__(6);

	/**
	 * Quaternions provide a convenient mathematical notation for
	 * representing orientations and rotations of objects in three dimensions.
	 * Compared to Euler angles, Quaternions are simpler to compose and can help avoid the problem of gimbal lock.
	 * Compared to rotation matrices, Quaternions are more numerically stable and the representation (4 numbers) is more compact.
	 * Quaternions are non-commutative and provide a convenient way to interpolate between rotations (using the <i>slerp</i> function).
	 * @param {number} x
	 * @param {number} y
	 * @param {number} z
	 * @param {number} w
	 */
	function Quaternion(x, y, z, w) {
		// @ifdef DEBUG
		this._x = 0;
		this._y = 0;
		this._z = 0;
		this._w = 1;
		// @endif

		if (arguments.length === 0) {
			// Nothing given
			this.x = 0;
			this.y = 0;
			this.z = 0;
			this.w = 1;
		} else if (arguments.length === 1 && typeof arguments[0] === 'object') {
			if (arguments[0] instanceof Quaternion) {
				// Quaternion
				this.copy(arguments[0]);
			} else {
				// Array
				this.x = arguments[0][0];
				this.y = arguments[0][1];
				this.z = arguments[0][2];
				this.w = arguments[0][3];
			}
		} else {
			// Numbers
			this.x = x;
			this.y = y;
			this.z = z;
			this.w = w;
		}

		// @ifdef DEBUG
		Object.seal(this);
		// @endif
	}

	// @ifdef DEBUG
	Vector.setupAliases(Quaternion.prototype, [['x'], ['y'], ['z'], ['w']]);
	// @endif

	Quaternion.prototype.setDirect = Vector4.prototype.setDirect;
	Quaternion.prototype.dot = Vector4.prototype.dot;
	Quaternion.prototype.length = Vector4.prototype.length;
	Quaternion.prototype.lengthSquared = Vector4.prototype.lengthSquared;
	Quaternion.prototype.normalize = Vector4.prototype.normalize;
	Quaternion.prototype.equals = Vector4.prototype.equals;

	Quaternion.IDENTITY = new Quaternion(0, 0, 0, 1);

	Quaternion.prototype.copy = function (rhs) {
		this.x = rhs.x;
		this.y = rhs.y;
		this.z = rhs.z;
		this.w = rhs.w;
		return this;
	};

	Quaternion.prototype.set = function (rhs) {
		if (rhs instanceof Quaternion) {
			this.x = rhs.x;
			this.y = rhs.y;
			this.z = rhs.z;
			this.w = rhs.w;
		} else {
			this.x = arguments[0];
			this.y = arguments[1];
			this.z = arguments[2];
			this.w = arguments[3];
		}

		return this;
	};

	/**
	 * Computes the spherical linear interpolation between startQuat and endQuat.
	 * @param {Quaternion} startQuat Start quaternion.
	 * @param {Quaternion} endQuat End quaternion.
	 * @param {number} changeAmnt Interpolation factor between 0.0 and 1.0.
	 * @param {Quaternion} workQuat Work quaternion.
	 * @returns {Quaternion} workQuat The interpolated work quaternion.
	 */
	Quaternion.slerp = function (startQuat, endQuat, changeAmnt, workQuat) {
		// check for weighting at either extreme
		if (changeAmnt === 0.0) {
			return workQuat.set(startQuat);
		} else if (changeAmnt === 1.0) {
			return workQuat.set(endQuat);
		}

		// Check for equality and skip operation.
		if (startQuat.equals(endQuat)) {
			return workQuat.set(startQuat);
		}

		var result = startQuat.dot(endQuat);
		workQuat.set(endQuat);

		if (result < 0.0) {
			// Negate the second quaternion and the result of the dot product
			workQuat.negate();
			result = -result;
		}

		// Set the first and second scale for the interpolation
		var scale0 = 1 - changeAmnt;
		var scale1 = changeAmnt;

		// Check if the angle between the 2 quaternions was big enough to
		// warrant such calculations
		if (1 - result > 0.1) {// Get the angle between the 2 quaternions,
			// and then store the sin() of that angle
			var theta = Math.acos(result);
			var invSinTheta = 1 / Math.sin(theta);

			// Calculate the scale for q1 and q2, according to the angle and
			// it's sine value
			scale0 = Math.sin((1 - changeAmnt) * theta) * invSinTheta;
			scale1 = Math.sin(changeAmnt * theta) * invSinTheta;
		}

		// Calculate the x, y, z and w values for the quaternion by using a
		// special form of linear interpolation for quaternions.
		var x = scale0 * startQuat.x + scale1 * workQuat.x;
		var y = scale0 * startQuat.y + scale1 * workQuat.y;
		var z = scale0 * startQuat.z + scale1 * workQuat.z;
		var w = scale0 * startQuat.w + scale1 * workQuat.w;

		workQuat.setDirect(x, y, z, w);

		// Return the interpolated quaternion
		return workQuat;
	};

	/**
	 * Multiplies this quaterion's values by -1.
	 * @returns {Quaternion} Self for chaining.
	 */
	Quaternion.prototype.negate = function () {
		this.x *= -1;
		this.y *= -1;
		this.z *= -1;
		this.w *= -1;

		return this;
	};

	/**
	 * Conjugates this quaternion
	 * @returns {Quaternion} Self for chaining.
	 */
	Quaternion.prototype.conjugate = function () {
		this.x *= -1;
		this.y *= -1;
		this.z *= -1;

		return this;
	};

	/**
	 * Inverts this quaternion
	 * @returns {Quaternion} Self for chaining.
	 */
	Quaternion.prototype.invert = function () {
		return this.conjugate().normalize();
	};

	/**
	 * Performs a multiplication between the current quaternion and another and stores the result locally.
	 * The result is a <b>quaternion product</b>.
	 * @param {Quaternion} rhs Quaternion on the right-hand side.
	 * @returns {Quaternion} Self for chaining.
	 */
	Quaternion.prototype.mul = function (rhs) {
		var ax = this.x, ay = this.y, az = this.z, aw = this.w;
		var bx = rhs.x, by = rhs.y, bz = rhs.z, bw = rhs.w;

		this.x = ax * bw + aw * bx + ay * bz - az * by;
		this.y = ay * bw + aw * by + az * bx - ax * bz;
		this.z = az * bw + aw * bz + ax * by - ay * bx;
		this.w = aw * bw - ax * bx - ay * by - az * bz;

		return this;
	};

	(function () {
		var slerpWorkQuat = new Quaternion();

		/**
		 * Computes the spherical linear interpolation from the current quaternion towards endQuat.
		 * @param {Quaternion} endQuat End quaternion.
		 * @param {number} changeAmount Interpolation factor between 0.0 and 1.0.
		 * @returns {Quaternion} Self for chaining.
		 */
		Quaternion.prototype.slerp = function (endQuat, changeAmount) {
			slerpWorkQuat.copy(endQuat);
			Quaternion.slerp(this, endQuat, changeAmount, slerpWorkQuat);
			this.copy(slerpWorkQuat);
			return this;
		};
	})();

	/**
	 * Sets the value of this quaternion to the rotation described by the given matrix values.
	 * @param {Matrix3} matrix Rotation matrix.
	 * @returns {Quaternion} Self for chaining.
	 */
	Quaternion.prototype.fromRotationMatrix = function (matrix) {
		// Uses the Graphics Gems code, from
		// ftp://ftp.cis.upenn.edu/pub/graphics/shoemake/quatut.ps.Z
		// *NOT* the "Matrix and Quaternions FAQ", which has errors!

		// the trace is the sum of the diagonal elements; see
		// http://mathworld.wolfram.com/MatrixTrace.html
		var t = matrix.e00 + matrix.e11 + matrix.e22;

		// we protect the division by s by ensuring that s>=1
		var x, y, z, w;
		if (t >= 0) { // |w| >= .5
			var s = Math.sqrt(t + 1); // |s|>=1 ...
			w = 0.5 * s;
			s = 0.5 / s; // so this division isn't bad
			x = (matrix.e21 - matrix.e12) * s;
			y = (matrix.e02 - matrix.e20) * s;
			z = (matrix.e10 - matrix.e01) * s;
		} else if (matrix.e00 > matrix.e11 && matrix.e00 > matrix.e22) {
			var s = Math.sqrt(1.0 + matrix.e00 - matrix.e11 - matrix.e22); // |s|>=1
			x = s * 0.5; // |x| >= .5
			s = 0.5 / s;
			y = (matrix.e10 + matrix.e01) * s;
			z = (matrix.e02 + matrix.e20) * s;
			w = (matrix.e21 - matrix.e12) * s;
		} else if (matrix.e11 > matrix.e22) {
			var s = Math.sqrt(1.0 + matrix.e11 - matrix.e00 - matrix.e22); // |s|>=1
			y = s * 0.5; // |y| >= .5
			s = 0.5 / s;
			x = (matrix.e10 + matrix.e01) * s;
			z = (matrix.e21 + matrix.e12) * s;
			w = (matrix.e02 - matrix.e20) * s;
		} else {
			var s = Math.sqrt(1.0 + matrix.e22 - matrix.e00 - matrix.e11); // |s|>=1
			z = s * 0.5; // |z| >= .5
			s = 0.5 / s;
			x = (matrix.e02 + matrix.e20) * s;
			y = (matrix.e21 + matrix.e12) * s;
			w = (matrix.e10 - matrix.e01) * s;
		}

		return this.setDirect(x, y, z, w);
	};

	/**
	 * Return a rotation matrix representing the current quaternion.
	 * @param {Matrix3} [store] The matrix to store our result in. If null, a new matrix is created.
	 * @returns {Matrix3} The normalized rotation matrix representation of this quaternion.
	 */
	Quaternion.prototype.toRotationMatrix = function (store) {
		var result = store || new Matrix3();

		var norm = this.lengthSquared();
		var s = norm > 0.0 ? 2.0 / norm : 0.0;

		var xs = this.x * s;
		var ys = this.y * s;
		var zs = this.z * s;
		var xx = this.x * xs;
		var xy = this.x * ys;
		var xz = this.x * zs;
		var xw = this.w * xs;
		var yy = this.y * ys;
		var yz = this.y * zs;
		var yw = this.w * ys;
		var zz = this.z * zs;
		var zw = this.w * zs;

		var t = result.data;
		t[0] = 1.0 - (yy + zz);
		t[1] = xy + zw;
		t[2] = xz - yw;
		t[3] = xy - zw;
		t[4] = 1.0 - (xx + zz);
		t[5] = yz + xw;
		t[6] = xz + yw;
		t[7] = yz - xw;
		t[8] = 1.0 - (xx + yy);

		return result;
	};

	(function () {
		var pivotVector = new Vector3();

		/**
		 * Sets this quaternion to the one that will rotate vector "from" into vector "to". Vectors do not have to be the same length.
		 * @param {Vector3} from The source vector.
		 * @param {Vector3} to The destination vector into which to rotate the source vector.
		 * @returns {Quaternion} Self for chaining.
		 */
		Quaternion.prototype.fromVectorToVector = function (from, to) {
			var a = from; //! AT: why this aliasing?
			var b = to;

			var factor = a.length() * b.length();
			if (Math.abs(factor) > MathUtils.EPSILON) {
				// Vectors have length > 0
				var dot = a.dot(b) / factor;
				var theta = Math.acos(Math.max(-1.0, Math.min(dot, 1.0)));
				pivotVector.copy(a).cross(b);
				if (dot < 0.0 && pivotVector.length() < MathUtils.EPSILON) {
					// Vectors parallel and opposite direction, therefore a rotation of 180 degrees about any vector
					// perpendicular to this vector will rotate vector a onto vector b.

					// The following guarantees the dot-product will be 0.0.
					var dominantIndex;
					if (Math.abs(a.x) > Math.abs(a.y)) {
						if (Math.abs(a.x) > Math.abs(a.z)) {
							dominantIndex = 0;
						} else {
							dominantIndex = 2;
						}
					} else {
						if (Math.abs(a.y) > Math.abs(a.z)) {
							dominantIndex = 1;
						} else {
							dominantIndex = 2;
						}
					}
					pivotVector.setValue(dominantIndex, -a[((dominantIndex + 1) % 3)]);
					pivotVector.setValue((dominantIndex + 1) % 3, a[dominantIndex]);
					pivotVector.setValue((dominantIndex + 2) % 3, 0.0);
				}
				return this.fromAngleAxis(theta, pivotVector);
			} else {
				return this.set(Quaternion.IDENTITY);
			}
		};
	})();

	(function () {
		var tmpStoreVector3 = new Vector3();
		/**
		 * Sets the values of this quaternion to the values represented by a given angle and axis of rotation.
		 * Note that this method creates an object, so use fromAngleNormalAxis if your axis is already normalized.
		 * If axis == (0, 0, 0) the quaternion is set to identity.
		 * @param {number} angle The angle to rotate (in radians).
		 * @param {Vector3} axis The axis of rotation.
		 * @returns {Quaternion} Self for chaining.
		 */
		Quaternion.prototype.fromAngleAxis = function (angle, axis) {
			tmpStoreVector3.copy(axis).normalize();
			return this.fromAngleNormalAxis(angle, tmpStoreVector3);
		};
	})();

	/**
	 * Sets the values of this quaternion to the values represented by a given angle and unit length axis of rotation.
	 * If axis == (0, 0, 0) the quaternion is set to identity.
	 * @param {number} angle The angle to rotate (in radians).
	 * @param {Vector3} axis The axis of rotation (already normalized - unit length).
	 * @returns {Quaternion} Self for chaining.
	 */
	Quaternion.prototype.fromAngleNormalAxis = function (angle, axis) {
		if (axis.equals(Vector3.ZERO)) {
			return this.set(Quaternion.IDENTITY);
		}

		var halfAngle = 0.5 * angle;
		var sin = Math.sin(halfAngle);
		var w = Math.cos(halfAngle);
		var x = sin * axis.x;
		var y = sin * axis.y;
		var z = sin * axis.z;
		return this.setDirect(x, y, z, w);
	};

	/**
	 * Returns the rotation angle represented by this quaternion. If a non-null vector is provided, the axis of rotation is stored in
	 *              that vector as well.
	 * @param {Vector3} axisStore The object to store the computed axis in. If null, no computations are done to determine axis.
	 * @returns {number} The angle of rotation in radians.
	 */
	Quaternion.prototype.toAngleAxis = function (axisStore) {
		var sqrLength = this.x * this.x + this.y * this.y + this.z * this.z;
		var angle;
		if (Math.abs(sqrLength) <= MathUtils.EPSILON) { // length is ~0
			angle = 0.0;
			if (axisStore !== null) {
				axisStore.x = 1.0;
				axisStore.y = 0.0;
				axisStore.z = 0.0;
			}
		} else {
			angle = 2.0 * Math.acos(this.w);
			if (axisStore !== null) {
				var invLength = 1.0 / Math.sqrt(sqrLength);
				axisStore.x = this.x * invLength;
				axisStore.y = this.y * invLength;
				axisStore.z = this.z * invLength;
			}
		}

		return angle;
	};

	/**
	 * Clones the quaternion
	 * @returns {Quaternion} Clone of self
	 */
	Quaternion.prototype.clone = function () {
		return new Quaternion(this.x, this.y, this.z, this.w);
	};

	/**
	 * Calculates the dot product between the current quaternion and another quaternion.
	 * @param rhs Quaternion on the right-hand side.
	 * @returns {number} The dot product.
	 */
	Quaternion.prototype.dot = function (q) {
		return this.x * q.x + this.y * q.y + this.z * q.z + this.w * q.w;
	};

	// @ifdef DEBUG
	Vector.addReturnChecks(Quaternion.prototype, [
		'dot', 'dotDirect',
		'length', 'lengthSquared',
		'distance', 'distanceSquared'
	]);
	// @endif

	/**
	 * Sets the vector's values from 4 numeric arguments
	 * @param {number} x
	 * @param {number} y
	 * @param {number} z
	 * @param {number} w
	 * @returns {Quaternion} Self to allow chaining
	 * @example
	 * var q = new Quaternion(); // q == (0, 0, 0, 0)
	 * q.setDirect(2, 4, 6, 8); // q == (2, 4, 6, 8)
	 */
	Quaternion.prototype.setDirect = function (x, y, z, w) {
		this.x = x;
		this.y = y;
		this.z = z;
		this.w = w;
		return this;
	};

	/**
	 * Set the quaternion components from an array (ordered x, y, z, w).
	 * @param {array} array
	 * @return {Quaternion} The self object.
	 */
	Quaternion.prototype.setArray = function (array) {
		this.x = array[0];
		this.y = array[1];
		this.z = array[2];
		this.w = array[3];
		return this;
	};


	// SHIM START

	Object.defineProperty(Quaternion.prototype, 'data', {
		get: ObjectUtils.warnOnce(
			'The .data property of Quaternion was removed. Please use the .x, .y, .z and .w properties instead.',
			function () {
				var data = [];
				var that = this;
				Object.defineProperties(data, {
					'0': {
						get: function () {
							return that.x;
						},
						set: function (value) {
							that.x = value;
						}
					},
					'1': {
						get: function () {
							return that.y;
						},
						set: function (value) {
							that.y = value;
						}
					},
					'2': {
						get: function () {
							return that.z;
						},
						set: function (value) {
							that.z = value;
						}
					},
					'3': {
						get: function () {
							return that.w;
						},
						set: function (value) {
							that.w = value;
						}
					}
				});
				return data;
			}
		)
	});

	/**
	 * @hidden
	 * @deprecated
	 */
	Quaternion.add = ObjectUtils.warnOnce(
		'Quaternion.add is deprecated.',
		function (lhs, rhs, target) {
			if (!target) {
				target = new Quaternion();
			}

			target.x = lhs.x + rhs.x;
			target.y = lhs.y + rhs.y;
			target.z = lhs.z + rhs.z;
			target.w = lhs.w + rhs.w;

			return target;
		}
	);

	/**
	 * @hidden
	 * @deprecated
	 */
	Quaternion.div = ObjectUtils.warnOnce(
		'Quaternion.div is deprecated',
		function (lhs, rhs, target) {
			if (!target) {
				target = new Quaternion();
			}

			var clean = true;

			target.x = (clean &= rhs.x < 0 || rhs.x > 0) ? lhs.x / rhs.x : 0;
			target.y = (clean &= rhs.y < 0 || rhs.y > 0) ? lhs.y / rhs.y : 0;
			target.z = (clean &= rhs.z < 0 || rhs.z > 0) ? lhs.z / rhs.z : 0;
			target.w = (clean &= rhs.w < 0 || rhs.w > 0) ? lhs.w / rhs.w : 0;

			return target;
		}
	);

	/**
	 * @hidden
	 * @deprecated
	 */
	Quaternion.mul = Quaternion.mul2 = ObjectUtils.warnOnce(
		'Quaternion.mul is deprecated.',
		function (a, b, out) {
			var ax = a.x, ay = a.y, az = a.z, aw = a.w,
				bx = b.x, by = b.y, bz = b.z, bw = b.w;

			out.x = ax * bw + aw * bx + ay * bz - az * by;
			out.y = ay * bw + aw * by + az * bx - ax * bz;
			out.z = az * bw + aw * bz + ax * by - ay * bx;
			out.w = aw * bw - ax * bx - ay * by - az * bz;
			return out;
		}
	);

	/**
	 * @hidden
	 * @deprecated
	 */
	Quaternion.sub = ObjectUtils.warnOnce(
		'Quaternion.sub is deprecated.',
		function (lhs, rhs, target) {
			if (!target) {
				target = new Quaternion();
			}

			target.x = lhs.x - rhs.x;
			target.y = lhs.y - rhs.y;
			target.z = lhs.z - rhs.z;
			target.w = lhs.w - rhs.w;

			return target;
		}
	);

	/**
	 * @hidden
	 * @deprecated
	 */
	Quaternion.prototype.add = ObjectUtils.warnOnce(
		'Quaternion.prototype.add is deprecated.',
		function (rhs) {
			return Quaternion.add(this, rhs, this);
		}
	);

	/**
	 * @hidden
	 * @deprecated
	 */
	Quaternion.prototype.div = ObjectUtils.warnOnce(
		'Quaternion.prototype.div is deprecated.',
		function (rhs) {
			return Quaternion.div(this, rhs, this);
		}
	);

	/**
	 * @hidden
	 * @deprecated
	 */
	Quaternion.prototype.magnitude = ObjectUtils.warnOnce(
		'Quaternion.prototype.magnitude is deprecated.',
		function () {
			var magnitudeSQ = this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
			if (magnitudeSQ === 1.0) {
				return 1.0;
			}
			return Math.sqrt(magnitudeSQ);
		}
	);

	/**
	 * @hidden
	 * @deprecated
	 */
	Quaternion.prototype.magnitudeSquared = ObjectUtils.warnOnce(
		'Quaternion.prototype.magnitudeSquared is deprecated.',
		function () {
			return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
		}
	);

	/**
	 * @hidden
	 * @deprecated
	 */
	Quaternion.scalarAdd = ObjectUtils.warnOnce(
		'Quaternion.prototype.scalarAdd is deprecated.',
		function (lhs, rhs, target) {
			if (!target) {
				target = new Quaternion();
			}

			target.x = lhs.x + rhs;
			target.y = lhs.y + rhs;
			target.z = lhs.z + rhs;
			target.w = lhs.w + rhs;

			return target;
		}
	);

	/**
	 * @hidden
	 * @deprecated
	 */
	Quaternion.scalarDiv = ObjectUtils.warnOnce(
		'Quaternion.scalarDiv is deprecated.',
		function (lhs, rhs, target) {
			if (!target) {
				target = new Quaternion();
			}

			var clean = true;

			rhs = (clean &= rhs < 0.0 || rhs > 0.0) ? 1.0 / rhs : 0.0;

			target.x = lhs.x * rhs;
			target.y = lhs.y * rhs;
			target.z = lhs.z * rhs;
			target.w = lhs.w * rhs;

			return target;
		}
	);

	/**
	 * @hidden
	 * @deprecated
	 */
	Quaternion.scalarMul = ObjectUtils.warnOnce(
		'Quaternion.scalarMul is deprecated.',
		function (lhs, rhs, target) {
			if (!target) {
				target = new Quaternion();
			}

			target.x = lhs.x * rhs;
			target.y = lhs.y * rhs;
			target.z = lhs.z * rhs;
			target.w = lhs.w * rhs;

			return target;
		}
	);

	/**
	 * @hidden
	 * @deprecated
	 */
	Quaternion.scalarSub = ObjectUtils.warnOnce(
		'Quaternion.scalarSub is deprecated.',
		function (lhs, rhs, target) {
			if (!target) {
				target = new Quaternion();
			}

			target.x = lhs.x - rhs;
			target.y = lhs.y - rhs;
			target.z = lhs.z - rhs;
			target.w = lhs.w - rhs;

			return target;
		}
	);

	/**
	 * @hidden
	 * @deprecated
	 */
	Quaternion.prototype.setVector = ObjectUtils.warnOnce(
		'Quaternion.prototype.setVector is deprecated.',
		function (quat) {
			this.x = quat.x;
			this.y = quat.y;
			this.z = quat.z;
			this.w = quat.w;

			return this;
		}
	);

	/**
	 * @hidden
	 * @deprecated
	 */
	Quaternion.prototype.sub = ObjectUtils.warnOnce(
		'Quaternion.prototype.sub is deprecated.',
		function (rhs) {
			return Quaternion.sub(this, rhs, this);
		}
	);

	/**
	 * @hidden
	 * @deprecated
	 */
	Quaternion.prototype.scalarAdd = ObjectUtils.warnOnce(
		'Quaternion.prototype.scalarAdd is deprecated.',
		function (rhs) {
			return Quaternion.scalarAdd(this, rhs, this);
		}
	);

	/**
	 * @hidden
	 * @deprecated
	 */
	Quaternion.prototype.scalarSub = ObjectUtils.warnOnce(
		'Quaternion.prototype.scalarSub is deprecated.',
		function (rhs) {
			return Quaternion.scalarSub(this, rhs, this);
		}
	);

	/**
	 * @hidden
	 * @deprecated
	 */
	Quaternion.prototype.scalarMul = ObjectUtils.warnOnce(
		'Quaternion.prototype.scalarMul is deprecated.',
		function (rhs) {
			return Quaternion.scalarMul(this, rhs, this);
		}
	);

	/**
	 * @hidden
	 * @deprecated
	 */
	Quaternion.prototype.scalarDiv = ObjectUtils.warnOnce(
		'Quaternion.prototype.scalarDiv is deprecated.',
		function (rhs) {
			return Quaternion.scalarDiv(this, rhs, this);
		}
	);

	// SHIM END
	module.exports = Quaternion;


/***/ },
/* 24 */
/***/ function(module, exports, __webpack_require__) {

	var MathUtils = __webpack_require__(9);
	var Matrix = __webpack_require__(25);
	var Vector3 = __webpack_require__(8);
	var ObjectUtils = __webpack_require__(6);

	/**
	 * Matrix with 3x3 components. Used to store 3D rotations. It also contains common 3D Rotation operations.
	 * Creates a new Matrix3 by passing in either a current Matrix3, number Array, or a set of 9 numbers.
	 * @extends Matrix
	 * @param {(Matrix3|Array<number>|...number)} arguments Initial values for the components.
	 * @example
	 * // Passing in no arguments
	 * var m1 = new Matrix3(); // m1 == (1, 0, 0, 0, 1, 0, 0, 0, 1)
	 *
	 * // Passing in a number Array
	 * var m2 = new Matrix3([1, 0, 0, 0, 1, 0, 0, 0, 1]);
	 *
	 * // Passing in numbers
	 * var m3 = new Matrix3(1, 0, 0, 0, 1, 0, 0, 0, 1);
	 *
	 * // Passing in an existing Matrix3
	 * var m4 = new Matrix3(m1); // m4 == (1, 0, 0, 0, 1, 0, 0, 0, 1)
	 */
	function Matrix3() {
		Matrix.call(this, 3, 3);

		if (arguments.length === 0) {
			this.data[0] = 1;
			this.data[4] = 1;
			this.data[8] = 1;
		} else if (arguments.length === 1 && typeof arguments[0] === 'object') {
			if (arguments[0] instanceof Matrix3) {
				this.copy(arguments[0]);
			} else {
				this.setArray(arguments[0]);
			}
		} else {
			for (var i = 0; i < arguments.length; i++) {
				this.data[i] = arguments[i];
			}
		}

		// @ifdef DEBUG
		Object.seal(this);
		// @endif
	}

	Matrix3._tempX = new Vector3();
	Matrix3._tempY = new Vector3();
	Matrix3._tempZ = new Vector3();

	Matrix3.prototype = Object.create(Matrix.prototype);
	Matrix3.prototype.constructor = Matrix3;

	Matrix.setupAliases(Matrix3.prototype, [['e00'], ['e10'], ['e20'], ['e01'], ['e11'], ['e21'], ['e02'], ['e12'], ['e22']]);

	/** @type {Matrix3} */
	Matrix3.IDENTITY = new Matrix3(1, 0, 0, 0, 1, 0, 0, 0, 1);

	/**
	 * Performs a component-wise addition.
	 * @param {Matrix3} rhs Matrix or scalar on the right-hand side.
	 * @returns {Matrix3} Self to allow chaining
	 */
	Matrix3.prototype.add = function (rhs) {
		var thisData = this.data;
		var rhsData = rhs.data;

		thisData[0] += rhsData[0];
		thisData[1] += rhsData[1];
		thisData[2] += rhsData[2];
		thisData[3] += rhsData[3];
		thisData[4] += rhsData[4];
		thisData[5] += rhsData[5];
		thisData[6] += rhsData[6];
		thisData[7] += rhsData[7];
		thisData[8] += rhsData[8];

		return this;
	};

	/**
	 * Performs a component-wise subtraction.
	 * @param {Matrix3} rhs Matrix or scalar on the right-hand side.
	 * @returns {Matrix3} Self to allow chaining
	 */
	Matrix3.prototype.sub = function (rhs) {
		var thisData = this.data;
		var rhsData = rhs.data;

		thisData[0] -= rhsData[0];
		thisData[1] -= rhsData[1];
		thisData[2] -= rhsData[2];
		thisData[3] -= rhsData[3];
		thisData[4] -= rhsData[4];
		thisData[5] -= rhsData[5];
		thisData[6] -= rhsData[6];
		thisData[7] -= rhsData[7];
		thisData[8] -= rhsData[8];

		return this;
	};

	/**
	 * Multiplies this matrix with a scalar
	 * @param {number} scalar
	 * @returns {Matrix3} Self to allow chaining
	 */
	Matrix3.prototype.scale = function (scalar) {
		var data = this.data;

		data[0] *= scalar;
		data[1] *= scalar;
		data[2] *= scalar;
		data[3] *= scalar;
		data[4] *= scalar;
		data[5] *= scalar;
		data[6] *= scalar;
		data[7] *= scalar;
		data[8] *= scalar;

		return this;
	};

	/**
	 * Multiplies this matrix with another matrix
	 * @param {Matrix3} rhs Matrix on the left-hand side
	 * @returns {Matrix3} Self to allow chaining
	 */
	Matrix3.prototype.mul = function (rhs) {
		var s1d = rhs.data;
		var m00 = s1d[0], m01 = s1d[3], m02 = s1d[6],
			m10 = s1d[1], m11 = s1d[4], m12 = s1d[7],
			m20 = s1d[2], m21 = s1d[5], m22 = s1d[8];

		var s2d = this.data;
		var n00 = s2d[0], n01 = s2d[3], n02 = s2d[6],
			n10 = s2d[1], n11 = s2d[4], n12 = s2d[7],
			n20 = s2d[2], n21 = s2d[5], n22 = s2d[8];

		var rd = this.data;
		rd[0] = m00 * n00 + m01 * n10 + m02 * n20;
		rd[3] = m00 * n01 + m01 * n11 + m02 * n21;
		rd[6] = m00 * n02 + m01 * n12 + m02 * n22;

		rd[1] = m10 * n00 + m11 * n10 + m12 * n20;
		rd[4] = m10 * n01 + m11 * n11 + m12 * n21;
		rd[7] = m10 * n02 + m11 * n12 + m12 * n22;

		rd[2] = m20 * n00 + m21 * n10 + m22 * n20;
		rd[5] = m20 * n01 + m21 * n11 + m22 * n21;
		rd[8] = m20 * n02 + m21 * n12 + m22 * n22;

		return this;
	};

	/**
	 * Multiplies two matrices and stores the result in this matrix
	 * @param {Matrix3} lhs Matrix on the left-hand side
	 * @param {Matrix3} rhs Matrix on the right-hand side
	 * @returns {Matrix3} Self to allow chaining
	 */
	Matrix3.prototype.mul2 = function (lhs, rhs) {
		var s1d = lhs.data;
		var m00 = s1d[0], m01 = s1d[3], m02 = s1d[6],
			m10 = s1d[1], m11 = s1d[4], m12 = s1d[7],
			m20 = s1d[2], m21 = s1d[5], m22 = s1d[8];
		var s2d = rhs.data;
		var n00 = s2d[0], n01 = s2d[3], n02 = s2d[6],
			n10 = s2d[1], n11 = s2d[4], n12 = s2d[7],
			n20 = s2d[2], n21 = s2d[5], n22 = s2d[8];

		var rd = this.data;
		rd[0] = m00 * n00 + m01 * n10 + m02 * n20;
		rd[3] = m00 * n01 + m01 * n11 + m02 * n21;
		rd[6] = m00 * n02 + m01 * n12 + m02 * n22;

		rd[1] = m10 * n00 + m11 * n10 + m12 * n20;
		rd[4] = m10 * n01 + m11 * n11 + m12 * n21;
		rd[7] = m10 * n02 + m11 * n12 + m12 * n22;

		rd[2] = m20 * n00 + m21 * n10 + m22 * n20;
		rd[5] = m20 * n01 + m21 * n11 + m22 * n21;
		rd[8] = m20 * n02 + m21 * n12 + m22 * n22;

		return this;
	};

	/**
	 * Transposes a matrix (exchanges rows and columns) and stores the result in a separate matrix.
	 * @returns {Matrix3} A new matrix if the target matrix is omitted, else the target matrix.
	 */
	Matrix3.prototype.transpose = function () {
		var data = this.data;

		var e01 = data[3];
		var e02 = data[6];
		var e12 = data[7];

		data[3] = data[1];
		data[6] = data[2];
		data[7] = data[5];

		data[1] = e01;
		data[2] = e02;
		data[5] = e12;

		return this;
	};

	/**
	 * Computes the analytical inverse and stores the result in a separate matrix.
	 * @param {Matrix3} source Source matrix.
	 * @param {Matrix3} [target] Target matrix.
	 * @returns {Matrix3} A new matrix if the target matrix is omitted, else the target matrix.
	 */
	Matrix3.invert = function (source, target) {
		if (!target) {
			target = new Matrix3();
		}

		if (target === source) {
			return target.copy(Matrix3.invert(source));
		}

		var det = source.determinant();

		if (Math.abs(det) < MathUtils.EPSILON) {
			return target;
		}

		det = 1.0 / det;
		var td = target.data, sd = source.data;

		td[0] = (sd[4] * sd[8] - sd[7] * sd[5]) * det;
		td[1] = (sd[7] * sd[2] - sd[1] * sd[8]) * det;
		td[2] = (sd[1] * sd[5] - sd[4] * sd[2]) * det;

		td[3] = (sd[6] * sd[5] - sd[3] * sd[8]) * det;
		td[4] = (sd[0] * sd[8] - sd[6] * sd[2]) * det;
		td[5] = (sd[3] * sd[2] - sd[0] * sd[5]) * det;

		td[6] = (sd[3] * sd[7] - sd[6] * sd[4]) * det;
		td[7] = (sd[6] * sd[1] - sd[0] * sd[7]) * det;
		td[8] = (sd[0] * sd[4] - sd[3] * sd[1]) * det;

		return target;
	};

	/**
	 * Computes the analytical inverse and stores the result locally.
	 * @returns {Matrix3} Self for chaining.
	 */
	Matrix3.prototype.invert = function () {
		return Matrix3.invert(this, this);
	};

	/**
	 * Tests if the matrix is orthogonal.
	 * @returns {Boolean} True if orthogonal.
	 */
	Matrix3.prototype.isOrthogonal = function () {
		var d = this.data;

		var dot = d[0] * d[3] + d[1] * d[4] + d[2] * d[5];

		if (Math.abs(dot) > MathUtils.EPSILON) {
			return false;
		}

		dot = d[0] * d[6] + d[1] * d[7] + d[2] * d[8];

		if (Math.abs(dot) > MathUtils.EPSILON) {
			return false;
		}

		dot = d[3] * d[6] + d[4] * d[7] + d[5] * d[8];

		if (Math.abs(dot) > MathUtils.EPSILON) {
			return false;
		}

		return true;
	};

	/**
	 * Tests if the matrix is normal.
	 * @returns {boolean} True if normal.
	 */
	Matrix3.prototype.isNormal = function () {
		var d = this.data;

		var l = d[0] * d[0] + d[1] * d[1] + d[2] * d[2];

		if (Math.abs(l - 1.0) > MathUtils.EPSILON) {
			return false;
		}

		l = d[3] * d[3] + d[4] * d[4] + d[5] * d[5];

		if (Math.abs(l - 1.0) > MathUtils.EPSILON) {
			return false;
		}

		l = d[6] * d[6] + d[7] * d[7] + d[8] * d[8];

		if (Math.abs(l - 1.0) > MathUtils.EPSILON) {
			return false;
		}

		return true;
	};

	/**
	 * Tests if the matrix is orthonormal.
	 * @returns {boolean} True if orthonormal.
	 */
	Matrix3.prototype.isOrthonormal = function () {
		return this.isOrthogonal() && this.isNormal();
	};

	/**
	 * Computes the determinant of the matrix.
	 * @returns {number} Determinant of matrix.
	 */
	Matrix3.prototype.determinant = function () {
		var d = this.data;
		return d[0] * (d[4] * d[8] - d[7] * d[5]) -
			d[3] * (d[1] * d[8] - d[7] * d[2]) +
			d[6] * (d[1] * d[5] - d[4] * d[2]);
	};

	/**
	 * Sets the matrix to identity: (1, 0, 0, 0, 1, 0, 0, 0, 1).
	 * @returns {Matrix3} Self for chaining.
	 */
	Matrix3.prototype.setIdentity = function () {
		var d = this.data;

		d[0] = 1;
		d[1] = 0;
		d[2] = 0;

		d[3] = 0;
		d[4] = 1;
		d[5] = 0;

		d[6] = 0;
		d[7] = 0;
		d[8] = 1;

		return this;
	};

	// unused
	/**
	 * Post-multiplies the matrix ("before") with a scaling vector.
	 * @param {Vector3} vec Vector on the right-hand side.
	 * @param {Matrix3} result Storage matrix.
	 * @returns {Matrix3} Storage matrix.
	 */
	Matrix3.prototype.multiplyDiagonalPost = function (vec, result) {
		var x = vec.x;
		var y = vec.y;
		var z = vec.z;

		var d = this.data;
		var r = result.data;
		r[0] = x * d[0];
		r[1] = x * d[1];
		r[2] = x * d[2];
		r[3] = y * d[3];
		r[4] = y * d[4];
		r[5] = y * d[5];
		r[6] = z * d[6];
		r[7] = z * d[7];
		r[8] = z * d[8];

		return result;
	};

	/**
	 * Sets the Matrix3 from rotational angles in radians.
	 * @param {number} pitch Pitch (X axis) angle in radians.
	 * @param {number} yaw Yaw (Y axis) angle in radians.
	 * @param {number} roll Roll (Z axis) angle in radians.
	 * @returns {Matrix3} Self for chaining.
	 * @example
	 * // sets the rotation to Math.PI (180 degrees) on the Y axis
	 * entity.transformComponent.transform.rotation.fromAngles(0, Math.PI, 0);
	 */
	Matrix3.prototype.fromAngles = function (pitch, yaw, roll) {
		var cy = Math.cos(pitch);
		var sy = Math.sin(pitch);
		var ch = Math.cos(yaw);
		var sh = Math.sin(yaw);
		var cp = Math.cos(roll);
		var sp = Math.sin(roll);

		var d = this.data;
		d[0] = ch * cp;
		d[3] = sh * sy - ch * sp * cy;
		d[6] = ch * sp * sy + sh * cy;
		d[1] = sp;
		d[4] = cp * cy;
		d[7] = -cp * sy;
		d[2] = -sh * cp;
		d[5] = sh * sp * cy + ch * sy;
		d[8] = -sh * sp * sy + ch * cy;

		return this;
	};

	/**
	 * Rotates a Matrix3 by the given angle in radians, around the X axis.
	 *
	 * @param {number} rad the angle in radians to rotate the Matrix3 by.
	 * @param {Matrix3} [store] the target Matrix3 to store the result or 'this', if undefined.
	 * @returns {Matrix3} store
	 * @example
	 * // rotates the entity on the X axis, by the amount of time per frame (tpf)
	 * entity.transformComponent.transform.rotation.rotateX(goo.world.tpf);
	 */
	Matrix3.prototype.rotateX = function (rad, store) {
		store = store || this;
		var a = this.data;
		var out = store.data;

		var s = Math.sin(rad),
			c = Math.cos(rad),
			a10 = a[3],
			a11 = a[4],
			a12 = a[5],
			a20 = a[6],
			a21 = a[7],
			a22 = a[8];

		if (a !== out) { // If the source and destination differ, copy the unchanged rows
			out[0] = a[0];
			out[1] = a[1];
			out[2] = a[2];
		}

		// Perform axis-specific matrix multiplication
		out[3] = a10 * c + a20 * s;
		out[4] = a11 * c + a21 * s;
		out[5] = a12 * c + a22 * s;
		out[6] = a20 * c - a10 * s;
		out[7] = a21 * c - a11 * s;
		out[8] = a22 * c - a12 * s;

		return store;
	};

	/**
	 * Rotates a Matrix3 by the given angle in radians, around the Y axis.
	 *
	 * @param {number} rad the angle in radians to rotate the Matrix3 by.
	 * @param {Matrix3} [store] the target Matrix3 to store the result or 'this', if undefined.
	 * @returns {Matrix3} store
	 * @example
	 * // rotates the entity on the Y axis, by Math.PI * 0.5 (90 degrees)
	 * entity.transformComponent.transform.rotation.rotateY(Math.PI * 0.5);
	 */
	Matrix3.prototype.rotateY = function (rad, store) {
		store = store || this;
		var a = this.data;
		var out = store.data;

		var s = Math.sin(rad),
			c = Math.cos(rad),
			a00 = a[0],
			a01 = a[1],
			a02 = a[2],
			a20 = a[6],
			a21 = a[7],
			a22 = a[8];

		if (a !== out) { // If the source and destination differ, copy the unchanged rows
			out[3] = a[3];
			out[4] = a[4];
			out[5] = a[5];
		}

		// Perform axis-specific matrix multiplication
		out[0] = a00 * c - a20 * s;
		out[1] = a01 * c - a21 * s;
		out[2] = a02 * c - a22 * s;
		out[6] = a00 * s + a20 * c;
		out[7] = a01 * s + a21 * c;
		out[8] = a02 * s + a22 * c;

		return store;
	};

	/**
	 * Rotates a Matrix3 by the given angle in radians, around the Z axis.
	 *
	 * @param {number} rad the angle in radians to rotate the Matrix3 by.
	 * @param {Matrix3} [store] the target Matrix3 to store the result or 'this', if undefined.
	 * @returns {Matrix3} store
	 * @example
	 * // rotates the entity on the Z axis, by 3.14 (180 degrees)
	 * entity.transformComponent.transform.rotation.rotateZ(3.14);
	 */
	Matrix3.prototype.rotateZ = function (rad, store) {
		store = store || this;
		var a = this.data;
		var out = store.data;

		var s = Math.sin(rad),
			c = Math.cos(rad),
			a00 = a[0],
			a01 = a[1],
			a02 = a[2],
			a10 = a[3],
			a11 = a[4],
			a12 = a[5];

		if (a !== out) { // If the source and destination differ, copy the unchanged last row
			out[6] = a[6];
			out[7] = a[7];
			out[8] = a[8];
		}

		// Perform axis-specific matrix multiplication
		out[0] = a00 * c + a10 * s;
		out[1] = a01 * c + a11 * s;
		out[2] = a02 * c + a12 * s;
		out[3] = a10 * c - a00 * s;
		out[4] = a11 * c - a01 * s;
		out[5] = a12 * c - a02 * s;

		return store;
	};

	/**
	 * Converts the current Matrix3 to Euler rotation angles in radians: (X axis, Y axis, Z axis)
	 * @param {Vector3} Vector3 to store the computed angles in (or undefined to create a new one).
	 * @returns {Vector3} Result
	 * @example
	 * // Not passing in a Vector3 to store the result, one is created and returned
	 * var rot = entity.transformComponent.transform.rotation.toAngles();
	 *
	 * // Passing in an existing Vector3 to store the result
	 * var angles = new Vector3();
	 * entity.transformComponent.transform.rotation.toAngles(angles);
	 */
	Matrix3.prototype.toAngles = function (store) {
		var result = store;
		if (!result) {
			result = new Vector3();
		}

		var d = this.data;
		if (d[3] > 1 - MathUtils.EPSILON) { // singularity at north pole
			result.y = Math.atan2(d[2], d[8]);
			result.z = Math.PI / 2;
			result.x = 0;
		} else if (d[3] < -1 + MathUtils.EPSILON) { // singularity at south pole
			result.y = Math.atan2(d[2], d[8]);
			result.z = -Math.PI / 2;
			result.x = 0;
		} else {
			result.y = Math.atan2(-d[2], d[0]);
			result.x = Math.atan2(-d[7], d[4]);
			result.z = Math.asin(d[1]);
		}

		return result;
	};

	/**
	 * Sets this matrix to the rotation indicated by the given angle and a unit-length axis of rotation.
	 * @param {number} angle the angle to rotate (in radians).
	 * @param {number} x
	 * @param {number} y
	 * @param {number} z
	 * @returns {Matrix3} this for chaining
	 */
	Matrix3.prototype.fromAngleNormalAxis = function (angle, x, y, z) {
		var fCos = Math.cos(angle);
		var fSin = Math.sin(angle);
		var fOneMinusCos = 1.0 - fCos;
		var fX2 = x * x;
		var fY2 = y * y;
		var fZ2 = z * z;
		var fXYM = x * y * fOneMinusCos;
		var fXZM = x * z * fOneMinusCos;
		var fYZM = y * z * fOneMinusCos;
		var fXSin = x * fSin;
		var fYSin = y * fSin;
		var fZSin = z * fSin;

		var d = this.data;
		d[0] = fX2 * fOneMinusCos + fCos;
		d[3] = fXYM - fZSin;
		d[6] = fXZM + fYSin;
		d[1] = fXYM + fZSin;
		d[4] = fY2 * fOneMinusCos + fCos;
		d[7] = fYZM - fXSin;
		d[2] = fXZM - fYSin;
		d[5] = fYZM + fXSin;
		d[8] = fZ2 * fOneMinusCos + fCos;

		return this;
	};

	/**
	 * Sets the Matrix3 to look in a specific direction.
	 * @param {Vector3} direction Direction vector.
	 * @param {Vector3} up Up vector.
	 * @returns {Matrix3} Self for chaining.
	 * @example
	 * // get the direction from the current entity to the 'other' entity
	 * var direction = Vector3.sub(other.transformComponent.transform.translation, entity.transformComponent.transform.translation);
	 * // pass in the direction, and use Vector3.UNIT_Y as 'up'
	 * entity.lookAt(direction, Vector3.UNIT_Y);
	 * // update the transform component with the new rotation
	 * entity.transformComponent.setUpdated();
	 */
	Matrix3.prototype.lookAt = function (direction, up) {
		var x = Matrix3._tempX, y = Matrix3._tempY, z = Matrix3._tempZ;

		z.set(direction).normalize().scale(-1);

		x.set(up).cross(z).normalize();

		if (x.equals(Vector3.ZERO)) {
			if (z.x !== 0.0) {
				x.setDirect(z.y, -z.x, 0);
			} else {
				x.setDirect(0, z.z, -z.y);
			}
		}

		y.set(z).cross(x);

		var d = this.data;
		d[0] = x.x;
		d[1] = x.y;
		d[2] = x.z;
		d[3] = y.x;
		d[4] = y.y;
		d[5] = y.z;
		d[6] = z.x;
		d[7] = z.y;
		d[8] = z.z;

		return this;
	};

	/**
	 * Sets the matrix from a quaternion.
	 * @param {Quaternion} quaternion Rotational quaternion.
	 * @returns {Matrix3} Self for chaining.
	 */
	Matrix3.prototype.copyQuaternion = function (quaternion) {
		return quaternion.toRotationMatrix(this);
	};

	/**
	 * Compares two matrices for approximate equality
	 * @param {Matrix3} rhs The matrix to compare against
	 * @returns {boolean}
	 */
	Matrix3.prototype.equals = function (rhs) {
		var thisData = this.data;
		var rhsData = rhs.data;

		return (Math.abs(thisData[0] - rhsData[0]) <= MathUtils.EPSILON) &&
			(Math.abs(thisData[1] - rhsData[1]) <= MathUtils.EPSILON) &&
			(Math.abs(thisData[2] - rhsData[2]) <= MathUtils.EPSILON) &&
			(Math.abs(thisData[3] - rhsData[3]) <= MathUtils.EPSILON) &&
			(Math.abs(thisData[4] - rhsData[4]) <= MathUtils.EPSILON) &&
			(Math.abs(thisData[5] - rhsData[5]) <= MathUtils.EPSILON) &&
			(Math.abs(thisData[6] - rhsData[6]) <= MathUtils.EPSILON) &&
			(Math.abs(thisData[7] - rhsData[7]) <= MathUtils.EPSILON) &&
			(Math.abs(thisData[8] - rhsData[8]) <= MathUtils.EPSILON);
	};

	/**
	 * Copies component values and stores them locally.
	 * @param {Matrix3} rhs Source matrix.
	 * @returns {Matrix3} Self for chaining.
	 */
	Matrix3.prototype.copy = function (rhs) {
		var thisData = this.data;
		var rhsData = rhs.data;

		thisData[0] = rhsData[0];
		thisData[1] = rhsData[1];
		thisData[2] = rhsData[2];
		thisData[3] = rhsData[3];
		thisData[4] = rhsData[4];
		thisData[5] = rhsData[5];
		thisData[6] = rhsData[6];
		thisData[7] = rhsData[7];
		thisData[8] = rhsData[8];

		return this;
	};

	/**
	 * Copies component values from the upper-left submatrix of a Matrix4.
	 * @param {Matrix4} rhs Source matrix.
	 * @returns {Matrix3} Self for chaining.
	 */
	Matrix3.prototype.copyMatrix4 = function (rhs) {
		var thisData = this.data;
		var rhsData = rhs.data;

		thisData[0] = rhsData[0];
		thisData[1] = rhsData[1];
		thisData[2] = rhsData[2];
		thisData[3] = rhsData[4];
		thisData[4] = rhsData[5];
		thisData[5] = rhsData[6];
		thisData[6] = rhsData[8];
		thisData[7] = rhsData[9];
		thisData[8] = rhsData[10];

		return this;
	};

	/**
	 * Sets matrix values from an array.
	 * @param {Array<number>} rhsData Array source
	 * @returns {Matrix3} Self for chaining.
	 */
	Matrix3.prototype.setArray = function (rhsData) {
		var thisData = this.data;

		thisData[0] = rhsData[0];
		thisData[1] = rhsData[1];
		thisData[2] = rhsData[2];
		thisData[3] = rhsData[3];
		thisData[4] = rhsData[4];
		thisData[5] = rhsData[5];
		thisData[6] = rhsData[6];
		thisData[7] = rhsData[7];
		thisData[8] = rhsData[8];

		return this;
	};

	/**
	 * Sets the matrix's values from another matrix's values; an alias for .copy
	 * @param {Matrix3} source Source matrix
	 * @returns {Matrix3} Self to allow chaining
	 */
	Matrix3.prototype.set = Matrix3.prototype.copy;

	/**
	 * Returns a new matrix with the same values as the existing one.
	 * @returns {Matrix3} The new matrix.
	 */
	Matrix3.prototype.clone = function () {
		return new Matrix3().copy(this);
	};


	// SHIM START

	/**
	 * @hidden
	 * @deprecated
	 */
	Matrix3.add = ObjectUtils.warnOnce(
		'Matrix3.add is deprecated - use Matrix3.prototype.add instead.',
		function (lhs, rhs, target) {
			if (!target) {
				target = new Matrix3();
			}

			var td = target.data, ld = lhs.data;
			if (rhs instanceof Matrix3) {
				var rd = rhs.data;
				td[0] = ld[0] + rd[0];
				td[1] = ld[1] + rd[1];
				td[2] = ld[2] + rd[2];
				td[3] = ld[3] + rd[3];
				td[4] = ld[4] + rd[4];
				td[5] = ld[5] + rd[5];
				td[6] = ld[6] + rd[6];
				td[7] = ld[7] + rd[7];
				td[8] = ld[8] + rd[8];
			} else {
				td[0] = ld[0] + rhs;
				td[1] = ld[1] + rhs;
				td[2] = ld[2] + rhs;
				td[3] = ld[3] + rhs;
				td[4] = ld[4] + rhs;
				td[5] = ld[5] + rhs;
				td[6] = ld[6] + rhs;
				td[7] = ld[7] + rhs;
				td[8] = ld[8] + rhs;
			}

			return target;
		}
	);

	/**
	 * @hidden
	 * @deprecated
	 */
	Matrix3.sub = ObjectUtils.warnOnce(
		'Matrix3.sub is deprecated - use Matrix3.prototype.sub instead.',
		function (lhs, rhs, target) {
			if (!target) {
				target = new Matrix3();
			}

			var td = target.data, ld = lhs.data;
			if (rhs instanceof Matrix3) {
				var rd = rhs.data;
				td[0] = ld[0] - rd[0];
				td[1] = ld[1] - rd[1];
				td[2] = ld[2] - rd[2];
				td[3] = ld[3] - rd[3];
				td[4] = ld[4] - rd[4];
				td[5] = ld[5] - rd[5];
				td[6] = ld[6] - rd[6];
				td[7] = ld[7] - rd[7];
				td[8] = ld[8] - rd[8];
			} else {
				td[0] = ld[0] - rhs;
				td[1] = ld[1] - rhs;
				td[2] = ld[2] - rhs;
				td[3] = ld[3] - rhs;
				td[4] = ld[4] - rhs;
				td[5] = ld[5] - rhs;
				td[6] = ld[6] - rhs;
				td[7] = ld[7] - rhs;
				td[8] = ld[8] - rhs;
			}

			return target;
		}
	);
	/**
	 * @hidden
	 * @deprecated
	 */
	Matrix3.mul = ObjectUtils.warnOnce(
		'Matrix3.mul is deprecated - use Matrix3.prototype.mul instead.',
		function (lhs, rhs, target) {
			if (!target) {
				target = new Matrix3();
			}

			var td = target.data, ld = lhs.data;
			if (rhs instanceof Matrix3) {
				var rd = rhs.data;
				td[0] = ld[0] * rd[0];
				td[1] = ld[1] * rd[1];
				td[2] = ld[2] * rd[2];
				td[3] = ld[3] * rd[3];
				td[4] = ld[4] * rd[4];
				td[5] = ld[5] * rd[5];
				td[6] = ld[6] * rd[6];
				td[7] = ld[7] * rd[7];
				td[8] = ld[8] * rd[8];
			} else {
				td[0] = ld[0] * rhs;
				td[1] = ld[1] * rhs;
				td[2] = ld[2] * rhs;
				td[3] = ld[3] * rhs;
				td[4] = ld[4] * rhs;
				td[5] = ld[5] * rhs;
				td[6] = ld[6] * rhs;
				td[7] = ld[7] * rhs;
				td[8] = ld[8] * rhs;
			}

			return target;
		}
	);

	/**
	 * @hidden
	 * @deprecated
	 */
	Matrix3.div = ObjectUtils.warnOnce(
		'Matrix3.div is deprecated - use Matrix3.prototype.div instead.',
		function (lhs, rhs, target) {
			if (!target) {
				target = new Matrix3();
			}

			var td = target.data, ld = lhs.data;
			if (rhs instanceof Matrix3) {
				var rd = rhs.data;
				td[0] = ld[0] / rd[0];
				td[1] = ld[1] / rd[1];
				td[2] = ld[2] / rd[2];
				td[3] = ld[3] / rd[3];
				td[4] = ld[4] / rd[4];
				td[5] = ld[5] / rd[5];
				td[6] = ld[6] / rd[6];
				td[7] = ld[7] / rd[7];
				td[8] = ld[8] / rd[8];
			} else {
				td[0] = ld[0] / rhs;
				td[1] = ld[1] / rhs;
				td[2] = ld[2] / rhs;
				td[3] = ld[3] / rhs;
				td[4] = ld[4] / rhs;
				td[5] = ld[5] / rhs;
				td[6] = ld[6] / rhs;
				td[7] = ld[7] / rhs;
				td[8] = ld[8] / rhs;
			}

			return target;
		}
	);

	/**
	 * @hidden
	 * @deprecated
	 */
	Matrix3.prototype.div = ObjectUtils.warnOnce(
		'Matrix3.prototype.div is deprecated.',
		function (rhs) {
			return Matrix3.div(this, rhs, this);
		}
	);

	/**
	 * @hidden
	 * @deprecated
	 */
	Matrix3.combine = ObjectUtils.warnOnce(
		'Matrix3.combine is deprecated - use Matrix3.prototype.mul or .mul2 instead.',
		function (lhs, rhs, target) {
			if (!target) {
				target = new Matrix3();
			}

			var s1d = lhs.data;
			var m00 = s1d[0], m01 = s1d[3], m02 = s1d[6],
				m10 = s1d[1], m11 = s1d[4], m12 = s1d[7],
				m20 = s1d[2], m21 = s1d[5], m22 = s1d[8];
			var s2d = rhs.data;
			var n00 = s2d[0], n01 = s2d[3], n02 = s2d[6],
				n10 = s2d[1], n11 = s2d[4], n12 = s2d[7],
				n20 = s2d[2], n21 = s2d[5], n22 = s2d[8];

			var rd = target.data;
			rd[0] = m00 * n00 + m01 * n10 + m02 * n20;
			rd[3] = m00 * n01 + m01 * n11 + m02 * n21;
			rd[6] = m00 * n02 + m01 * n12 + m02 * n22;

			rd[1] = m10 * n00 + m11 * n10 + m12 * n20;
			rd[4] = m10 * n01 + m11 * n11 + m12 * n21;
			rd[7] = m10 * n02 + m11 * n12 + m12 * n22;

			rd[2] = m20 * n00 + m21 * n10 + m22 * n20;
			rd[5] = m20 * n01 + m21 * n11 + m22 * n21;
			rd[8] = m20 * n02 + m21 * n12 + m22 * n22;

			return target;
		}
	);

	/**
	 * @hidden
	 * @deprecated
	 */
	Matrix3.prototype.combine = ObjectUtils.warnOnce(
		'Matrix3.prototype.combine is deprecated - use Matrix3.prototype.mul or .mul2 instead.',
		function (rhs) {
			return Matrix3.combine(this, rhs, this);
		}
	);

	/**
	 * @hidden
	 * @deprecated
	 */
	Matrix3.transpose = ObjectUtils.warnOnce(
		'Matrix3.transpose is deprecated - use Matrix3.prototype.transpose instead.',
		function (source, target) {
			if (!target) {
				target = new Matrix3();
			}

			var s = source.data;
			var t = target.data;

			if (target === source) {
				var e01 = s[3];
				var e02 = s[6];
				var e12 = s[7];

				t[3] = s[1];
				t[6] = s[2];
				t[7] = s[5];

				t[1] = e01;
				t[2] = e02;
				t[5] = e12;

				return target;
			}

			t[0] = s[0];
			t[1] = s[3];
			t[2] = s[6];
			t[3] = s[1];
			t[4] = s[4];
			t[5] = s[7];
			t[6] = s[2];
			t[7] = s[5];
			t[8] = s[8];

			return target;
		}
	);

	/**
	 * @hidden
	 * @deprecated
	 */
	Matrix3.prototype.applyPost = ObjectUtils.warnOnce(
		'Matrix3.prototype.applyPost is deprecated - use Vector3.prototype.applyPost instead.',
		function (rhs) {
			var source = this.data;

			var x = rhs.x;
			var y = rhs.y;
			var z = rhs.z;

			rhs.x = source[0] * x + source[3] * y + source[6] * z;
			rhs.y = source[1] * x + source[4] * y + source[7] * z;
			rhs.z = source[2] * x + source[5] * y + source[8] * z;

			return rhs;
		}
	);

	/**
	 * @hidden
	 * @deprecated
	 */
	Matrix3.prototype.applyPre = ObjectUtils.warnOnce(
		'Matrix3.prototype.applyPre is deprecated - use Vector3.prototype.applyPre instead.',
		function (rhs) {
			var source = this.data;

			var x = rhs.x;
			var y = rhs.y;
			var z = rhs.z;

			rhs.x = source[0] * x + source[1] * y + source[2] * z;
			rhs.y = source[3] * x + source[4] * y + source[5] * z;
			rhs.z = source[6] * x + source[7] * y + source[8] * z;

			return rhs;
		}
	);
	// SHIM END

	// @ifdef DEBUG
	Matrix.addPostChecks(Matrix3.prototype, [
		'add', 'sub', 'scale', 'transpose', 'invert',
		'isOrthogonal', 'determinant',
		'fromAngles', 'rotateX', 'rotateY', 'rotateZ', 'fromAngleNormalAxis', 'lookAt',
		'copyQuaternion', 'copy'
	]);
	// @endif

	module.exports = Matrix3;


/***/ },
/* 25 */
/***/ function(module, exports, __webpack_require__) {

	var MathUtils = __webpack_require__(9);
	var ObjectUtils = __webpack_require__(6);

	/**
	 * Matrix with RxC components.
	 * @param {number} rows Number of rows.
	 * @param {number} cols Number of columns.
	 */
	function Matrix(rows, cols) {
		this.rows = rows || 0;
		this.cols = cols || 0;
		/** Column-major storage for the matrix components.
		 * @type {Float32Array}
		 */
		this.data = new Float32Array(this.rows * this.cols);
	}

	/**
	 * Binds aliases to the different matrix components.
	 * @hidden
	 * @param {Object} prototype The prototype to bind to.
	 * @param {Array<Array<string>>} aliases Array of component aliases for each component index.
	 */
	Matrix.setupAliases = function (prototype, aliases) {
		aliases.forEach(function (aliasesPerComponent, index) {
			aliasesPerComponent.forEach(function (alias) {
				Object.defineProperty(prototype, alias, {
					get: function () {
						return this.data[index];
					},
					set: function (value) {
						this.data[index] = value;
						// @ifdef DEBUG
						if (isNaN(this.data[index])) {
							throw new Error('Tried setting NaN to matrix component ' + alias);
						}
						// @endif
					}
				});
			});

			Object.defineProperty(prototype, index, {
				get: function () {
					return this.data[index];
				},
				set: function (value) {
					this.data[index] = value;
					// @ifdef DEBUG
					if (isNaN(this.data[index])) {
						throw new Error('Tried setting NaN to matrix component ' + index);
					}
					// @endif
				}
			});
		});
	};

	// @ifdef DEBUG
	/**
	 * Throws an error if any of the matrix's components are NaN
	 * @hidden
	 */
	Matrix.prototype.checkIntegrity = function () {
		for (var i = 0; i < this.data.length; i++) {
			if (isNaN(this.data[i])) {
				throw new Error('Matrix contains NaN at index ' + i);
			}
		}
	};

	/**
	 * Replaces the supplied method of object and wraps it in a integrity check
	 * @hidden
	 * @param {Object} object The object to attach the post-check to
	 * @param {string} methodName The name of the original method the check is attached to
	 */
	Matrix.addPostCheck = function (object, methodName) {
		var originalMethod = object[methodName];
		object[methodName] = function () {
			var ret = originalMethod.apply(this, arguments);
			if (typeof ret === 'number') {
				if (isNaN(ret)) {
					throw new Error('Matrix method ' + methodName + ' returned NaN');
				}
			}

			this.checkIntegrity();
			return ret;
		};
	};

	/**
	 * Adds more validators at once
	 * @hidden
	 * @param object
	 * @param {Array<string>} methodNames
	 */
	Matrix.addPostChecks = function (object, methodNames) {
		methodNames.forEach(Matrix.addPostCheck.bind(null, object));
	};
	// @endif

	// SHIM START
	/**
	 * Performs a component-wise addition.
	 * @param {Matrix} lhs Matrix on the left-hand side.
	 * @param {(Matrix|number)} rhs Matrix or scalar on the right-hand side.
	 * @param {Matrix} [target] Target matrix for storage.
	 * @returns {Matrix} A new matrix if the target matrix is omitted, else the target matrix.
	 * @deprecated
	 */
	Matrix.add = ObjectUtils.warnOnce(
		'Matrix.add is deprecated. Use Matrix3.prototype.add, Matrix2.prototype.add or Matrix4.prototype.add instead.',
		function (lhs, rhs, target) {
			var rows = lhs.rows;
			var cols = lhs.cols;

			if (!target) {
				target = new Matrix(rows, cols);
			}

			if (rhs instanceof Matrix) {
				for (var i = 0; i < lhs.data.length; i++) {
					target.data[i] = lhs.data[i] + rhs.data[i];
				}
			} else {
				for (var i = 0; i < lhs.data.length; i++) {
					target.data[i] = lhs.data[i] + rhs;
				}
			}

			return target;
		}
	);

	/**
	 * Performs a component-wise addition.
	 * @param {(Matrix|number)} rhs Matrix or scalar on the right-hand side.
	 * @returns {Matrix} Self for chaining.
	 * @deprecated
	 */
	Matrix.prototype.add = ObjectUtils.warnOnce(
		'Matrix.prototype.add is deprecated. Use Matrix3.prototype.add, Matrix2.prototype.add or Matrix4.prototype.add instead.',
		function (rhs) {
			return Matrix.add(this, rhs, this);
		}
	);

	/* ====================================================================== */

	/**
	 * Performs a component-wise subtraction.
	 * @param {Matrix} lhs Matrix on the left-hand side.
	 * @param {(Matrix|number)} rhs Matrix or scalar on the right-hand side.
	 * @param {Matrix} [target] Target matrix for storage.
	 * @returns {Matrix} A new matrix if the target matrix is omitted, else the target matrix.
	 * @deprecated
	 */

	Matrix.sub = ObjectUtils.warnOnce(
		'Matrix.sub is deprecated. Use Matrix3.prototype.sub, Matrix2.prototype.sub or Matrix4.prototype.sub instead.',
		function (lhs, rhs, target) {
			var rows = lhs.rows;
			var cols = lhs.cols;

			if (!target) {
				target = new Matrix(rows, cols);
			}

			if (rhs instanceof Matrix) {
				for (var i = 0; i < lhs.data.length; i++) {
					target.data[i] = lhs.data[i] - rhs.data[i];
				}
			} else {
				for (var i = 0; i < lhs.data.length; i++) {
					target.data[i] = lhs.data[i] - rhs;
				}
			}

			return target;
		}
	);

	/**
	 * Performs a component-wise subtraction.
	 * @param {(Matrix|number)} rhs Matrix or scalar on the right-hand side.
	 * @returns {Matrix} Self for chaining.
	 * @deprecated
	 */
	Matrix.prototype.sub = ObjectUtils.warnOnce(
		'Matrix.prototype.sub is deprecated. Use Matrix3.prototype.sub, Matrix2.prototype.sub or Matrix4.prototype.sub instead.',
		function (rhs) {
			return Matrix.sub(this, rhs, this);
		}
	);

	/* ====================================================================== */

	/**
	 * Performs a component-wise multiplication.
	 * @param {Matrix} lhs Matrix on the left-hand side.
	 * @param {(Matrix|number)} rhs Matrix or scalar on the right-hand side.
	 * @param {Matrix} [target] Target matrix for storage.
	 * @returns {Matrix} A new matrix if the target matrix is omitted, else the target matrix.
	 * @deprecated
	 */
	Matrix.mul = ObjectUtils.warnOnce(
		'Matrix.mul is deprecated. Use Matrix3.prototype.mul, Matrix2.prototype.mul or Matrix4.prototype.mul instead.',
		function (lhs, rhs, target) {
			var rows = lhs.rows;
			var cols = lhs.cols;

			if (!target) {
				target = new Matrix(rows, cols);
			}

			if (rhs instanceof Matrix) {
				for (var i = 0; i < lhs.data.length; i++) {
					target.data[i] = lhs.data[i] * rhs.data[i];
				}
			} else {
				for (var i = 0; i < lhs.data.length; i++) {
					target.data[i] = lhs.data[i] * rhs;
				}
			}

			return target;
		}
	);

	/**
	 * Performs a component-wise multiplication.
	 * @param {(Matrix|number)} rhs Matrix or scalar on the right-hand side.
	 * @returns {Matrix} Self for chaining.
	 * @deprecated
	 */
	Matrix.prototype.mul = ObjectUtils.warnOnce(
		'Matrix.prototype.mul is deprecated. Use Matrix3.prototype.mul, Matrix2.prototype.mul or Matrix4.prototype.mul instead.',
		function (rhs) {
			return Matrix.mul(this, rhs, this);
		}
	);

	/* ====================================================================== */

	/**
	 * Performs a component-wise division.
	 * @param {Matrix} lhs Matrix on the left-hand side.
	 * @param {(Matrix|number)} rhs Matrix or scalar on the right-hand side.
	 * @param {Matrix} [target] Target matrix for storage.
	 * @returns {Matrix} A new matrix if the target matrix is omitted, else the target matrix.
	 * @deprecated
	 */
	Matrix.div = ObjectUtils.warnOnce(
		'Matrix.div is deprecated. Use Matrix3.prototype.div, Matrix2.prototype.div or Matrix4.prototype.div instead.',
		function (lhs, rhs, target) {
			var rows = lhs.rows;
			var cols = lhs.cols;

			if (!target) {
				target = new Matrix(rows, cols);
			}

			if (rhs instanceof Matrix) {
				for (var i = 0; i < lhs.data.length; i++) {
					target.data[i] = lhs.data[i] / rhs.data[i];
				}
			} else {
				rhs = 1.0 / rhs;

				for (var i = 0; i < lhs.data.length; i++) {
					target.data[i] = lhs.data[i] * rhs;
				}
			}

			return target;
		}
	);

	/**
	 * Performs a component-wise division.
	 * @param {(Matrix|number)} rhs Matrix or scalar on the right-hand side.
	 * @returns {Matrix} Self for chaining.
	 * @deprecated
	 */
	Matrix.prototype.div = ObjectUtils.warnOnce(
		'Matrix.prototype.div is deprecated. Use Matrix3.prototype.div, Matrix2.prototype.div or Matrix4.prototype.div instead.',
		function (rhs) {
			return Matrix.div(this, rhs, this);
		}
	);

	/* ====================================================================== */

	/**
	 * Combines two matrices (matrix multiplication) and stores the result in a separate matrix.
	 * @param {Matrix} lhs Matrix on the left-hand side.
	 * @param {Matrix} rhs Matrix on the right-hand side.
	 * @param {Matrix} [target] Target matrix for storage.
	 * @returns {Matrix} A new matrix if the target matrix is omitted, else the target matrix.
	 * @deprecated
	 */
	Matrix.combine = ObjectUtils.warnOnce(
		'Matrix.combine is deprecated. Use Matrix2/3/4.prototype.mul or Matrix2/3/4.prototype.mul2 instead.',
		function (lhs, rhs, target) {
			var rows = lhs.rows;
			var cols = rhs.cols;
			var size = lhs.cols = rhs.rows;

			if (!target) {
				target = new Matrix(rows, cols);
			}

			if (target === lhs || target === rhs) {
				return Matrix.copy(Matrix.combine(lhs, rhs), target);
			}

			for (var c = 0; c < cols; c++) {
				var o = c * rows;

				for (var r = 0; r < rows; r++) {
					var sum = 0.0;

					for (var i = 0; i < size; i++) {
						sum += lhs.data[i * lhs.rows + r] * rhs.data[c * rhs.rows + i];
					}

					target.data[o + r] = sum;
				}
			}

			return target;
		}
	);

	/**
	 * Combines two matrices (matrix multiplication) and stores the result locally.
	 * @param {Matrix} rhs Matrix on the right-hand side.
	 * @returns {Matrix} Self for chaining.
	 * @deprecated
	 */
	Matrix.prototype.combine = ObjectUtils.warnOnce(
		'Matrix.prototype.combine is deprecated. Use Matrix2/3/4.prototype.mul or Matrix2/3/4.prototype.mul2 instead.',
		function (rhs) {
			return Matrix.combine(this, rhs, this);
		}
	);

	/* ====================================================================== */

	/**
	 * Transposes a matrix (exchanges rows and columns) and stores the result in a separate matrix.
	 * @param {Matrix} source Source matrix.
	 * @param {Matrix} [target] Target matrix.
	 * @returns {Matrix} A new matrix if the target matrix is omitted, else the target matrix.
	 * @deprecated
	 */
	Matrix.transpose = ObjectUtils.warnOnce(
		'Matrix.transpose is deprecated. Use Matrix2/3/4.prototype.transpose instead.',
		function (source, target) {
			var rows = source.cols;
			var cols = source.rows;

			if (!target) {
				target = new Matrix(rows, cols);
			}

			if (target === source) {
				return Matrix.copy(Matrix.transpose(source), target);
			}

			for (var c = 0; c < cols; c++) {
				var o = c * rows;

				for (var r = 0; r < rows; r++) {
					target.data[o + r] = source.data[r * cols + c];
				}
			}

			return target;
		}
	);

	/**
	 * Transposes the matrix (exchanges rows and columns) and stores the result locally.
	 * @returns {Matrix} Self for chaining.
	 * @deprecated
	 */
	Matrix.prototype.transpose = ObjectUtils.warnOnce(
		'Matrix.prototype.transpose is deprecated. Use Matrix2/3/4.prototype.transpose instead.',
		function () {
			return Matrix.transpose(this, this);
		}
	);

	/* ====================================================================== */

	/**
	 * Copies component values and stores them in a separate matrix.
	 * @param {Matrix} source Source matrix.
	 * @param {Matrix} [target] Target matrix.
	 * @returns {Matrix} A new matrix if the target matrix is omitted, else the target matrix.
	 * @deprecated
	 */
	Matrix.copy = ObjectUtils.warnOnce(
		'Matrix.copy is deprecated. Use Matrix2/3/4.prototype.copy instead.',
		function (source, target) {
			var rows = source.rows;
			var cols = source.cols;

			if (!target) {
				target = new Matrix(rows, cols);
			}

			target.data.set(source.data);

			return target;
		}
	);

	/**
	 * Copies component values and stores them locally.
	 * @param {Matrix} source Source matrix.
	 * @returns {Matrix} Self for chaining.
	 * @deprecated
	 */
	Matrix.prototype.copy = ObjectUtils.warnOnce(
		'Matrix.prototype.copy is deprecated. Use Matrix2/3/4.prototype.copy instead.',
		function (source) {
			return Matrix.copy(source, this);
		}
	);

	/* ====================================================================== */

	/**
	 * Compares two matrices for approximate equality.
	 * @param {Matrix} lhs Matrix on the left-hand side.
	 * @param {Matrix} rhs Matrix on the right-hand side.
	 * @returns {boolean} True if equal.
	 * @deprecated
	 */
	Matrix.equals = ObjectUtils.warnOnce(
		'Matrix.equals is deprecated. Use Matrix2/3/4.prototype.equals instead.',
		function (lhs, rhs) {
			if (lhs.rows !== rhs.rows || lhs.cols !== rhs.cols) {
				return false;
			}

			for (var i = 0; i < lhs.data.length; i++) {
				// why the backwards check? because otherwise if NaN is present in either lhs or rhs
				// then Math.abs(NaN) is NaN which is neither bigger or smaller than EPSILON
				// which never satisfies the condition
				// NaN is not close to NaN and we want to preserve that for matrices as well
				if (!(Math.abs(lhs.data[i] - rhs.data[i]) <= MathUtils.EPSILON)) {
					return false;
				}
			}

			return true;
		}
	);

	/**
	 * Compares two matrices for approximate equality.
	 * @param {Matrix} rhs Matrix on the right-hand side.
	 * @returns {boolean} True if equal.
	 * @deprecated
	 */
	Matrix.prototype.equals = ObjectUtils.warnOnce(
		'Matrix.prototype.equals is deprecated. Use Matrix2/3/4.prototype.equals instead.',
		function (rhs) {
			return Matrix.equals(this, rhs);
		}
	);

	/* ====================================================================== */

	/**
	 * Tests if the matrix is orthogonal.
	 * @returns {boolean} True if orthogonal.
	 * @deprecated
	 */
	Matrix.prototype.isOrthogonal = ObjectUtils.warnOnce(
		'Matrix.prototype.isOrthogonal is deprecated. Use Matrix2/3/4.prototype.isOrthogonal instead.',
		function () {
			for (var ca = 0; ca < this.cols; ca++) {
				for (var cb = ca + 1; cb < this.cols; cb++) {
					var oa = ca * this.rows;
					var ob = cb * this.rows;
					var sum = 0.0;

					for (var r = 0; r < this.rows; r++) {
						sum += this.data[oa + r] * this.data[ob + r];
					}

					if (Math.abs(sum) > MathUtils.EPSILON) {
						return false;
					}
				}
			}

			return true;
		}
	);

	/* ====================================================================== */

	/**
	 * Tests if the matrix is normal.
	 * @returns {boolean} True if normal.
	 * @deprecated
	 */
	Matrix.prototype.isNormal = ObjectUtils.warnOnce(
		'Matrix.prototype.isNormal is deprecated. Use Matrix2/3/4.prototype.isNormal instead.',
		function () {
			for (var c = 0; c < this.cols; c++) {
				var o = c * this.rows;
				var sum = 0.0;

				for (var r = 0; r < this.rows; r++) {
					sum += this.data[o + r] * this.data[o + r];
				}

				if (Math.abs(sum - 1.0) > MathUtils.EPSILON) {
					return false;
				}
			}

			return true;
		}
	);

	/* ====================================================================== */

	/**
	 * Tests if the matrix is orthonormal.
	 * @returns {boolean} True if orthonormal.
	 * @deprecated
	 */
	Matrix.prototype.isOrthonormal = ObjectUtils.warnOnce(
		'Matrix.prototype.isOrthonormal is deprecated. Use Matrix2/3/4.prototype.isOrthonormal instead.',
		function () {
			return this.isOrthogonal() && this.isNormal();
		}
	);

	/* ====================================================================== */

	/**
	 * Clones the matrix.
	 * @returns {Matrix} Clone of self.
	 * @deprecated
	 */
	Matrix.prototype.clone = ObjectUtils.warnOnce(
		'Matrix.prorotype.clone is deprecated. Use Matrix2/3/4.prototype.clone instead.',
		function () {
			return Matrix.copy(this);
		}
	);

	/* ====================================================================== */

	/**
	 * Sets the components of the matrix.
	 * @param {(Matrix|number[]|...number)} arguments Component values.
	 * @returns {Matrix} Self for chaining.
	 * @deprecated
	 */
	Matrix.prototype.set = ObjectUtils.warnOnce(
		'Matrix.prototype.set is deprecated. Use Matrix2/3/4.prototype.set instead.',
		function () {
			if (arguments.length === 1 && typeof arguments[0] === 'object') {
				if (arguments[0] instanceof Matrix) {
					this.copy(arguments[0]);
				} else {
					for (var i = 0; i < arguments[0].length; i++) {
						this.data[i] = arguments[0][i];
					}
				}
			} else {
				for (var i = 0; i < arguments.length; i++) {
					this.data[i] = arguments[i];
				}
			}

			return this;
		}
	);

	/**
	 * Converts the matrix into a string.
	 * @returns {string} String of component values.
	 * @deprecated
	 */
	Matrix.prototype.toString = ObjectUtils.warnOnce(
		'Matrix.prorotype.toString is deprecated.',
		function () {
			var string = '';

			for (var c = 0; c < this.cols; c++) {
				var offset = c * this.rows;

				string += '[';

				for (var r = 0; r < this.rows; r++) {
					string += this.data[offset + r];
					string += r !== this.rows - 1 ? ', ' : '';
				}

				string += c !== this.cols - 1 ? '], ' : ']';
			}

			return string;
		}
	);
	// SHIM END

	module.exports = Matrix;


/***/ },
/* 26 */,
/* 27 */
/***/ function(module, exports, __webpack_require__) {

	var MeshData = __webpack_require__(14);
	var ObjectUtils = __webpack_require__(6);

	/**
	 * An axis-aligned rectangular prism defined by a center point and x-, y- and z-extents (radii)
	 * from that center (a box).
	 * @extends MeshData
	 * @param {number} [width=1] Total width of box.
	 * @param {number} [height=1] Total height of box.
	 * @param {number} [length=1] Total length of box.
	 * @param {number} [tileX=1] Number of texture repetitions in the texture's x direction.
	 * @param {number} [tileY=1] Number of texture repetitions in the texture's y direction.
	 * @param {Enum} [textureMode=Box.TextureModes.Uniform] Texture wrapping mode.
	 */
	function Box(width, height, length, tileX, tileY, textureMode) {
		if (arguments.length === 1 && arguments[0] instanceof Object) {
			var props = arguments[0];
			width = props.width;
			height = props.height;
			length = props.length;
			tileX = props.tileX;
			tileY = props.tileY;
			textureMode = props.textureMode;
		}

		/**
		 * Extent along the local x axis.
		 * @type {number}
		 * @default 0.5
		 */
		this.xExtent = width !== undefined ? width * 0.5 : 0.5;

		/**
		 * Extent along the local y axis.
		 * @type {number}
		 * @default 0.5
		 */
		this.yExtent = height !== undefined ? height * 0.5 : 0.5;

		/**
		 * Extent along the local z axis.
		 * @type {number}
		 * @default 0.5
		 */
		this.zExtent = length !== undefined ? length * 0.5 : 0.5;

		/**
		 * Number of texture repetitions in the texture's x direction.
		 * @type {number}
		 * @default 1
		 */
		this.tileX = tileX || 1;

		/**
		 * Number of texture repetitions in the texture's y direction.
		 * @type {number}
		 * @default 1
		 */
		this.tileY = tileY || 1;

		/**
		 * Texture wrapping mode.
		 * @type {Enum}
		 * @default Box.TextureModes.Uniform
		 */
		this.textureMode = textureMode !== undefined ? textureMode : Box.TextureModes.Uniform;

		var attributeMap = MeshData.defaultMap([MeshData.POSITION, MeshData.NORMAL, MeshData.TEXCOORD0]);
		MeshData.call(this, attributeMap, 24, 36);

		this.rebuild();
	}

	Box.prototype = Object.create(MeshData.prototype);
	Box.prototype.constructor = Box;

	/**
	 * Builds or rebuilds the mesh data.
	 * @returns {Box} Self for chaining.
	 */
	Box.prototype.rebuild = function () {
		var xExtent = this.xExtent;
		var yExtent = this.yExtent;
		var zExtent = this.zExtent;
		var tileX = this.tileX;
		var tileY = this.tileY;

		var verts = [
			-xExtent, -yExtent, -zExtent,
			xExtent, -yExtent, -zExtent,
			xExtent,  yExtent, -zExtent,
			-xExtent,  yExtent, -zExtent,
			xExtent, -yExtent,  zExtent,
			-xExtent, -yExtent,  zExtent,
			xExtent,  yExtent,  zExtent,
			-xExtent,  yExtent,  zExtent
		];

		var vertices = [];
		function fillV(fillIndices) {
			for (var i = 0; i < fillIndices.length; i++) {
				var index = fillIndices[i] * 3;
				vertices.push(verts[index]);
				vertices.push(verts[index + 1]);
				vertices.push(verts[index + 2]);
			}
		}

		fillV([
			0, 1, 2, 3,
			1, 4, 6, 2,
			4, 5, 7, 6,
			5, 0, 3, 7,
			2, 6, 7, 3,
			0, 5, 4, 1
		]);

		this.getAttributeBuffer(MeshData.POSITION).set(vertices);

		var norms = [
			0, 0, -1,
			1, 0, 0,
			0, 0, 1,
			-1, 0, 0,
			0, 1, 0,
			0, -1, 0
		];

		var normals = [];
		function fillN() {
			for (var i = 0; i < norms.length / 3; i++) {
				for (var j = 0; j < 4; j++) {
					var index = i * 3;
					normals.push(norms[index]);
					normals.push(norms[index + 1]);
					normals.push(norms[index + 2]);
				}
			}
		}
		fillN();

		this.getAttributeBuffer(MeshData.NORMAL).set(normals);

		var tex = [];
		if (this.textureMode === Box.TextureModes.Uniform) {
			for (var i = 0; i < 6; i++) {
				tex.push(tileX);
				tex.push(0);

				tex.push(0);
				tex.push(0);

				tex.push(0);
				tex.push(tileY);

				tex.push(tileX);
				tex.push(tileY);
			}
		} else {
			tex.push(4 / 4, 1 / 3,   3 / 4, 1 / 3,   3 / 4, 2 / 3,   4 / 4, 2 / 3); // 5
			tex.push(3 / 4, 1 / 3,   2 / 4, 1 / 3,   2 / 4, 2 / 3,   3 / 4, 2 / 3); // 4
			tex.push(2 / 4, 1 / 3,   1 / 4, 1 / 3,   1 / 4, 2 / 3,   2 / 4, 2 / 3); // 3
			tex.push(1 / 4, 1 / 3,   0 / 4, 1 / 3,   0 / 4, 2 / 3,   1 / 4, 2 / 3); // 2
			tex.push(2 / 4, 3 / 3,   2 / 4, 2 / 3,   1 / 4, 2 / 3,   1 / 4, 3 / 3); // 1
			tex.push(1 / 4, 0 / 3,   1 / 4, 1 / 3,   2 / 4, 1 / 3,   2 / 4, 0 / 3); // 6
		}

		this.getAttributeBuffer(MeshData.TEXCOORD0).set(tex);

		this.getIndexBuffer().set([
			2,  1,  0,  3,  2,  0,
			6,  5,  4,  7,  6,  4,
			10,  9,  8, 11, 10,  8,
			14, 13, 12, 15, 14, 12,
			18, 17, 16, 19, 18, 16,
			22, 21, 20, 23, 22, 20
		]);

		return this;
	};

	/**
	 * Returns a clone of this box
	 * @returns {Box}
	 */
	Box.prototype.clone = function () {
		var options = ObjectUtils.shallowSelectiveClone(this, ['tileX', 'tileY', 'textureMode']);

		// converting xExtent to width so the constructor will convert it the other way around again
		options.width = this.xExtent * 2;
		options.height = this.yExtent * 2;
		options.length = this.zExtent * 2;

		return new Box(options);
	};

	/** Possible texture wrapping modes: Uniform, Unfolded
	 * @type {Object}
	 */
	Box.TextureModes = {
		Uniform: 'Uniform',
		Unfolded: 'Unfolded'
	};

	module.exports = Box;

/***/ },
/* 28 */
/***/ function(module, exports, __webpack_require__) {

	var MeshData = __webpack_require__(14);
	var ObjectUtils = __webpack_require__(6);

	/**
	 * A rectangular, two dimensional shape. The local height of the Quad defines it's size about the y-axis,
	 * while the width defines the x-axis. The z-axis will always be 0.
	 * @extends MeshData
	 * @param {number} [width=1] Total width of quad.
	 * @param {number} [height=1] Total height of quad.
	 * @param {number} [tileX=1] Number of texture repetitions in the texture's x direction.
	 * @param {number} [tileY=1] Number of texture repetitions in the texture's y direction.
	 */
	function Quad(width, height, tileX, tileY) {
		if (arguments.length === 1 && arguments[0] instanceof Object) {
			var props = arguments[0];
			width = props.width;
			height = props.height;
			tileX = props.tileX;
			tileY = props.tileY;
		}

		/** Half-extent along the local x axis.
		 * @type {number}
		 * @default 0.5
		 */
		this.xExtent = width !== undefined ? width * 0.5 : 0.5;

		/** Half-extent along the local y axis.
		 * @type {number}
		 * @default 0.5
		 */
		this.yExtent = height !== undefined ? height * 0.5 : 0.5;

		/** Number of texture repetitions in the texture's x direction.
		 * @type {number}
		 * @default 1
		 */
		this.tileX = tileX || 1;

		/** Number of texture repetitions in the texture's y direction.
		 * @type {number}
		 * @default 1
		 */
		this.tileY = tileY || 1;

		var attributeMap = MeshData.defaultMap([MeshData.POSITION, MeshData.NORMAL, MeshData.TEXCOORD0]);
		MeshData.call(this, attributeMap, 4, 6);

		this.rebuild();
	}

	Quad.prototype = Object.create(MeshData.prototype);
	Quad.prototype.constructor = Quad;

	/**
	 * Builds or rebuilds the mesh data.
	 * @returns {Quad} Self for chaining.
	 */
	Quad.prototype.rebuild = function () {
		var xExtent = this.xExtent;
		var yExtent = this.yExtent;
		var tileX = this.tileX;
		var tileY = this.tileY;

		this.getAttributeBuffer(MeshData.POSITION).set([-xExtent, -yExtent, 0, -xExtent, yExtent, 0, xExtent, yExtent, 0, xExtent, -yExtent, 0]);
		this.getAttributeBuffer(MeshData.NORMAL).set([0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1]);
		this.getAttributeBuffer(MeshData.TEXCOORD0).set([0, 0, 0, tileY, tileX, tileY, tileX, 0]);

		this.getIndexBuffer().set([0, 3, 1, 1, 3, 2]);

		return this;
	};

	/**
	 * Returns a clone of this quad
	 * @returns {Quad}
	 */
	Quad.prototype.clone = function () {
		var options = ObjectUtils.shallowSelectiveClone(this, ['xExtent', 'yExtent', 'tileX', 'tileY']);

		return new Quad(options);
	};

	module.exports = Quad;

/***/ },
/* 29 */
/***/ function(module, exports, __webpack_require__) {

	var MeshData = __webpack_require__(14);
	var Vector3 = __webpack_require__(8);
	var MathUtils = __webpack_require__(9);
	var ObjectUtils = __webpack_require__(6);

	/**
	 * A 3D object with all points equi-distance from a center point.
	 * @extends MeshData
	 * @param {number} [zSamples=8] Number of segments.
	 * @param {number} [radialSamples=8] Number of slices.
	 * @param {number} [radius=0.5] Radius.
	 * @param {Enum} [textureMode=Sphere.TextureModes.Polar] Texture wrapping mode.
	 */
	function Sphere(zSamples, radialSamples, radius, textureMode) {
		if (arguments.length === 1 && arguments[0] instanceof Object) {
			var props = arguments[0];
			zSamples = props.zSamples;
			radialSamples = props.radialSamples;
			radius = props.radius;
			textureMode = props.textureMode;
		}
		/** Number of segments.
		 * @type {number}
		 * @default 8
		 */
		this.zSamples = (zSamples !== undefined ? zSamples : 8) + 1;
		/** Number of slices.
		 * @type {number}
		 * @default 8
		 */
		this.radialSamples = radialSamples !== undefined ? radialSamples : 8;
		/** @type {number}
		 * @default 0.5
		 */
		this.radius = radius !== undefined ? radius : 0.5;

		if (typeof textureMode === 'string') {
			textureMode = Sphere.TextureModes[textureMode];
		}
		/** Texture wrapping mode.
		 * @type {Enum}
		 * @default Sphere.TextureModes.Polar
		 */
		this.textureMode = textureMode !== undefined ? textureMode : Sphere.TextureModes.Polar;

		/** Inward-facing normals, for skydomes.
		 * @type {boolean}
		 * @default false
		 */
		this.viewInside = false;

		var attributeMap = MeshData.defaultMap([MeshData.POSITION, MeshData.NORMAL, MeshData.TEXCOORD0]);

		var samples = (this.textureMode === Sphere.TextureModes.Chromeball) ? this.zSamples + 1 : this.zSamples;

		// If Projected & Linear use shared pole vertices the uv-mapping will get too distorted, so let them
		// have full 'rings' of vertices for a straighter texture mapping.
		this._useSharedPoleVertices = (this.textureMode !== Sphere.TextureModes.Projected) &&
			(this.textureMode !== Sphere.TextureModes.Linear);

		// sharedVert = pole vertex that represents a whole layer. When not using shared vertices,
		// full layers are used for both poles.
		var sharedVerts = this._useSharedPoleVertices ? 2 : 0;
		var verts = (samples - sharedVerts) * (this.radialSamples + 1) + sharedVerts;
		var tris = 6 * ((samples) - 2) * this.radialSamples;

		MeshData.call(this, attributeMap, verts, tris);

		this.rebuild();
	}

	Sphere.prototype = Object.create(MeshData.prototype);
	Sphere.prototype.constructor = Sphere;

	/**
	 * Builds or rebuilds the mesh data.
	 * @returns {Sphere} Self for chaining.
	 */
	Sphere.prototype.rebuild = function () {
		var vbuf = this.getAttributeBuffer(MeshData.POSITION);
		var norms = this.getAttributeBuffer(MeshData.NORMAL);
		var texs = this.getAttributeBuffer(MeshData.TEXCOORD0);
		var indices = this.getIndexBuffer();

		// generate geometry
		var fInvRS = 1.0 / this.radialSamples;
		var fZFactor = 2.0 / (this.zSamples - 1);

		// Generate points on the unit circle to be used in computing the mesh
		// points on a sphere slice.
		var afSin = [];
		var afCos = [];
		for (var iR = 0; iR < this.radialSamples; iR++) {
			var fAngle = MathUtils.TWO_PI * fInvRS * iR;
			afCos[iR] = Math.cos(fAngle);
			afSin[iR] = Math.sin(fAngle);
		}
		afSin[this.radialSamples] = afSin[0];
		afCos[this.radialSamples] = afCos[0];

		// z range to generate vertices for. If sharing pole vertices, skip those layers.
		var zBegin = 0;
		var zEnd = this.zSamples;

		if (this._useSharedPoleVertices) {
			zBegin = 1;
			zEnd = this.zSamples - 1;
		}

		// generate the sphere itself
		var i = 0;
		var tempVa = new Vector3();
		var tempVb = new Vector3();
		var tempVc = new Vector3();
		for (var iZ = zBegin; iZ < zEnd; iZ++) {
			var fAFraction = MathUtils.HALF_PI * (-1.0 + fZFactor * iZ); // in (-pi / 2, pi / 2)
			var fZFraction = Math.sin(fAFraction); // in (-1, 1)
			var fZ = this.radius * fZFraction;

			// compute center of slice
			var kSliceCenter = tempVb.setDirect(0, 0, 0);
			kSliceCenter.z += fZ;

			// compute radius of slice
			var fSliceRadius = Math.sqrt(Math.abs(this.radius * this.radius - fZ * fZ));

			// compute slice vertices with duplication at end point
			var kNormal;
			var iSave = i;
			for (var iR = 0; iR < this.radialSamples; iR++) {
				var fRadialFraction = iR * fInvRS; // in [0, 1)
				var kRadial = tempVc.setDirect(afCos[iR], afSin[iR], 0);
				tempVa.copy(kRadial).scale(fSliceRadius);

				vbuf[i * 3 + 0] = kSliceCenter.x + tempVa.x;
				vbuf[i * 3 + 1] = kSliceCenter.y + tempVa.y;
				vbuf[i * 3 + 2] = kSliceCenter.z + tempVa.z;

				kNormal = tempVa.setDirect(vbuf[i * 3 + 0], vbuf[i * 3 + 1], vbuf[i * 3 + 2]);
				kNormal.normalize();
				if (!this.viewInside) {
					norms[i * 3 + 0] = kNormal.x;
					norms[i * 3 + 1] = kNormal.y;
					norms[i * 3 + 2] = kNormal.z;
				} else {
					norms[i * 3 + 0] = -kNormal.x;
					norms[i * 3 + 1] = -kNormal.y;
					norms[i * 3 + 2] = -kNormal.z;
				}

				// When not having shared pole vertices: ajustment of u at the poles for linear & projected modes.
				// This is because at the pole we squeeze a quad into a triangle, so this centers the pointy end of it.
				var uOffset = 0;
				if (!this._useSharedPoleVertices && (iZ === zBegin || iZ === (zEnd - 1))) {
					uOffset = 0.5 * fInvRS;
				}

				if (this.textureMode === Sphere.TextureModes.Linear) {
					texs[i * 2 + 0] = fRadialFraction + uOffset;
					texs[i * 2 + 1] = 0.5 * (fZFraction + 1.0);
				} else if (this.textureMode === Sphere.TextureModes.Projected) {
					texs[i * 2 + 0] = fRadialFraction + uOffset;
					texs[i * 2 + 1] = (MathUtils.HALF_PI + Math.asin(fZFraction)) / Math.PI;
				} else if (this.textureMode === Sphere.TextureModes.Polar) {
					var r = (MathUtils.HALF_PI - Math.abs(fAFraction)) / Math.PI;
					var u = r * afCos[iR] + 0.5;
					var v = r * afSin[iR] + 0.5;
					texs[i * 2 + 0] = u;
					texs[i * 2 + 1] = v;
				} else if (this.textureMode === Sphere.TextureModes.Chromeball) {
					var r = Math.sin((MathUtils.HALF_PI + fAFraction) / 2);
					r /= 2;
					var u = r * afCos[iR] + 0.5;
					var v = r * afSin[iR] + 0.5;
					texs[i * 2 + 0] = u;
					texs[i * 2 + 1] = v;
				}

				i++;
			}

			copyInternal(vbuf, iSave, i);
			copyInternal(norms, iSave, i);

			if (this.textureMode === Sphere.TextureModes.Linear) {
				texs[i * 2 + 0] = 1.0;
				texs[i * 2 + 1] = 0.5 * (fZFraction + 1.0);
			} else if (this.textureMode === Sphere.TextureModes.Projected) {
				texs[i * 2 + 0] = 1.0;
				texs[i * 2 + 1] = (MathUtils.HALF_PI + Math.asin(fZFraction)) / Math.PI;
			} else if (this.textureMode === Sphere.TextureModes.Polar) {
				var r = (MathUtils.HALF_PI - Math.abs(fAFraction)) / Math.PI;
				texs[i * 2 + 0] = r + 0.5;
				texs[i * 2 + 1] = 0.5;
			} else if (this.textureMode === Sphere.TextureModes.Chromeball) {
				var r = Math.sin((MathUtils.HALF_PI + fAFraction) / 2);
				r /= 2;
				texs[i * 2 + 0] = r + 0.5;
				texs[i * 2 + 1] = 0.5;
			}

			i++;
		}
		// We need to add an extra slice so the north pole doesn't look freake
		if (this.textureMode === Sphere.TextureModes.Chromeball) {
			var epsilonAngle = MathUtils.HALF_PI - 1e-3;
			var z = this.radius * Math.sin(epsilonAngle);
			var sliceR = Math.sqrt(Math.abs(this.radius * this.radius - z * z));
			var iSave = i;
			for (var iR = 0; iR < this.radialSamples; iR++) {
				vbuf[i * 3 + 0] = sliceR * afCos[iR];
				vbuf[i * 3 + 1] = sliceR * afSin[iR];
				vbuf[i * 3 + 2] = z;

				var kNormal = tempVa.setDirect(vbuf[i * 3 + 0], vbuf[i * 3 + 1], vbuf[i * 3 + 2]);
				kNormal.normalize();
				if (!this.viewInside) {
					norms[i * 3 + 0] = kNormal.x;
					norms[i * 3 + 1] = kNormal.y;
					norms[i * 3 + 2] = kNormal.z;
				} else {
					norms[i * 3 + 0] = -kNormal.x;
					norms[i * 3 + 1] = -kNormal.y;
					norms[i * 3 + 2] = -kNormal.z;
				}
				var r = Math.sin((MathUtils.HALF_PI + epsilonAngle) / 2);
				r /= 2;
				var u = r * afCos[iR] + 0.5;
				var v = r * afSin[iR] + 0.5;
				texs[i * 2 + 0] = u;
				texs[i * 2 + 1] = v;
				i++;
			}
			copyInternal(vbuf, iSave, i);
			copyInternal(norms, iSave, i);
			var r = Math.sin((MathUtils.HALF_PI + epsilonAngle) / 2);
			r /= 2;
			texs[i * 2 + 0] = r + 0.5;
			texs[i * 2 + 1] = 0.5;
			i++;
		}

		if (this._useSharedPoleVertices) {
			// south pole
			vbuf[i * 3 + 0] = 0;
			vbuf[i * 3 + 1] = 0;
			vbuf[i * 3 + 2] = -this.radius;

			if (!this.viewInside) {
				norms[i * 3 + 0] = 0;
				norms[i * 3 + 1] = 0;
				norms[i * 3 + 2] = -1;
			} else {
				norms[i * 3 + 0] = 0;
				norms[i * 3 + 1] = 0;
				norms[i * 3 + 2] = 1;
			}

			if (this.textureMode === Sphere.TextureModes.Polar || this.textureMode === Sphere.TextureModes.Chromeball) {
				texs[i * 2 + 0] = 0.5;
				texs[i * 2 + 1] = 0.5;
			} else {
				texs[i * 2 + 0] = 0.5;
				texs[i * 2 + 1] = 0.0;
			}

			i++;

			// north pole
			vbuf[i * 3 + 0] = 0;
			vbuf[i * 3 + 1] = 0;
			vbuf[i * 3 + 2] = this.radius;

			if (!this.viewInside) {
				norms[i * 3 + 0] = 0;
				norms[i * 3 + 1] = 0;
				norms[i * 3 + 2] = 1;
			} else {
				norms[i * 3 + 0] = 0;
				norms[i * 3 + 1] = 0;
				norms[i * 3 + 2] = -1;
			}

			if (this.textureMode === Sphere.TextureModes.Polar) {
				texs[i * 2 + 0] = 0.5;
				texs[i * 2 + 1] = 0.5;
			} else if (this.textureMode === Sphere.TextureModes.Chromeball) {
				texs[i * 2 + 0] = 1;
				texs[i * 2 + 1] = -0.5;
			} else {
				texs[i * 2 + 0] = 0.5;
				texs[i * 2 + 1] = 1.0;
			}
		}

		// generate connectivity
		var index = 0;

		var samples = (this.textureMode === Sphere.TextureModes.Chromeball) ? this.zSamples + 1 : this.zSamples;

		var iZStart = 0;
		if (!this._useSharedPoleVertices) {
			// When triangles at the pole dont use a shared vertices, there's an extra pole layer here that will be
			// used only for the pole.
			iZStart = this.radialSamples + 1;
		}

		for (var iZ = 0; iZ < samples - 3; iZ++) {
			var i0 = iZStart;
			var i1 = i0 + 1;
			iZStart += this.radialSamples + 1;
			var i2 = iZStart;
			var i3 = i2 + 1;
			for (var i = 0; i < this.radialSamples; i++) {
				if (!this.viewInside) {
					indices[index++] = i0++;
					indices[index++] = i1;
					indices[index++] = i2;
					indices[index++] = i1++;
					indices[index++] = i3++;
					indices[index++] = i2++;
				} else {
					indices[index++] = i0++;
					indices[index++] = i2;
					indices[index++] = i1;
					indices[index++] = i1++;
					indices[index++] = i2++;
					indices[index++] = i3++;
				}
			}
		}

		// south pole triangles
		for (var i = 0; i < this.radialSamples; i++) {
			var i0, i1, i2;

			if (!this._useSharedPoleVertices) {
				i0 = i;
				i1 = i + this.radialSamples + 2;
				i2 = i + this.radialSamples + 1;
			} else {
				i0 = i;
				i1 = this.vertexCount - 2;
				i2 = i + 1;
			}

			if (!this.viewInside) {
				indices[index++] = i0;
				indices[index++] = i1;
				indices[index++] = i2;
			} else {
				indices[index++] = i0;
				indices[index++] = i2;
				indices[index++] = i1;
			}
		}

		// north pole triangles
		// - point iOffset point to the start of the last generated ring of vertices
		var iOffset = (zEnd - zBegin - 1) * (this.radialSamples + 1);
		for (var i = 0; i < this.radialSamples; i++) {
			var i0, i1, i2;

			if (!this._useSharedPoleVertices) {
				// as we are in the last pole ring (with iOffset added), step back to the
				// next-to-last as there is no pole vertex in this mode.
				i0 = i + iOffset - this.radialSamples - 1;
				i1 = i + iOffset - this.radialSamples;
				i2 = i + iOffset;
			} else {
				i0 = i + iOffset;
				i1 = i + 1 + iOffset;
				i2 = this.vertexCount - 1;
			}

			if (!this.viewInside) {
				indices[index++] = i0;
				indices[index++] = i1;
				indices[index++] = i2;
			} else {
				indices[index++] = i0;
				indices[index++] = i2;
				indices[index++] = i1;
			}
		}
		return this;
	};

	//! AT: there's a method for doing this exact thing on typed arrays, copyWithin()
	function copyInternal(buf, from, to) {
		buf[to * 3 + 0] = buf[from * 3 + 0];
		buf[to * 3 + 1] = buf[from * 3 + 1];
		buf[to * 3 + 2] = buf[from * 3 + 2];
	}

	/**
	 * Returns a clone of this sphere
	 * @returns {Sphere}
	 */
	Sphere.prototype.clone = function () {
		var options = ObjectUtils.shallowSelectiveClone(this, ['zSamples', 'radialSamples', 'radius', 'textureMode']);

		return new Sphere(options);
	};

	/** Possible texture wrapping modes: Linear, Projected, Polar, Chromeball
	 * @type {Object}
	 */
	Sphere.TextureModes = {
		Linear: 'Linear',
		Projected: 'Projected',
		Polar: 'Polar',
		Chromeball: 'Chromeball'
	};

	module.exports = Sphere;

/***/ },
/* 30 */
/***/ function(module, exports, __webpack_require__) {

	var Shader = __webpack_require__(31);
	var ObjectUtils = __webpack_require__(6);

	/**
	 * A Material defines the look of an object
	 * @param {string} [name='Default Material'] Material name
	 * @param {{ vshader, fshader }} [shaderDefinition] Optional shader to associate with the material
	 */
	function Material(name, shaderDefinition) {
		this.id = null;

		/** Material name
		 * @type {string}
		 */
		this.name = 'Default Material';

		/** [Shader]{@link Shader} to use when rendering
		 * @type {Shader}
		 */
		this.shader = null;

		//! AT: horrendous type checking follows
		// function has 2 signatures because the deprecated .createMaterial had parameters in inverse order
		if (typeof name === 'string') {
			this.name = name;
		} else if (name && name.vshader && name.fshader) {
			this.shader = Material.createShader(name);
		}

		if (shaderDefinition && shaderDefinition.vshader && shaderDefinition.fshader) {
			this.shader = Material.createShader(shaderDefinition);
		} else if (typeof shaderDefinition === 'string') {
			this.name = shaderDefinition;
		}

		/** Possible overrides for shader uniforms
		 * @type {Object}
		 * @default
		 */
		this.uniforms = {};

		// Texture storage
		this._textureMaps = {};
		/* REVIEW
		 * There was an idea to specify and jsdoc uniforms.materialDiffuse etc instead,
		 * since those are the ones we use now
		 */

		/* Specification of colors for this Material
		 * @type {Object}
		 * @property {Array<number>} ambient The ambient color, [r, g, b, a]
		 * @property {Array<number>} diffuse The diffuse color, [r, g, b, a]
		 * @property {Array<number>} emissive The emissive color, [r, g, b, a]
		 * @property {Array<number>} specular The specular color, [r, g, b, a]
		 * @property {number} shininess The shininess exponent.
		 */
		/*
		this.materialState = {
			ambient: Shader.DEFAULT_AMBIENT,
			diffuse: Shader.DEFAULT_DIFFUSE,
			emissive: Shader.DEFAULT_EMISSIVE,
			specular: Shader.DEFAULT_SPECULAR,
			shininess: Shader.DEFAULT_SHININESS
		};
		*/

		/** Specification of culling for this Material
		 * @type {Object}
		 * @property {boolean} enabled
		 * @property {string} cullFace possible values: 'Front', 'Back', 'FrontAndBack', default 'Back'
		 * @property {string} frontFace possible values: 'CW' (clockwise) and 'CCW' (counterclockwise - default)
		 */
		this.cullState = {
			enabled: true,
			cullFace: 'Back', // Front, Back, FrontAndBack
			frontFace: 'CCW' // CW, CCW
		};

		/** Specification of blending for this Material
		 * @type {Object}
		 * @property {string} blending possible values: <strong>'NoBlending'</strong>, 'TransparencyBlending', 'AdditiveBlending', 'SubtractiveBlending', 'MultiplyBlending', 'CustomBlending'
		 * @property {string} blendEquation possible values: <strong>'AddEquation'</strong>, 'SubtractEquation', 'ReverseSubtractEquation'
		 * @property {string} blendSrc possible values: <strong>'SrcAlphaFactor'</strong>, 'ZeroFactor', 'OneFactor', 'SrcColorFactor', 'OneMinusSrcColorFactor', 'OneMinusSrcAlphaFactor', 'OneMinusDstAlphaFactor''DstColorFactor', 'OneMinusDstColorFactor', 'SrcAlphaSaturateFactor', 'DstAlphaFactor'
		 * @property {string} blendDst possible values: 'SrcAlphaFactor', 'ZeroFactor', 'OneFactor', 'SrcColorFactor', 'OneMinusSrcColorFactor', <strong>'OneMinusSrcAlphaFactor'</strong>, 'OneMinusDstAlphaFactor''DstColorFactor', 'OneMinusDstColorFactor', 'DstAlphaFactor'
		 */
		this.blendState = {
			blending: 'NoBlending',
			blendEquation: 'AddEquation',
			blendSrc: 'SrcAlphaFactor',
			blendDst: 'OneMinusSrcAlphaFactor'
		};

		/** Specification of depth handling for this Material
		 * @type {Object}
		 * @property {boolean} enabled default: true
		 * @property {boolean} write default: true
		 * @property {string} depthFunc possible values: 'Never', 'Always', 'Less', 'LessEqual', 'Equal', 'GreaterEqual', 'Greater', 'NotEqual'
		 */
		this.depthState = {
			enabled: true,
			write: true,
			depthFunc: 'LessEqual'
		};

		/** Specification of the polygon offset for this Material
		 * @type {Object}
		 * @property {boolean} enabled
		 * @property {number} factor default: 1
		 * @property {number} units default: 1
		 */
		this.offsetState = {
			enabled: false,
			factor: 1,
			units: 1
		};

		/** Render the mesh twice with front/back-facing for double transparency rendering. Default is false.
		 * @type {boolean}
		 * @default false
		 */
		this.dualTransparency = false;

		/** Show wireframe on this material. Default is false.
		 * @type {boolean}
		 * @default false
		 */
		this.wireframe = false;

		/** Use flat rendering mode for this material. Default is false.
		 * @type {boolean}
		 * @default false
		 */
		this.flat = false;

		/** Width of lines, if line rendering / wireframe is enabled. Default is 1.
		 * @type {number}
		 * @default 1
		 */
		this.lineWidth = 1;

		/** Determines the order in which an object is drawn. There are four pre-defined render queues:
		 *		<ul>
		 *			<li>RenderQueue.BACKGROUND = Rendered before any other objects. Commonly used for skyboxes and the likes (0-999)
		 *			<li>RenderQueue.OPAQUE = Used for most objects, typically opaque geometry. Rendered front to back (1000-1999)
		 *			<li>RenderQueue.TRANSPARENT = For all alpha-blended objects. Rendered back to front (2000-2999)
		 *			<li>RenderQueue.OVERLAY = For overlay effects like lens-flares etc (3000+)
		 *		</ul>
		 * By default materials use the render queue of the shader. See {@link Shader} or {@link RenderQueue} for more info
		 * @type {number}
		 */
		this.renderQueue = null;

		this.fullOverride = false;
		this.errorOnce = false;

		// @ifdef DEBUG
		Object.seal(this);
		// @endif
	}

	/**
	 * Sets a texture in a specific slot
	 *
	 * @param {string} name Name of texture slot
	 * @param {Texture} texture Texture to set
	 */
	Material.prototype.setTexture = function (name, texture) {
		this._textureMaps[name] = texture;
	};

	/**
	 * Gets a texture in a specific slot
	 *
	 * @param {string} name Name of texture slot to retrieve texture from
	 * @returns {Texture} Texture if found, or undefined if not in slot
	 */
	Material.prototype.getTexture = function (name) {
		return this._textureMaps[name];
	};

	/**
	 * Removes a texture in a specific slot
	 *
	 * @param {string} name Name of texture slot to remove
	 */
	Material.prototype.removeTexture = function (name) {
		delete this._textureMaps[name];
	};

	/**
	 * Get all textures as an array
	 *
	 * @returns {Array<Texture>} Array containing all set textures
	 */
	Material.prototype.getTextures = function () {
		var textures = [];
		for (var key in this._textureMaps) {
			textures.push(this._textureMaps[key]);
		}
		return textures;
	};

	/**
	 * Get the map of [slot_name]: [Texture]
	 *
	 * @returns {Object} Mapping of slot - textures
	 */
	Material.prototype.getTextureEntries = function () {
		return this._textureMaps;
	};

	/**
	 * Returns the render queue of this material
	 * @returns {number}
	 */
	Material.prototype.getRenderQueue = function () {
		if (this.renderQueue !== null) {
			return this.renderQueue;
		} else if (this.shader !== null) {
			return this.shader.renderQueue;
		}
		return 1000;
	};

	/**
	 * Sets the render queue of this material
	 * @param {number} queue See {@link RenderQueue} for options
	 */
	Material.prototype.setRenderQueue = function (queue) {
		this.renderQueue = queue;
	};

	/**
	 * Returns a clone of this material
	 * @param {Object} [options]
	 * @param {boolean} [options.shareUniforms=false] Cloning this material clones the uniforms by default
	 * @param {boolean} [options.shareTextures=false] Cloning this material clones the textures by default
	 * @returns {Material}
	 */
	Material.prototype.clone = function (options) {
		options = options || {};

		var clone = new Material(this.name);

		clone.id = this.id;
		clone.name = this.name;
		clone.shader = this.shader.clone();

		if (options.shareUniforms) {
			clone.uniforms = this.uniforms;
		} else {
			clone.uniforms = ObjectUtils.deepClone(this.uniforms);
		}

		if (options.shareTextures) {
			var textureKeys = Object.keys(this._textureMaps);
			for (var i = 0; i < textureKeys.length; i++) {
				var textureKey = textureKeys[i];
				clone._textureMaps[textureKey] = this._textureMaps[textureKey];
			}
		} else {
			var textureKeys = Object.keys(this._textureMaps);
			for (var i = 0; i < textureKeys.length; i++) {
				var textureKey = textureKeys[i];
				clone._textureMaps[textureKey] = this._textureMaps[textureKey].clone();
			}
		}

		clone.cullState.enabled = this.cullState.enabled;
		clone.cullState.cullFace = this.cullState.cullFace;
		clone.cullState.frontFace = this.cullState.frontFace;

		clone.blendState.blending = this.blendState.blending;
		clone.blendState.blendEquation = this.blendState.blendEquation;
		clone.blendState.blendSrc = this.blendState.blendSrc;
		clone.blendState.blendDst = this.blendState.blendDst;

		clone.depthState.enabled = this.depthState.enabled;
		clone.depthState.write = this.depthState.write;

		clone.offsetState.enabled = this.offsetState.enabled;
		clone.offsetState.factor = this.offsetState.factor;
		clone.offsetState.units = this.offsetState.units;

		clone.dualTransparency = this.dualTransparency;

		clone.wireframe = this.wireframe;
		clone.flat = this.flat;

		clone.renderQueue = this.renderQueue;

		clone.fullOverride = this.fullOverride;
		clone.errorOnce = this.errorOnce;

		return clone;
	};

	/**
	 * Creates a new or finds an existing, cached Shader object
	 *
	 * @param {ShaderDefinition} shaderDefinition see {@link Shader}
	 * @param {string} [name=DefaultShader]
	 * @returns {Shader}
	 */
	Material.createShader = function (shaderDefinition, name) {
		//! AT: function has parameters in reverse order than the constructor
		var shader = new Shader(name || null, shaderDefinition);
		if (shader.name === null) {
			shader.name = 'DefaultShader' + shader._id;
		}
		return shader;
	};

	/**
	 * Clears the shader cache.
	 * @deprecated Deprecated since 0.12.0 and scheduled for removal in 0.14.0
	 */
	Material.clearShaderCache = function () {
	};

	/**
	 * Creates an 'empty' material
	 * @private
	 * @param shaderDefinition see {@link Shader}
	 * @param name [name='Empty Material'] The name of the newly created material
	 * @returns {Material}
	 */
	Material.createEmptyMaterial = function (shaderDefinition, name) {
		var material = new Material(name || 'Empty Material');
		material.empty();
		if (shaderDefinition) {
			material.shader = Material.createShader(shaderDefinition);
		} else {
			material.shader = undefined;
		}
		return material;
	};

	//! AT: how about a immutable material named EMPTY and a clone method for materials instead of this mutable madness?
	/**
	 * Removed the material's properties
	 * @private
	 */
	Material.prototype.empty = function () {
		this.cullState = {};
		this.blendState = {};
		this.depthState = {};
		this.offsetState = {};
		this.wireframe = undefined;
		this.renderQueue = undefined;
		this.flat = undefined;
		this._textureMaps = {};
		this.shader = undefined;
		this.uniforms = {};
	};

	module.exports = Material;


/***/ },
/* 31 */
/***/ function(module, exports, __webpack_require__) {

	var ShaderCall = __webpack_require__(32);
	var Matrix3 = __webpack_require__(24);
	var Matrix4 = __webpack_require__(33);
	var World = __webpack_require__(34);
	var RenderQueue = __webpack_require__(43);
	var ObjectUtils = __webpack_require__(6);
	var SystemBus = __webpack_require__(44);

	/* global WebGLRenderingContext */

	/**
	 * Defines vertex and fragment shader and uniforms to shader callbacks
	 * @param {string} name Shader name (mostly for debug/tool use)
	 * @param {ShaderDefinition} shaderDefinition Shader data
	 *
	 * <code>
	 * {
	 *    vshader: [required] vertex shader source
	 *    fshader: [required] fragment shader source
	 *    defines : shader definitions (becomes #define)
	 *    attributes : attribute bindings
	 *       attribute bindings need to map to an attribute in the meshdata being rendered
	 *    uniforms : uniform bindings
	 *       uniform bindings can be a value (like 2.5 or [1, 2]) or a function
	 * }
	 * </code>
	 */
	function Shader(name, shaderDefinition) {
		if (!shaderDefinition.vshader || !shaderDefinition.fshader) {
			throw new Error('Missing shader sources for shader: ' + name);
		}

		this.originalShaderDefinition = shaderDefinition;
		this.shaderDefinition = shaderDefinition;

		this.origVertexSource = shaderDefinition.vshader;
		this.origFragmentSource = shaderDefinition.fshader;

		/** The shader name
		 * @type {string}
		 */
		this.name = name;

		this.shaderProgram = null;
		this.vertexShader = null;
		this.fragmentShader = null;

		/**
		 * The renderer where the program and shaders were allocated.
		 * @type {WebGLRenderingContext}
		 */
		this.renderer = null;

		/**
		 * Attributes detected in the shader source code.
		 * Maps attribute variable's name to <code>{format: string}</code>
		 * @type {Object<string, object>}}
		 */
		this.attributeMapping = {};

		/**
		 * Maps attribute variable's name to attribute location (from getAttribLocation).
		 * @type {Object<string, number>}
		 */
		this.attributeIndexMapping = {};

		/**
		 * Uniforms detected in the shader source code.
		 * Maps variable name to <code>{format: string}</code>.
		 * @type {Object<string, object>}
		 */
		this.uniformMapping = {};

		/**
		 * Maps uniform variable name to ShaderCall object.
		 * @type {Object<string, ShaderCall>}
		 */
		this.uniformCallMapping = {};

		/**
		 * Texture slots detected in the shader source code.
		 * Will be an array of <code>{format: string, name: string}</code>
		 * @type {Array}
		 */
		this.textureSlots = [];
		this.textureSlotsNaming = {};
		this.textureIndex = 0;

		this.currentCallbacks = {};

		this.overridePrecision = shaderDefinition.precision || null;
		this.processors = shaderDefinition.processors;
		this.builder = shaderDefinition.builder;
		this.defines = shaderDefinition.defines || {};
		this.attributes = shaderDefinition.attributes || {};
		this.uniforms = shaderDefinition.uniforms || {};
		this.defineKey = shaderDefinition.defineKey || '';
		this.defineKeyDirty = true;
		this.frameStart = true;
		this.attributeKeys = null;
		this.matchedUniforms = [];

		/** Determines the order in which an object is drawn. There are four pre-defined render queues:
		 *		<ul>
		 *			<li>RenderQueue.BACKGROUND = Rendered before any other objects. Commonly used for skyboxes and the likes (0-999)
		 *			<li>RenderQueue.OPAQUE = Used for most objects, typically opaque geometry. Rendered front to back (1000-1999)
		 *			<li>RenderQueue.TRANSPARENT = For all alpha-blended objects. Rendered back to front (2000-2999)
		 *			<li>RenderQueue.OVERLAY = For overlay effects like lens-flares etc (3000+)
		 *		</ul>
		 * By default materials use the render queue of the shader. See {@link RenderQueue} for more info
		 * @type {number}
		 */
		this.renderQueue = RenderQueue.OPAQUE;

		// this._id = Shader.id++;
		if (Shader.cache.has(shaderDefinition)) {
			this._id = Shader.cache.get(shaderDefinition);
		} else {
			this._id = Shader.cache.size;
			Shader.cache.set(shaderDefinition, this._id);
		}
		// console.log('creating shader', this._id, this.name);

		this.errorOnce = false;

		this.vertexSource = typeof this.origVertexSource === 'function' ? this.origVertexSource() : this.origVertexSource;
		this.fragmentSource = typeof this.origFragmentSource === 'function' ? this.origFragmentSource() : this.origFragmentSource;

		// @ifdef DEBUG
		Object.seal(this);
		// @endif
	}

	// Shader.id = 0;
	Shader.cache = new Map();

	Shader.prototype.clone = function () {
		return new Shader(this.name, ObjectUtils.deepClone({
			precision: this.precision,
			processors: this.processors,
			builder: this.builder,
			defines: this.defines,
			attributes: this.attributes,
			uniforms: this.uniforms,
			vshader: this.origVertexSource,
			fshader: this.origFragmentSource,
			defineKey: this.defineKey
		}));
	};

	Shader.prototype.cloneOriginal = function () {
		return new Shader(this.name, this.originalShaderDefinition);
	};

	/**
	 * Compiles a shader and does not apply it
	 * @private
	 * @param renderer
	 */
	Shader.prototype.precompile = function (renderer) {
		if (this.shaderProgram === null) {
			this._investigateShaders();
			this.addDefines(this.defines);
			this.addPrecision(this.overridePrecision || renderer.shaderPrecision);
			this.compile(renderer);
		}
	};

	/*
	 * Matches an attribute or uniform variable declaration.
	 *
	 * Match groups:
	 *
	 *   1: type (attribute|uniform)
	 *   2: format (float|int|bool|vec2|vec3|vec4|mat2|mat3|mat4|sampler2D|sampler3D|samplerCube)
	 *   3: variable name
	 *   4: if exists, the variable is an array
	 */
	var regExp = /\b(attribute|uniform)\s+(float|int|bool|vec2|vec3|vec4|mat2|mat3|mat4|sampler2D|sampler3D|samplerCube)\s+(\w+)(\s*\[\s*\w+\s*\])*;/g;

	Shader.prototype.compileProgram = function (renderer) {
		if (this.shaderProgram === null) {
			this._investigateShaders();
			this.addDefines(this.defines);
			this.addPrecision(this.overridePrecision || renderer.shaderPrecision);
			this.compile(renderer);
		}
	};

	Shader.prototype.activateProgram = function (record, context) {
		if (record.usedProgram !== this.shaderProgram) {
			context.useProgram(this.shaderProgram);
			record.usedProgram = this.shaderProgram;
			return true;
		}
	};

	Shader.prototype.bindAttributeKey = function (record, renderer, attributeMap, key) {
		var attribute = attributeMap[this.attributes[key]];
		if (!attribute) {
			return;
		}

		var attributeIndex = this.attributeIndexMapping[key];
		if (attributeIndex === undefined) {
			// console.warn('Attribute binding [' + name + '] does not exist in the shader.');
			return;
		}

		record.newlyEnabledAttributes[attributeIndex] = true;
		renderer.bindVertexAttribute(attributeIndex, attribute);
	};

	Shader.prototype.bindAttributes = function (record, renderer, attributeMap) {
		if (this.attributes) {
			for (var i = 0, l = this.attributeKeys.length; i < l; i++) {
				this.bindAttributeKey(record, renderer, attributeMap, this.attributeKeys[i]);
			}
		}
	};

	Shader.prototype.disableAttributes = function (record, context) {
		for (var i = 0, l = record.enabledAttributes.length; i < l; i++) {
			var enabled = record.enabledAttributes[i];
			var newEnabled = record.newlyEnabledAttributes[i];
			if (!newEnabled && enabled) {
				context.disableVertexAttribArray(i);
				record.enabledAttributes[i] = false;
			}
		}
	};

	Shader.prototype.enableAttributes = function (record, context) {
		for (var i = 0, l = record.newlyEnabledAttributes.length; i < l; i++) {
			var enabled = record.enabledAttributes[i];
			var newEnabled = record.newlyEnabledAttributes[i];
			if (newEnabled && !enabled) {
				context.enableVertexAttribArray(i);
				record.enabledAttributes[i] = true;
			}
		}
	};

	Shader.prototype.matchUniforms = function (shaderInfo) {
		var uniforms = this.matchedUniforms;
		if (uniforms) {
			this.textureIndex = 0;

			for (var i = 0, l = uniforms.length; i < l; i++) {
				this._bindUniform(uniforms[i], shaderInfo);
			}
		}
	};

	Shader.prototype.apply = function (shaderInfo, renderer) {
		var context = renderer.context;
		var record = renderer.rendererRecord;

		this.compileProgram(renderer);
		// Set the ShaderProgram active
		this.activateProgram(record, context);

		record.newlyEnabledAttributes.length = 0;

		// Bind attributes
		this.bindAttributes(record, renderer, shaderInfo.meshData.attributeMap);

		this.disableAttributes(record, context);
		this.enableAttributes(record, context);
		this.matchUniforms(shaderInfo);
	};

	Shader.prototype.defineValue = function (shaderInfo, name) {
		var defValue = shaderInfo.material.uniforms[name];
		if (defValue === undefined) {
			defValue = this.uniforms[name];
		}
		return defValue;
	};


	Shader.prototype.mapSlot = function (shaderInfo, mapping, slot) {
		var maps = shaderInfo.material.getTexture(slot.mapping);
		if (maps instanceof Array) {
			this.arrayType(mapping, slot, maps);
		} else {
			slot.index = this.textureIndex;
			mapping.call(this.textureIndex++);
		}
	};

	Shader.prototype.arrayType = function (mapping, slot, maps) {
		var arr = [];
		slot.index = [];
		for (var i = 0; i < maps.length; i++) {
			slot.index.push(this.textureIndex);
			arr.push(this.textureIndex++);
		}
		mapping.call(arr);
	};

	Shader.prototype.stringType = function (shaderInfo, name, mapping) {
		var callback = this.currentCallbacks[name];
		if (callback) {
			callback(mapping, shaderInfo);
		} else {
			var slot = this.textureSlotsNaming[name];
			if (slot !== undefined) {
				this.mapSlot(shaderInfo, mapping, slot);
			}
		}
	};

	Shader.prototype.callMapping = function (shaderInfo, name, mapping) {
		var defValue = this.defineValue(shaderInfo, name);
		var type = typeof defValue;
		if (type === 'string') {
			this.stringType(shaderInfo, name, mapping, defValue);
		} else {
			var value = type === 'function' ? defValue(shaderInfo) : defValue;
			if (value !== undefined) {
				mapping.call(value);
			}
		}
	};

	Shader.prototype._bindUniform = function (name, shaderInfo) {
		var mapping = this.uniformCallMapping[name];
		if (mapping === undefined) {
			return;
		}
		this.callMapping(shaderInfo, name, mapping);
	};

	Shader.prototype.setDefine = function (key, value) {
		this.defineKeyDirty = this.defineKeyDirty || this.defines[key] !== value;
		this.defines[key] = value;
	};

	Shader.prototype.removeDefine = function (key) {
		this.defineKeyDirty = this.defineKeyDirty || this.defines[key] !== undefined;
		this.defines[key] = undefined;
	};

	Shader.prototype.hasDefine = function (key) {
		return this.defines[key] !== false && this.defines[key] !== undefined;
	};

	Shader.prototype.startFrame = function () {
		this.frameStart = true;
	};

	Shader.prototype.endFrame = function () {
		this.frameStart = false;
	};

	Shader.prototype.updateProcessors = function (renderInfo) {
		if (this.processors) {
			for (var j = 0; j < this.processors.length; j++) {
				this.processors[j](this, renderInfo);
			}
		}
	};

	Shader.prototype.getDefineKey = function (definesIndices) {
		if (this.defineKeyDirty) {
			var key = 'Key:' + this.name;
			var defineArray = Object.keys(this.defines);
			for (var i = 0; i < defineArray.length; i++) {
				var defineArrayKey = defineArray[i];
				var defineVal = this.defines[defineArrayKey];
				if (defineVal === undefined || defineVal === false) {
					continue;
				}
				if (definesIndices.indexOf(defineArrayKey) === -1) {
					definesIndices.push(defineArrayKey);
				}
			}
			for (var i = 0, l = definesIndices.length; i < l; i++) {
				var defineArrayKey = definesIndices[i];
				var defineVal = this.defines[defineArrayKey];
				if (defineVal === undefined || defineVal === false) {
					continue;
				}
				key += '_' + i + ':' + defineVal;
			}
			this.defineKey = key;
			this.defineKeyDirty = false;
		}

		return this.defineKey;
	};


	Shader.prototype.rebuild = function () {
		this.shaderProgram = null;
		this.attributeMapping = {};
		this.attributeIndexMapping = {};
		this.uniformMapping = {};
		this.uniformCallMapping = {};
		this.currentCallbacks = {};
		this.attributeKeys = null;
		this.vertexSource = typeof this.origVertexSource === 'function' ? this.origVertexSource() : this.origVertexSource;
		this.fragmentSource = typeof this.origFragmentSource === 'function' ? this.origFragmentSource() : this.origFragmentSource;
		this.defineKeyDirty = true;
	};

	Shader.prototype._investigateShaders = function () {
		this.textureSlots = [];
		this.textureSlotsNaming = {};
		Shader.investigateShader(this.vertexSource, this);
		Shader.investigateShader(this.fragmentSource, this);
	};

	/**
	 * Extract shader variable definitions from shader source code.
	 * @param {string} source The source code.
	 * @param {Object} target
	 * @param {Object} target.attributeMapping
	 * @param {Object} target.uniformMapping
	 * @param {Array} target.textureSlots
	 */
	Shader.investigateShader = function (source, target) {
		regExp.lastIndex = 0;
		var matcher = regExp.exec(source);

		while (matcher !== null) {
			var definition = {
				// data type: float, int, ...
				format: matcher[2]
			};
			var type = matcher[1];  // "attribute" or "uniform"
			var variableName = matcher[3];
			var arrayDeclaration = matcher[4];
			if (arrayDeclaration) {
				if (definition.format === 'float') {
					definition.format = 'floatarray';
				} else if (definition.format === 'int') {
					definition.format = 'intarray';
				} else if (definition.format.indexOf('sampler') === 0) {
					definition.format = 'samplerArray';
				}
			}

			if (type === 'attribute') {
				target.attributeMapping[variableName] = definition;
			} else {
				if (definition.format.indexOf('sampler') === 0) {
					var textureSlot = {
						format: definition.format,
						name: variableName,
						mapping: target.uniforms[variableName],
						index: target.textureSlots.length
					};
					target.textureSlots.push(textureSlot);
					target.textureSlotsNaming[textureSlot.name] = textureSlot;
				}
				target.uniformMapping[variableName] = definition;
			}

			matcher = regExp.exec(source);
		}
	};

	Shader.prototype.compile = function (renderer) {
		var context = renderer.context;
		this.renderer = renderer;
		this.vertexShader = this._getShader(context, context.VERTEX_SHADER !== undefined ? context.VERTEX_SHADER : WebGLRenderingContext.VERTEX_SHADER, this.vertexSource);
		this.fragmentShader = this._getShader(context, context.FRAGMENT_SHADER !== undefined ? context.FRAGMENT_SHADER : WebGLRenderingContext.FRAGMENT_SHADER, this.fragmentSource);

		if (this.vertexShader === null || this.fragmentShader === null) {
			console.error('Shader error - no shaders');
		}

		this.shaderProgram = context.createProgram();

		var error = context.getError();
		if (this.shaderProgram === null || error !== 0) {
			console.error('Shader error: ' + error + ' [shader: ' + this.name + ']');
			SystemBus.emit('goo.shader.error');
		}

		context.attachShader(this.shaderProgram, this.vertexShader);
		context.attachShader(this.shaderProgram, this.fragmentShader);

		// Link the Shader Program
		context.linkProgram(this.shaderProgram);
		if (!context.getProgramParameter(this.shaderProgram, (context.LINK_STATUS !== undefined ? context.LINK_STATUS : WebGLRenderingContext.LINK_STATUS))) {
			var errInfo = context.getProgramInfoLog(this.shaderProgram);
			console.error('Could not initialise shaders: ' + errInfo);
			SystemBus.emit('goo.shader.error', errInfo);
		}

		for (var key in this.attributeMapping) {
			var attributeIndex = context.getAttribLocation(this.shaderProgram, key);
			if (attributeIndex === -1) {
				continue;
			}

			this.attributeIndexMapping[key] = attributeIndex;
		}

		for (var key in this.uniformMapping) {
			var uniform = context.getUniformLocation(this.shaderProgram, key);

			if (!uniform) {
				var l = this.textureSlots.length;
				for (var i = 0; i < l; i++) {
					var slot = this.textureSlots[i];
					if (slot.name === key) {
						this.textureSlots.splice(i, 1);
						delete this.textureSlotsNaming[slot.name];
						for (; i < l - 1; i++) {
							this.textureSlots[i].index--;
						}
						break;
					}
				}
				continue;
			}

			this.uniformCallMapping[key] = new ShaderCall(context, uniform, this.uniformMapping[key].format);
		}

		if (this.attributes) {
			this.attributeKeys = Object.keys(this.attributes);
		}

		if (this.uniforms) {
			this.matchedUniforms = [];
			for (var name in this.uniforms) {
				var mapping = this.uniformCallMapping[name];
				if (mapping !== undefined) {
					this.matchedUniforms.push(name);
				}

				var value = this.uniforms[name];
				if (this.defaultCallbacks[value]) {
					this.currentCallbacks[name] = this.defaultCallbacks[value];
				}
			}
		}
	};

	var errorRegExp = /\b\d+:(\d+):\s(.+)\b/g;
	var errorRegExpIE = /\((\d+),\s*\d+\):\s(.+)/g;

	Shader.prototype._getShader = function (context, type, source) {
		var shader = context.createShader(type);

		context.shaderSource(shader, source);
		context.compileShader(shader);

		// check if the Shader is successfully compiled
		if (!context.getShaderParameter(shader, context.COMPILE_STATUS !== undefined ? context.COMPILE_STATUS : WebGLRenderingContext.COMPILE_STATUS)) {
			var infoLog = context.getShaderInfoLog(shader);
			var shaderType = type === (context.VERTEX_SHADER !== undefined ? context.VERTEX_SHADER : WebGLRenderingContext.VERTEX_SHADER) ? 'VertexShader' : 'FragmentShader';

			errorRegExp.lastIndex = 0;
			var errorMatcher = errorRegExp.exec(infoLog);
			if (errorMatcher === null) {
				errorMatcher = errorRegExpIE.exec(infoLog);
			}
			if (errorMatcher !== null) {
				while (errorMatcher !== null) {
					var splitSource = source.split('\n');
					var lineNum = errorMatcher[1];
					var errorStr = errorMatcher[2];
					console.error('Error in ' + shaderType + ' - [' + this.name + '][' + this._id + '] at line ' + lineNum + ':');
					console.error('\tError: ' + errorStr);
					console.error('\tSource: ' + splitSource[lineNum - 1]);
					errorMatcher = errorRegExp.exec(infoLog);
				}
			} else {
				console.error('Error in ' + shaderType + ' - [' + this.name + '][' + this._id + '] ' + infoLog);
			}

			return null;
		}

		return shader;
	};

	var precisionRegExp = /\bprecision\s+(lowp|mediump|highp)\s+(float|int);/g;

	Shader.prototype.addPrecision = function (precision) {
		precisionRegExp.lastIndex = 0;
		var vertMatcher = precisionRegExp.exec(this.vertexSource);
		if (vertMatcher === null) {
			this.vertexSource = 'precision ' + precision + ' float;' + '\n' + this.vertexSource;
		}
		precisionRegExp.lastIndex = 0;
		var fragMatcher = precisionRegExp.exec(this.fragmentSource);
		if (fragMatcher === null) {
			this.fragmentSource = 'precision ' + precision + ' float;' + '\n' + this.fragmentSource;
		}
	};

	Shader.prototype.addDefines = function (defines) {
		if (!defines) {
			return;
		}

		var defineStr = this.generateDefines(defines);

		this.vertexSource = defineStr + '\n' + this.vertexSource;
		this.fragmentSource = defineStr + '\n' + this.fragmentSource;
	};

	Shader.prototype.generateDefines = function (defines) {
		var chunks = [];
		for (var d in defines) {
			var value = defines[d];
			if (value === false || value === undefined) {
				continue;
			}

			var chunk = '#define ' + d + ' ' + value;
			chunks.push(chunk);
		}

		return chunks.join('\n');
	};

	function setupDefaultCallbacks(defaultCallbacks) {
		defaultCallbacks[Shader.PROJECTION_MATRIX] = function (uniformCall, shaderInfo) {
			var matrix = shaderInfo.camera.getProjectionMatrix();
			uniformCall.uniformMatrix4fv(matrix);
		};
		defaultCallbacks[Shader.VIEW_MATRIX] = function (uniformCall, shaderInfo) {
			var matrix = shaderInfo.camera.getViewMatrix();
			uniformCall.uniformMatrix4fv(matrix);
		};
		defaultCallbacks[Shader.WORLD_MATRIX] = function (uniformCall, shaderInfo) {
			//! AT: when is this condition ever true?
			var matrix = shaderInfo.transform !== undefined ? shaderInfo.transform.matrix : Matrix4.IDENTITY;
			uniformCall.uniformMatrix4fv(matrix);
		};
		defaultCallbacks[Shader.NORMAL_MATRIX] = function (uniformCall, shaderInfo) {
			//! AT: when is this condition ever true?
			var matrix = shaderInfo.transform !== undefined ? shaderInfo.transform.normalMatrix : Matrix3.IDENTITY;
			uniformCall.uniformMatrix3fv(matrix);
		};

		defaultCallbacks[Shader.VIEW_INVERSE_MATRIX] = function (uniformCall, shaderInfo) {
			var matrix = shaderInfo.camera.getViewInverseMatrix();
			uniformCall.uniformMatrix4fv(matrix);
		};
		defaultCallbacks[Shader.VIEW_PROJECTION_MATRIX] = function (uniformCall, shaderInfo) {
			var matrix = shaderInfo.camera.getViewProjectionMatrix();
			uniformCall.uniformMatrix4fv(matrix);
		};
		defaultCallbacks[Shader.VIEW_PROJECTION_INVERSE_MATRIX] = function (uniformCall, shaderInfo) {
			var matrix = shaderInfo.camera.getViewProjectionInverseMatrix();
			uniformCall.uniformMatrix4fv(matrix);
		};

		for (var i = 0; i < 16; i++) {
			defaultCallbacks[Shader['TEXTURE' + i]] = (function (i) {
				return function (uniformCall) {
					uniformCall.uniform1i(i);
				};
			})(i);
		}

		for (var i = 0; i < 8; i++) {
			defaultCallbacks[Shader['LIGHT' + i]] = (function (i) {
				return function (uniformCall, shaderInfo) {
					var light = shaderInfo.lights[i];
					if (light !== undefined) {
						uniformCall.uniform3f(light.translation.x, light.translation.y, light.translation.z);
					} else {
						uniformCall.uniform3f(-20, 20, 20);
					}
				};
			})(i);
		}
		defaultCallbacks[Shader.LIGHTCOUNT] = function (uniformCall, shaderInfo) {
			uniformCall.uniform1i(shaderInfo.lights.length);
		};

		defaultCallbacks[Shader.CAMERA] = function (uniformCall, shaderInfo) {
			var cameraPosition = shaderInfo.camera.translation;
			uniformCall.uniform3f(cameraPosition.x, cameraPosition.y, cameraPosition.z);
		};
		defaultCallbacks[Shader.NEAR_PLANE] = function (uniformCall, shaderInfo) {
			uniformCall.uniform1f(shaderInfo.camera.near);
		};
		defaultCallbacks[Shader.FAR_PLANE] = function (uniformCall, shaderInfo) {
			uniformCall.uniform1f(shaderInfo.camera.far);
		};
		defaultCallbacks[Shader.MAIN_NEAR_PLANE] = function (uniformCall, shaderInfo) {
			uniformCall.uniform1f(shaderInfo.mainCamera.near);
		};
		defaultCallbacks[Shader.MAIN_FAR_PLANE] = function (uniformCall, shaderInfo) {
			uniformCall.uniform1f(shaderInfo.mainCamera.far);
		};
		defaultCallbacks[Shader.MAIN_DEPTH_SCALE] = function (uniformCall, shaderInfo) {
			uniformCall.uniform1f(1.0 / (shaderInfo.mainCamera.far - shaderInfo.mainCamera.near));
		};


		defaultCallbacks[Shader.AMBIENT] = function (uniformCall, shaderInfo) {
			var materialState = shaderInfo.material.materialState !== undefined ? shaderInfo.material.materialState.ambient : Shader.DEFAULT_AMBIENT;
			uniformCall.uniform4fv(materialState);
		};
		defaultCallbacks[Shader.EMISSIVE] = function (uniformCall, shaderInfo) {
			var materialState = shaderInfo.material.materialState !== undefined ? shaderInfo.material.materialState.emissive : Shader.DEFAULT_EMISSIVE;
			uniformCall.uniform4fv(materialState);
		};
		defaultCallbacks[Shader.DIFFUSE] = function (uniformCall, shaderInfo) {
			var materialState = shaderInfo.material.materialState !== undefined ? shaderInfo.material.materialState.diffuse : Shader.DEFAULT_DIFFUSE;
			uniformCall.uniform4fv(materialState);
		};
		defaultCallbacks[Shader.SPECULAR] = function (uniformCall, shaderInfo) {
			var materialState = Shader.DEFAULT_SPECULAR;
			if (shaderInfo.material.materialState !== undefined) {
				materialState = shaderInfo.material.materialState.specular;
				materialState[3] = Math.max(shaderInfo.material.materialState.shininess, 1);
			}
			uniformCall.uniform4fv(materialState);
		};
		defaultCallbacks[Shader.SPECULAR_POWER] = function (uniformCall, shaderInfo) {
			var shininess = shaderInfo.material.materialState !== undefined ? shaderInfo.material.materialState.shininess : Shader.DEFAULT_SHININESS;
			shininess = Math.max(shininess, 1.0);
			uniformCall.uniform1f(shininess);
		};

		defaultCallbacks[Shader.TIME] = function (uniformCall) {
			uniformCall.uniform1f(World.time);
		};
		defaultCallbacks[Shader.TPF] = function (uniformCall) {
			uniformCall.uniform1f(World.tpf);
		};

		defaultCallbacks[Shader.RESOLUTION] = function (uniformCall, shaderInfo) {
			uniformCall.uniform2f(shaderInfo.renderer.viewportWidth, shaderInfo.renderer.viewportHeight);
		};
	}

	Shader.prototype.getShaderDefinition = function () {
		return {
			vshader: this.vertexSource,
			fshader: this.fragmentSource,
			defines: this.defines,
			attributes: this.attributes,
			uniforms: this.uniforms
		};
	};

	Shader.prototype.destroy = function () {
		if (this.shaderProgram) {
			this.renderer.context.deleteProgram(this.shaderProgram);
			this.shaderProgram = null;
		}
		if (this.vertexShader) {
			this.renderer.context.deleteShader(this.vertexShader);
			this.vertexShader = null;
		}
		if (this.fragmentShader) {
			this.renderer.context.deleteShader(this.fragmentShader);
			this.fragmentShader = null;
		}
		this.renderer = null;
	};

	Shader.prototype.toString = function () {
		return this.name;
	};

	Shader.PROJECTION_MATRIX = 'PROJECTION_MATRIX';
	Shader.VIEW_MATRIX = 'VIEW_MATRIX';
	Shader.VIEW_INVERSE_MATRIX = 'VIEW_INVERSE_MATRIX';
	Shader.VIEW_PROJECTION_MATRIX = 'VIEW_PROJECTION_MATRIX';
	Shader.VIEW_PROJECTION_INVERSE_MATRIX = 'VIEW_PROJECTION_INVERSE_MATRIX';
	Shader.WORLD_MATRIX = 'WORLD_MATRIX';
	Shader.NORMAL_MATRIX = 'NORMAL_MATRIX';
	for (var i = 0; i < 8; i++) {
		Shader['LIGHT' + i] = 'LIGHT' + i;
	}
	Shader.CAMERA = 'CAMERA';
	Shader.AMBIENT = 'AMBIENT';
	Shader.EMISSIVE = 'EMISSIVE';
	Shader.DIFFUSE = 'DIFFUSE';
	Shader.SPECULAR = 'SPECULAR';
	Shader.SPECULAR_POWER = 'SPECULAR_POWER';
	Shader.NEAR_PLANE = 'NEAR_PLANE';
	Shader.FAR_PLANE = 'FAR_PLANE';
	Shader.MAIN_NEAR_PLANE = 'MAIN_NEAR_PLANE';
	Shader.MAIN_FAR_PLANE = 'MAIN_FAR_PLANE';
	Shader.MAIN_DEPTH_SCALE = 'DEPTH_SCALE';
	Shader.TIME = 'TIME';
	Shader.TPF = 'TPF';
	Shader.RESOLUTION = 'RESOLUTION';

	Shader.DIFFUSE_MAP = 'DIFFUSE_MAP';
	Shader.NORMAL_MAP = 'NORMAL_MAP';
	Shader.SPECULAR_MAP = 'SPECULAR_MAP';
	Shader.LIGHT_MAP = 'LIGHT_MAP';
	Shader.SHADOW_MAP = 'SHADOW_MAP';
	Shader.AO_MAP = 'AO_MAP';
	Shader.EMISSIVE_MAP = 'EMISSIVE_MAP';
	Shader.DEPTH_MAP = 'DEPTH_MAP';

	Shader.DEFAULT_AMBIENT = [0.1, 0.1, 0.1, 1.0];
	Shader.DEFAULT_EMISSIVE = [0, 0, 0, 0];
	Shader.DEFAULT_DIFFUSE = [0.8, 0.8, 0.8, 1.0];
	Shader.DEFAULT_SPECULAR = [0.6, 0.6, 0.6, 64.0];
	Shader.DEFAULT_SHININESS = 64.0;

	Shader.prototype.defaultCallbacks = {};
	setupDefaultCallbacks(Shader.prototype.defaultCallbacks);

	module.exports = Shader;


/***/ },
/* 32 */
/***/ function(module, exports) {

	/**
	 * Makes sure shader calls are not done when already set
	 */
	function ShaderCall(context, uniform, type) {
		this.context = context;
		this.location = uniform;
		this.location.value = undefined;

		if (type) {
			switch (type) {
				case 'float':
					this.call = this.uniform1f;
					break;
				case 'bool':
				case 'int':
				case 'integer':
				case 'sampler2D':
				case 'sampler3D':
				case 'samplerCube':
					this.call = this.uniform1i;
					break;
				case 'floatarray':
					this.call = this.uniform1fv;
					break;
				case 'intarray':
				case 'samplerArray':
					this.call = this.uniform1iv;
					break;
				case 'ivec2':
					this.call = this.uniform2iv;
					break;
				case 'ivec3':
					this.call = this.uniform3iv;
					break;
				case 'ivec4':
					this.call = this.uniform4iv;
					break;
				case 'vec2':
					this.call = this.uniform2fv;
					break;
				case 'vec3':
					this.call = this.uniform3fv;
					break;
				case 'vec4':
					this.call = this.uniform4fv;
					break;
				case 'mat2':
					this.call = this.uniformMatrix2fv;
					break;
				case 'mat3':
					this.call = this.uniformMatrix3fv;
					break;
				case 'mat4':
					this.call = this.uniformMatrix4fv;
					break;
				default:
					throw new Error('Uniform type not handled: ' + type);
			}
		}
	}

	ShaderCall.prototype.uniform1f = function (v0) {
		var curValue = this.location.value;
		if (curValue === v0) {
			return;
		}
		this.context.uniform1f(this.location, v0);
		this.location.value = v0;
	};

	ShaderCall.prototype.uniform1fv = function (values) {
		var curValue = this.location.value;
		if (curValue !== undefined) {
			if (compareArrays(values, curValue)) {
				return;
			}
		}
		this.context.uniform1fv(this.location, values);
		this.location.value = values.slice();
	};

	ShaderCall.prototype.uniform1i = function (v0) {
		var curValue = this.location.value;
		if (curValue === v0) {
			return;
		}
		this.context.uniform1i(this.location, v0);
		this.location.value = v0;
	};

	ShaderCall.prototype.uniform1iv = function (values) {
		var curValue = this.location.value;
		if (curValue !== undefined) {
			if (compareArrays(values, curValue)) {
				return;
			}
		}
		this.context.uniform1iv(this.location, values);
		this.location.value = values.slice();
	};

	ShaderCall.prototype.uniform2f = function (v0, v1) {
		var curValue = this.location.value;
		if (curValue !== undefined) {
			if (curValue[0] === v0 && curValue[1] === v1) {
				return;
			}
		}
		this.context.uniform2f(this.location, v0, v1);
		this.location.value = [v0, v1];
	};

	ShaderCall.prototype.uniform2fv = function (values) {
		var curValue = this.location.value;
		if (curValue !== undefined) {
			if (compareArrays(values, curValue)) {
				return;
			}
		} else {
			curValue = this.location.value = new Float64Array(values.length);
		}
		this.context.uniform2fv(this.location, values);
		var l = values.length;
		while (l--) {
			curValue[l] = values[l];
		}
	};

	ShaderCall.prototype.uniform2i = function (v0, v1) {
		var curValue = this.location.value;
		if (curValue !== undefined) {
			if (curValue[0] === v0 && curValue[1] === v1) {
				return;
			}
		}
		this.context.uniform2i(this.location, v0, v1);
		this.location.value = [v0, v1];
	};

	ShaderCall.prototype.uniform2iv = function (values) {
		var curValue = this.location.value;
		if (curValue !== undefined) {
			if (compareArrays(values, curValue)) {
				return;
			}
		}
		this.context.uniform2iv(this.location, values);
		this.location.value = values.slice();
	};

	ShaderCall.prototype.uniform3f = function (v0, v1, v2) {
		var curValue = this.location.value;
		if (curValue !== undefined) {
			if (curValue[0] === v0 && curValue[1] === v1 && curValue[2] === v2) {
				return;
			}
		} else {
			curValue = this.location.value = [];
		}
		this.context.uniform3f(this.location, v0, v1, v2);
		curValue[0] = v0;
		curValue[1] = v1;
		curValue[2] = v2;
	};

	ShaderCall.prototype.uniform3fv = function (values) {
		var curValue = this.location.value;
		if (curValue !== undefined) {
			if (compareArrays(values, curValue)) {
				return;
			}
		} else {
			curValue = this.location.value = new Float64Array(values.length);
		}
		this.context.uniform3fv(this.location, values);
		var l = values.length;
		while (l--) {
			curValue[l] = values[l];
		}
	};

	ShaderCall.prototype.uniform3i = function (v0, v1, v2) {
		var curValue = this.location.value;
		if (curValue !== undefined) {
			if (curValue[0] === v0 && curValue[1] === v1 && curValue[2] === v2) {
				return;
			}
		}
		this.context.uniform3i(this.location, v0, v1, v2);
		this.location.value = [v0, v1, v2];
	};

	ShaderCall.prototype.uniform3iv = function (values) {
		var curValue = this.location.value;
		if (curValue !== undefined) {
			if (compareArrays(values, curValue)) {
				return;
			}
		}
		this.context.uniform3iv(this.location, values);
		this.location.value = values.slice();
	};

	ShaderCall.prototype.uniform4f = function (v0, v1, v2, v3) {
		var curValue = this.location.value;
		if (curValue !== undefined) {
			if (curValue[0] === v0 && curValue[1] === v1 && curValue[2] === v2 && curValue[3] === v3) {
				return;
			}
		}
		this.context.uniform4f(this.location, v0, v1, v2, v3);
		this.location.value = [v0, v1, v2, v3];
	};

	ShaderCall.prototype.uniform4fv = function (values) {
		var curValue = this.location.value;
		if (curValue !== undefined) {
			if (compareArrays(values, curValue)) {
				return;
			}
		} else {
			curValue = this.location.value = new Float64Array(values.length);
		}
		this.context.uniform4fv(this.location, values);
		var l = values.length;
		while (l--) {
			curValue[l] = values[l];
		}
	};

	ShaderCall.prototype.uniform4i = function (v0, v1, v2, v3) {
		var curValue = this.location.value;
		if (curValue !== undefined) {
			if (curValue[0] === v0 && curValue[1] === v1 && curValue[2] === v2 && curValue[3] === v3) {
				return;
			}
		}
		this.context.uniform4i(this.location, v0, v1, v2, v3);
		this.location.value = [v0, v1, v2, v3];
	};

	ShaderCall.prototype.uniform4iv = function (values) {
		var curValue = this.location.value;
		if (curValue !== undefined) {
			if (compareArrays(values, curValue)) {
				return;
			}
		}
		this.context.uniform4iv(this.location, values);
		this.location.value = values.slice();
	};

	function compareArrays(a1, a2) {
		var l = a1.length;
		while (l--) {
			if (a1[l] !== a2[l]) {
				return false;
			}
		}
		return true;
	}

	// NOTE: optimize check before calling.
	ShaderCall.prototype.uniformMatrix2fv = function (matrix, transpose) {
		transpose = transpose === true;
		if (!matrix.data) {
			var values = matrix;
			var curValue = this.location.value;
			if (curValue !== undefined) {
				if (compareArrays(values, curValue)) {
					return;
				}
			} else {
				curValue = this.location.value = new Float64Array(values.length);
			}
			this.context.uniformMatrix2fv(this.location, transpose, values);
			var l = values.length;
			while (l--) {
				curValue[l] = values[l];
			}
			return;
		}

		var curValue = this.location.value;
		if (curValue !== undefined) {
			var equals = compareArrays(curValue.data, matrix.data);
			if (equals) {
				return;
			} else {
				curValue.copy(matrix);
			}
		} else {
			this.location.value = matrix.clone();
		}

		this.context.uniformMatrix2fv(this.location, transpose, matrix.data);
	};

	// NOTE: optimize check before calling.
	ShaderCall.prototype.uniformMatrix3fv = function (matrix, transpose) {
		transpose = transpose === true;
		if (!matrix.data) {
			var values = matrix;
			var curValue = this.location.value;
			if (curValue !== undefined) {
				if (compareArrays(values, curValue)) {
					return;
				}
			} else {
				curValue = this.location.value = new Float64Array(values.length);
			}
			this.context.uniformMatrix3fv(this.location, transpose, values);
			var l = values.length;
			while (l--) {
				curValue[l] = values[l];
			}
			return;
		}

		var curValue = this.location.value;
		if (curValue !== undefined) {
			var equals = compareArrays(curValue.data, matrix.data);
			if (equals) {
				return;
			} else {
				curValue.copy(matrix);
			}
		} else {
			this.location.value = matrix.clone();
		}

		this.context.uniformMatrix3fv(this.location, transpose, matrix.data);
	};

	ShaderCall.prototype.uniformMatrix4fv = function (matrix, transpose) {
		transpose = transpose === true;
		if (!matrix.data) {
			var values = matrix;
			var curValue = this.location.value;
			if (curValue !== undefined) {
				if (compareArrays(values, curValue)) {
					return;
				}
			} else {
				curValue = this.location.value = new Float64Array(values.length);
			}
			this.context.uniformMatrix4fv(this.location, transpose, values);
			var l = values.length;
			while (l--) {
				curValue[l] = values[l];
			}
			return;
		}

		var curValue = this.location.value;
		if (curValue !== undefined) {
			var equals = compareArrays(curValue.data, matrix.data);
			if (equals) {
				return;
			} else {
				curValue.copy(matrix);
			}
		} else {
			this.location.value = matrix.clone();
		}

		this.context.uniformMatrix4fv(this.location, transpose, matrix.data);
	};

	module.exports = ShaderCall;

/***/ },
/* 33 */
/***/ function(module, exports, __webpack_require__) {

	var MathUtils = __webpack_require__(9);
	var Matrix = __webpack_require__(25);
	var Vector3 = __webpack_require__(8);
	var ObjectUtils = __webpack_require__(6);

	/**
	 * Matrix with 4x4 components.
	 * @extends Matrix
	 * @param {(Matrix4|Array<number>)} arguments Initial values for the components.
	 */
	function Matrix4() {
		Matrix.call(this, 4, 4);

		if (arguments.length === 0) {
			this.data[0] = 1;
			this.data[5] = 1;
			this.data[10] = 1;
			this.data[15] = 1;
		} else if (arguments.length === 1 && typeof arguments[0] === 'object') {
			if (arguments[0] instanceof Matrix4) {
				this.copy(arguments[0]);
			} else {
				this.setArray(arguments[0]);
			}
		} else {
			for (var i = 0; i < arguments.length; i++) {
				this.data[i] = arguments[i];
			}
		}

		// @ifdef DEBUG
		Object.seal(this);
		// @endif
	}

	Matrix4.prototype = Object.create(Matrix.prototype);
	Matrix4.prototype.constructor = Matrix4;

	Matrix.setupAliases(Matrix4.prototype, [['e00'], ['e10'], ['e20'], ['e30'], ['e01'], ['e11'], ['e21'], ['e31'], ['e02'], ['e12'], ['e22'], ['e32'], ['e03'], ['e13'], ['e23'], ['e33']]);

	Matrix4.IDENTITY = new Matrix4(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);

	/**
	 * Performs a component-wise addition.
	 * @param {Matrix4} rhs Matrix or scalar on the right-hand side.
	 * @returns {Matrix4} Self to allow chaining.
	 */
	Matrix4.prototype.add = function (rhs) {
		var thisData = this.data;
		var rhsData = rhs.data;

		thisData[0] += rhsData[0];
		thisData[1] += rhsData[1];
		thisData[2] += rhsData[2];
		thisData[3] += rhsData[3];
		thisData[4] += rhsData[4];
		thisData[5] += rhsData[5];
		thisData[6] += rhsData[6];
		thisData[7] += rhsData[7];
		thisData[8] += rhsData[8];
		thisData[9] += rhsData[9];
		thisData[10] += rhsData[10];
		thisData[11] += rhsData[11];
		thisData[12] += rhsData[12];
		thisData[13] += rhsData[13];
		thisData[14] += rhsData[14];
		thisData[15] += rhsData[15];

		return this;
	};

	/**
	 * Performs a component-wise subtraction.
	 * @param {Matrix4} rhs Matrix or scalar on the right-hand side.
	 * @returns {Matrix4} Self to allow chaining
	 */
	Matrix4.prototype.sub = function (rhs) {
		var thisData = this.data;
		var rhsData = rhs.data;

		thisData[0] -= rhsData[0];
		thisData[1] -= rhsData[1];
		thisData[2] -= rhsData[2];
		thisData[3] -= rhsData[3];
		thisData[4] -= rhsData[4];
		thisData[5] -= rhsData[5];
		thisData[6] -= rhsData[6];
		thisData[7] -= rhsData[7];
		thisData[8] -= rhsData[8];
		thisData[9] -= rhsData[9];
		thisData[10] -= rhsData[10];
		thisData[11] -= rhsData[11];
		thisData[12] -= rhsData[12];
		thisData[13] -= rhsData[13];
		thisData[14] -= rhsData[14];
		thisData[15] -= rhsData[15];

		return this;
	};

	/**
	 * Multiplies this matrix with a scalar
	 * @param {number} scalar
	 * @returns {Matrix4} Self to allow chaining
	 */
	Matrix4.prototype.scale = function (scalar) {
		var data = this.data;

		data[0] *= scalar;
		data[1] *= scalar;
		data[2] *= scalar;
		data[3] *= scalar;
		data[4] *= scalar;
		data[5] *= scalar;
		data[6] *= scalar;
		data[7] *= scalar;
		data[8] *= scalar;
		data[9] *= scalar;
		data[10] *= scalar;
		data[11] *= scalar;
		data[12] *= scalar;
		data[13] *= scalar;
		data[14] *= scalar;
		data[15] *= scalar;

		return this;
	};

	/**
	 * Multiplies this matrix with another matrix
	 * @param {Matrix4} rhs Matrix on the left-hand side
	 * @returns {Matrix4} Self to allow chaining
	 */
	Matrix4.prototype.mul = function (rhs) {
		var s1d = this.data;
		var m00 = s1d[0], m01 = s1d[4], m02 = s1d[8], m03 = s1d[12],
			m10 = s1d[1], m11 = s1d[5], m12 = s1d[9], m13 = s1d[13],
			m20 = s1d[2], m21 = s1d[6], m22 = s1d[10], m23 = s1d[14],
			m30 = s1d[3], m31 = s1d[7], m32 = s1d[11], m33 = s1d[15];
		var s2d = rhs.data;
		var n00 = s2d[0], n01 = s2d[4], n02 = s2d[8], n03 = s2d[12],
			n10 = s2d[1], n11 = s2d[5], n12 = s2d[9], n13 = s2d[13],
			n20 = s2d[2], n21 = s2d[6], n22 = s2d[10], n23 = s2d[14],
			n30 = s2d[3], n31 = s2d[7], n32 = s2d[11], n33 = s2d[15];

		var rd = this.data;
		rd[0] = m00 * n00 + m01 * n10 + m02 * n20 + m03 * n30;
		rd[4] = m00 * n01 + m01 * n11 + m02 * n21 + m03 * n31;
		rd[8] = m00 * n02 + m01 * n12 + m02 * n22 + m03 * n32;
		rd[12] = m00 * n03 + m01 * n13 + m02 * n23 + m03 * n33;

		rd[1] = m10 * n00 + m11 * n10 + m12 * n20 + m13 * n30;
		rd[5] = m10 * n01 + m11 * n11 + m12 * n21 + m13 * n31;
		rd[9] = m10 * n02 + m11 * n12 + m12 * n22 + m13 * n32;
		rd[13] = m10 * n03 + m11 * n13 + m12 * n23 + m13 * n33;

		rd[2] = m20 * n00 + m21 * n10 + m22 * n20 + m23 * n30;
		rd[6] = m20 * n01 + m21 * n11 + m22 * n21 + m23 * n31;
		rd[10] = m20 * n02 + m21 * n12 + m22 * n22 + m23 * n32;
		rd[14] = m20 * n03 + m21 * n13 + m22 * n23 + m23 * n33;

		rd[3] = m30 * n00 + m31 * n10 + m32 * n20 + m33 * n30;
		rd[7] = m30 * n01 + m31 * n11 + m32 * n21 + m33 * n31;
		rd[11] = m30 * n02 + m31 * n12 + m32 * n22 + m33 * n32;
		rd[15] = m30 * n03 + m31 * n13 + m32 * n23 + m33 * n33;

		return this;
	};

	/**
	 * Multiplies two matrices and stores the result in this matrix
	 * @param {Matrix4} lhs Matrix on the left-hand side
	 * @param {Matrix4} rhs Matrix on the right-hand side
	 * @returns {Matrix4} Self to allow chaining
	 */
	Matrix4.prototype.mul2 = function (lhs, rhs) {
		var s1d = lhs.data;
		var m00 = s1d[0], m01 = s1d[4], m02 = s1d[8], m03 = s1d[12],
			m10 = s1d[1], m11 = s1d[5], m12 = s1d[9], m13 = s1d[13],
			m20 = s1d[2], m21 = s1d[6], m22 = s1d[10], m23 = s1d[14],
			m30 = s1d[3], m31 = s1d[7], m32 = s1d[11], m33 = s1d[15];
		var s2d = rhs.data;
		var n00 = s2d[0], n01 = s2d[4], n02 = s2d[8], n03 = s2d[12],
			n10 = s2d[1], n11 = s2d[5], n12 = s2d[9], n13 = s2d[13],
			n20 = s2d[2], n21 = s2d[6], n22 = s2d[10], n23 = s2d[14],
			n30 = s2d[3], n31 = s2d[7], n32 = s2d[11], n33 = s2d[15];

		var rd = this.data;
		rd[0] = m00 * n00 + m01 * n10 + m02 * n20 + m03 * n30;
		rd[4] = m00 * n01 + m01 * n11 + m02 * n21 + m03 * n31;
		rd[8] = m00 * n02 + m01 * n12 + m02 * n22 + m03 * n32;
		rd[12] = m00 * n03 + m01 * n13 + m02 * n23 + m03 * n33;

		rd[1] = m10 * n00 + m11 * n10 + m12 * n20 + m13 * n30;
		rd[5] = m10 * n01 + m11 * n11 + m12 * n21 + m13 * n31;
		rd[9] = m10 * n02 + m11 * n12 + m12 * n22 + m13 * n32;
		rd[13] = m10 * n03 + m11 * n13 + m12 * n23 + m13 * n33;

		rd[2] = m20 * n00 + m21 * n10 + m22 * n20 + m23 * n30;
		rd[6] = m20 * n01 + m21 * n11 + m22 * n21 + m23 * n31;
		rd[10] = m20 * n02 + m21 * n12 + m22 * n22 + m23 * n32;
		rd[14] = m20 * n03 + m21 * n13 + m22 * n23 + m23 * n33;

		rd[3] = m30 * n00 + m31 * n10 + m32 * n20 + m33 * n30;
		rd[7] = m30 * n01 + m31 * n11 + m32 * n21 + m33 * n31;
		rd[11] = m30 * n02 + m31 * n12 + m32 * n22 + m33 * n32;
		rd[15] = m30 * n03 + m31 * n13 + m32 * n23 + m33 * n33;

		return this;
	};

	/**
	 * Transposes a matrix (exchanges rows and columns)
	 * @returns {Matrix4} Self to allow chaining
	 */
	Matrix4.prototype.transpose = function () {
		var data = this.data;

		var e01 = data[4];
		var e02 = data[8];
		var e03 = data[12];
		var e12 = data[9];
		var e13 = data[13];
		var e23 = data[14];

		data[4] = data[1];
		data[8] = data[2];
		data[12] = data[3];
		data[9] = data[6];
		data[13] = data[7];
		data[14] = data[11];

		data[1] = e01;
		data[2] = e02;
		data[3] = e03;
		data[6] = e12;
		data[7] = e13;
		data[11] = e23;

		return this;
	};

	/**
	 * Computes the analytical inverse and stores the result in a separate matrix.
	 * @param {Matrix4} source Source matrix.
	 * @param {Matrix4} [target] Target matrix.
	 * @returns {Matrix4} A new matrix if the target matrix is omitted, else the target matrix.
	 */
	Matrix4.invert = function (source, target) {
		if (!target) {
			target = new Matrix4();
		}

		if (target === source) {
			return target.copy(Matrix4.invert(source));
		}

		var det = source.determinant();

		if (!det) { //! AT: why not Math.abs(det) < MathUtils.EPSILON ? (I don't dare change it)
			return target;
		}

		var s = source.data;
		var t = target.data;

		det = 1.0 / det;

		t[0] = (s[5] * (s[10] * s[15] - s[14] * s[11]) - s[9] * (s[6] * s[15] - s[14] * s[7]) + s[13] * (s[6] * s[11] - s[10] * s[7])) * det;
		t[1] = (s[1] * (s[14] * s[11] - s[10] * s[15]) - s[9] * (s[14] * s[3] - s[2] * s[15]) + s[13] * (s[10] * s[3] - s[2] * s[11])) * det;
		t[2] = (s[1] * (s[6] * s[15] - s[14] * s[7]) - s[5] * (s[2] * s[15] - s[14] * s[3]) + s[13] * (s[2] * s[7] - s[6] * s[3])) * det;
		t[3] = (s[1] * (s[10] * s[7] - s[6] * s[11]) - s[5] * (s[10] * s[3] - s[2] * s[11]) + s[9] * (s[6] * s[3] - s[2] * s[7])) * det;
		t[4] = (s[4] * (s[14] * s[11] - s[10] * s[15]) - s[8] * (s[14] * s[7] - s[6] * s[15]) + s[12] * (s[10] * s[7] - s[6] * s[11])) * det;
		t[5] = (s[0] * (s[10] * s[15] - s[14] * s[11]) - s[8] * (s[2] * s[15] - s[14] * s[3]) + s[12] * (s[2] * s[11] - s[10] * s[3])) * det;
		t[6] = (s[0] * (s[14] * s[7] - s[6] * s[15]) - s[4] * (s[14] * s[3] - s[2] * s[15]) + s[12] * (s[6] * s[3] - s[2] * s[7])) * det;
		t[7] = (s[0] * (s[6] * s[11] - s[10] * s[7]) - s[4] * (s[2] * s[11] - s[10] * s[3]) + s[8] * (s[2] * s[7] - s[6] * s[3])) * det;
		t[8] = (s[4] * (s[9] * s[15] - s[13] * s[11]) - s[8] * (s[5] * s[15] - s[13] * s[7]) + s[12] * (s[5] * s[11] - s[9] * s[7])) * det;
		t[9] = (s[0] * (s[13] * s[11] - s[9] * s[15]) - s[8] * (s[13] * s[3] - s[1] * s[15]) + s[12] * (s[9] * s[3] - s[1] * s[11])) * det;
		t[10] = (s[0] * (s[5] * s[15] - s[13] * s[7]) - s[4] * (s[1] * s[15] - s[13] * s[3]) + s[12] * (s[1] * s[7] - s[5] * s[3])) * det;
		t[11] = (s[0] * (s[9] * s[7] - s[5] * s[11]) - s[4] * (s[9] * s[3] - s[1] * s[11]) + s[8] * (s[5] * s[3] - s[1] * s[7])) * det;
		t[12] = (s[4] * (s[13] * s[10] - s[9] * s[14]) - s[8] * (s[13] * s[6] - s[5] * s[14]) + s[12] * (s[9] * s[6] - s[5] * s[10])) * det;
		t[13] = (s[0] * (s[9] * s[14] - s[13] * s[10]) - s[8] * (s[1] * s[14] - s[13] * s[2]) + s[12] * (s[1] * s[10] - s[9] * s[2])) * det;
		t[14] = (s[0] * (s[13] * s[6] - s[5] * s[14]) - s[4] * (s[13] * s[2] - s[1] * s[14]) + s[12] * (s[5] * s[2] - s[1] * s[6])) * det;
		t[15] = (s[0] * (s[5] * s[10] - s[9] * s[6]) - s[4] * (s[1] * s[10] - s[9] * s[2]) + s[8] * (s[1] * s[6] - s[5] * s[2])) * det;

		return target;
	};

	/**
	 * Computes the analytical inverse and stores the result locally.
	 * @returns {Matrix4} Self for chaining.
	 */
	Matrix4.prototype.invert = function () {
		return Matrix4.invert(this, this);
	};

	/**
	 * Tests if the matrix is orthogonal.
	 * @returns {Boolean} True if orthogonal.
	 */
	Matrix4.prototype.isOrthogonal = function () {
		var dot;

		dot = this.e00 * this.e01 + this.e10 * this.e11 + this.e20 * this.e21 + this.e30 * this.e31;

		if (Math.abs(dot) > MathUtils.EPSILON) {
			return false;
		}

		dot = this.e00 * this.e02 + this.e10 * this.e12 + this.e20 * this.e22 + this.e30 * this.e32;

		if (Math.abs(dot) > MathUtils.EPSILON) {
			return false;
		}

		dot = this.e00 * this.e03 + this.e10 * this.e13 + this.e20 * this.e23 + this.e30 * this.e33;

		if (Math.abs(dot) > MathUtils.EPSILON) {
			return false;
		}

		dot = this.e01 * this.e02 + this.e11 * this.e12 + this.e21 * this.e22 + this.e31 * this.e32;

		if (Math.abs(dot) > MathUtils.EPSILON) {
			return false;
		}

		dot = this.e01 * this.e03 + this.e11 * this.e13 + this.e21 * this.e23 + this.e31 * this.e33;

		if (Math.abs(dot) > MathUtils.EPSILON) {
			return false;
		}

		dot = this.e02 * this.e03 + this.e12 * this.e13 + this.e22 * this.e23 + this.e32 * this.e33;

		//! AT: why wrap in an if?!?!
		if (Math.abs(dot) > MathUtils.EPSILON) {
			return false;
		}

		return true;
	};

	/**
	 * Tests if the matrix is normal.
	 * @returns {Boolean} True if normal.
	 */
	Matrix4.prototype.isNormal = function () {
		var l;

		l = this.e00 * this.e00 + this.e10 * this.e10 + this.e20 * this.e20 + this.e30 * this.e30;

		if (Math.abs(l - 1.0) > MathUtils.EPSILON) {
			return false;
		}

		l = this.e01 * this.e01 + this.e11 * this.e11 + this.e21 * this.e21 + this.e31 * this.e31;

		if (Math.abs(l - 1.0) > MathUtils.EPSILON) {
			return false;
		}

		l = this.e02 * this.e02 + this.e12 * this.e12 + this.e22 * this.e22 + this.e32 * this.e32;

		if (Math.abs(l - 1.0) > MathUtils.EPSILON) {
			return false;
		}

		l = this.e03 * this.e03 + this.e13 * this.e13 + this.e23 * this.e23 + this.e33 * this.e33;

		//! AT: why wrap in an if?!?!
		if (Math.abs(l - 1.0) > MathUtils.EPSILON) {
			return false;
		}

		return true;
	};

	/**
	 * Tests if the matrix is orthonormal.
	 * @returns {Boolean} True if orthonormal.
	 */
	Matrix4.prototype.isOrthonormal = function () {
		return this.isOrthogonal() && this.isNormal();
	};

	/**
	 * Computes the determinant of the matrix.
	 * @returns {Float} Determinant of matrix.
	 */
	Matrix4.prototype.determinant = function () {
		var d = this.data;

		var val1 = d[5] * d[10] * d[15] +
			d[9] * d[14] * d[7] +
			d[13] * d[6] * d[11] -
			d[13] * d[10] * d[7] -
			d[9] * d[6] * d[15] -
			d[5] * d[14] * d[11];
		var val2 = d[1] * d[10] * d[15] +
			d[9] * d[14] * d[3] +
			d[13] * d[2] * d[11] -
			d[13] * d[10] * d[3] -
			d[9] * d[2] * d[15] -
			d[1] * d[14] * d[11];
		var val3 = d[1] * d[6] * d[15] +
			d[5] * d[14] * d[3] +
			d[13] * d[2] * d[7] -
			d[13] * d[6] * d[3] -
			d[5] * d[2] * d[15] -
			d[1] * d[14] * d[7];
		var val4 = d[1] * d[6] * d[11] +
			d[5] * d[10] * d[3] +
			d[9] * d[2] * d[7] -
			d[9] * d[6] * d[3] -
			d[5] * d[2] * d[11] -
			d[1] * d[10] * d[7];

		return d[0] * val1 -
			d[4] * val2 +
			d[8] * val3 -
			d[12] * val4;
	};

	//! AT: matrix.set(Matrix3.IDENTITY);
	/**
	 * Sets the matrix to identity.
	 * @returns {Matrix4} Self for chaining.
	 */
	Matrix4.prototype.setIdentity = function () {
		var d = this.data;

		d[0] = 1;
		d[1] = 0;
		d[2] = 0;
		d[3] = 0;
		d[4] = 0;
		d[5] = 1;
		d[6] = 0;
		d[7] = 0;
		d[8] = 0;
		d[9] = 0;
		d[10] = 1;
		d[11] = 0;
		d[12] = 0;
		d[13] = 0;
		d[14] = 0;
		d[15] = 1;

		return this;
	};

	/**
	 * Sets the rotational part of the matrix from a vector of angles. Order convention is x followed by y followed by z.
	 * @param {Vector3} angles Rotational angles in radians.
	 * @returns {Matrix4} Self for chaining.
	 */
	Matrix4.prototype.setRotationFromVector = function (angles) {
		var sx = Math.sin(angles.x);
		var cx = Math.cos(angles.x);
		var sy = Math.sin(angles.y);
		var cy = Math.cos(angles.y);
		var sz = Math.sin(angles.z);
		var cz = Math.cos(angles.z);

		var d = this.data;
		d[0] = cz * cy;
		d[1] = sz * cy;
		d[2] = 0.0 - sy;
		d[4] = cz * sy * sx - sz * cx;
		d[5] = sz * sy * sx + cz * cx;
		d[6] = cy * sx;
		d[8] = cz * sy * cx + sz * sx;
		d[9] = sz * sy * cx - cz * sx;
		d[10] = cy * cx;

		return this;
	};

	/**
	 * Sets the rotational part of the matrix from a quaternion.
	 * @param {Vector4} quaternion Rotational quaternion.
	 * @returns {Matrix4} Self for chaining.
	 */
	Matrix4.prototype.setRotationFromQuaternion = function (quaternion) {
		var l = quaternion.lengthSquared();

		l = (l > 0.0) ? 2.0 / l : 0.0; //! AT: epsilon?

		var a = quaternion.x * l;
		var b = quaternion.y * l;
		var c = quaternion.z * l;

		var wa = quaternion.w * a;
		var wb = quaternion.w * b;
		var wc = quaternion.w * c;
		var xa = quaternion.x * a;
		var xb = quaternion.x * b;
		var xc = quaternion.x * c;
		var yb = quaternion.y * b;
		var yc = quaternion.y * c;
		var zc = quaternion.z * c;

		var d = this.data;
		d[0] = 1.0 - yb - zc;
		d[1] = xb + wc;
		d[2] = xc - wb;
		d[4] = xb - wc;
		d[5] = 1.0 - xa - zc;
		d[6] = yc + wa;
		d[8] = xc + wb;
		d[9] = yc - wa;
		d[10] = 1.0 - xa - yb;

		return this;
	};

	/**
	 * Sets the translational part of the matrix.
	 * @param {Vector3} translation Translation vector.
	 * @returns {Matrix4} Self for chaining.
	 */
	Matrix4.prototype.setTranslation = function (translation) {
		this.data[12] = translation.x;
		this.data[13] = translation.y;
		this.data[14] = translation.z;

		return this;
	};

	/**
	 * Gets the translational part of the matrix.
	 * @param {Vector3} store Translation vector to store result in.
	 * @returns {Matrix4} Self for chaining.
	 */
	Matrix4.prototype.getTranslation = function (store) {
		store.x = this.data[12];
		store.y = this.data[13];
		store.z = this.data[14];

		return this;
	};

	/**
	 * Gets the rotational part of the matrix (the upper left 3x3 matrix).
	 * @param {Matrix3} store Rotation matrix to store in.
	 * @returns {Matrix4} Self for chaining.
	 */
	Matrix4.prototype.getRotation = function (store) {
		var d = this.data;
		var sd = store.data;

		sd[0] = d[0];
		sd[1] = d[1];
		sd[2] = d[2];
		sd[3] = d[4];
		sd[4] = d[5];
		sd[5] = d[6];
		sd[6] = d[8];
		sd[7] = d[9];
		sd[8] = d[10];

		return this;
	};

	/**
	 * Gets the scaling part of the matrix.
	 * @param {Vector3} store Scaling vector to store result in.
	 * @returns {Matrix4} Self for chaining.
	 */
	Matrix4.prototype.getScale = function (store) {
		//! AT: length?
		var sx = Math.sqrt(store.setDirect(this.data[0], this.data[4], this.data[8]).lengthSquared());
		var sy = Math.sqrt(store.setDirect(this.data[1], this.data[5], this.data[9]).lengthSquared());
		var sz = Math.sqrt(store.setDirect(this.data[2], this.data[6], this.data[10]).lengthSquared());

		store.x = sx;
		store.y = sy;
		store.z = sz;

		return this;
	};

	/**
	 * Sets the scale of the matrix.
	 * @param {Vector3} scale Scale vector.
	 * @returns {Matrix4} Self for chaining.
	 */
	Matrix4.prototype.setScale = function (scale) {
		var td = this.data;
		var x = scale.x, y = scale.y, z = scale.z;

		td[0] = x;
		td[5] = y;
		td[10] = z;

		return this;
	};

	/**
	 * Scales the matrix.
	 * @param {Vector3} scale Scale vector.
	 * @returns {Matrix4} Self for chaining.
	 */
	Matrix4.prototype.scale = function (scale) {
		var td = this.data;
		var x = scale.x, y = scale.y, z = scale.z;

		td[0] *= x;
		td[1] *= y;
		td[2] *= z;

		td[4] *= x;
		td[5] *= y;
		td[6] *= z;

		td[8] *= x;
		td[9] *= y;
		td[10] *= z;

		return this;
	};

	Matrix4.prototype.decompose = function (position, rotation, scale) {
		var te = this.data;
		var sx = position.set(te[0], te[1], te[2]).length();
		var sy = position.set(te[4], te[5], te[6]).length();
		var sz = position.set(te[8], te[9], te[10]).length();

		// if determine is negative, we need to invert one scale
		var det = this.determinant();
		if ( det < 0 ) {
			sx = - sx;
		}

		position.x = te[12];
		position.y = te[13];
		position.z = te[14];

		// scale the rotation part
		rotation.copyMatrix4(this);

		var invSX = 1 / sx;
		var invSY = 1 / sy;
		var invSZ = 1 / sz;

		var rt = rotation.data;
		rt[ 0 ] *= invSX;
		rt[ 1 ] *= invSX;
		rt[ 2 ] *= invSX;
		rt[ 3 ] *= invSY;
		rt[ 4 ] *= invSY;
		rt[ 5 ] *= invSY;
		rt[ 6 ] *= invSZ;
		rt[ 7 ] *= invSZ;
		rt[ 8 ] *= invSZ;

		scale.x = sx;
		scale.y = sy;
		scale.z = sz;

		return this;
	};

	/**
	 * Compares two matrices for approximate equality
	 * @param {Matrix4} rhs The matrix to compare against
	 * @param {number} [epsilon] Maximum tolerance
	 * @returns {boolean}
	 */
	Matrix4.prototype.equals = function (rhs, epsilon) {
		var thisData = this.data;
		var rhsData = rhs.data;
		var eps = epsilon === undefined ? MathUtils.EPSILON : epsilon;

		if (eps === 0) {
			return (
				thisData[0] === rhsData[0] &&
				thisData[1] === rhsData[1] &&
				thisData[2] === rhsData[2] &&
				thisData[3] === rhsData[3] &&
				thisData[4] === rhsData[4] &&
				thisData[5] === rhsData[5] &&
				thisData[6] === rhsData[6] &&
				thisData[7] === rhsData[7] &&
				thisData[8] === rhsData[8] &&
				thisData[9] === rhsData[9] &&
				thisData[10] === rhsData[10] &&
				thisData[11] === rhsData[11] &&
				thisData[12] === rhsData[12] &&
				thisData[13] === rhsData[13] &&
				thisData[14] === rhsData[14] &&
				thisData[15] === rhsData[15]
			);
		} else {
			return (Math.abs(thisData[0] - rhsData[0]) <= eps) &&
				(Math.abs(thisData[1] - rhsData[1]) <= eps) &&
				(Math.abs(thisData[2] - rhsData[2]) <= eps) &&
				(Math.abs(thisData[3] - rhsData[3]) <= eps) &&
				(Math.abs(thisData[4] - rhsData[4]) <= eps) &&
				(Math.abs(thisData[5] - rhsData[5]) <= eps) &&
				(Math.abs(thisData[6] - rhsData[6]) <= eps) &&
				(Math.abs(thisData[7] - rhsData[7]) <= eps) &&
				(Math.abs(thisData[8] - rhsData[8]) <= eps) &&
				(Math.abs(thisData[9] - rhsData[9]) <= eps) &&
				(Math.abs(thisData[10] - rhsData[10]) <= eps) &&
				(Math.abs(thisData[11] - rhsData[11]) <= eps) &&
				(Math.abs(thisData[12] - rhsData[12]) <= eps) &&
				(Math.abs(thisData[13] - rhsData[13]) <= eps) &&
				(Math.abs(thisData[14] - rhsData[14]) <= eps) &&
				(Math.abs(thisData[15] - rhsData[15]) <= eps);
		}
	};

	/**
	 * Copies component values and stores them locally.
	 * @param {Matrix4} rhs Source matrix.
	 * @returns {Matrix4} Self for chaining.
	 */
	Matrix4.prototype.copy = function (rhs) {
		var thisData = this.data;
		var rhsData = rhs.data;

		thisData[0] = rhsData[0];
		thisData[1] = rhsData[1];
		thisData[2] = rhsData[2];
		thisData[3] = rhsData[3];
		thisData[4] = rhsData[4];
		thisData[5] = rhsData[5];
		thisData[6] = rhsData[6];
		thisData[7] = rhsData[7];
		thisData[8] = rhsData[8];
		thisData[9] = rhsData[9];
		thisData[10] = rhsData[10];
		thisData[11] = rhsData[11];
		thisData[12] = rhsData[12];
		thisData[13] = rhsData[13];
		thisData[14] = rhsData[14];
		thisData[15] = rhsData[15];

		return this;
	};

	/**
	 * Sets matrix values from an array.
	 * @param {Array<number>} rhsData Array source
	 * @returns {Matrix4} Self for chaining.
	 */
	Matrix4.prototype.setArray = function (rhsData) {
		var thisData = this.data;

		thisData[0] = rhsData[0];
		thisData[1] = rhsData[1];
		thisData[2] = rhsData[2];
		thisData[3] = rhsData[3];
		thisData[4] = rhsData[4];
		thisData[5] = rhsData[5];
		thisData[6] = rhsData[6];
		thisData[7] = rhsData[7];
		thisData[8] = rhsData[8];
		thisData[9] = rhsData[9];
		thisData[10] = rhsData[10];
		thisData[11] = rhsData[11];
		thisData[12] = rhsData[12];
		thisData[13] = rhsData[13];
		thisData[14] = rhsData[14];
		thisData[15] = rhsData[15];

		return this;
	};

	/**
	 * Sets the matrix's values from another matrix's values; an alias for .copy
	 * @param {Matrix4} source Source matrix
	 * @returns {Matrix4} Self to allow chaining
	 */
	Matrix4.prototype.set = Matrix4.prototype.copy;

	/**
	 * Returns a new matrix with the same values as the existing one.
	 * @returns {Matrix4} The new matrix.
	 */
	Matrix4.prototype.clone = function () {
		return new Matrix4().copy(this);
	};

	// SHIMS START

	/**
	 * @hidden
	 * @deprecated
	 */
	Matrix4.add = ObjectUtils.warnOnce(
		'Matrix4.add is deprecated, use Matrix4.prototype.add instead',
		function (lhs, rhs, target) {
			if (!target) {
				target = new Matrix4();
			}

			if (rhs instanceof Matrix4) {
				target.e00 = lhs.e00 + rhs.e00;
				target.e10 = lhs.e10 + rhs.e10;
				target.e20 = lhs.e20 + rhs.e20;
				target.e30 = lhs.e30 + rhs.e30;
				target.e01 = lhs.e01 + rhs.e01;
				target.e11 = lhs.e11 + rhs.e11;
				target.e21 = lhs.e21 + rhs.e21;
				target.e31 = lhs.e31 + rhs.e31;
				target.e02 = lhs.e02 + rhs.e02;
				target.e12 = lhs.e12 + rhs.e12;
				target.e22 = lhs.e22 + rhs.e22;
				target.e32 = lhs.e32 + rhs.e32;
				target.e03 = lhs.e03 + rhs.e03;
				target.e13 = lhs.e13 + rhs.e13;
				target.e23 = lhs.e23 + rhs.e23;
				target.e33 = lhs.e33 + rhs.e33;
			} else {
				target.e00 = lhs.e00 + rhs;
				target.e10 = lhs.e10 + rhs;
				target.e20 = lhs.e20 + rhs;
				target.e30 = lhs.e30 + rhs;
				target.e01 = lhs.e01 + rhs;
				target.e11 = lhs.e11 + rhs;
				target.e21 = lhs.e21 + rhs;
				target.e31 = lhs.e31 + rhs;
				target.e02 = lhs.e02 + rhs;
				target.e12 = lhs.e12 + rhs;
				target.e22 = lhs.e22 + rhs;
				target.e32 = lhs.e32 + rhs;
				target.e03 = lhs.e03 + rhs;
				target.e13 = lhs.e13 + rhs;
				target.e23 = lhs.e23 + rhs;
				target.e33 = lhs.e33 + rhs;
			}

			return target;
		}
	);

	/**
	 * @hidden
	 * @deprecated
	 */
	Matrix4.sub = ObjectUtils.warnOnce(
		'Matrix4.sub is deprecated',
		function (lhs, rhs, target) {
			if (!target) {
				target = new Matrix4();
			}

			if (rhs instanceof Matrix4) {
				target.e00 = lhs.e00 - rhs.e00;
				target.e10 = lhs.e10 - rhs.e10;
				target.e20 = lhs.e20 - rhs.e20;
				target.e30 = lhs.e30 - rhs.e30;
				target.e01 = lhs.e01 - rhs.e01;
				target.e11 = lhs.e11 - rhs.e11;
				target.e21 = lhs.e21 - rhs.e21;
				target.e31 = lhs.e31 - rhs.e31;
				target.e02 = lhs.e02 - rhs.e02;
				target.e12 = lhs.e12 - rhs.e12;
				target.e22 = lhs.e22 - rhs.e22;
				target.e32 = lhs.e32 - rhs.e32;
				target.e03 = lhs.e03 - rhs.e03;
				target.e13 = lhs.e13 - rhs.e13;
				target.e23 = lhs.e23 - rhs.e23;
				target.e33 = lhs.e33 - rhs.e33;
			} else {
				target.e00 = lhs.e00 - rhs;
				target.e10 = lhs.e10 - rhs;
				target.e20 = lhs.e20 - rhs;
				target.e30 = lhs.e30 - rhs;
				target.e01 = lhs.e01 - rhs;
				target.e11 = lhs.e11 - rhs;
				target.e21 = lhs.e21 - rhs;
				target.e31 = lhs.e31 - rhs;
				target.e02 = lhs.e02 - rhs;
				target.e12 = lhs.e12 - rhs;
				target.e22 = lhs.e22 - rhs;
				target.e32 = lhs.e32 - rhs;
				target.e03 = lhs.e03 - rhs;
				target.e13 = lhs.e13 - rhs;
				target.e23 = lhs.e23 - rhs;
				target.e33 = lhs.e33 - rhs;
			}

			return target;
		}
	);

	/**
	 * @hidden
	 * @deprecated
	 */
	Matrix4.mul = ObjectUtils.warnOnce(
		'Matrix4.mul is deprecated, use Matrix4.prototype.mul instead',
		function (lhs, rhs, target) {
			if (!target) {
				target = new Matrix4();
			}

			if (rhs instanceof Matrix4) {
				target.e00 = lhs.e00 * rhs.e00;
				target.e10 = lhs.e10 * rhs.e10;
				target.e20 = lhs.e20 * rhs.e20;
				target.e30 = lhs.e30 * rhs.e30;
				target.e01 = lhs.e01 * rhs.e01;
				target.e11 = lhs.e11 * rhs.e11;
				target.e21 = lhs.e21 * rhs.e21;
				target.e31 = lhs.e31 * rhs.e31;
				target.e02 = lhs.e02 * rhs.e02;
				target.e12 = lhs.e12 * rhs.e12;
				target.e22 = lhs.e22 * rhs.e22;
				target.e32 = lhs.e32 * rhs.e32;
				target.e03 = lhs.e03 * rhs.e03;
				target.e13 = lhs.e13 * rhs.e13;
				target.e23 = lhs.e23 * rhs.e23;
				target.e33 = lhs.e33 * rhs.e33;
			} else {
				target.e00 = lhs.e00 * rhs;
				target.e10 = lhs.e10 * rhs;
				target.e20 = lhs.e20 * rhs;
				target.e30 = lhs.e30 * rhs;
				target.e01 = lhs.e01 * rhs;
				target.e11 = lhs.e11 * rhs;
				target.e21 = lhs.e21 * rhs;
				target.e31 = lhs.e31 * rhs;
				target.e02 = lhs.e02 * rhs;
				target.e12 = lhs.e12 * rhs;
				target.e22 = lhs.e22 * rhs;
				target.e32 = lhs.e32 * rhs;
				target.e03 = lhs.e03 * rhs;
				target.e13 = lhs.e13 * rhs;
				target.e23 = lhs.e23 * rhs;
				target.e33 = lhs.e33 * rhs;
			}

			return target;
		}
	);

	/**
	 * @hidden
	 * @deprecated
	 */
	Matrix4.div = ObjectUtils.warnOnce(
		'Matrix4.div is deprecated',
		function (lhs, rhs, target) {
			if (!target) {
				target = new Matrix4();
			}

			if (rhs instanceof Matrix4) {
				target.e00 = lhs.e00 / rhs.e00;
				target.e10 = lhs.e10 / rhs.e10;
				target.e20 = lhs.e20 / rhs.e20;
				target.e30 = lhs.e30 / rhs.e30;
				target.e01 = lhs.e01 / rhs.e01;
				target.e11 = lhs.e11 / rhs.e11;
				target.e21 = lhs.e21 / rhs.e21;
				target.e31 = lhs.e31 / rhs.e31;
				target.e02 = lhs.e02 / rhs.e02;
				target.e12 = lhs.e12 / rhs.e12;
				target.e22 = lhs.e22 / rhs.e22;
				target.e32 = lhs.e32 / rhs.e32;
				target.e03 = lhs.e03 / rhs.e03;
				target.e13 = lhs.e13 / rhs.e13;
				target.e23 = lhs.e23 / rhs.e23;
				target.e33 = lhs.e33 / rhs.e33;
			} else {
				rhs = 1.0 / rhs;

				target.e00 = lhs.e00 * rhs;
				target.e10 = lhs.e10 * rhs;
				target.e20 = lhs.e20 * rhs;
				target.e30 = lhs.e30 * rhs;
				target.e01 = lhs.e01 * rhs;
				target.e11 = lhs.e11 * rhs;
				target.e21 = lhs.e21 * rhs;
				target.e31 = lhs.e31 * rhs;
				target.e02 = lhs.e02 * rhs;
				target.e12 = lhs.e12 * rhs;
				target.e22 = lhs.e22 * rhs;
				target.e32 = lhs.e32 * rhs;
				target.e03 = lhs.e03 * rhs;
				target.e13 = lhs.e13 * rhs;
				target.e23 = lhs.e23 * rhs;
				target.e33 = lhs.e33 * rhs;
			}

			return target;
		}
	);

	/**
	 * @hidden
	 * @deprecated
	 */
	Matrix4.prototype.div = ObjectUtils.warnOnce(
		'Matrix4.prototype.div is deprecated',
		function (rhs) {
			return Matrix4.div(this, rhs, this);
		}
	);

	/**
	 * @hidden
	 * @deprecated
	 */
	Matrix4.combine = ObjectUtils.warnOnce(
		'Matrix4.combine is deprecated, use Matrix4.prototype.mul instead',
		function (lhs, rhs, target) {
			if (!target) {
				target = new Matrix4();
			}

			var s1d = lhs.data;
			var m00 = s1d[0], m01 = s1d[4], m02 = s1d[8], m03 = s1d[12],
				m10 = s1d[1], m11 = s1d[5], m12 = s1d[9], m13 = s1d[13],
				m20 = s1d[2], m21 = s1d[6], m22 = s1d[10], m23 = s1d[14],
				m30 = s1d[3], m31 = s1d[7], m32 = s1d[11], m33 = s1d[15];
			var s2d = rhs.data;
			var n00 = s2d[0], n01 = s2d[4], n02 = s2d[8], n03 = s2d[12],
				n10 = s2d[1], n11 = s2d[5], n12 = s2d[9], n13 = s2d[13],
				n20 = s2d[2], n21 = s2d[6], n22 = s2d[10], n23 = s2d[14],
				n30 = s2d[3], n31 = s2d[7], n32 = s2d[11], n33 = s2d[15];

			var rd = target.data;
			rd[0] = m00 * n00 + m01 * n10 + m02 * n20 + m03 * n30;
			rd[4] = m00 * n01 + m01 * n11 + m02 * n21 + m03 * n31;
			rd[8] = m00 * n02 + m01 * n12 + m02 * n22 + m03 * n32;
			rd[12] = m00 * n03 + m01 * n13 + m02 * n23 + m03 * n33;

			rd[1] = m10 * n00 + m11 * n10 + m12 * n20 + m13 * n30;
			rd[5] = m10 * n01 + m11 * n11 + m12 * n21 + m13 * n31;
			rd[9] = m10 * n02 + m11 * n12 + m12 * n22 + m13 * n32;
			rd[13] = m10 * n03 + m11 * n13 + m12 * n23 + m13 * n33;

			rd[2] = m20 * n00 + m21 * n10 + m22 * n20 + m23 * n30;
			rd[6] = m20 * n01 + m21 * n11 + m22 * n21 + m23 * n31;
			rd[10] = m20 * n02 + m21 * n12 + m22 * n22 + m23 * n32;
			rd[14] = m20 * n03 + m21 * n13 + m22 * n23 + m23 * n33;

			rd[3] = m30 * n00 + m31 * n10 + m32 * n20 + m33 * n30;
			rd[7] = m30 * n01 + m31 * n11 + m32 * n21 + m33 * n31;
			rd[11] = m30 * n02 + m31 * n12 + m32 * n22 + m33 * n32;
			rd[15] = m30 * n03 + m31 * n13 + m32 * n23 + m33 * n33;

			return target;
		}
	);

	/**
	 * @hidden
	 * @deprecated
	 */
	Matrix4.prototype.combine = ObjectUtils.warnOnce(
		'Matrix4.prototype.combine is deprecated, use Matrix4.prototype.mul instead',
		function (rhs) {
			return Matrix4.combine(this, rhs, this);
		}
	);

	/**
	 * @hidden
	 * @deprecated
	 */
	Matrix4.transpose = ObjectUtils.warnOnce(
		'Matrix4.transpose is deprecated, use Matrix4.prototype.transpose instead',
		function (source, target) {
			if (!target) {
				target = new Matrix4();
			}

			var s = source.data;
			var t = target.data;

			if (target === source) {
				var e01 = s[4];
				var e02 = s[8];
				var e03 = s[12];
				var e12 = s[9];
				var e13 = s[13];
				var e23 = s[14];

				t[4] = s[1];
				t[8] = s[2];
				t[12] = s[3];
				t[9] = s[6];
				t[13] = s[7];
				t[14] = s[11];

				t[1] = e01;
				t[2] = e02;
				t[3] = e03;
				t[6] = e12;
				t[7] = e13;
				t[11] = e23;

				return target;
			}

			t[0] = s[0];
			t[1] = s[4];
			t[2] = s[8];
			t[3] = s[12];
			t[4] = s[1];
			t[5] = s[5];
			t[6] = s[9];
			t[7] = s[13];
			t[8] = s[2];
			t[9] = s[6];
			t[10] = s[10];
			t[11] = s[14];
			t[12] = s[3];
			t[13] = s[7];
			t[14] = s[11];
			t[15] = s[15];

			return target;
		}
	);

	/**
	 * @hidden
	 * @deprecated
	 */
	Matrix4.prototype.applyPre = ObjectUtils.warnOnce(
		'Matrix4.prototype.applyPre is deprecated, use Vector4.prototype.applyPre instead',
		function (rhs) {
			var x = rhs.x;
			var y = rhs.y;
			var z = rhs.z;
			var w = rhs.w;

			var s = this.data;
			rhs.x = s[0] * x + s[1] * y + s[2] * z + s[3] * w;
			rhs.y = s[4] * x + s[5] * y + s[6] * z + s[7] * w;
			rhs.z = s[8] * x + s[9] * y + s[10] * z + s[11] * w;
			rhs.w = s[12] * x + s[13] * y + s[14] * z + s[15] * w;

			return rhs;
		}
	);

	/**
	 * @hidden
	 * @deprecated
	 */
	Matrix4.prototype.applyPost = ObjectUtils.warnOnce(
		'Matrix4.prototype.applyPost is deprecated, use Vector4.prototype.applyPost instead',
		function (rhs) {
			var x = rhs.x;
			var y = rhs.y;
			var z = rhs.z;
			var w = rhs.w;

			var s = this.data;
			rhs.x = s[0] * x + s[4] * y + s[8] * z + s[12] * w;
			rhs.y = s[1] * x + s[5] * y + s[9] * z + s[13] * w;
			rhs.z = s[2] * x + s[6] * y + s[10] * z + s[14] * w;
			rhs.w = s[3] * x + s[7] * y + s[11] * z + s[15] * w;

			return rhs;
		}
	);

	/**
	 * @hidden
	 * @deprecated
	 */
	Matrix4.prototype.applyPostPoint = ObjectUtils.warnOnce(
		'Matrix4.prototype.applyPostPoint is deprecated, use Vector4.prototype.applyPostPoint instead',
		function (rhs) {
			return rhs.applyPostPoint(this);
		}
	);

	/**
	 * @hidden
	 * @deprecated
	 */
	Matrix4.prototype.applyPostVector = ObjectUtils.warnOnce(
		'Matrix4.prototype.applyPostVector is deprecated, use Vector4.prototype.applyPostVector instead',
		function (rhs) {
			var x = rhs.x;
			var y = rhs.y;
			var z = rhs.z;

			var d = this.data;
			rhs.x = d[0] * x + d[4] * y + d[8] * z;
			rhs.y = d[1] * x + d[5] * y + d[9] * z;
			rhs.z = d[2] * x + d[6] * y + d[10] * z;

			return rhs;
		}
	);

	// SHIMS END

	// @ifdef DEBUG
	Matrix.addPostChecks(Matrix4.prototype, [
		'add', 'sub', 'scale', 'transpose', 'invert',
		'isOrthogonal', 'determinant',
		'copy'
	]);
	// @endif

	module.exports = Matrix4;


/***/ },
/* 34 */
/***/ function(module, exports, __webpack_require__) {

	var Entity = __webpack_require__(35);
	var EntityManager = __webpack_require__(38);
	var TransformComponent = __webpack_require__(40);
	var Manager = __webpack_require__(39);
	var System = __webpack_require__(42);
	var Component = __webpack_require__(20);
	var EntitySelection = __webpack_require__(21);
	var ObjectUtils = __webpack_require__(6);

	var lastInstantiatedWorld;

	/**
	 * Main handler for an entity world. The World keeps track of managers and systems,
	 * and also provides methods to create, select and remove entities.
	 * Note that process() has to be called manually if objects need to be added and retrieved within the same update loop.
	 * See [this engine overview article]{@link http://www.gootechnologies.com/learn/tutorials/engine/engine-overview/} for more info.
	 * @param {object} [options]
	 * @param {GooRunner} [options.gooRunner]
	 * @param {boolean} [options.tpfSmoothingCount=10] Specifies the amount of previous frames to use when computing the 'time per frame'
	 */
	function World(options) {
		if (options && options._registerBaseComponents) {
			console.warn('World constructor changed! Please use it like this instead: new World({ gooRunner: gooRunner })');
			var tmp = options;
			options = {};
			options.gooRunner = tmp;
		}

		options = options || {};

		/** GooRunner for updating the world and calling the renderers.
		 * @type {GooRunner}
		 */
		this.gooRunner = options.gooRunner !== undefined ? options.gooRunner : null;

		/** Accumulated time per frames(tpf) the world has been running.  Calculated at the start of each frame.
		 * @type {number}
		 */
		this.time = 0;

		/** Current fixed step accumulated time.
		 * @type {number}
		 */
		this.fixedTpfTime = 0;

		/** The fixed time step to use for physics and other fixed-updates.
		 * @type {number}
		 */
		this.fixedTpf = options.fixedTpf !== undefined ? options.fixedTpf : 1 / 60;

		/** Max fixed steps to use for the fixed update loop.
		 * @type {number}
		 */
		this.maxSubSteps = options.maxSubSteps !== undefined ? options.maxSubSteps : 10;

		/** Time since last frame in seconds.
		 * @type {number}
		 */
		this.tpf = 0;

		/** The tpf, averaged by a number of samples.
		 * @type {number}
		 */
		this.smoothedTpf = this.tpf;

		/** Interpolation alpha time value: a number between 0 and 1. Use to interpolate between two fixed updates from the frame update.
		 * @type {number}
		 */
		this.interpolationTime = 0;

		/** Number of samples to use for smoothing the tpf.
		 * @type {number}
		 */
		this.tpfSmoothingCount = options.tpfSmoothingCount !== undefined ? options.tpfSmoothingCount : 10;

		this._managers = [];
		this._systems = [];

		this._addedEntities = [];
		this._changedEntities = [];
		this._removedEntities = [];

		this.by = {};
		this._installDefaultSelectors();

		/** Main keeper of entities.
		 * @type {EntityManager}
		 */
		this.entityManager = new EntityManager();
		this.setManager(this.entityManager);

		this._components = [];

		this._tpfIndex = 0;
		this._tpfSmoothingArray = [];
		this._accumulator = 0;

		lastInstantiatedWorld = this;
	}

	// Deprecated these with warnings on 2016-04-06
	Object.defineProperties(World, {
		time: {
			get: ObjectUtils.warnOnce('World.time is deprecated, use world.time instead.', function () {
				return lastInstantiatedWorld && lastInstantiatedWorld.time || 0;
			}),
			set: function () {
				throw new Error('Don\'t set World.time!');
			}
		},
		tpf: {
			get: ObjectUtils.warnOnce('World.tpf is deprecated, use world.tpf instead.', function () {
				return lastInstantiatedWorld && lastInstantiatedWorld.tpf || 1;
			}),
			set: function () {
				throw new Error('Don\'t set World.time!');
			}
		}
	});

	/** Entity selector. Its methods return an {@link EntitySelection}. Can select by system, component, attribute or tag. See examples for usage.
	 * <br><i>Will get additional methods when an {@link EntityManager} is attached.</i>
	 * @member by
	 * @memberOf World.prototype
	 * @example
	 * var bySystem = gooRunner.world.by.system("RenderSystem").toArray();
	 * var byComponent = gooRunner.world.by.component("cameraComponent").toArray();
	 * var byTag = gooRunner.world.by.tag("monster").toArray()
	 * var byAttribute = gooRunner.world.by.attribute("hit-points").toArray();
	 */
	World.prototype._installDefaultSelectors = function () {
		this.by.system = function (systemType) {
			var system = this.getSystem(systemType);
			return new EntitySelection(system._activeEntities);
		}.bind(this);

		this.by.component = function (componentType) {
			var entities = this.entityManager.getEntities();

			return new EntitySelection(entities.filter(function (entity) {
				return entity.hasComponent(componentType);
			}));
		}.bind(this);

		//! AT: this will be relocated into the Tag Manager once it gets implemented
		this.by.tag = function (tag) {
			var entities = this.entityManager.getEntities();

			return new EntitySelection(entities.filter(function (entity) {
				return entity.hasTag(tag);
			}));
		}.bind(this);

		//! AT: this will be relocated into the Attribute Manager once it gets implemented
		this.by.attribute = function (attribute) {
			var entities = this.entityManager.getEntities();

			return new EntitySelection(entities.filter(function (entity) {
				return entity.hasAttribute(attribute);
			}));
		}.bind(this);
	};

	/**
	 * Universal shorthand for adding managers, systems, entities and registering components.
	 * Arguments can be of types Entity, Manager, System or Component and added in any order or combination.
	 * @param {Entity} [entity]
	 * @param {Manager} [manager]
	 * @param {System} [system]
	 * @param {Component} [component]
	 * @example
	 * // Add two entities and register a component, all in one swoop
	 * var entity1 = new Entity(gooRunner.world, 'Entity 1');
	 * var entity2 = new Entity(gooRunner.world, 'Entity 2');
	 * var animationComponent = new AnimationComponent();
	 * gooRunner.world.add(entity1, animationComponent, entity2);
	 *
	 * @returns {World} Returns self to allow chaining
	 */
	//! AT: again, 'set' vs 'add' - entities are added to the world, systems/managers are set
	World.prototype.add = function () {
		for (var i = 0; i < arguments.length; i++) {
			var argument = arguments[i];

			if (argument instanceof Entity) {
				this.addEntity(argument);
			} else if (argument instanceof Manager) {
				this.setManager(argument);
			} else if (argument instanceof System) {
				this.setSystem(argument);
			} else if (argument instanceof Component) {
				//! AT: TransformComponent and co and NOT instances of Component
				this.registerComponent(argument);
			}
		}

		return this;
	};

	/**
	 * Registers a component type. This is necessary to allow automatic creation of components
	 * from 'basic' data types (CameraComponents from Cameras, MeshRendererComponents from materials and so on).
	 * When a {@link GooRunner} is created, it registers {@link TransformComponent}, {@link MeshDataComponent},
	 * {@link MeshRendererComponent}, {@link CameraComponent}, {@link LightComponent} and {@link ScriptComponent} automatically.
	 * @example
	 * // Register the animation component type so that animations
	 * // can be automatically created.
	 * gooRunner.world.registerComponent(AnimationComponent);
	 *
	 * @param {Component} componentConstructor
	 * @returns {World} Returns self to allow chaining.
	 */
	World.prototype.registerComponent = function (componentConstructor) {
		if (this._components.indexOf(componentConstructor) === -1) {
			this._components.push(componentConstructor);
			Component.applyEntitySelectionAPI(componentConstructor.entitySelectionAPI, componentConstructor.type);
		}
		return this;
	};

	/**
	 * Adds a {@link Manager} to the world.
	 *
	 * @param {Manager} manager
	 * @returns {World} Returns self to allow chaining.
	 */
	World.prototype.setManager = function (manager) {
		this._managers.push(manager);
		manager.applyAPI(this.by);
		return this;
	};

	/**
	 * Retrieves a {@link Manager} of a certain type.
	 *
	 * @param {string} type Type of manager to retrieve eg. 'EntityManager'.
	 * @returns {Manager}
	 */
	World.prototype.getManager = function (type) {
		for (var i = 0; i < this._managers.length; i++) {
			var manager = this._managers[i];
			if (manager.type === type) {
				return manager;
			}
		}
	};

	/**
	 * Adds a {@link System} to the world.
	 *
	 * @param {System} system
	 * @returns {World} Returns self to allow chaining.
	 */
	World.prototype.setSystem = function (system) {
		if (this._systems.indexOf(system) !== -1) {
			return this;
		}

		var priority = system.priority;

		for (var i = 0; i < this._systems.length; i++) {
			if (this._systems[i].priority > priority) {
				break;
			}
		}
		this._systems.splice(i, 0, system);

		system.world = this;
		system.setup(this);

		return this;
	};

	/**
	 * Retrieve a {@link System} of type 'type'.
	 *
	 * @param {string} type Type of system to retrieve.
	 * @returns {System}
	 */
	World.prototype.getSystem = function (type) {
		for (var i = 0; i < this._systems.length; i++) {
			var system = this._systems[i];
			if (system.type === type) {
				return system;
			}
		}
	};

	/**
	 * Removes the {@link System} of type 'type'.
	 * Entities tracked by the removed system will not get handled properly when they are removed from the world
	 * or when their components (that are tracked by this system) change.
	 *
	 * @param {string} type Type of system to remove.
	 * @returns {World} Returns self to allow chaining.
	 */
	World.prototype.clearSystem = function (type) {
		for (var i = 0; i < this._systems.length; i++) {
			var system = this._systems[i];
			if (system.type === type) {
				system.cleanup();
				system.world = null;
				this._systems.splice(i, 1);
			}
		}
		return this;
	};

	/**
	 * Creates a new {@link Entity} with an optional MeshData, MeshRenderer, Camera, Script and Light component, placed optionally at a location. Parameters can be given in any order.
	 * @example
	 * // Create a sphere entity and add it to the world
	 * var sphereEntity = world.createEntity(new Sphere(32, 32), material, [0, 0, 5]).addToWorld();
	 * // Create a camera entity and add it to the world
	 * var cameraEntity = world.createEntity(new Camera(), [0, 0, 3]).lookAt(new Vector3(0, 0, 0)).addToWorld();
	 *
	 * @param {MeshData} [meshData]
	 * @param {Material} [material]
	 * @param {string} [name]
	 * @param {Camera} [camera]
	 * @param {Light} [light]
	 * @returns {Entity}
	 */
	World.prototype.createEntity = function () {
		var entity = new Entity(this);
		for (var i = 0; i < arguments.length; i++) {
			if (typeof arguments[i] === 'string') { // does not cover new String()
				entity.name = arguments[i];
			} else {
				entity.set(arguments[i]);
			}
		}

		// separate treatment
		if (!entity.transformComponent) {
			entity.setComponent(new TransformComponent());
		}

		return entity;
	};

	/**
	 * Get an array of all entities in world.
	 *
	 * @returns {Array<Entity>} All entities existing in world.
	 */
	World.prototype.getEntities = function () {
		return this.entityManager.getEntities();
	};

	/**
	 * Add an {@link Entity} to the world.
	 *
	 * @param {Entity} entity Entity to add.
	 * @param {boolean} [recursive=true] If entity hierarchy should be added recursively.
	 * @returns {World} Returns self to allow chaining.
	 */
	World.prototype.addEntity = function (entity, recursive) {
		if (this._addedEntities.indexOf(entity) === -1) {
			this._addedEntities.push(entity);
		}

		if (entity.transformComponent && (recursive === undefined || recursive === true)) {
			var children = entity.transformComponent.children;
			for (var i = 0; i < children.length; i++) {
				this.addEntity(children[i].entity, recursive);
			}
		}

		// directly add to managers
		for (var i = 0; i < this._managers.length; i++) {
			var manager = this._managers[i];
			manager.added(entity);
		}

		return this;
	};

	/**
	 * Remove an {@link Entity} from the world.
	 *
	 * @param {Entity} entity Entity to remove.
	 * @param {boolean} [recursive=true] If entity hierarchy should be removed recursively.
	 * @returns {World} Returns self to allow chaining.
	 */
	World.prototype.removeEntity = function (entity, recursive) {
		if (this._removedEntities.indexOf(entity) === -1) {
			this._removedEntities.push(entity);
		}

		var transformComponent = entity.transformComponent;
		if (transformComponent.parent) {
			transformComponent.parent.detachChild(transformComponent);
			transformComponent.parent = null;
		}

		if (recursive === false) {
			var children = transformComponent.children;
			for (var i = 0; i < children.length; i++) {
				children[i].parent = null;
			}

			transformComponent.children = [];
		} else {
			var children = transformComponent.children;
			for (var i = 0; i < children.length; i++) {
				this._recursiveRemoval(children[i].entity, recursive);
			}
		}

		// directly remove from managers
		for (var i = 0; i < this._managers.length; i++) {
			var manager = this._managers[i];
			manager.removed(entity);
		}

		return this;
	};

	World.prototype._recursiveRemoval = function (entity, recursive) {
		if (this._removedEntities.indexOf(entity) === -1) {
			this._removedEntities.push(entity);
		}

		// this and the whole recursive removal needs refactoring
		for (var i = 0; i < this._managers.length; i++) {
			var manager = this._managers[i];
			manager.removed(entity);
		}

		if (entity.transformComponent && (recursive === undefined || recursive === true)) {
			var children = entity.transformComponent.children;
			for (var i = 0; i < children.length; i++) {
				this._recursiveRemoval(children[i].entity, recursive);
			}
		}
	};

	/**
	 * Let the world and its systems know that an entity has been changed/updated.
	 *
	 * @param entity
	 * @param component
	 * @param eventType
	 */
	World.prototype.changedEntity = function (entity, component, eventType) {
		var event = {
			entity: entity
		};
		if (component !== undefined) {
			event.component = component;
		}
		if (eventType !== undefined) {
			event.eventType = eventType;
		}
		this._changedEntities.push(event);
	};

	/**
	 * Processes newly added entities, changed entities and removed entities
	 */
	World.prototype.processEntityChanges = function () {
		this._check(this._addedEntities, function (observer, entity) {
			observer.added(entity);

			// not in use by any system
			if (observer.addedComponent) {
				for (var i = 0; i < entity._components.length; i++) {
					observer.addedComponent(entity, entity._components[i]);
				}
			}
		});
		this._check(this._changedEntities, function (observer, event) {
			observer.changed(event.entity);
			if (event.eventType !== undefined) {
				if (observer[event.eventType]) {
					observer[event.eventType](event.entity, event.component);
				}
			}
		});
		this._check(this._removedEntities, function (observer, entity) {
			observer.removed(entity);

			// not in use by any system
			if (observer.removedComponent) {
				for (var i = 0; i < entity._components.length; i++) {
					observer.removedComponent(entity, entity._components[i]);
				}
			}
		});
	};

	/**
	 * Update the world. This will run process and fixedUpdate.
	 * @param  {number} tpf Time since last called, in seconds.
	 * @return {World} the self object
	 */
	World.prototype.update = function (tpf) {
		// Increment time
		var time = this.time;
		time += tpf;

		// Set current values
		this.time = time;
		this.tpf = tpf;

		// Compute .smoothedTpf
		var tpfSmoothingArray = this._tpfSmoothingArray;
		this._tpfSmoothingArray[this._tpfIndex] = tpf;
		this._tpfIndex = (this._tpfIndex + 1) % this.tpfSmoothingCount;
		var avg = 0;
		for (var i = 0; i < tpfSmoothingArray.length; i++) {
			avg += tpfSmoothingArray[i];
		}
		avg /= this.tpfSmoothingCount;
		this.smoothedTpf = avg;

		// Fixed updates
		var numSteps = 0;
		var fixedTpf = this.fixedTpf;
		var fixedTpfTime = this.fixedTpfTime;
		var maxSubSteps = this.maxSubSteps;
		var accumulator = this._accumulator;

		accumulator += tpf;
		while (accumulator >= fixedTpf && numSteps < maxSubSteps) {
			fixedTpfTime += fixedTpf;
			numSteps++;
			this.fixedUpdate();
			accumulator -= fixedTpf;
		}
		this.fixedTpfTime = fixedTpfTime;
		this.interpolationTime = (accumulator % fixedTpf) / fixedTpf;
		this._accumulator = accumulator;

		// Frame update (process)
		this.process();

		return this;
	};

	/**
	 * Do a fixed time update of all systems.
	 */
	World.prototype.fixedUpdate = function () {
		this.processEntityChanges();
		for (var i = 0; i < this._systems.length; i++) {
			var system = this._systems[i];
			if (!system.passive) {
				system._fixedUpdate(this.fixedTpf);
			}
		}
	};

	/**
	 * Process all added/changed/removed entities and callback to active systems and managers. Usually called automatically each frame.
	 * Has to be called between adding an entity to the world and getting it back.
	 */
	World.prototype.process = function () {
		this.processEntityChanges();

		for (var i = 0; i < this._systems.length; i++) {
			var system = this._systems[i];
			if (!system.passive) {
				system._process(this.tpf);
			}
		}
	};

	World.prototype.onPreRender = function () {
		for (var i = 0; i < this._systems.length; i++) {
			var system = this._systems[i];
			system.onPreRender();
		}
	};

	World.prototype.onPostRender = function () {
		for (var i = 0; i < this._systems.length; i++) {
			var system = this._systems[i];
			system.onPostRender();
		}
	};

	World.prototype._check = function (entities, callback) {
		// each entity needs to be "checked" against each system
		for (var i = 0; i < entities.length; i++) {
			var entity = entities[i];
			for (var systemIndex = 0; systemIndex < this._systems.length; systemIndex++) {
				var system = this._systems[systemIndex];
				callback(system, entity);
			}
		}

		entities.length = 0;
	};

	/**
	 * Calls .clear on all systems that support this method
	 */
	World.prototype.clear = function () {
		for (var i = 0; i < this._systems.length; i++) {
			var system = this._systems[i];
			if (system.clear) {
				system.clear();
			}
		}

		this._systems = [];

		// severe all connections from entities to this world
		var allEntities = this.entityManager.getEntities();
		for (var i = 0; i < allEntities.length; i++) {
			var entity = allEntities[i];
			entity._world = null;
		}

		this.entityManager.clear();

		this._addedEntities = [];
		this._changedEntities = [];
		this._removedEntities = [];

		// severe the connection to gooRunner
		this.gooRunner = null;

		// todo: remove when World.time is removed
		if (lastInstantiatedWorld === this) {
			lastInstantiatedWorld = undefined;
		}
	};

	module.exports = World;

/***/ },
/* 35 */
/***/ function(module, exports, __webpack_require__) {

	var Component = __webpack_require__(20);
	var StringUtils = __webpack_require__(36);
	var EventTarget = __webpack_require__(37);

	/**
	 * An Entity is a generic container of data.
	 * This data is wrapped in [Components]{@link Component}, which usually provide isolated features (transforms, geometries, materials, scripts and so on).
	 * By setting components to an entity, the entity will get the functionality provided by the components.
	 * For example, an entity with a {@link TransformComponent} and a {@link LightComponent} will be a light source in 3D space.
	 * Note that when attaching components to an entity, methods of the component will be injected into the entity, extending its interface.
	 * @param {World} world The {@link World} this entity will be part of after calling .addToWorld().
	 * @param {string} [name] Entity name.
	 * @param {number} [id] Entity id.
	 */
	function Entity(world, name, id) {
		EventTarget.apply(this);

		this._world = world;
		this._components = [];
		this.id = id !== undefined ? id : StringUtils.createUniqueId('entity');
		this._index = Entity.entityCount;

		this._tags = new Set();
		this._attributes = new Map();

		/*Object.defineProperty(this, 'id', {
			value : Entity.entityCount++,
			writable : false
		});*/
		this.name = name !== undefined ? name : 'Entity_' + this._index;

		// (move to meshrenderercomponent)
		/** Set to true to skip all processing (rendering, script updating, et cetera) of the entity.
		 * @type {boolean}
		 * @default false
		 */
		this.skip = false;

		/** Holds the hidden status of the entity. The hidden status will not however propagate to components or child entities.
		 * @deprecated The usage of this flag changed. Please use entity.hide/show() instead to change the hidden status of the entity and entity.isHidden/isVisiblyHidden() to query the status
		 * @type {boolean}
		 * @default false
		 */
		this.hidden = false;
		//! AT: users are always confused about this - I'll have to hide it

		/**
		 * Has the same function as the `hidden` property, except it's now private.
		 * @type {boolean}
		 * @private
		 */
		this._hidden = false;

		/**
		 * True if the entity is within the frustum
		 * @type {boolean}
		 */
		this.isVisible = false;

		/** Mark entity as static.
		 * Non static entities become roots in the tree of combined ones so one can have statics under a moving node that combines but you can still move the parent node.
		 * @type {boolean}
		 * @default false
		 */
		this.static = false;

		Entity.entityCount++;
	}
	Entity.prototype = Object.create(EventTarget.prototype);
	Entity.prototype.constructor = Entity;

	//! AT: not sure if 'add' is a better name - need to search for something short and compatible with the other 'set' methods
	/**
	 * Sets components on the entity or tries to create and set components out of the supplied parameters.
	 * @example-link http://code.gooengine.com/latest/examples/goo/entities/Entity/Entity-set-example.html Working example
	 * @example
	 * // Create three entities with different components, add them to world
	 * var sphereEntity = new Entity(world).set(sphere, material, [2, 0, 0]).addToWorld();
	 * var lightEntity = new Entity(world).set(light, [0, 1, 0]).addToWorld();
	 * var spinningEntity = new Entity(world).set(box, material, [-2, 0, 0], script).addToWorld();
	 *
	 * @returns {Entity} Returns self to allow chaining.
	 */
	Entity.prototype.set = function () {
		for (var i = 0; i < arguments.length; i++) {
			var argument = arguments[i];
			if (argument instanceof Component) {
				this.setComponent(argument);
			} else {
				// ask all components if they are compatible with the given data
				if (!this._world) { return this; }
				var components = this._world._components;
				for (var j = 0; j < components.length; j++) {
					var component = components[j];
					var applied = component.applyOnEntity(argument, this);
					if (applied) {
						break;
					}
				}
			}
		}

		// allow chaining
		return this;
	};

	/**
	 * Add the entity to the world, making it active and processed by systems and managers.
	 * @param {boolean} [recursive=true] Add children of the transform hierarchy recursively.
	 * @returns {Entity} Returns self to allow chaining.
	 */
	Entity.prototype.addToWorld = function (recursive) {
		this._world.addEntity(this, recursive);
		return this;
	};

	/**
	 * Remove entity from the world.
	 * @param {boolean} [recursive=true] Remove children of the transform hierarchy recursively.
	 * @returns {Entity} Returns self to allow chaining.
	 */
	Entity.prototype.removeFromWorld = function (recursive) {
		this._world.removeEntity(this, recursive);
		return this;
	};

	/**
	 * lower cases the first character of the type parameter.
	 * @param {string} type name.
	 * @returns {string} lower cased type name.
	 * @private
	 */
	function getTypeAttributeName(type) {
		return type.charAt(0).toLowerCase() + type.substr(1);
	}

	/**
	 * Set component of a certain type on entity. The operation has no effect if the entity already contains a component of the same type.
	 *
	 * @param {Component} component Component to set on the entity.
	 * @returns {Entity} Returns self to allow chaining.
	 */
	Entity.prototype.setComponent = function (component) {
		if (this.hasComponent(component.type)) {
			return this;
		} else {
			this._components.push(component);
		}
		this[getTypeAttributeName(component.type)] = component;

		component.entity = this;

		// inform the component it's being attached to an entity
		component.attached(this);

		component.applyAPI(this);

		if (this._world && this._world.entityManager.containsEntity(this)) {
			this._world.changedEntity(this, component, 'addedComponent');
		}

		return this;
	};

	/**
	 * Checks if a component of a specific type is present or not.
	 *
	 * @param {string} type Type of component to check for (eg. 'meshDataComponent').
	 * @returns {boolean}
	 */
	Entity.prototype.hasComponent = function (type) {
		var typeAttributeName = getTypeAttributeName(type);
		return !!this[typeAttributeName];
	};

	/**
	 * Retrieve a component of a specific type.
	 *
	 * @param {string} type Type of component to retrieve (eg. 'transformComponent').
	 * @returns {Component} Component with requested type or undefined if not present.
	 */
	Entity.prototype.getComponent = function (type) {
		var typeAttributeName = getTypeAttributeName(type);
		return this[typeAttributeName];
	};

	/**
	 * Remove a component of a specific type from entity.
	 *
	 * @param {string} type Type of component to remove (eg. 'meshDataComponent').
	 * @returns {Entity} Returns self to allow chaining.
	 */
	Entity.prototype.clearComponent = function (type) {
		var typeAttributeName = getTypeAttributeName(type);
		var component = this[typeAttributeName];

		if (!!component && this._components.indexOf(component) > -1) {
			// inform the component it's being detached from the entity
			component.detached(this);

			component.entity = null;

			// removing API
			component.removeAPI(this);

			// removing from dense array
			var index = this._components.indexOf(component);
			this._components.splice(index, 1);

			// removing from entity
			delete this[typeAttributeName];

			// notifying the world of the change
			if (this._world && this._world.entityManager.containsEntity(this)) {
				this._world.changedEntity(this, component, 'removedComponent');
			}
		}

		return this;
	};

	/**
	 * Adds a tag to the entity.
	 * @param {string} tag
	 * @example-link http://code.gooengine.com/latest/examples/goo/entities/Entity/Entity-tags-example.html Working example
	 * @example
	 * var banana = world.createEntity().setTag('fruit').setTag('green');
	 * @returns {Entity} Returns self to allow chaining.
	 */
	Entity.prototype.setTag = function (tag) {
		this._tags.add(tag);
		return this;
	};

	/**
	 * Checks whether an entity has a tag or not.
	 * @param {string} tag
	 * @example-link http://code.gooengine.com/latest/examples/goo/entities/Entity/Entity-tags-example.html Working example
	 * @example
	 * if (banana.hasTag('yellow')) {
	 *     console.log('The banana is yellow');
	 * }
	 * @returns {boolean}.
	 */
	Entity.prototype.hasTag = function (tag) {
		return this._tags.has(tag);
	};

	/**
	 * Clears a tag on an entity.
	 * @param {string} tag
	 * @example-link http://code.gooengine.com/latest/examples/goo/entities/Entity/Entity-tags-example.html Working example
	 * @example
	 * // Remove 'alive' tag if hit points drops to zero
	 * if (hero.getAttribute('hit-points') <= 0) {
	 *     hero.clearTag('alive');
	 * }
	 * @returns {Entity} Returns self to allow chaining.
	 */
	Entity.prototype.clearTag = function (tag) {
		this._tags.delete(tag);
		return this;
	};

	/**
	 * Sets an attribute and its value on the entity.
	 *
	 * @param {string} attribute
	 * @param value
	 * @example-link http://code.gooengine.com/latest/examples/goo/entities/Entity/Entity-attributes-example.html Working example
	 * @example
	 * // Create an entity with tags and attributes, and add it to world
	 * var hero = world.createEntity()
	 *                 .setTag('hero')
	 *                 .setAttribute('hit-points', 30)
	 *                 .setAttribute('attack-power', 3)
	 *                 .setTag('alive')
	 *                 .addToWorld();
	 *
	 * @returns {Entity} Returns self to allow chaining.
	 */
	Entity.prototype.setAttribute = function (attribute, value) {
		this._attributes.set(attribute, value);
		return this;
	};

	/**
	 * Checks whether an entity has an attribute or not.
	 * @param {string} attribute
	 * @returns {boolean}
	 */
	Entity.prototype.hasAttribute = function (attribute) {
		return this._attributes.has(attribute);
	};

	/**
	 * Gets the value of the specified attribute.
	 * @param {string} attribute
	 * @example
	 * // Check hit points on monster entity
	 * if (monster.getAttribute('hit-points') <= 0) {
	 *     console.log('The hero triumphs!');
	 * }
	 *
	 * @returns {*}
	 */
	Entity.prototype.getAttribute = function (attribute) {
		return this._attributes.get(attribute);
	};

	/**
	 * Clears an attribute of the entity.
	 * @param {string} attribute
	 * @returns {Entity} Returns self to allow chaining.
	 */
	Entity.prototype.clearAttribute = function (attribute) {
		this._attributes.delete(attribute);
		return this;
	};

	/**
	 * @returns {string} Name of entity.
	 */
	Entity.prototype.toString = function () {
		//! AT: should also return a list of its components or something more descriptive than just the name
		return this.name;
	};

	Entity.entityCount = 0;

	module.exports = Entity;


/***/ },
/* 36 */
/***/ function(module, exports) {

	/**
	 * Provides string manipulation methods
	 */
	function StringUtils() {}

	StringUtils.endsWith = function (str, suffix) {
		return str.indexOf(suffix, str.length - suffix.length) !== -1;
	};

	StringUtils.startsWith = function (str, prefix) {
		return str.indexOf(prefix) === 0;
	};

	StringUtils.capitalize = function (str) {
		return str.charAt(0).toUpperCase() + str.substring(1);
	};

	StringUtils.uncapitalize = function (str) {
		return str.charAt(0).toLowerCase() + str.substring(1);
	};

	StringUtils.createUniqueId = function (type) {
		var date = Date.now();
		var uuid = 'xxxxxxxxxxxx4xxxyxxxxxxxxxxxxxxx'.replace(/[xy]/g, function (c) {
			// | 0 is a hack to floor a number, so this is a random number between 0 and 15
			var randomNumber = (date + Math.random() * 16) % 16 | 0;
			if (c === 'x') {
				return randomNumber.toString(16);
			} else {
				// Set bit 6 and 7 to 0 and 1
				return (randomNumber & 0x3 | 0x8).toString(16);
			}
		});
		if (type === undefined) {
			return uuid;
		}
		return uuid + '.' + type;
	};

	/**
	 * Returns the string from the beginning of the string until the specified stop string. The stop string
	 * is not included in the returned string.
	 *
	 * If the specified stop string is not found, the whole string is returned.
	 *
	 * @param {string} string
	 * @param {string} stopString
	 */
	StringUtils.getUntil = function (string, stopString) {
		var stopIndex = string.indexOf(stopString);
		if (stopIndex === -1) {
			return string;
		} else {
			return string.slice(0, stopIndex);
		}
	};

	/**
	 * Returns the string from the last occurence of the stop string until the end. The stop string is not included in the result.
	 * @param {string} string
	 * @param {string} stopString
	 * @returns {string}
	 */
	StringUtils.getAfterLast = function (string, stopString) {
		var stopIndex = string.lastIndexOf(stopString);
		if (stopIndex === -1) {
			return string;
		} else {
			return string.slice(stopIndex + stopString.length, string.length);
		}
	};

	/**
	 * Returns the string from the index of the start string until the end of the string. The start character is
	 * not included in the returned string.
	 *
	 * If the specified start string is not found in the string, an empty string is returned.
	 *
	 * @param {string} string
	 * @param {string} startString
	 */
	StringUtils.getFrom = function (string, startString) {
		var startIndex = string.indexOf(startString);
		if (startIndex === -1) {
			return '';
		} else {
			// Adding offset equal to the length of the start string,
			// to not include the start string in the returned string.
			return string.slice(startIndex + startString.length, string.length);
		}
	};

	StringUtils.getIndexedName = function (base, takenNames, separator) {
		if (!separator) {
			separator = '_';
		}

		var re = new RegExp(base + '(' + separator + '\\d+)?');
		var i;
		var index = 0;
		for (i in takenNames) {
			var name = takenNames[i];
			var m = re.exec(name);
			if (m) {
				if (m.length > 1 && m[1]) {
					var nidx = parseInt(m[1].substring(separator.length), 10);
					if (nidx >= index) {
						index = nidx + 1;
					}
				} else {
					index = 1;
				}
			}
		}

		return base + separator + index;
	};

	StringUtils.getUniqueName = function (desiredName, takenNames, separator) {
		if (takenNames.indexOf(desiredName) === -1) {
			return desiredName;
		}

		return StringUtils.getIndexedName(desiredName, takenNames, separator);
	};

	//! AT: toASCII, in JS everything is caps (JSON, innerHTML, etc)
	StringUtils.toAscii = function (input) {
		return input.replace(/([^\x00-\x7F])/g, 'x');
	};

	/**
	Js implementation of Java's hashcode (sort of). Somewhat useful for creating
	unique ideas that contain [A-Za-z0-9-_]
	*/
	StringUtils.hashCode = function (str) {
		var hash = 0;

		if (str.length === 0) {
			return hash;
		}

		for (var i = 0; i < str.length; i++) {
			var character = str.charCodeAt(i);
			hash = ((hash << 5) - hash) + character;
			hash &= hash; // Convert to 32bit integer
		}

		return btoa(hash).replace('/', '_').replace('+', '-');
	};

	// REVIEW: idCounter is only updated on declaration, same session will always have the same seed
	// used in generating ids
	var idCounter = Date.now();

	// returns an almost unique id
	StringUtils.getUniqueId = function () {
		idCounter++;
		var stringedArguments = Array.prototype.slice.call(arguments, 0).join('');
		return StringUtils.hashCode(idCounter + '' + stringedArguments);
	};

	/**
	 * Escapes all HTML entities from a given string.
	 * @param {string} text The string whose HTML entities are to be encoded.
	 * @returns {string} The specified string with all its HTML entities encoded.
	 */
	StringUtils.escapeHtmlEntities = function (text) {
		var div = document.createElement('div');
		div.appendChild(document.createTextNode(text));

		// Any edge cases that are not escaped by the browser.
		var edgeCases = { 34: 'quot' };

		return div.innerHTML.replace(/[\u00A0-\u2666\"\']/g, function (c) {
			var entityName = edgeCases[c.charCodeAt(0)];
			return '&' + (entityName || '#' + c.charCodeAt(0)) + ';';
		});
	};

	/**
	 * Parses an URL
	 * @param {string} url
	 * @example
	 *     var url = 'http://example.com:1234/images/goo.png?param=1#fragment';
	 *     var parts = Ajax.parseURL(url);
	 *     parts.scheme			// 'http'
	 *     parts.domain			// 'example.com'
	 *     parts.user_info		// undefined
	 *     parts.port			// '1234'
	 *     parts.path			// '/images/goo.png'
	 *     parts.query_data		// 'param=1'
	 *     parts.fragment		// 'fragment'
	 */

	//! AT: this does far too much and is used only to get the extension of whatever the uri is
	// write a faster one instead

	// let's save it ourselves if the browser doesn't automagically do it
	/**
	 * @private
	 */
	var splitRegExp = new RegExp(
		'^' +
		'(?:' +
		'([^:/?#.]+)' +                         // scheme - ignore special characters
		// used by other URL parts such as :,
		// ?, /, #, and .
		':)?' +
		'(?://' +
		'(?:([^/?#]*)@)?' +                     // userInfo
		'([\\w\\d\\-\\u0100-\\uffff.%]*)' +     // domain - restrict to letters,
		// digits, dashes, dots, percent
		// escapes, and unicode characters.
		'(?::([0-9]+))?' +                      // port
		')?' +
		'([^?#]+)?' +                           // path
		'(?:\\?([^#]*))?' +                     // query
		'(?:#(.*))?' +                          // fragment
		'$');

	StringUtils.parseURL = function (uri) {
		var split = uri.match(splitRegExp);
		return {
			'scheme': split[1],
			'user_info': split[2],
			'domain': split[3],
			'port': split[4],
			'path': split[5],
			'query_data': split[6],
			'fragment': split[7]
		};
	};

	module.exports = StringUtils;


/***/ },
/* 37 */
/***/ function(module, exports) {

	/**
	 * EventTarget is implemented by objects that can receive events and may have listeners for them.
	 * @example
	 * function MyObject() {
	 * 		EventTarget.apply(this, arguments);
	 * }
	 * MyObject.prototype = Object.create(EventTarget.prototype);
	 */
	function EventTarget() {
		this._listenerMap = new Map();
		this._listenersCopy = [];
	}

	/**
	 * Sends an event to all listeners
	 * @param {Object} event Event passed to the listeners
	 * @param {string} event.type The name of the event
	 * @returns {EventTarget} Self for chaining.
	 */
	EventTarget.prototype.fire = function (event) {
		var listeners = this._listenerMap.get(event.type);
		if (listeners) {
			event.target = this;

			var l = listeners.length;

			var listenersCopy = this._listenersCopy;
			for (var i = 0; i < l; i++) {
				listenersCopy[i] = listeners[i];
			}

			for (var i = 0; i < l; i++) {
				listenersCopy[i](event);
			}
		}

		return this;
	};

	/**
	 * Registers a new listener for a certain event type
	 * @param {string} type Type of event listener to add
	 * @param {Function} listener Listener to add
	 * @returns {EventTarget} Self for chaining.
	 */
	EventTarget.prototype.on = function (type, listener) {
		var listeners = this._listenerMap.get(type);
		if (!listeners) {
			listeners = [listener];
			this._listenerMap.set(type, listeners);
		} else if (listeners.indexOf(listener) === -1) {
			listeners.push(listener);
		}

		return this;
	};

	/**
	 * Removes a listener for a certain event type
	 * @param {string} type Type of event listener to remove
	 * @param {Function} listener Listener to remove
	 * @returns {EventTarget} Self for chaining.
	 */
	EventTarget.prototype.off = function (type, listener) {
		if (listener) {
			var index;
			var listeners = this._listenerMap.get(type);
			if (listeners && (index = listeners.indexOf(listener)) !== -1) {
				listeners.splice(index, 1);

				if (listeners.length === 0) {
					this._listenerMap.delete(type);
				}
			}
		} else {
			this._listenerMap.delete(type);
		}

		return this;
	};

	/**
	 * Test if there are any listeners bound to a certain event type
	 * @param {string} type Type of event to test for
	 * @returns {boolean} If there are any listeners of specified type on this target
	 */
	EventTarget.prototype.has = function (type) {
		return this._listenerMap.has(type);
	};

	module.exports = EventTarget;

/***/ },
/* 38 */
/***/ function(module, exports, __webpack_require__) {

	var Manager = __webpack_require__(39);
	var EntitySelection = __webpack_require__(21);

	/**
	 * Main handler of all entities in the world.
	 * @extends Manager
	 */
	function EntityManager() {
		Manager.call(this);

		this.type = 'EntityManager';

		this._entitiesById = new Map();
		this._entitiesByIndex = new Map();
		this._entityCount = 0;

		/** Entity selector. Its methods return an {@link EntitySelection}. Can select by id or name, see examples for usage.
		 * <br><i>Injected into {@link World}.</i>
		 * @member by
		 * @memberOf EntityManager.prototype
		 * @example
		 * var byId = gooRunner.world.by.id("2b88941938444da8afab8205b1c80616.entity").first();
		 * var byName = gooRunner.world.by.name("Box").first();
		 */
		this.api = {
			id: function () {
				var ret = EntityManager.prototype.getEntityById.apply(this, arguments);
				return new EntitySelection(ret);
			}.bind(this),
			name: function (name) {
				var entities = this.getEntities();
				return new EntitySelection(entities.filter(function (entity) {
					return entity.name === name;
				}));
			}.bind(this)
		};
	}

	EntityManager.prototype = Object.create(Manager.prototype);

	EntityManager.prototype.added = function (entity) {
		if (!this.containsEntity(entity)) {
			this._entitiesById.set(entity.id, entity); //! AT: more entities can share the same id!
			// happens if you're loading the same entity more than once with the dynamic loader
			this._entitiesByIndex.set(entity._index, entity);
			this._entityCount++;
		}
	};

	EntityManager.prototype.removed = function (entity) {
		if (this.containsEntity(entity)) {
			this._entitiesById.delete(entity.id); //! AT: more entities can share the same id!
			// happens if you're loading the same entity more than once with the dynamic loader
			this._entitiesByIndex.delete(entity._index);
			this._entityCount--;
		}
	};

	/**
	 * Checks if an entity exists
	 *
	 * @param entity Entity to check for
	 * @returns {boolean} true if the entity exists
	 */
	EntityManager.prototype.containsEntity = function (entity) {
		return this._entitiesByIndex.has(entity._index);
	};

	/**
	 * Retrieve an entity based on an id
	 *
	 * @param id Id to retrieve entity for
	 * @returns Entity or undefined if not existing
	 */
	EntityManager.prototype.getEntityById = function (id) {
		return this._entitiesById.get(id); //! AT: more entities can share the same id!
		// happens if you're loading the same entity more than once with the dynamic loader
	};

	/**
	 * Retrieve an entity based on an index
	 *
	 * @param index Index to retrieve entity for
	 * @returns Entity or undefined if not existing
	 */
	EntityManager.prototype.getEntityByIndex = function (index) {
		return this._entitiesByIndex.get(index);
	};

	/**
	 * Retrieve an entity based on its name
	 *
	 * @param name Name to retrieve entity for
	 * @returns Entity or undefined if not existing
	 */
	EntityManager.prototype.getEntityByName = function (name) {
		if (this._entityCount <= 0) { return; }

		var foundEntity;
		this._entitiesByIndex.forEach(function (entity) {
			if (entity.name === name) {
				foundEntity = entity;
			}
		});

		return foundEntity;
	};

	/**
	 * Get the number of entities currently indexed by the Entity Manager
	 *
	 * @returns {number}
	 */
	EntityManager.prototype.size = function () {
		return this._entityCount;
	};

	/**
	 * Get all entities in the world
	 *
	 * @returns {Array} Array containing all entities in the world
	 */
	//! AT: this need to return an EntitySelection object
	EntityManager.prototype.getEntities = function () {
		var entities = [];

		this._entitiesByIndex.forEach(function (entity) {
			entities.push(entity);
		});

		return entities;
	};

	/**
	 * Get all entities on top level based on the transform scenegraph
	 *
	 * @returns {Array} Array containing all top entities
	 */
	EntityManager.prototype.getTopEntities = function () {
		var entities = [];

		this._entitiesByIndex.forEach(function (entity) {
			if (!entity.transformComponent || !entity.transformComponent.parent) {
				entities.push(entity);
			}
		});

		return entities;
	};

	/**
	 * Removes all entities
	 */
	EntityManager.prototype.clear = function () {
		this._entitiesById.clear();
		this._entitiesByIndex.clear();
		this._entityCount = 0;
	};

	module.exports = EntityManager;

/***/ },
/* 39 */
/***/ function(module, exports) {

	/**
	 * Base class for managers.
	 */
	function Manager() {
		this.installedAPI = {};
	}

	Manager.prototype.applyAPI = function (worldBy) {
		var api = this.api;
		for (var key in api) {
			if (typeof worldBy[key] === 'undefined') {
				worldBy[key] = api[key];
				this.installedAPI[key] = true;
			} else {
				throw new Error('Could not install method ' + key + ' of ' + this.type + ' as it is already taken');
			}
		}
	};

	module.exports = Manager;

/***/ },
/* 40 */
/***/ function(module, exports, __webpack_require__) {

	var Transform = __webpack_require__(41);
	var Vector3 = __webpack_require__(8);
	var Component = __webpack_require__(20);
	var EntitySelection = __webpack_require__(21);

	/**
	 * Holds the transform of an entity. It also allows for a scene graph to be created,
	 * in which transforms are inherited down the tree.
	 * @example-link http://code.gooengine.com/latest/visual-test/goo/entities/components/TransformComponent/TransformComponent-vtest.html Working example
	 * @extends Component
	 */
	function TransformComponent() {
		Component.apply(this, arguments);

		this.type = 'TransformComponent';

		/**
		 * Parent TransformComponent in the "scene graph".
		 * @type {TransformComponent}
		 */
		this.parent = null;

		/**
		 * Child TransformComponents in the "scene graph".
		 * @type {Array<TransformComponent>}
		 */
		this.children = [];

		/**
		 * The entity's transform in local space.
		 * @type {Transform}
		 */
		this.transform = new Transform();

		/**
		 * The entity's transform in world space.
		 * @readonly
		 * @type {Transform}
		 */
		this.worldTransform = new Transform();

		this._localTransformDirty = true;
		this._worldTransformDirty = true;

		// @ifdef DEBUG
		Object.seal(this);
		// @endif
	}

	TransformComponent.type = 'TransformComponent';

	TransformComponent.prototype = Object.create(Component.prototype);
	TransformComponent.prototype.constructor = TransformComponent;

	//! AT: can this stay not on the prototype, but on the constructor?
	// it would require Transform.prototype.constructor = TransformComponent; (for all components)
	TransformComponent.prototype.api = {
		// these @target-class comments can sit anywhere in the source (as far as modoc is concerned)
		// I'm placing it here however since it's near the code it documents
		/**
		 * Sets the translation of this entity. Injected on entities with a transformComponent
		 * @target-class Entity setTranslation method
		 * @param {(Vector3|Array<number>)} translation
		 * @returns {Entity} Self to allow chaining
		 */
		setTranslation: function () {
			TransformComponent.prototype.setTranslation.apply(this.transformComponent, arguments);
			return this;
		},

		/**
		 * Sets the rotation of this entity. Injected on entities with a transformComponent
		 * @target-class Entity setRotation method
		 * @param {(Vector3|Array<number>)} angle
		 * @returns {Entity} Self to allow chaining
		 */
		setRotation: function () {
			TransformComponent.prototype.setRotation.apply(this.transformComponent, arguments);
			return this;
		},

		/**
		 * Sets the scale of this entity. Injected on entities with a transformComponent
		 * @target-class Entity setScale method
		 * @param {(Vector3|Array<number>)} scale
		 * @returns {Entity} Self to allow chaining
		 */
		setScale: function () {
			TransformComponent.prototype.setScale.apply(this.transformComponent, arguments);
			return this;
		},

		/**
		 * Orients the entity so it faces the supplied look at point. Injected on entities with a transformComponent
		 * @target-class Entity lookAt method
		 * @param {(Vector3|Array<number>)} lookAtPoint
		 * @returns {Entity} Self to allow chaining
		 */
		lookAt: function () {
			TransformComponent.prototype.lookAt.apply(this.transformComponent, arguments);
			return this;
		},

		/**
		 * Translates the entity with the supplied amount multipled by the entity's orientation. Injected on entities with a transformComponent
		 * @target-class Entity move method
		 * @param {(Vector3|Array<number>)} translation
		 * @returns {Entity} Self to allow chaining
		 */
		move: function () {
			TransformComponent.prototype.move.apply(this.transformComponent, arguments);
			return this;
		},

		/**
		 * Returns the local translation of the entity. Injected on entities with a transformComponent
		 * @target-class Entity getTranslation method
		 * @returns {Vector3} Translation
		 */
		getTranslation: function () {
			return TransformComponent.prototype.getTranslation.apply(this.transformComponent, arguments);
		},

		/**
		 * Returns the local rotation of the entity. Injected on entities with a transformComponent
		 * @target-class Entity getRotation method
		 * @returns {Vector3} Rotation
		 */
		getRotation: function () {
			return TransformComponent.prototype.getRotation.apply(this.transformComponent, arguments);
		},

		/**
		 * Returns the local scale of the entity. Injected on entities with a transformComponent
		 * @target-class Entity getScale method
		 * @returns {Vector3} Scale
		 */
		getScale: function () {
			return TransformComponent.prototype.getScale.apply(this.transformComponent, arguments);
		},

		/**
		 * Translates the entity with the given amount. Injected on entities with a transformComponent
		 * @target-class Entity addTranslation method
		 * @param {(Vector3|Array<number>)} translation
		 * @returns {Entity} Self to allow chaining
		 */
		addTranslation: function () {
			TransformComponent.prototype.addTranslation.apply(this.transformComponent, arguments);
			return this;
		},

		/**
		 * Rotates the entity with the given amount. Injected on entities with a transformComponent
		 * @target-class Entity addRotation method
		 * @param {(Vector3|Array<number>)} rotation
		 * @returns {Entity} Self to allow chaining
		 */
		addRotation: function () {
			TransformComponent.prototype.addRotation.apply(this.transformComponent, arguments);
			return this;
		},

		// no, there's no addScale

		/**
		 * Attaches the supplied entity to this entity as a child. Injected on entities with a transformComponent
		 * @target-class Entity attachChild method
		 * @param {Entity} childEntity
		 * @param {boolean} keepTransform If enabled will preserve the world transform of the child entity
		 * @returns {Entity} Self to allow chaining
		 */
		attachChild: function (childEntity, keepTransform) {
			this.transformComponent.attachChild(childEntity.transformComponent, keepTransform);
			return this;
		},

		/**
		 * Detaches the supplied entity from this entity. Injected on entities with a transformComponent
		 * @target-class Entity detachChild method
		 * @param {Entity} childEntity
		 * @param {boolean} keepTransform If enabled will preserve the world transform of the child entity
		 * @returns {Entity} Self to allow chaining
		 */
		detachChild: function (childEntity, keepTransform) {
			this.transformComponent.detachChild(childEntity.transformComponent, keepTransform);
			return this;
		},

		/**
		 * Returns an {@link EntitySelection} of the children of this entity. Injected on entities with a transformComponent
		 * @target-class Entity children method
		 * @returns {EntitySelection}
		 */
		children: function () {
			return new EntitySelection(this).children();
		},

		/**
		 * Returns an {@link EntitySelection} of the parent of this entity. Injected on entities with a transformComponent
		 * @target-class Entity parent method
		 * @returns {EntitySelection}
		 */
		parent: function () {
			return new EntitySelection(this).parent();
		},

		/**
		 * Traverses the entity hierarchy downwards starting from this entity and applies a function to all entities traversed.
		 * Traversal can be stopped if the function returns 'false'.
		 * Injected on entities with a transformComponent
		 * @target-class Entity traverse method
		 * @param {function (entity: Entity, level: number) : boolean} callback The function to be applied to traversed entities. Takes an entity and the current deph level and returns a boolean.
		 * @param {number} [level=0]
		 * @returns {Entity} Self to allow chaining
		 */
		traverse: function (callback, level) {
			level = level !== undefined ? level : 0;

			if (callback(this, level) !== false) {
				for (var i = 0; i < this.transformComponent.children.length; i++) {
					var childEntity = this.transformComponent.children[i].entity;
					childEntity.traverse(callback, level + 1);
				}
			}

			return this;
		},

		/**
		 * Traverses the entity hierarchy upwards starting from this entity and applies a function to all entities traversed.
		 * Traversal can be stopped if the function returns 'false'.
		 * Injected on entities with a transformComponent
		 * @target-class Entity traverseUp method
		 * @param {function (entity: Entity) : boolean} callback The function to be applied to traversed entities. Takes an entity and returns a boolean.
		 * @returns {Entity} Self to allow chaining
		 */
		traverseUp: function (callback) {
			var transformComponent = this.transformComponent;
			while (callback(transformComponent.entity) !== false && transformComponent.parent) {
				transformComponent = transformComponent.parent;
			}

			return this;
		},

		/**
		 * Hides the entity and its children. Injected on entities with a transformComponent
		 * @target-class Entity hide method
		 * @returns {Entity} Self to allow chaining
		 */
		hide: function () {
			this._hidden = true;

			// hide everything underneath this
			this.traverse(function (entity) {
				// will have to refactor this loop in some function; it's used in other places too
				for (var i = 0; i < entity._components.length; i++) {
					var component = entity._components[i];
					if (typeof component.hidden === 'boolean') {
						component.hidden = true;
					}
				}
			});

			return this;
		},

		/**
		 * Clears the hidden flag on this entity. The entity may still not show if it has a hidden ancestor. Injected on entities with a transformComponent
		 * @target-class Entity show method
		 * @returns {Entity} Self to allow chaining
		 */
		// will not show the entity (and it's children) if any of its ancestors are hidden
		show: function () {
			this._hidden = false;

			// first search if it has hidden parents to determine if itself should be visible
			var pointer = this;
			while (pointer.transformComponent.parent) {
				pointer = pointer.transformComponent.parent.entity;
				if (pointer._hidden) {
					// extra check and set might be needed
					for (var i = 0; i < this._components.length; i++) {
						var component = this._components[i];
						if (typeof component.hidden === 'boolean') {
							component.hidden = true;
						}
					}
					return this;
				}
			}

			this.traverse(function (entity) {
				if (entity._hidden) { return false; }
				for (var i = 0; i < entity._components.length; i++) {
					var component = entity._components[i];
					if (typeof component.hidden === 'boolean') {
						component.hidden = entity._hidden;
					}
				}
			});

			return this;
		},

		/**
		 * Returns whether the entity or any of its ancestors are hidden. Injected on entities with a transformComponent
		 * @target-class Entity isVisiblyHidden method
		 * @returns {boolean}
		 */
		isVisiblyHidden: function () {
			var pointer = this;

			if (pointer._hidden) {
				return true;
			}

			while (pointer.transformComponent.parent) {
				pointer = pointer.transformComponent.parent.entity;
				if (pointer._hidden) {
					return true;
				}
			}

			return false;
		},

		/**
		 * Returns the 'hidden' status of this entity. The entity may still be hidden if one of its ancestors is hidden. Injected on entities with a transformComponent
		 * @target-class Entity isHidden method
		 * @returns {boolean}
		 */
		isHidden: function () {
			return this._hidden;
		}
	};

	TransformComponent.entitySelectionAPI = {
		setTranslation: TransformComponent.prototype.api.setTranslation,
		setRotation: TransformComponent.prototype.api.setRotation,
		setScale: TransformComponent.prototype.api.setScale,
		lookAt: TransformComponent.prototype.api.lookAt,
		move: TransformComponent.prototype.api.move,
		addTranslation: TransformComponent.prototype.api.addTranslation,
		addRotation: TransformComponent.prototype.api.addRotation,
		hide: TransformComponent.prototype.api.hide,
		show: TransformComponent.prototype.api.show
	};

	var tmpVec = new Vector3();

	/**
	 * Returns the local translation vector. Do not modify the returned value, use .setTranslation() instead.
	 * @returns {Vector3}
	 * @example
	 * var translation = entity.transformComponent.getTranslation();
	 */
	TransformComponent.prototype.getTranslation = function () {
		return this.sync().transform.translation;
	};

	/**
	 * Returns the world translation vector. Do not modify the returned value, use .setTranslation() instead.
	 * @returns {Vector3}
	 * @example
	 * var worldTranslation = entity.transformComponent.getWorldTranslation();
	 */
	TransformComponent.prototype.getWorldTranslation = function () {
		return this.sync().worldTransform.translation;
	};

	/**
	 * Set the local translation vector.
	 * @example
	 * entity.transformComponent.setTranslation(1, 1, 0);
	 * entity.transformComponent.setTranslation(new Vector3(1, 1, 0));
	 * entity.transformComponent.setTranslation([1, 1, 0]);
	 *
	 * @param {(Vector | Array<number>)} translation
	 * @returns {TransformComponent} Self for chaining.
	 */
	TransformComponent.prototype.setTranslation = function () {
		this.transform.translation.set(Vector3.fromAny.apply(null, arguments));
		this.setUpdated();
		return this;
	};

	/**
	 * Adds to this transform's local translation.
	 * @example
	 * entity.transformComponent.addTranslation(1, 2, 1);
	 * entity.transformComponent.addTranslation(new Vector3(1, 2, 1));
	 * entity.transformComponent.addTranslation([1, 2, 1]);
	 *
	 * @param {(Vector | Array<number>)} Component values.
	 * @returns {TransformComponent} Self for chaining.
	 */
	TransformComponent.prototype.addTranslation = function () {
		this.transform.translation.add(Vector3.fromAny.apply(null, arguments));
		this.setUpdated();
		return this;
	};

	/**
	 * Get the local transform scale. Do not modify the returned value, use .setScale() instead.
	 * @returns {Vector3}
	 * @example
	 * var scale = entity.transformComponent.getScale();
	 */
	TransformComponent.prototype.getScale = function () {
		return this.sync().transform.scale;
	};

	/**
	 * Get the world transform scale. Do not modify the returned value, use .setScale() instead.
	 * @returns {Vector3}
	 * @example
	 * var scale = entity.transformComponent.getWorldScale();
	 */
	TransformComponent.prototype.getWorldScale = function () {
		return this.sync().worldTransform.scale;
	};

	/**
	 * Sets this transform local scale.
	 * @param {(Vector | Array<number>)} Component values.
	 * @returns {TransformComponent} Self for chaining
	 * @example
	 * entity.transformComponent.setScale(1, 1, 0);
	 * entity.transformComponent.setScale(new Vector3(1, 1, 0));
	 * entity.transformComponent.setScale([1, 1, 0]);
	 */
	TransformComponent.prototype.setScale = function () {
		this.transform.scale.set(Vector3.fromAny.apply(null, arguments));
		this.setUpdated();
		return this;
	};


	/**
	 * Returns the local rotation matrix. Do not modify the returned value, use .setRotationMatrix() instead.
	 * @returns {Matrix3}
	 * @example
	 * var matrix = entity.transformComponent.getRotationMatrix();
	 */
	TransformComponent.prototype.getRotationMatrix = function () {
		return this.sync().transform.rotation;
	};

	/**
	 * Sets the local rotation matrix.
	 * @returns {TransformComponent} Self for chaining
	 * @example
	 * entity.transformComponent.setRotationMatrix(new Matrix3());
	 */
	TransformComponent.prototype.setRotationMatrix = function (matrix) {
		this.transform.rotation.copy(matrix);
		this.setUpdated();
		return this;
	};

	/**
	 * Returns the world rotation matrix. Do not modify the returned value, use .setRotationMatrix() instead.
	 * @returns {Matrix3}
	 * @example
	 * var worldRotation = entity.transformComponent.getWorldRotationMatrix();
	 */
	TransformComponent.prototype.getWorldRotationMatrix = function () {
		return this.sync().worldTransform.rotation;
	};

	/**
	 * Gets the local rotation in Euler angles (in radians, Euler order YZX).
	 * @param {Vector3} [target] Target vector for storage. If not provided, a new vector object will be created and returned.
	 * @returns {Vector3}
	 *
	 * @example
	 * var localRotation = entity.transformComponent.getRotation(); // warning: creates a new Vector3 object
	 * var localRotation2 = new Vector3();
	 * entity.transformComponent.getRotation(localRotation2); // stores the result without creating a new object
	 */
	TransformComponent.prototype.getRotation = function (target) {
		target = target || new Vector3();
		return this.sync().transform.rotation.toAngles(target);
	};

	/**
	 * Adds to this transform's rotation using Euler angles (in radians, Euler order YZX).
	 * @param {(Vector | Array<number>)} Component values.
	 * @returns {TransformComponent} Self for chaining.
	 *
	 * @example
	 * entity.transformComponent.addRotation(Math.PI / 4, 0, 0);
	 * entity.transformComponent.addRotation(new Vector3(Math.PI / 4, 0, 0));
	 * entity.transformComponent.addRotation([Math.PI / 4, 0, 0]);
	 */
	TransformComponent.prototype.addRotation = function () {
		this.getRotation(tmpVec);
		if (arguments.length === 1 && typeof (arguments[0]) === 'object') {
			var arg0 = arguments[0];
			if (arg0 instanceof Vector3) {
				this.transform.rotation.fromAngles(tmpVec.x + arg0.x, tmpVec.y + arg0.y, tmpVec.z + arg0.z);
			} else if (arg0.length === 3) {
				this.transform.rotation.fromAngles(tmpVec.x + arg0[0], tmpVec.y + arg0[1], tmpVec.z + arg0[2]);
			}
		} else {
			this.transform.rotation.fromAngles(tmpVec.x + arguments[0], tmpVec.y + arguments[1], tmpVec.z + arguments[2]);
		}

		this.setUpdated();
		return this;
	};

	/**
	 * Sets this transform's rotation around X, Y and Z axis (in radians, Euler order YZX). The rotation is applied in X, Y, Z order.
	 * @param {(Vector | Array<number>)} Component values.
	 * @returns {TransformComponent} Self for chaining.
	 *
	 * @example
	 * entity.transformComponent.setRotation(Math.PI / 4, 0, 0);
	 * entity.transformComponent.setRotation(new Vector3(Math.PI / 4, 0, 0));
	 * entity.transformComponent.setRotation([Math.PI / 4, 0, 0]);
	 */
	TransformComponent.prototype.setRotation = function () {
		if (arguments.length === 1 && typeof (arguments[0]) === 'object') {
			var arg0 = arguments[0];
			if (arg0 instanceof Vector3) {
				this.transform.rotation.fromAngles(arg0.x, arg0.y, arg0.z);
			} else if (arg0.length === 3) {
				this.transform.rotation.fromAngles(arg0[0], arg0[1], arg0[2]);
			}
		} else {
			this.transform.rotation.fromAngles(arguments[0], arguments[1], arguments[2]);
		}

		this.setUpdated();
		return this;
	};

	/**
	 * Sets the transform to look in a specific direction.
	 * <br /><i>Injected into entity when adding component.</i>
	 *
	 * @param {(Vector3|Entity)} position Target position.
	 * @param {Vector3} [up=(0, 1, 0)] Up vector.
	 * @returns {TransformComponent} Self for chaining.
	 *
	 * @example
	 * // Omitted up vector assumes Y is up:
	 * entity.transformComponent.lookAt(1, 2, 3);
	 * entity.transformComponent.lookAt([1, 2, 3]);
	 * entity.transformComponent.lookAt(new Vector3(1, 2, 3));
	 * entity.transformComponent.lookAt(otherEntity);
	 *
	 * // However, you can pass the up vector as well:
	 * entity.transformComponent.lookAt([1, 2, 3], [0, 1, 0]);
	 * entity.transformComponent.lookAt(new Vector3(1, 2, 3), new Vector3(0, 1, 0));
	 * entity.transformComponent.lookAt(otherEntity, new Vector3(0, 1, 0));
	 */
	TransformComponent.prototype.lookAt = function (position, up) {
		if (arguments.length === 3) {
			this.transform.lookAt(new Vector3(arguments[0], arguments[1], arguments[2]));
		} else if (position.transformComponent) {
			this.transform.lookAt(position.transformComponent.sync().worldTransform.translation, up);
		} else {
			if (Array.isArray(position)) {
				position = Vector3.fromArray(position);
			}
			if (Array.isArray(up)) {
				up = Vector3.fromArray(up);
			}
			this.transform.lookAt(position, up);
		}
		this.setUpdated();
		return this;
	};

	/**
	 * Adds to the translation in a local direction.
	 * @param {(Vector | Array<number>)} component values.
	 * @returns {TransformComponent} Self for chaining.
	 *
	 * @example
	 * // Move the spaceShip entity in its own forward direction
	 * spaceShip.transformComponent.move(new Vector3(0, 0, -1));
	 */
	TransformComponent.prototype.move = (function () {
		var moveWorldDirection = new Vector3();
		return function () {
			var moveLocalDirection = Vector3.fromAny.apply(null, arguments);
			this.transform.applyForwardVector(moveLocalDirection, moveWorldDirection);
			this.addTranslation(moveWorldDirection);
			return this;
		};
	})();

	/**
	 * Mark the component for updates of world transform. Needs to be called after manually changing the transform without using helper functions.
	 */
	TransformComponent.prototype.setUpdated = function () {
		this._worldTransformDirty = this._localTransformDirty = true;
	};

	/**
	 * Handles attaching itself to an entity. Should only be called by the engine.
	 * @private
	 * @param entity
	 */
	TransformComponent.prototype.attached = function (entity) {
		this.entity = entity;
	};

	/**
	 * Handles detaching itself to an entity. Should only be called by the engine.
	 * @private
	 * @param entity
	 */
	TransformComponent.prototype.detached = function (/*entity*/) {
		this.entity = undefined; //! AT: used to be 'undefined' when it was handled in Entity; should instead be null
	};

	/**
	 * Attach a child transform to this component tree
	 * <br /><i>Injected into entity when adding component.</i>
	 *
	 * @param {TransformComponent} childComponent Child transform component to attach
	 * @param {boolean} [keepTransform=false] If enabled, the child's position, rotation and scale will appear unaffected
	 */
	TransformComponent.prototype.attachChild = function (childComponent, keepTransform) {
		var component = this;
		while (component) {
			if (component === childComponent) {
				console.warn('attachChild: An object can\'t be added as a descendant of itself.');
				return;
			}
			component = component.parent;
		}
		if (childComponent.parent) {
			childComponent.parent.detachChild(childComponent);
		}

		if (keepTransform) {
			childComponent.sync();
			this.sync();
			childComponent.transform.multiply(this.worldTransform.invert(), childComponent.transform);
			childComponent.setUpdated();
		}

		childComponent.parent = this;
		this.children.push(childComponent);
	};

	/**
	 * Detach a child transform from this component tree.
	 * <br /><i>Injected into entity when adding component.</i>
	 *
	 * @param {TransformComponent} childComponent child transform component to detach
	 * @param {boolean} [keepTransform=false] If enabled, the child's position, rotation and scale will appear unaffected
	 */
	TransformComponent.prototype.detachChild = function (childComponent, keepTransform) {
		if (childComponent === this) {
			console.warn('detachChild: An object can\'t be removed from itself.');
			return;
		}

		if (keepTransform) {
			childComponent.transform.copy(childComponent.sync().worldTransform);
		}

		var index = this.children.indexOf(childComponent);
		if (index !== -1) {
			childComponent.parent = null;
			this.children.splice(index, 1);
		}

		childComponent.setUpdated();
	};

	/**
	 * Update component's transform.
	 */
	TransformComponent.prototype.updateTransform = function () {
		this.transform.update();
		this._localTransformDirty = false;
		this._worldTransformDirty = true;
	};

	/**
	 * Update component's world transform (resulting transform considering parent transformations).
	 */
	TransformComponent.prototype.updateWorldTransform = (function () {
		var transformUpdatedEvent = {
			type: 'transformUpdated'
		};
		return function () {
			if (this._localTransformDirty) {
				this.updateTransform();
			}

			var worldTransform = this.worldTransform;
			var transform = this.transform;

			if (this.parent) {
				worldTransform.multiply(this.parent.worldTransform, transform);
			} else {
				worldTransform.copy(transform);
			}

			worldTransform.updateNormalMatrix();

			var entity = this.entity;
			if (entity) {
				entity.fire(transformUpdatedEvent);
			}
			this._worldTransformDirty = false;
		};
	})();

	/**
	 * Update the local and world transforms of the entity tree above this component (and the component itself).
	 */
	TransformComponent.prototype.sync = (function () {
		var parents = [];
		return function () {
			var current = this;

			while (current !== null) {
				parents.push(current);
				current = current.parent;
			}

			var update = false;
			for (var i = parents.length - 1; i >= 0; i--) {
				var component = parents[i];
				if (component._worldTransformDirty || update) {
					update = true; // update the rest of the tree branch
					component.updateWorldTransform();

					// Parent was dirty but we set it to undirty. The children still need to be dirty because we didn't update them yet.
					var children = component.children;
					var l = children.length;
					while (l--) {
						children[l]._worldTransformDirty = true;
					}
				}
			}

			parents.length = 0;

			return this;
		};
	})();

	TransformComponent.applyOnEntity = function (obj, entity) {
		var transformComponent = entity.transformComponent;

		if (!transformComponent) {
			transformComponent = new TransformComponent();
		}

		var matched = false;
		if (Array.isArray(obj) && obj.length === 3) {
			transformComponent.transform.translation.setDirect(obj[0], obj[1], obj[2]);
			matched = true;
		} else if (obj instanceof Vector3) {
			transformComponent.transform.translation.setDirect(obj.x, obj.y, obj.z);
			matched = true;
		} else if (typeof obj === 'object' &&
			typeof obj.x !== 'undefined' && typeof obj.y !== 'undefined' && typeof obj.z !== 'undefined') {
			transformComponent.transform.translation.setDirect(obj.x, obj.y, obj.z);
			matched = true;
		} else if (obj instanceof Transform) {
			transformComponent.transform = obj;
			matched = true;
		}

		if (matched) {
			transformComponent.setUpdated();
			entity.setComponent(transformComponent);
			return true;
		}
	};

	module.exports = TransformComponent;

/***/ },
/* 41 */
/***/ function(module, exports, __webpack_require__) {

	var Vector3 = __webpack_require__(8);
	var Matrix3 = __webpack_require__(24);
	var Matrix4 = __webpack_require__(33);
	var MathUtils = __webpack_require__(9);

	/**
	 * Transform models a transformation in 3d space as: Y = M*X+T, with M being a Matrix3 and T is a Vector3. Generally M will be a rotation
	 *        only matrix in which case it is represented by the matrix and scale fields as R*S, where S is a positive scale vector. For non-uniform
	 *        scales and reflections, use setMatrix, which will consider M as being a general 3x3 matrix and disregard anything set in scale.
	 */
	function Transform() {
		/** Read only, will be updated automatically by {@link Transform.update}
		 * @type {Matrix4}
		 */
		this.matrix = new Matrix4();
		this.normalMatrix = new Matrix3();

		/** @type {Vector3} */
		this.translation = new Vector3();
		/** @type {Matrix3} */
		this.rotation = new Matrix3();
		/** @type {Vector3} */
		this.scale = new Vector3(1, 1, 1);

		// @ifdef DEBUG
		Object.seal(this);
		// @endif
	}

	var tmpVec = new Vector3();
	var tmpVec2 = new Vector3();
	var tmpMat1 = new Matrix3();

	/**
	 * Combines two transforms into one. This will only work if scaling in the left hand transform is uniform
	 * @param {Transform} lhs left hand side transform
	 * @param {Transform} rhs right hand side transform
	 * @param {Transform} target
	 * @returns {Transform} target
	 */
	Transform.combine = function (lhs, rhs, target) {
		target = target || new Transform();

		// Translation
		tmpVec.set(rhs.translation);
		// Rotate translation
		tmpVec.applyPost(lhs.rotation);
		// Scale translation
		tmpVec.mul(lhs.scale);
		// Translate translation
		tmpVec.add(lhs.translation);

		// Scale
		tmpVec2.set(rhs.scale);
		// Scale scale
		tmpVec2.mul(lhs.scale);

		// Rotation
		// Rotate rotation
		tmpMat1.mul2(lhs.rotation, rhs.rotation);

		target.rotation.copy(tmpMat1);
		target.scale.set(tmpVec2);
		target.translation.set(tmpVec);

		target.update();

		return target;
	};

	/**
	 * Combines new transform into this one. This will only work if scaling in the left hand transform is uniform
	 * @param {Transform} rhs right hand side transform
	 * @returns {Transform} this for chaining
	 */
	Transform.prototype.combine = function (rhs) {
		return Transform.combine(this, rhs, this);
	};

	// TODO: sort this crap out!
	Transform.prototype.multiply = function (a, b) {
		this.matrix.mul2(a.matrix, b.matrix);

		tmpMat1.data.set(a.rotation.data);
		//tmpMat1.multiplyDiagonalPost(a.scale, tmpMat1);
		this.rotation.data.set(b.rotation.data);
		//this.rotation.multiplyDiagonalPost(b.scale, this.rotation);
		this.rotation.mul2(tmpMat1, this.rotation);
		this.translation.set(b.translation);
		this.translation.mul(a.scale);
		this.translation.applyPost(tmpMat1).add(a.translation);

		tmpVec.set(a.scale).mul(b.scale);
		this.scale.set(tmpVec);

		return this;
	};

	/**
	 * Set Transform to identity
	 * @returns {Transform} Self to allow chaining
	 */
	Transform.prototype.setIdentity = function () {
		this.matrix.setIdentity();

		this.translation.set(Vector3.ZERO);
		this.rotation.setIdentity();
		this.scale.set(Vector3.ONE);

		return this;
	};

	/**
	 * Applies this transform to supplied vector as a point
	 * @param {Vector3} point
	 * @param {Vector3} store
	 * @returns {Vector3} store
	 * @example
	 * // Vector3 object, one unit right, two units up, two units back
	 * var v1 = new Vector3(1, 2, 2);
	 * // Vector3 to store the local position
	 * var localPos = new Vector3();
	 * // converts v1 to be in 'world space' based on the entities postion / rotation
	 * entity.transformComponent.transform.applyForward(v1, localPos);
	 */
	Transform.prototype.applyForward = function (point, store) {
		store.set(point);

		// store.set(store.x * this.scale.x, store.y * this.scale.y, store.z * this.scale.z);
		// this.rotation.applyPost(store);
		// store.add(this.translation);

		store.applyPostPoint(this.matrix);

		return store;
	};

	/**
	 * Applies this transform to supplied vector as a direction-vector (translation will not affect it)
	 * @param {Vector3} vector
	 * @param {Vector3} store
	 * @returns {Vector3} store
	 * @example
	 * // Vector3 pointing in the direction we want
	 * var back = new Vector3(0, 0, 1);
	 * // Vector3 to store the local 'back'
	 * var localBack = new Vector3();
	 * // converts 'back' to a localized direction based on the entities rotation
	 * entity.transformComponent.transform.applyForwardVector(back, localBack);
	 */
	Transform.prototype.applyForwardVector = function (vector, store) {
		store.copy(vector);

		store.setDirect(store.x * this.scale.x, store.y * this.scale.y, store.z * this.scale.z);
		store.applyPost(this.rotation);

		return store;
	};

	/**
	 * Updates the transform according to set scaling, rotation and translation. This is done automatically by the engine
	 * @returns {Transform} Self to allow chaining
	 */
	Transform.prototype.update = function () {
		var target = this.matrix.data;
		var rotation = this.rotation.data;
		var scale = this.scale;
		var translation = this.translation;

		target[0] = scale.x * rotation[0];
		target[1] = scale.x * rotation[1];
		target[2] = scale.x * rotation[2];
		target[3] = 0.0;
		target[4] = scale.y * rotation[3];
		target[5] = scale.y * rotation[4];
		target[6] = scale.y * rotation[5];
		target[7] = 0.0;
		target[8] = scale.z * rotation[6];
		target[9] = scale.z * rotation[7];
		target[10] = scale.z * rotation[8];
		target[11] = 0.0;
		target[12] = translation.x;
		target[13] = translation.y;
		target[14] = translation.z;
		target[15] = 1.0;

		return this;
	};

	/**
	 * Updates the normal matrix. This is done automatically by the engine.
	 * @returns {Transform} Self to allow chaining
	 */
	Transform.prototype.updateNormalMatrix = function () {
		// Copy upper left of 4x4 to 3x3
		var t = this.normalMatrix.data;
		var s = this.matrix.data;
		t[0] = s[0];
		t[1] = s[1];
		t[2] = s[2];
		t[3] = s[4];
		t[4] = s[5];
		t[5] = s[6];
		t[6] = s[8];
		t[7] = s[9];
		t[8] = s[10];

		// invert + transpose if non-uniform scaling
		// RH: Should we check against epsilon here?
		var scale = this.scale;
		if (scale.x !== scale.y || scale.x !== scale.z) {
			this.normalMatrix.invert().transpose();
		}

		return this;
	};

	/**
	 * Copy supplied transform into this transform
	 * @param {Transform} transform
	 * @returns {Transform} Self to allow chaining
	 */
	Transform.prototype.copy = function (transform) {
		this.matrix.copy(transform.matrix);

		this.translation.set(transform.translation);
		this.rotation.copy(transform.rotation);
		this.scale.set(transform.scale);

		return this;
	};

	/**
	 * Set this transform's rotation to rotation around X, Y and Z axis. Euler order is YZX.
	 * @param {number} x
	 * @param {number} y
	 * @param {number} z
	 * @returns {Transform} Self to allow chaining
	 */
	Transform.prototype.setRotationXYZ = function (x, y, z) {
		this.rotation.fromAngles(x, y, z);

		return this;
	};

	/**
	 * Sets the transform to look in a specific direction.
	 * @param {Vector3} position Target position.
	 * @param {Vector3} [up=(0, 1, 0)] Up vector.
	 * @returns {Transform} Self to allow chaining
	 */
	Transform.prototype.lookAt = function (position, up) {
		if (!up) {
			up = Vector3.UNIT_Y;
		}

		tmpVec.set(position).sub(this.translation);
		if (tmpVec.lengthSquared() > MathUtils.EPSILON) { // should be epsilon^2 but it hopefully doesn't matter
			tmpVec.normalize();
			this.rotation.lookAt(tmpVec, up);
		}

		return this;
	};

	/**
	 * Invert this transform and store it in supplied transform
	 * @param {Transform} store
	 * @returns {Transform} store
	 */
	Transform.prototype.invert = function (store) {
		var result = store;
		if (!result) {
			result = new Transform();
		}

		// if (_identity) {
		// result.setIdentity();
		// return result;
		// }

		result.matrix.copy(this.matrix);
		result.matrix.invert();

		var newRotation = result.rotation.copy(this.rotation);
		newRotation.transpose();
		// if (_uniformScale) {
		// var sx = this.scale.x;
		// newRotation.transposeLocal();
		// if (sx !== 1.0) {
		// newRotation.multiplyLocal(1.0 / sx);
		// }
		// } else {
		//newRotation.multiplyDiagonalPost(this.scale, newRotation).invert();
		// }

		result.scale.set(Vector3.ONE).div(this.scale);
		result.translation.copy(this.translation).negate().mul(result.scale);
		result.translation.applyPost(result.rotation);

		// result.update();

		return result;
	};

	/**
	 * Returns a clone of this transform
	 * @returns {Transform}
	 */
	Transform.prototype.clone = function () {
		var clone = new Transform();

		clone.matrix.copy(this.matrix);
		clone.normalMatrix.copy(this.normalMatrix);

		clone.translation.copy(this.translation);
		clone.rotation.copy(this.rotation);
		clone.scale.copy(this.scale);

		return clone;
	};

	module.exports = Transform;

/***/ },
/* 42 */
/***/ function(module, exports) {

	/**
	 * Creates a new System
	 *
	 * Base class for all entity systems
	 *        <ul>
	 *        <li> interests = null -> listen to all entities
	 *        <li> interests = [] -> don't listen to any entities
	 *        <li> interests = ['coolComponent', 'testComponent'] -> listen to entities that contains at minimum 'coolComponent' and 'testComponent'
	 *        </ul>
	 * See [this engine overview article]{@link http://www.gootechnologies.com/learn/tutorials/engine/engine-overview/} for more info.
	 * @param {string} type System type name as a string
	 * @param {Array<String>} interests Array of component types this system is interested in
	 * @property {string} type System type
	 * @property {Array<String>} interests Array of component types this system is interested in
	 */
	function System(type, interests) {

		/**
		 * @type {World}
		 */
		this.world = null;

		/**
		 * @type {string}
		 */
		this.type = type;

		/**
		 * @type {array}
		 */
		this.interests = interests;

		this._activeEntities = [];

		/**
		 * @type {boolean}
		 */
		this.passive = false;

		/**
		 * Priority of a system. The lower the number the higher the priority is. By default a systems has priority 0. Internal goo systems (like TransformSystem and CameraSystem) should have negative priority.
		 * @type {number}
		 */
		this.priority = 0;
	}

	/**
	 * Called on each render frame, if the system is not passive.
	 * @param {array} entities
	 * @param {number} tpf
	 */
	System.prototype.process = function (/*entities, tpf*/) {};

	/**
	 * Called on each physics tick, if the system is not passive.
	 * @param {array} entities
	 * @param {number} fixedTpf
	 */
	System.prototype.fixedUpdate = function (/*entities, fixedTpf*/) {};

	/**
	 * Called when an entity is added to the world and systems need to be informed. Called by the world.
	 * @hidden
	 * @param entity
	 */
	System.prototype.added = function (entity) {
		this._check(entity);
	};

	/**
	 * Called when an entity is added to the world and systems need to be informed. To be implemented in subclasses.
	 * @param entity
	 */
	System.prototype.inserted = function (/*entity*/) {};

	/**
	 * Called when an entity is remove from the world and systems need to be informed. To be implemented in subclasses.
	 * @param entity
	 */
	System.prototype.deleted = function (/*entity*/) {};

	/**
	 * Called when an entity gets/loses components
	 * @param entity
	 */
	System.prototype.changed = function (entity) {
		this._check(entity);
	};

	/**
	 * Called when an entity is removed from the world
	 * @param entity
	 */
	System.prototype.removed = function (entity) {
		var index = this._activeEntities.indexOf(entity);
		if (index !== -1) {
			this._activeEntities.splice(index, 1);
			this.deleted(entity);
		}
	};

	/**
	 * Called when the system is added to the world.
	 * This method is called automatically when the system is added to a world.
	 * By default it will go through all entities
	 * accounted by the entity manager and try to add them to this system.
	 * @param {World} world
	 */
	System.prototype.setup = function (world) {
		world.entityManager.getEntities().forEach(this._check.bind(this));
	};

	/**
	 * Called when the system is removed from the world.
	 * By default it will call the deleted method on all entities it is keeping track of.
	 */
	System.prototype.cleanup = function () {
		for (var i = 0; i < this._activeEntities.length; i++) {
			var entity = this._activeEntities[i];
			this.deleted(entity);
		}
	};

	function getTypeAttributeName(type) {
		return type.charAt(0).toLowerCase() + type.substr(1);
	}

	/**
	 * Checks if a system is interested in an entity based on its interests list and adds or removed the entity from the system's index
	 * @param entity {Entity} to check if the system is interested in
	 * @private
	 */
	System.prototype._check = function (entity) {
		if (this.interests && this.interests.length === 0) {
			return;
		}
		var isInterested = this.interests === null;
		if (!isInterested && this.interests.length <= entity._components.length) {
			isInterested = true;
			for (var i = 0; i < this.interests.length; i++) {
				var interest = getTypeAttributeName(this.interests[i]);

				if (!entity[interest]) {
					isInterested = false;
					break;
				}
			}
		}

		var index = this._activeEntities.indexOf(entity);
		if (isInterested && index === -1) {
			this._activeEntities.push(entity);
			this.inserted(entity);
		} else if (!isInterested && index !== -1) {
			this._activeEntities.splice(index, 1);
			this.deleted(entity);
		}
	};

	System.prototype._fixedUpdate = function (fixedTpf) {
		this.fixedUpdate(this._activeEntities, fixedTpf);
	};

	System.prototype._process = function (tpf) {
		this.process(this._activeEntities, tpf);
	};

	System.prototype._lateProcess = function (tpf) {
		this.lateProcess(this._activeEntities, tpf);
	};

	System.prototype.clear = function () {
		this._activeEntities.length  = 0;
	};

	/**
	 * Called before the scene is being rendered
	 */
	System.prototype.onPreRender = function () {};

	/**
	 * Called after the scene is being rendered
	 */
	System.prototype.onPostRender = function () {};

	module.exports = System;

/***/ },
/* 43 */
/***/ function(module, exports, __webpack_require__) {

	var Vector3 = __webpack_require__(8);

	/**
	 * The RenderQueue handles sorting of entities. Entities are ordered by their renderQueue value into buckets.
	 * Entities within the opaque buckets are sorted front to back and entities within the transparent buckets are sorted
	 * back to front.
	 */
	function RenderQueue() {
		this.opaqueSorter = function (a, b) {
			var shader1 = a.meshRendererComponent.materials[0].shader;
			var shader2 = b.meshRendererComponent.materials[0].shader;
			if (shader1 === null || shader2 === null) {
				return 0;
			}
			if (shader1.defineKey === shader2.defineKey) {
				return a.meshRendererComponent._renderDistance - b.meshRendererComponent._renderDistance;
			}

			if (shader2.defineKey < shader1.defineKey) {
				return -1;
			} else if (shader2.defineKey > shader1.defineKey) {
				return 1;
			} else {
				return 0;
			}
		};

		this.transparentSorter = function (a, b) {
			return b.meshRendererComponent._renderDistance - a.meshRendererComponent._renderDistance;
		};

		this.bucketSorter = function (a, b) {
			return a - b;
		};
	}

	var bucketSortList = [];

	var tmpVec = new Vector3();

	/**
	 * @param {Array<Entity>} renderList
	 * @param {Camera} camera
	 */
	RenderQueue.prototype.sort = function (renderList, camera) {
		// TODO: Reuse objects more
		var index = 0;
		var buckets = {};
		bucketSortList.length = 0;
		for (var i = 0, l = renderList.length; i < l; i++) {
			var renderable = renderList[i];
			var meshRendererComponent = renderable.meshRendererComponent;

			if (!meshRendererComponent || meshRendererComponent.materials.length === 0) {
				renderList[index] = renderable;
				index++;
				continue;
			}
			var renderQueue = meshRendererComponent.materials[0].getRenderQueue();

			var distance = 0;
			var bound = meshRendererComponent.worldBound;
			if (bound !== null) {
				distance = tmpVec.set(camera.translation).sub(bound.center).lengthSquared();
			} else if (renderable.transformComponent) {
				distance = tmpVec.set(camera.translation).sub(renderable.transformComponent.worldTransform.translation).lengthSquared();
			}
			meshRendererComponent._renderDistance = distance;

			var bucket = buckets[renderQueue];
			if (!bucket) {
				bucket = [];
				buckets[renderQueue] = bucket;
				bucketSortList.push(renderQueue);
			}
			bucket.push(renderable);
		}

		if (bucketSortList.length > 1) {
			bucketSortList.sort(this.bucketSorter);
		}
		for (var bucketIndex = 0, l = bucketSortList.length; bucketIndex < l; bucketIndex++) {
			var key = bucketSortList[bucketIndex];
			var bucket = buckets[key];
			var bl = bucket.length;
			if (bl > 1 && key >= 0) {
				if (key < RenderQueue.TRANSPARENT) {
					bucket.sort(this.opaqueSorter);
				} else {
					bucket.sort(this.transparentSorter);
				}
			}
			for (var i = 0; i < bl; i++) {
				renderList[index] = bucket[i];
				index++;
			}
		}
	};

	/** Rendered before any other objects. Commonly used for skyboxes and the likes
	 * @type {number}
	 * @readonly
	 * @default
	 */
	RenderQueue.BACKGROUND = 0;
	/** Used for most objects, typically opaque geometry. Rendered front to back
	 * @type {number}
	 * @readonly
	 * @default
	 */
	RenderQueue.OPAQUE = 1000;
	/** For all alpha-blended objects. Rendered back to front
	 * @type {number}
	 * @readonly
	 * @default
	 */
	RenderQueue.TRANSPARENT = 2000;
	/** For overlay effects like lens-flares etc
	 * @type {number}
	 * @readonly
	 * @default
	 */
	RenderQueue.OVERLAY = 3000;

	module.exports = RenderQueue;

/***/ },
/* 44 */
/***/ function(module, exports, __webpack_require__) {

	var Bus = __webpack_require__(45);

	/**
	 * SystemBus is a global instance of the {@link Bus} class.
	 * @target-class SystemBus SystemBus constructor
	 * @require-pathvar SystemBus = require('../../entities/SystemBus');
	 * @group entities
	 */
	module.exports = new Bus();


/***/ },
/* 45 */
/***/ function(module, exports) {

	/**
	 * A generic message bus. Offers ways to receive and subscribe to messages on a hierarchy of channels.
	 * @example
	 * // Listen to an event on the global system bus
	 * function listener() {
	 *     console.log('caught message!');
	 * }
	 * SystemBus.addListener('eventName', listener);
	 *
	 * // Emit an event on the bus
	 * SystemBus.emit('eventName');
	 *
	 * // Remove the listener after you're done with it
	 * SystemBus.removeListener('eventName', listener);
	 */
	function Bus() {
		this.trie = { name: '', listeners: [], children: new Map() };
	}

	/**
	 * Sends messages to all listeners with provided callback function.
	 *
	 * @param {(string | Array<string>)} channels channel(s) addressed
	 * @param {Object} data
	 * @param {boolean} [storeEmit=false] Store the emit data for transmitting to future listeners
	 * @example
	 * bus.emit('emptyEvent');
	 * bus.emit('eventWithData', data);
	 * bus.emit(['channel1', 'channel2'], data);
	 */
	Bus.prototype.emit = function (channels, data, storeEmit) {
		storeEmit = !!storeEmit;

		if (typeof channels === 'string') {
			this._emitToSingle(channels, data, storeEmit);
		} else {
			for (var i = 0; i < channels.length; i++) {
				this._emitToSingle(channels[i], data, storeEmit);
			}
		}

		return this;
	};

	Bus.prototype._getNode = function (channelName, storeEmit) {
		var node = this.trie;
		var channelPath = channelName.split('.');

		for (var i = 0; i < channelPath.length; i++) {
			var channelSub = channelPath[i];

			if (node.children.has(channelSub)) {
				node = node.children.get(channelSub);
			} else {
				if (storeEmit) {
					var newNode = { listeners: [], children: new Map() };
					node.children.set(channelSub, newNode);
					node = newNode;
				} else {
					return;
				}
			}
		}

		return node;
	};

	function emitToListeners(node, data, channelName, bus) {
		var l = node.listeners.length;
		for (var i = 0; i < l; i++) {
			var listener = node.listeners[i];
			if (listener) {
				listener(data, channelName, bus);
			}
		}

		for (var i = 0; i < node.listeners.length; i++) {
			var listener = node.listeners[i];
			if (!listener) {
				node.listeners.splice(i, 1);
				i--;
			}
		}
	}

	function emitToAll(node, data, channelName, bus) {
		function traverse(node) {
			emitToListeners(node, data, channelName, bus);
			node.children.forEach(traverse);
		}

		traverse(node);
	}

	Bus.prototype._emitToSingle = function (channelName, data, storeEmit) {
		var node = this._getNode(channelName, storeEmit);
		if (node) {
			emitToAll(node, data, channelName, this);
			if (storeEmit) {
				node.latestData = data;
				node.latestChannel = channelName;
			}
		}
	};

	/**
	 * Register callback for a channel
	 * @param {string} channelName
	 * @param {Function} callback function (data)
	 * @param {boolean} [retrieveLatestEmit=false] Retrieve the last emit done before this listener was added (if emitted with storeEmit)
	 * @example
	 * bus.addListener('channel', function (data){
	 *     console.log('Received message with data:', data);
	 * });
	 */
	Bus.prototype.addListener = function (channelName, callback, retrieveLatestEmit) {
		retrieveLatestEmit = !!retrieveLatestEmit;

		var node = this.trie;
		var channelPath = channelName.split('.');

		for (var i = 0; i < channelPath.length; i++) {
			var channelSub = channelPath[i];

			if (node.children.has(channelSub)) {
				node = node.children.get(channelSub);
			} else {
				var newNode = { listeners: [], children: new Map() };
				node.children.set(channelSub, newNode);
				node = newNode;
			}
		}

		if (node.listeners.indexOf(callback) === -1) {
			node.listeners.push(callback);
			if (retrieveLatestEmit && node.latestData) {
				callback(node.latestData, node.latestChannel, this);
			}
		}

		return this;
	};

	/**
	 * Sets element to null if it's present in the provided array
	 * @param {Array} array
	 * @param {*} element
	 */
	function nullifyElement(array, element) {
		var index = array.indexOf(element);
		if (index !== -1) {
			array[index] = null;
		}
	}

	/**
	 * Remove a listener from a channel but not from its children
	 * @param {string} channelName
	 * @param {function} callbackToRemove
	 * @example
	 * bus.removeListener('channel', listener);
	 */
	Bus.prototype.removeListener = function (channelName, callbackToRemove) {
		var node = this._getNode(channelName);
		if (node) { nullifyElement(node.listeners, callbackToRemove); }
		return this;
	};

	/**
	 * Retrieves the last message sent on a channel. This will only work if message preservation is enabled when emitting.
	 * @param channelName
	 */
	Bus.prototype.getLastMessageOn = function (channelName) {
		var node = this._getNode(channelName);
		if (node) {
			return node.latestData;
		}
	};

	/**
	 * Removes all listeners on a specific channel
	 * @param channelName
	 */
	Bus.prototype.removeAllOnChannel = function (channelName) {
		var node = this._getNode(channelName);
		if (node) { node.listeners = []; }
		return this;
	};

	/**
	 * Removes a channel and its children
	 * @param channelName
	 */
	Bus.prototype.removeChannelAndChildren = function (channelName) {
		var channelParts = channelName.split('.');

		if (channelParts.length > 1) {
			var leafChannelName = channelParts.pop();
			var parentChannelName = channelParts.join('.');
			var parentNode = this._getNode(parentChannelName);

			parentNode.children.delete(leafChannelName);
		} else {
			this.trie.children.delete(channelName);
		}

		return this;
	};

	Bus.prototype._removeListener = function (node, callbackToRemove) {
		nullifyElement(node.listeners, callbackToRemove);

		node.children.forEach(function (child) {
			this._removeListener(child, callbackToRemove);
		}, this);
	};

	/**
	 * Removes a listener from all channels
	 * @param callbackToRemove
	 */
	Bus.prototype.removeListenerFromAllChannels = function (callbackToRemove) {
		this._removeListener(this.trie, callbackToRemove);
		return this;
	};

	Bus.prototype.clear = function () {
		this.trie = { name: '', listeners: [], children: new Map() };
	};

	module.exports = Bus;


/***/ },
/* 46 */
/***/ function(module, exports, __webpack_require__) {

	/*eslint indent: "off" */

	var MeshData = __webpack_require__(14);
	var Shader = __webpack_require__(31);
	var ShaderFragment = __webpack_require__(47);
	var ShaderBuilder = __webpack_require__(48);

	/**
	 * Collection of useful shaders<br>
	 * Details of each can be printed like this for example: console.log(ShaderLib.texturedLit).<br>
	 * There are more special purpose shaders in {@link ShaderLibExtra}
	 */
	function ShaderLib() {}

	/**
	 * The uber shader is the default Goo shader supporting the most common realistic render features.
	 * It supports lights, animations, reflective materials, normal, diffuse, AO and light textures, transparency, fog and shadows.
	 */
	ShaderLib.uber = {
		processors: [
			ShaderBuilder.uber.processor,
			ShaderBuilder.light.processor,
			ShaderBuilder.animation.processor
		],
		attributes: {
			vertexPosition: MeshData.POSITION,
			vertexNormal: MeshData.NORMAL,
			vertexTangent: MeshData.TANGENT,
			vertexColor: MeshData.COLOR,
			vertexUV0: MeshData.TEXCOORD0,
			vertexUV1: MeshData.TEXCOORD1,
			vertexJointIDs: MeshData.JOINTIDS,
			vertexWeights: MeshData.WEIGHTS
		},
		uniforms: {
			viewProjectionMatrix: Shader.VIEW_PROJECTION_MATRIX,
			worldMatrix: Shader.WORLD_MATRIX,
			normalMatrix: Shader.NORMAL_MATRIX,
			cameraPosition: Shader.CAMERA,
			diffuseMap: Shader.DIFFUSE_MAP,
			offsetRepeat: [0, 0, 1, 1],
			normalMap: Shader.NORMAL_MAP,
			normalMultiplier: 1.0,
			specularMap: Shader.SPECULAR_MAP,
			emissiveMap: Shader.EMISSIVE_MAP,
			aoMap: Shader.AO_MAP,
			lightMap: Shader.LIGHT_MAP,
			environmentCube: 'ENVIRONMENT_CUBE',
			environmentSphere: 'ENVIRONMENT_SPHERE',
			reflectionMap: 'REFLECTION_MAP',
			transparencyMap: 'TRANSPARENCY_MAP',
			opacity: 1.0,
			reflectivity: 0.0,
			refractivity: 0.0,
			etaRatio: -0.5,
			fresnel: 0.0,
			discardThreshold: -0.01,
			fogSettings: [0, 10000],
			fogColor: [1, 1, 1],
			vertexColorAmount: 1.0,
			lodBias: 0.0,
			wrapSettings: [0.5, 0.0]
		},
		builder: function (shader, shaderInfo) {
			ShaderBuilder.light.builder(shader, shaderInfo);
		},
		vshader: function () {
			return [
			'attribute vec3 vertexPosition;',

			'#ifdef NORMAL',
				'attribute vec3 vertexNormal;',
			'#endif',
			'#ifdef TANGENT',
				'attribute vec4 vertexTangent;',
			'#endif',
			'#ifdef COLOR',
				'attribute vec4 vertexColor;',
			'#endif',
			'#ifdef TEXCOORD0',
				'attribute vec2 vertexUV0;',
				'uniform vec4 offsetRepeat;',
				'varying vec2 texCoord0;',
			'#endif',
			'#ifdef TEXCOORD1',
				'attribute vec2 vertexUV1;',
				'varying vec2 texCoord1;',
			'#endif',

			'uniform mat4 viewProjectionMatrix;',
			'uniform mat4 worldMatrix;',
			'uniform mat3 normalMatrix;',
			'uniform vec3 cameraPosition;',

			'varying vec3 vWorldPos;',
			'varying vec3 viewPosition;',
			'#ifdef NORMAL',
			'varying vec3 normal;',
			'#endif',
			'#ifdef TANGENT',
			'varying vec3 binormal;',
			'varying vec3 tangent;',
			'#endif',
			'#ifdef COLOR',
			'varying vec4 color;',
			'#endif',

			ShaderBuilder.light.prevertex,

			ShaderBuilder.animation.prevertex,

			'void main(void) {',
				'mat4 wMatrix = worldMatrix;',
				'#ifdef NORMAL',
					'mat3 nMatrix = normalMatrix;',
				'#endif',
				ShaderBuilder.animation.vertex,
				'vec4 worldPos = wMatrix * vec4(vertexPosition, 1.0);',
				'vWorldPos = worldPos.xyz;',
				'gl_Position = viewProjectionMatrix * worldPos;',

				'viewPosition = cameraPosition - worldPos.xyz;',

				'#ifdef NORMAL',
				'	normal = normalize(nMatrix * vertexNormal);',
				'#endif',
				'#ifdef TANGENT',
				'	tangent = normalize(nMatrix * vertexTangent.xyz);',
				'	binormal = cross(normal, tangent) * vec3(vertexTangent.w);',
				'#endif',
				'#ifdef COLOR',
				'	color = vertexColor;',
				'#endif',
				'#ifdef TEXCOORD0',
				'	texCoord0 = vertexUV0 * offsetRepeat.zw + offsetRepeat.xy;',
				'#endif',
				'#ifdef TEXCOORD1',
				'	texCoord1 = vertexUV1;',
				'#endif',

				ShaderBuilder.light.vertex,
			'}'
		].join('\n');
		},
		fshader: function () {
			return [
			'uniform float lodBias;',
			'#ifdef DIFFUSE_MAP',
				'uniform sampler2D diffuseMap;',
			'#endif',
			'#ifdef NORMAL_MAP',
				'uniform sampler2D normalMap;',
				'uniform float normalMultiplier;',
			'#endif',
			'#ifdef SPECULAR_MAP',
				'uniform sampler2D specularMap;',
			'#endif',
			'#ifdef EMISSIVE_MAP',
				'uniform sampler2D emissiveMap;',
			'#endif',
			'#ifdef AO_MAP',
				'uniform sampler2D aoMap;',
			'#endif',
			'#ifdef LIGHT_MAP',
				'uniform sampler2D lightMap;',
			'#endif',
			'#ifdef TRANSPARENCY_MAP',
				'uniform sampler2D transparencyMap;',
			'#endif',
			'#ifdef REFLECTIVE',
				'#ifdef ENVIRONMENT_CUBE',
					'uniform samplerCube environmentCube;',
				'#elif defined(ENVIRONMENT_SPHERE)',
					'uniform sampler2D environmentSphere;',
				'#endif',
				'uniform vec4 clearColor;',
				'uniform float reflectivity;',
				'uniform float fresnel;',
				'uniform float refractivity;',
				'uniform float etaRatio;',
				'#ifdef REFLECTION_MAP',
					'uniform sampler2D reflectionMap;',
				'#endif',
			'#endif',

			'#ifdef OPACITY',
				'uniform float opacity;',
			'#endif',
			'#ifdef DISCARD',
				'uniform float discardThreshold;',
			'#endif',

			'#ifdef FOG',
				'uniform vec2 fogSettings;',
				'uniform vec3 fogColor;',
			'#endif',

			'varying vec3 vWorldPos;',
			'varying vec3 viewPosition;',
			'#ifdef NORMAL',
				'varying vec3 normal;',
			'#endif',
			'#ifdef TANGENT',
				'varying vec3 binormal;',
				'varying vec3 tangent;',
			'#endif',
			'#ifdef COLOR',
				'varying vec4 color;',
				'uniform float vertexColorAmount;',
			'#endif',
			'#ifdef TEXCOORD0',
				'varying vec2 texCoord0;',
			'#endif',
			'#ifdef TEXCOORD1',
				'varying vec2 texCoord1;',
			'#endif',

			'#define M_PI 3.14159265358979323846264338328',

			ShaderBuilder.light.prefragment,

			'void main(void)',
			'{',
				'vec4 final_color = vec4(1.0);',

				'#if defined(DIFFUSE_MAP) && defined(TEXCOORD0)',
					'final_color *= texture2D(diffuseMap, texCoord0, lodBias);',
				'#endif',

				'#ifdef COLOR',
					'final_color *= mix(vec4(1.0), color, vertexColorAmount);',
				'#endif',

				'#if defined(TRANSPARENCY_MAP) && defined(TEXCOORD0)',
					'#ifdef TRANSPARENCY_BW',
						'final_color.a = texture2D(transparencyMap, texCoord0).r;',
					'#else',
						'final_color.a = texture2D(transparencyMap, texCoord0).a;',
					'#endif',
				'#endif',
				'#ifdef OPACITY',
					'final_color.a *= opacity;',
				'#endif',

				'#ifdef DISCARD',
					'if (final_color.a < discardThreshold) discard;',
				'#endif',

				'#ifdef AO_MAP',
					'#ifdef TEXCOORD1',
						'final_color.rgb *= texture2D(aoMap, texCoord1).rgb;',
					'#elif defined(TEXCOORD0)',
						'final_color.rgb *= texture2D(aoMap, texCoord0).rgb;',
					'#endif',
				'#endif',

				'#ifdef LIGHT_MAP',
					'#ifdef TEXCOORD1',
						'final_color.rgb *= texture2D(lightMap, texCoord1).rgb * 2.0;',
					'#elif defined(TEXCOORD0)',
						'final_color.rgb *= texture2D(lightMap, texCoord0).rgb * 2.0;',
					'#endif',
				'#else',
					'vec3 N = vec3(0.0, 1.0, 0.0);',
					'#if defined(NORMAL)', // Do nasty doublework for IE compliance
						'N = normalize(normal);',
					'#endif',
					'#if defined(TANGENT) && defined(NORMAL_MAP) && defined(TEXCOORD0)',
						'mat3 tangentToWorld = mat3(tangent, binormal, normal);',
						'vec3 tangentNormal = texture2D(normalMap, texCoord0, lodBias).xyz * vec3(2.0) - vec3(1.0);',
						'tangentNormal = mix(vec3(0.0, 0.0, 1.0), tangentNormal, normalMultiplier);',
						'vec3 worldNormal = (tangentToWorld * tangentNormal);',
						'N = normalize(worldNormal);',
					'#endif',

					'N = N * (-1.0 + 2.0 * float(gl_FrontFacing));',

					ShaderBuilder.light.fragment,
				'#endif',

				'#ifdef REFLECTIVE',
					'if (refractivity > 0.0) {',
						'vec4 environment = vec4(0.0);',
						'#ifdef ENVIRONMENT_CUBE',
							'vec3 refractionVector = refract(normalize(viewPosition), N, etaRatio);',
							'refractionVector.x = -refractionVector.x;',
							'environment = textureCube(environmentCube, refractionVector);',
						'#elif defined(ENVIRONMENT_SPHERE)',
							'vec3 refractionVector = refract(normalize(viewPosition), N, etaRatio);',
							'refractionVector = -refractionVector;',
							'float xx = (atan(refractionVector.z, refractionVector.x) + M_PI) / (2.0 * M_PI);',
							'float yy = refractionVector.y * 0.5 + 0.5;',
							'environment = texture2D(environmentSphere, vec2(xx, yy));',
						'#endif',
						'environment.rgb = mix(clearColor.rgb, environment.rgb, environment.a);',

						'final_color.rgb = mix(final_color.rgb, environment.rgb, refractivity);',
					'}',

					'if (reflectivity > 0.0) {',
						'vec4 environment = vec4(0.0);',
						'#ifdef ENVIRONMENT_CUBE',
							'vec3 reflectionVector = reflect(normalize(viewPosition), N);',
							'reflectionVector.yz = -reflectionVector.yz;',
							'environment = textureCube(environmentCube, reflectionVector);',
						'#elif defined(ENVIRONMENT_SPHERE)',
							'vec3 reflectionVector = reflect(normalize(viewPosition), N);',
							'float xx = (atan(reflectionVector.z, reflectionVector.x) + M_PI) / (2.0 * M_PI);',
							'float yy = reflectionVector.y * 0.5 + 0.5;',
							'environment = texture2D(environmentSphere, vec2(xx, yy));',
						'#endif',
						'environment.rgb = mix(clearColor.rgb, environment.rgb, environment.a);',

						'float reflectionAmount = reflectivity;',
						'#if defined(REFLECTION_MAP) && defined(TEXCOORD0)',
							'reflectionAmount *= texture2D(reflectionMap, texCoord0).r;',
						'#endif',

						'float fresnelVal = pow(1.0 - abs(dot(normalize(viewPosition), N)), fresnel * 4.0);',
						'reflectionAmount *= fresnelVal;',

						'#if REFLECTION_TYPE == 0',
							'final_color.rgb = mix(final_color.rgb, environment.rgb, reflectionAmount);',
						'#elif REFLECTION_TYPE == 1',
							'final_color.rgb += environment.rgb * reflectionAmount;',
						'#elif REFLECTION_TYPE == 2',
							'final_color.rgb *= environment.rgb * reflectionAmount;',
						'#endif',
						'final_color.a = min(final_color.a + reflectionAmount, 1.0);',
					'}',
				'#endif',

				'#ifndef LIGHT_MAP',
					'final_color.rgb += totalSpecular;',
					'final_color.a = min(final_color.a + length(totalSpecular) / 3.0, 1.0);',
				'#endif',

				'#ifdef FOG',
					'float d = pow(smoothstep(fogSettings.x, fogSettings.y, length(viewPosition)), 1.0);',
					'final_color.rgb = mix(final_color.rgb, fogColor, d);',
				'#endif',

				'gl_FragColor = final_color;',
			'}'
		].join('\n');
		}
	};

	// only terrain depends on this
	ShaderLib.screenCopy = {
		attributes: {
			vertexPosition: MeshData.POSITION,
			vertexUV0: MeshData.TEXCOORD0
		},
		uniforms: {
			diffuseMap: Shader.DIFFUSE_MAP
		},
		vshader: [
		'attribute vec3 vertexPosition;',
		'attribute vec2 vertexUV0;',

		'varying vec2 texCoord0;',

		'void main(void) {',
			'texCoord0 = vertexUV0;',
			'gl_Position = vec4(vertexPosition, 1.0);',
		'}'
		].join('\n'),
		fshader: [
		'uniform sampler2D diffuseMap;',

		'varying vec2 texCoord0;',

		'void main(void)',
		'{',
			'gl_FragColor = texture2D(diffuseMap, texCoord0);',
		'}'
		].join('\n')
	};

	ShaderLib.copy = {
		attributes: {
			vertexPosition: MeshData.POSITION,
			vertexUV0: MeshData.TEXCOORD0
		},
		uniforms: {
			viewProjectionMatrix: Shader.VIEW_PROJECTION_MATRIX,
			worldMatrix: Shader.WORLD_MATRIX,
			opacity: 1.0,
			diffuseMap: Shader.DIFFUSE_MAP
		},
		vshader: [
		'attribute vec3 vertexPosition;',
		'attribute vec2 vertexUV0;',

		'uniform mat4 viewProjectionMatrix;',
		'uniform mat4 worldMatrix;',

		'varying vec2 texCoord0;',

		'void main(void) {',
			'texCoord0 = vertexUV0;',
			'gl_Position = viewProjectionMatrix * (worldMatrix * vec4(vertexPosition, 1.0));',
		'}'
		].join('\n'),
		fshader: [
		'uniform sampler2D diffuseMap;',
		'uniform float opacity;',

		'varying vec2 texCoord0;',

		'void main(void)',
		'{',
			'gl_FragColor = vec4(texture2D(diffuseMap, texCoord0).rgb, opacity);',
		'}'
		].join('\n')
	};

	ShaderLib.copyPure = {
		attributes: {
			vertexPosition: MeshData.POSITION,
			vertexUV0: MeshData.TEXCOORD0
		},
		uniforms: {
			viewProjectionMatrix: Shader.VIEW_PROJECTION_MATRIX,
			worldMatrix: Shader.WORLD_MATRIX,
			opacity: 1.0,
			diffuseMap: Shader.DIFFUSE_MAP
		},
		vshader: [
		'attribute vec3 vertexPosition;',
		'attribute vec2 vertexUV0;',

		'uniform mat4 viewProjectionMatrix;',
		'uniform mat4 worldMatrix;',

		'varying vec2 texCoord0;',

		'void main(void) {',
			'texCoord0 = vertexUV0;',
			'gl_Position = viewProjectionMatrix * (worldMatrix * vec4(vertexPosition, 1.0));',
		'}'
		].join('\n'),
		fshader: [
		'uniform sampler2D diffuseMap;',
		'uniform float opacity;',

		'varying vec2 texCoord0;',

		'void main(void)',
		'{',
			'vec4 col = texture2D(diffuseMap, texCoord0);',
			'gl_FragColor = vec4(col.rgb, col.a * opacity);',
		'}'
		].join('\n')
	};

	ShaderLib.simple = {
		attributes: {
			vertexPosition: MeshData.POSITION
		},
		uniforms: {
			viewProjectionMatrix: Shader.VIEW_PROJECTION_MATRIX,
			worldMatrix: Shader.WORLD_MATRIX
		},
		vshader: [
		'attribute vec3 vertexPosition;',

		'uniform mat4 viewProjectionMatrix;',
		'uniform mat4 worldMatrix;',

		'void main(void) {',
			'gl_Position = viewProjectionMatrix * (worldMatrix * vec4(vertexPosition, 1.0));',
		'}'
		].join('\n'),
		fshader: [
		'void main(void)',
		'{',
			'gl_FragColor = vec4(1.0);',
		'}'
		].join('\n')
	};

	ShaderLib.simpleColored = {
		attributes: {
			vertexPosition: MeshData.POSITION
		},
		uniforms: {
			viewProjectionMatrix: Shader.VIEW_PROJECTION_MATRIX,
			worldMatrix: Shader.WORLD_MATRIX,
			color: [1.0, 1.0, 1.0],
			opacity: 1.0
		},
		vshader: [
		'attribute vec3 vertexPosition;',

		'uniform mat4 viewProjectionMatrix;',
		'uniform mat4 worldMatrix;',

		'void main(void) {',
			'gl_Position = viewProjectionMatrix * (worldMatrix * vec4(vertexPosition, 1.0));',
		'}'
		].join('\n'),
		fshader: [
		'uniform vec3 color;',
		'uniform float opacity;',

		'void main(void)',
		'{',
			'if (opacity == 0.0) {',
				'discard;',
			'}',
			'gl_FragColor = vec4(color, opacity);',
		'}'
		].join('\n')
	};

	ShaderLib.simpleLit = {
		processors: [
			ShaderBuilder.light.processor
		],
		defines: {
			NORMAL: true
		},
		attributes: {
			vertexPosition: MeshData.POSITION,
			vertexNormal: MeshData.NORMAL
		},
		uniforms: {
			viewProjectionMatrix: Shader.VIEW_PROJECTION_MATRIX,
			worldMatrix: Shader.WORLD_MATRIX,
			cameraPosition: Shader.CAMERA,
			opacity: 1.0
		},
		builder: function (shader, shaderInfo) {
			ShaderBuilder.light.builder(shader, shaderInfo);
		},
		vshader: function () {
			return [
		'attribute vec3 vertexPosition;',
		'attribute vec3 vertexNormal;',

		'uniform mat4 viewProjectionMatrix;',
		'uniform mat4 worldMatrix;',
		'uniform vec3 cameraPosition;',

		ShaderBuilder.light.prevertex,
		'varying vec3 normal;',
		'varying vec3 vWorldPos;',
		'varying vec3 viewPosition;',

		'void main(void) {',
			'vec4 worldPos = worldMatrix * vec4(vertexPosition, 1.0);',
			'vWorldPos = worldPos.xyz;',
			'gl_Position = viewProjectionMatrix * worldPos;',

			ShaderBuilder.light.vertex,

			'normal = (worldMatrix * vec4(vertexNormal, 0.0)).xyz;',
			'viewPosition = cameraPosition - worldPos.xyz;',
		'}'
		].join('\n');
		},
		fshader: function () {
			return [
		'#ifdef SPECULAR_MAP',
			'uniform sampler2D specularMap;',
		'#ifdef TEXCOORD0',
			'varying vec2 texCoord0;',
		'#endif',
		'#endif',

		'uniform float opacity;',

		ShaderBuilder.light.prefragment,

		'#ifdef NORMAL',
		'varying vec3 normal;',
		'#endif',
		'varying vec3 vWorldPos;',
		'varying vec3 viewPosition;',

		'void main(void)',
		'{',
			'if (opacity == 0.0) {',
				'discard;',
		// 'return;',
			'}',
		'#ifdef NORMAL',
			'vec3 N = normalize(normal);',
		'#else',
			'vec3 N = vec3(0,0,1);',
		'#endif',
			'vec4 final_color = vec4(1.0);',

			ShaderBuilder.light.fragment,

			'final_color.a = opacity;',
			'gl_FragColor = final_color;',
		'}'
		].join('\n');
		}
	};

	ShaderLib.textured = {
		defines: {
			TEXCOORD0: true,
			DIFFUSE_MAP: true
		},
		attributes: {
			vertexPosition: MeshData.POSITION,
			vertexUV0: MeshData.TEXCOORD0
		},
		uniforms: {
			viewProjectionMatrix: Shader.VIEW_PROJECTION_MATRIX,
			worldMatrix: Shader.WORLD_MATRIX,
			diffuseMap: Shader.DIFFUSE_MAP
		},
		vshader: [
		'attribute vec3 vertexPosition;',
		'attribute vec2 vertexUV0;',

		'uniform mat4 viewProjectionMatrix;',
		'uniform mat4 worldMatrix;',

		'varying vec2 texCoord0;',

		'void main(void) {',
			'texCoord0 = vertexUV0;',
			'gl_Position = viewProjectionMatrix * (worldMatrix * vec4(vertexPosition, 1.0));',
		'}'
		].join('\n'),
		fshader: [
		'#if defined(TEXCOORD0) && defined(DIFFUSE_MAP)',
		'uniform sampler2D diffuseMap;',

		'varying vec2 texCoord0;',
		'#endif',

		'void main(void)',
		'{',
		'#if defined(TEXCOORD0) && defined(DIFFUSE_MAP)',
			'gl_FragColor = texture2D(diffuseMap, texCoord0);',
		'#else',
			'gl_FragColor = vec4(1.0);',
		'#endif',
		'}'
		].join('\n')
	};

	ShaderLib.texturedLit = {
		processors: [
			ShaderBuilder.light.processor
		],
		attributes: {
			vertexPosition: MeshData.POSITION,
			vertexNormal: MeshData.NORMAL,
			vertexUV0: MeshData.TEXCOORD0
		},
		uniforms: {
			viewProjectionMatrix: Shader.VIEW_PROJECTION_MATRIX,
			worldMatrix: Shader.WORLD_MATRIX,
			cameraPosition: Shader.CAMERA,
			diffuseMap: Shader.DIFFUSE_MAP
		},
		builder: function (shader, shaderInfo) {
			ShaderBuilder.light.builder(shader, shaderInfo);
		},
		vshader: function () {
			return [
		'attribute vec3 vertexPosition;',
		'attribute vec3 vertexNormal;',
		'attribute vec2 vertexUV0;',

		'uniform mat4 viewProjectionMatrix;',
		'uniform mat4 worldMatrix;',
		'uniform vec3 cameraPosition;',

		ShaderBuilder.light.prevertex,

		'varying vec3 normal;',
		'varying vec3 vWorldPos;',
		'varying vec3 viewPosition;',
		'varying vec2 texCoord0;',

		'void main(void) {',
			'vec4 worldPos = worldMatrix * vec4(vertexPosition, 1.0);',
			'vWorldPos = worldPos.xyz;',
			'gl_Position = viewProjectionMatrix * worldPos;',

			ShaderBuilder.light.vertex,

			'normal = (worldMatrix * vec4(vertexNormal, 0.0)).xyz;',
			'texCoord0 = vertexUV0;',
			'viewPosition = cameraPosition - worldPos.xyz;',
		'}'
		].join('\n');
		},
		fshader: function () {
			return [
		'uniform sampler2D diffuseMap;',

		ShaderBuilder.light.prefragment,

		'varying vec3 normal;',
		'varying vec3 vWorldPos;',
		'varying vec3 viewPosition;',
		'varying vec2 texCoord0;',

		'void main(void)',
		'{',
			'vec3 N = normalize(normal);',
			'vec4 final_color = texture2D(diffuseMap, texCoord0);',

			ShaderBuilder.light.fragment,

			'gl_FragColor = final_color;',
		'}'
		].join('\n');
		}
	};

	ShaderLib.convolution = {
		defines: {
			KERNEL_SIZE_FLOAT: '25.0',
			KERNEL_SIZE_INT: '25'
		},
		attributes: {
			position: MeshData.POSITION,
			uv: MeshData.TEXCOORD0
		},
		uniforms: {
			viewMatrix: Shader.VIEW_MATRIX,
			projectionMatrix: Shader.PROJECTION_MATRIX,
			worldMatrix: Shader.WORLD_MATRIX,
			tDiffuse: Shader.DIFFUSE_MAP,
			uImageIncrement: [0.001953125, 0.0],
			cKernel: [],
			size: 1.0
		},
		vshader: [
		'attribute vec3 position;',
		'attribute vec2 uv;',

		'uniform mat4 viewMatrix;',
		'uniform mat4 projectionMatrix;',
		'uniform mat4 worldMatrix;',
		'uniform float size;',

		'uniform vec2 uImageIncrement;',

		'varying vec2 vUv;',

		'void main() {',
			'vUv = uv - ( ( KERNEL_SIZE_FLOAT - 1.0 ) / 2.0 ) * size * uImageIncrement;',
			'gl_Position = projectionMatrix * viewMatrix * worldMatrix * vec4( position, 1.0 );',
		'}'
		].join('\n'),
		fshader: [
		'uniform float cKernel[ KERNEL_SIZE_INT ];',
		'uniform sampler2D tDiffuse;',
		'uniform vec2 uImageIncrement;',
		'uniform float size;',

		'varying vec2 vUv;',

		'void main() {',
			'vec2 imageCoord = vUv;',
			'vec4 sum = vec4( 0.0 );',

			// 'for ( int i = 0; i < KERNEL_SIZE_INT; i ++ ) {',
				// 'sum += texture2D( tDiffuse, imageCoord ) * cKernel[ i ];',
				// 'imageCoord += uImageIncrement * size;',
			// '}',
			// Hack for Android, who seems to crash on int looping
			'for (float i = 0.0; i < KERNEL_SIZE_FLOAT; i++) {',
				'sum += texture2D( tDiffuse, imageCoord ) * cKernel[int(i)];',
				'imageCoord += uImageIncrement * size;',
			'}',

			'gl_FragColor = sum;',
		'}'
		].join('\n'),
		buildKernel: function (sigma) {
			// Ensure no negative values are used; otherwise we get an invalid
			// kernel size.
			sigma = Math.abs(sigma);

			// We lop off the sqrt(2 * pi) * sigma term, since we're going to normalize anyway.
			function gauss(x, sigma) {
				return Math.exp(-(x * x) / (2.0 * sigma * sigma));
			}

			var i, values, sum, halfWidth, kMaxKernelSize = 25, kernelSize = 2 * Math.ceil(sigma * 3.0) + 1;

			if (kernelSize > kMaxKernelSize) {
				kernelSize = kMaxKernelSize;
			}
			halfWidth = (kernelSize - 1) * 0.5;
			values = new Array(kernelSize);
			sum = 0.0;
			for (i = 0; i < kernelSize; ++i) {
				values[i] = gauss(i - halfWidth, sigma);
				sum += values[i];
			}

			// normalize the kernel
			for (i = 0; i < kernelSize; ++i) {
				values[i] /= sum;
			}
			return values;
		}
	};

	ShaderLib.showNormals = {
		defines: {
			NORMAL: true
		},
		attributes: {
			vertexPosition: MeshData.POSITION,
			vertexNormal: MeshData.NORMAL
		},
		uniforms: {
			viewMatrix: Shader.VIEW_MATRIX,
			projectionMatrix: Shader.PROJECTION_MATRIX,
			viewProjectionMatrix: Shader.VIEW_PROJECTION_MATRIX,
			worldMatrix: Shader.WORLD_MATRIX,
			opacity: 1.0
		},
		vshader: [
		'attribute vec3 vertexPosition;',
		'attribute vec3 vertexNormal;',

		'uniform mat4 viewProjectionMatrix;',
		'uniform mat4 worldMatrix;',

		'varying vec3 normal;',

		'void main() {',
			'normal = vec3(worldMatrix * vec4(vertexNormal, 0.0));',
			'gl_Position = viewProjectionMatrix * (worldMatrix * vec4(vertexPosition, 1.0));',
		'}'
		].join('\n'),
		fshader: [
		'uniform float opacity;',
		'#ifdef NORMAL',
		'varying vec3 normal;',
		'#else',
		'vec3 normal = vec3(0,0,1);',
		'#endif',

		'void main() {',
			'gl_FragColor = vec4( 0.5 * normalize( normal ) + 0.5, opacity );',
		'}'
		].join('\n')
	};

	ShaderLib.particles = {
		attributes: {
			vertexPosition: MeshData.POSITION,
			vertexColor: MeshData.COLOR,
			vertexUV0: MeshData.TEXCOORD0
		},
		uniforms: {
			viewProjectionMatrix: Shader.VIEW_PROJECTION_MATRIX,
			worldMatrix: Shader.WORLD_MATRIX,
			diffuseMap: Shader.DIFFUSE_MAP
		},
		vshader: [
		'attribute vec3 vertexPosition;',
		'attribute vec4 vertexColor;',
		'attribute vec2 vertexUV0;',

		'uniform mat4 viewProjectionMatrix;',
		'uniform mat4 worldMatrix;',

		'varying vec2 texCoord0;',
		'varying vec4 color;',

		'void main(void) {',
			'texCoord0 = vertexUV0;',
			'color = vertexColor;',
			'gl_Position = viewProjectionMatrix * (worldMatrix * vec4(vertexPosition, 1.0));',
		'}'
		].join('\n'),
		fshader: [
		'uniform sampler2D diffuseMap;',

		'varying vec2 texCoord0;',
		'varying vec4 color;',

		'void main(void)',
		'{',
			'vec4 texCol = texture2D(diffuseMap, texCoord0);',
			'if (color.a == 0.0 || texCol.a == 0.0) discard;',
			'else gl_FragColor = texCol * color;',
		'}'
		].join('\n')
	};

	ShaderLib.normalmap = {
		attributes: {
			vertexPosition: MeshData.POSITION,
			vertexUV0: MeshData.TEXCOORD0
		},
		uniforms: {
			viewProjectionMatrix: Shader.VIEW_PROJECTION_MATRIX,
			worldMatrix: Shader.WORLD_MATRIX,
			heightMap: Shader.DIFFUSE_MAP,
			resolution: [512, 512],
			height: 0.05
		},
		vshader: [
			'attribute vec3 vertexPosition;',
			'attribute vec2 vertexUV0;',

			'uniform mat4 viewProjectionMatrix;',
			'uniform mat4 worldMatrix;',

			'varying vec2 vUv;',
			'void main() {',
				'vUv = vertexUV0;',
				'gl_Position = viewProjectionMatrix * (worldMatrix * vec4( vertexPosition, 1.0 ));',
			'}'
		].join('\n'),
		fshader: [
			'uniform float height;',
			'uniform vec2 resolution;',
			'uniform sampler2D heightMap;',

			'varying vec2 vUv;',

			'void main() {',
				'float val = texture2D( heightMap, vUv ).x;',
				'float valU = texture2D( heightMap, vUv + vec2( 1.0 / resolution.x, 0.0 ) ).x;',
				'float valV = texture2D( heightMap, vUv + vec2( 0.0, 1.0 / resolution.y ) ).x;',

				'gl_FragColor = vec4( ( 0.5 * normalize( vec3( val - valU, val - valV, height  ) ) + 0.5 ), 1.0 );',
			'}'
		].join('\n')
	};

	ShaderLib.point = {
		attributes: {
			vertexPosition: MeshData.POSITION,
			vertexColor: MeshData.COLOR
		},
		uniforms: {
			viewProjectionMatrix: Shader.VIEW_PROJECTION_MATRIX,
			worldMatrix: Shader.WORLD_MATRIX,
			pointSize: 2.0
		},
		vshader: [
		'attribute vec3 vertexPosition;',
		'attribute vec4 vertexColor;',

		'uniform mat4 viewProjectionMatrix;',
		'uniform mat4 worldMatrix;',
		'uniform float pointSize;',

		'varying vec4 color;',

		'void main(void) {',
			'color = vertexColor;',
			'gl_Position = viewProjectionMatrix * (worldMatrix * vec4(vertexPosition, 1.0));',
			'gl_PointSize = pointSize;',
		'}'
		].join('\n'),
		fshader: [
		'varying vec4 color;',

		'void main(void)',
		'{',
			'gl_FragColor = color;',
		'}'
		].join('\n')
	};

	ShaderLib.downsample = {
		attributes: {
			vertexPosition: MeshData.POSITION,
			vertexUV0: MeshData.TEXCOORD0
		},
		uniforms: {
			viewMatrix: Shader.VIEW_MATRIX,
			projectionMatrix: Shader.PROJECTION_MATRIX,
			worldMatrix: Shader.WORLD_MATRIX,
			tDiffuse: Shader.DIFFUSE_MAP
		},
		vshader: [
			'attribute vec3 vertexPosition;',
			'attribute vec2 vertexUV0;',

			'uniform mat4 viewMatrix;',
			'uniform mat4 projectionMatrix;',
			'uniform mat4 worldMatrix;',

			'varying vec2 vUv;',
			'void main() {',
				'vUv = vertexUV0;',
				'gl_Position = projectionMatrix * viewMatrix * worldMatrix * vec4( vertexPosition, 1.0 );',
			'}'
		].join('\n'),
		fshader: [
			'uniform sampler2D tDiffuse;',

			'varying vec2 vUv;',

			'void main() {',
				'gl_FragColor = texture2D( tDiffuse, vUv );',
			'}'
		].join('\n')
	};

	ShaderLib.lightDepth = {
		processors: [
			ShaderBuilder.animation.processor
		],
		defines: {
			SHADOW_TYPE: 0,
			WEIGHTS: true,
			JOINTIDS: true
		},
		attributes: {
			vertexPosition: MeshData.POSITION,
			vertexJointIDs: MeshData.JOINTIDS,
			vertexWeights: MeshData.WEIGHTS
		},
		uniforms: {
			viewMatrix: Shader.VIEW_MATRIX,
			projectionMatrix: Shader.PROJECTION_MATRIX,
			worldMatrix: Shader.WORLD_MATRIX,
			cameraScale: Shader.MAIN_DEPTH_SCALE
		},
		vshader: [
		'attribute vec3 vertexPosition;',

		'uniform mat4 viewMatrix;',
		'uniform mat4 projectionMatrix;',
		'uniform mat4 worldMatrix;',

		'varying vec4 worldPosition;',
		ShaderBuilder.animation.prevertex,

		'void main(void) {',
			'mat4 wMatrix = worldMatrix;',
			ShaderBuilder.animation.vertex,
			'worldPosition = viewMatrix * (wMatrix * vec4(vertexPosition, 1.0));',
			'gl_Position = projectionMatrix * worldPosition;',
		'}'
		].join('\n'),
		fshader: [
		'#if SHADOW_TYPE == 2',
			'uniform float cameraScale;',
		'#endif',

		'varying vec4 worldPosition;',

		ShaderFragment.methods.packDepth,

		'void main(void)',
		'{',
			'#if SHADOW_TYPE == 0',
				'gl_FragColor = packDepth(gl_FragCoord.z);',
			'#elif SHADOW_TYPE == 1',
				'gl_FragColor = packDepth(gl_FragCoord.z);',
			'#elif SHADOW_TYPE == 2',
				'float linearDepth = length(worldPosition) * cameraScale;',
				'gl_FragColor = vec4(linearDepth, linearDepth * linearDepth, 0.0, 0.0);',
			'#endif',
		'}'
		].join('\n')
	};

	ShaderLib.pickingShader = {
		defines: {
			WEIGHTS: true,
			JOINTIDS: true
		},
		attributes: {
			vertexPosition: MeshData.POSITION,
			vertexJointIDs: MeshData.JOINTIDS,
			vertexWeights: MeshData.WEIGHTS,
			vertexNormal: MeshData.NORMAL
		},
		uniforms: {
			normalMatrix: Shader.NORMAL_MATRIX,
			viewMatrix: Shader.VIEW_MATRIX,
			projectionMatrix: Shader.PROJECTION_MATRIX,
			worldMatrix: Shader.WORLD_MATRIX,
			cameraFar: Shader.FAR_PLANE,
			thickness: 0.0,
			id: function (shaderInfo) {
				return shaderInfo.renderable._index != null ? shaderInfo.renderable._index + 1 : shaderInfo.renderable.id + 1;
			}
		},
		processors: [
			// ShaderBuilder.uber.processor,
			ShaderBuilder.animation.processor,

			function (shader) {
				shader.setDefine('NORMAL', true);
			}
		],
		vshader: [
		'attribute vec3 vertexPosition;',

		'#ifdef NORMAL',
			'attribute vec3 vertexNormal;',
		'#endif',

		'uniform mat4 viewMatrix;',
		'uniform mat4 projectionMatrix;',
		'uniform mat4 worldMatrix;',
		'uniform float cameraFar;',
		'uniform float thickness;',
		'uniform mat3 normalMatrix;',

		ShaderBuilder.animation.prevertex,

		'varying float depth;',

		'void main() {',

			'#ifdef NORMAL',
				'mat3 nMatrix = normalMatrix;',
			'#endif',

			'mat4 wMatrix = worldMatrix;',
			ShaderBuilder.animation.vertex,

			'#ifdef NORMAL',
				'vec4 mvPosition = viewMatrix * (wMatrix * vec4( vertexPosition + vertexNormal * thickness, 1.0 ));',
			'#else',
				'vec4 mvPosition = viewMatrix * (wMatrix * vec4( vertexPosition, 1.0 ));',
			'#endif',

			'depth = -mvPosition.z / cameraFar;',
			'gl_Position = projectionMatrix * mvPosition;',
		'}'
		].join('\n'),
		fshader: [
		'uniform float id;',

		'varying float depth;',

		ShaderFragment.methods.packDepth16,

		'void main() {',
			'vec2 packedId = vec2(floor(id/255.0), mod(id, 255.0)) * vec2(1.0/255.0);',
			'vec2 packedDepth = packDepth16(depth);',
			'gl_FragColor = vec4(packedId, packedDepth);',
		'}'
		].join('\n')
	};

	module.exports = ShaderLib;


/***/ },
/* 47 */
/***/ function(module, exports) {

	/* eslint indent: "off" */

	/**
	 * Collection of useful shader fragments
	 */
	function ShaderFragment() {
	}

	ShaderFragment.noisecommon = [
		'vec4 mod289(vec4 x) {',
			'return x - floor(x * (1.0 / 289.0)) * 289.0;',
		'}',

		'vec3 mod289(vec3 x) {',
			'return x - floor(x * (1.0 / 289.0)) * 289.0;',
		'}',

		'vec2 mod289(vec2 x) {',
			'return x - floor(x * (1.0 / 289.0)) * 289.0;',
		'}',

		'vec3 permute(vec3 x) {',
			'return mod289(((x*34.0)+1.0)*x);',
		'}',

		'vec4 permute(vec4 x) {',
			'return mod289(((x*34.0)+1.0)*x);',
		'}'
	].join('\n');

	ShaderFragment.noise2d = [
		ShaderFragment.noisecommon,
		'float snoise(vec2 v) {',
			'const vec4 C = vec4(0.211324865405187, // (3.0-sqrt(3.0))/6.0',
				'0.366025403784439, // 0.5*(sqrt(3.0)-1.0)',
				'-0.577350269189626, // -1.0 + 2.0 * C.x',
				'0.024390243902439); // 1.0 / 41.0',
			'vec2 i  = floor(v + dot(v, C.yy) );',
			'vec2 x0 = v - i + dot(i, C.xx);',
			'vec2 i1;',
			'//i1.x = step( x0.y, x0.x ); x0.x > x0.y ? 1.0 : 0.0',
			'//i1.y = 1.0 - i1.x;',
			'i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);',
			'// x0 = x0 - 0.0 + 0.0 * C.xx ;',
			'// x1 = x0 - i1 + 1.0 * C.xx ;',
			'// x2 = x0 - 1.0 + 2.0 * C.xx ;',
			'vec4 x12 = x0.xyxy + C.xxzz;',
			'x12.xy -= i1;',
			'i = mod289(i); // Avoid truncation effects in permutation',
			'vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))',
				'+ i.x + vec3(0.0, i1.x, 1.0 ));',
			'vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);',
			'm = m*m ;',
			'm = m*m ;',
			'vec3 x = 2.0 * fract(p * C.www) - 1.0;',
			'vec3 h = abs(x) - 0.5;',
			'vec3 ox = floor(x + 0.5);',
			'vec3 a0 = x - ox;',
			'm *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );',
			'vec3 g;',
			'g.x  = a0.x  * x0.x  + h.x  * x0.y;',
			'g.yz = a0.yz * x12.xz + h.yz * x12.yw;',
			'return 130.0 * dot(m, g);',
		'}'
	].join('\n');

	ShaderFragment.noise3d = [
		ShaderFragment.noisecommon,
		'vec4 taylorInvSqrt(vec4 r) {',
			'return 1.79284291400159 - 0.85373472095314 * r;',
		'}',

		'float snoise(vec3 v) {',
			'const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;',
			'const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);',
			'vec3 i  = floor(v + dot(v, C.yyy) );',
			'vec3 x0 = v - i + dot(i, C.xxx);',
			'vec3 g = step(x0.yzx, x0.xyz);',
			'vec3 l = 1.0 - g;',
			'vec3 i1 = min( g.xyz, l.zxy );',
			'vec3 i2 = max( g.xyz, l.zxy );',
			'vec3 x1 = x0 - i1 + C.xxx;',
			'vec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y',
			'vec3 x3 = x0 - D.yyy;      // -1.0+3.0*C.x = -0.5 = -D.y',
			'i = mod289(i); ',
			'vec4 p = permute( permute( permute( ',
				'i.z + vec4(0.0, i1.z, i2.z, 1.0 ))',
				'+ i.y + vec4(0.0, i1.y, i2.y, 1.0 )) ',
				'+ i.x + vec4(0.0, i1.x, i2.x, 1.0 ));',
			'float n_ = 0.142857142857; // 1.0/7.0',
			'vec3 ns = n_ * D.wyz - D.xzx;',
			'vec4 j = p - 49.0 * floor(p * ns.z * ns.z); // mod(p,7*7)',
			'vec4 x_ = floor(j * ns.z);',
			'vec4 y_ = floor(j - 7.0 * x_ ); // mod(j,N)',
			'vec4 x = x_ *ns.x + ns.yyyy;',
			'vec4 y = y_ *ns.x + ns.yyyy;',
			'vec4 h = 1.0 - abs(x) - abs(y);',
			'vec4 b0 = vec4( x.xy, y.xy );',
			'vec4 b1 = vec4( x.zw, y.zw );',
			'vec4 s0 = floor(b0)*2.0 + 1.0;',
			'vec4 s1 = floor(b1)*2.0 + 1.0;',
			'vec4 sh = -step(h, vec4(0.0));',
			'vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;',
			'vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;',
			'vec3 p0 = vec3(a0.xy,h.x);',
			'vec3 p1 = vec3(a0.zw,h.y);',
			'vec3 p2 = vec3(a1.xy,h.z);',
			'vec3 p3 = vec3(a1.zw,h.w);',
			'vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));',
			'p0 *= norm.x;',
			'p1 *= norm.y;',
			'p2 *= norm.z;',
			'p3 *= norm.w;',
			'vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);',
			'm = m * m;',
			'return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3) ) );',
		'}'
	].join('\n');

	var packCommon = [
		'float shift_right (float v, float amt) {',
			'v = floor(v) + 0.5;',
			'return floor(v / exp2(amt));',
		'}',
		'float shift_left (float v, float amt) {',
			'return floor(v * exp2(amt) + 0.5);',
		'}',
		'float mask_last (float v, float bits) {',
			'return mod(v, shift_left(1.0, bits));',
		'}',
		'float extract_bits (float num, float from, float to) {',
			'from = floor(from + 0.5); to = floor(to + 0.5);',
			'return mask_last(shift_right(num, from), to - from);',
		'}'
	].join('\n');

	ShaderFragment.methods = {
		packDepth: [
			'vec4 packDepth(const in float depth) {',
				'const vec4 bit_shift = vec4(256.0 * 256.0 * 256.0, 256.0 * 256.0, 256.0, 1.0);',
				'const vec4 bit_mask  = vec4(0.0, 1.0 / 256.0, 1.0 / 256.0, 1.0 / 256.0);',
				'vec4 res = fract(depth * bit_shift);',
				'res -= res.xxyz * bit_mask;',
				'return res;',
			'}'
		].join('\n'),
		unpackDepth: [
			'float unpackDepth(const in vec4 rgba_depth) {',
				'const vec4 bit_shift = vec4(1.0 / (256.0 * 256.0 * 256.0), 1.0 / (256.0 * 256.0), 1.0 / 256.0, 1.0);',
				'return dot(rgba_depth, bit_shift);',
			'}'
		].join('\n'),
		packFloat: [
			packCommon,
			'vec4 packFloat(float val) {',
				'if (val == 0.0) return vec4(0, 0, 0, 0);',
				'float sign = val > 0.0 ? 0.0 : 1.0;',
				'val = abs(val);',
				'float exponent = floor(log2(val));',
				'float biased_exponent = exponent + 127.0;',
				'float fraction = ((val / exp2(exponent)) - 1.0) * 8388608.0;',
				'float t = biased_exponent / 2.0;',
				'float last_bit_of_biased_exponent = fract(t) * 2.0;',
				'float remaining_bits_of_biased_exponent = floor(t);',
				'float byte4 = extract_bits(fraction, 0.0, 8.0) / 255.0;',
				'float byte3 = extract_bits(fraction, 8.0, 16.0) / 255.0;',
				'float byte2 = (last_bit_of_biased_exponent * 128.0 + extract_bits(fraction, 16.0, 23.0)) / 255.0;',
				'float byte1 = (sign * 128.0 + remaining_bits_of_biased_exponent) / 255.0;',
				'return vec4(byte4, byte3, byte2, byte1);',
			'}'
		].join('\n'),
		unpackFloat: [
			packCommon,
			'float unpackFloat(vec4 val) {',
				// 'if (val == vec4(0.0)) return 0.0;',
				'val = val * vec4(255.0);',
				'float sign = - shift_right(val.w, 7.0) * 2.0 + 1.0;',

				'float mantissa = ',
					'val.x +',
					'shift_left(val.y, 8.0) +',
					'shift_left(extract_bits(val.z, 0.0, 7.0), 16.0);',
				' mantissa = mantissa / 8388608.0 + 1.0;',

				'float exponent = ',
					'shift_left(extract_bits(val.w, 0.0, 7.0), 1.0) +',
					'shift_right(val.z, 7.0) - 127.0;',

				'return sign * mantissa * exp2(exponent);',
			'}'
		].join('\n'),
		packDepth16: [
			'vec2 packDepth16(const in float depth) {',
				'const vec2 bias = vec2(1.0 / 255.0, 0.0);',
				'vec2 res = vec2(depth, fract(depth * 255.0));',
				'return res - (res.yy * bias);',
			'}'
		].join('\n'),
		unpackDepth16: [
			'float unpackDepth16(const in vec2 rg_depth) {',
				'return rg_depth.x + (rg_depth.y / 255.0);',
			'}'
		].join('\n'),
		hsv: [
			'vec3 rgb2hsv(vec3 c) {',
				'vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);',
				'vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));',
				'vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));',
				'float d = q.x - min(q.w, q.y);',
				'float e = 1.0e-10;',
				'return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);',
			'}',
			'vec3 hsv2rgb(vec3 c) {',
				'vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);',
				'vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);',
				'return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);',
			'}'
		].join('\n')
	};

	ShaderFragment.blendmodes = [
		'#define BlendLinearDodgef				BlendAddf',
		'#define BlendLinearBurnf				BlendSubstractf',
		'#define BlendAddf(base, blend)			min(base + blend, 1.0)',
		'#define BlendSubstractf(base, blend)	max(base + blend - 1.0, 0.0)',
		'#define BlendLightenf(base, blend)		max(blend, base)',
		'#define BlendDarkenf(base, blend)		min(blend, base)',
		'#define BlendLinearLightf(base, blend)	(blend < 0.5 ? BlendLinearBurnf(base, (2.0 * blend)) : BlendLinearDodgef(base, (2.0 * (blend - 0.5))))',
		'#define BlendScreenf(base, blend)		(1.0 - ((1.0 - base) * (1.0 - blend)))',
		'#define BlendOverlayf(base, blend)		(base < 0.5 ? (2.0 * base * blend) : (1.0 - 2.0 * (1.0 - base) * (1.0 - blend)))',
		'#define BlendSoftLightf(base, blend)	((blend < 0.5) ? (2.0 * base * blend + base * base * (1.0 - 2.0 * blend)) : (sqrt(base) * (2.0 * blend - 1.0) + 2.0 * base * (1.0 - blend)))',
		'#define BlendColorDodgef(base, blend)	((blend == 1.0) ? blend : min(base / (1.0 - blend), 1.0))',
		'#define BlendColorBurnf(base, blend)	((blend == 0.0) ? blend : max((1.0 - ((1.0 - base) / blend)), 0.0))',
		'#define BlendVividLightf(base, blend)	((blend < 0.5) ? BlendColorBurnf(base, (2.0 * blend)) : BlendColorDodgef(base, (2.0 * (blend - 0.5))))',
		'#define BlendPinLightf(base, blend)	((blend < 0.5) ? BlendDarkenf(base, (2.0 * blend)) : BlendLightenf(base, (2.0 *(blend - 0.5))))',
		'#define BlendHardMixf(base, blend)		((BlendVividLightf(base, blend) < 0.5) ? 0.0 : 1.0)',
		'#define BlendReflectf(base, blend)		((blend == 1.0) ? blend : min(base * base / (1.0 - blend), 1.0))',
		'#define Blend(base, blend, funcf)		vec3(funcf(base.r, blend.r), funcf(base.g, blend.g), funcf(base.b, blend.b))',
		'#define BlendNormal(base, blend)		(blend)',
		'#define BlendLighten					BlendLightenf',
		'#define BlendDarken					BlendDarkenf',
		'#define BlendMultiply(base, blend)		(base * blend)',
		'#define BlendAverage(base, blend)		((base + blend) / 2.0)',
		'#define BlendAdd(base, blend)			min(base + blend, vec3(1.0))',
		'#define BlendSubstract(base, blend)	max(base + blend - vec3(1.0), vec3(0.0))',
		'#define BlendDifference(base, blend)	abs(base - blend)',
		'#define BlendNegation(base, blend)		(vec3(1.0) - abs(vec3(1.0) - base - blend))',
		'#define BlendExclusion(base, blend)	(base + blend - 2.0 * base * blend)',
		'#define BlendScreen(base, blend)		Blend(base, blend, BlendScreenf)',
		'#define BlendOverlay(base, blend)		Blend(base, blend, BlendOverlayf)',
		'#define BlendSoftLight(base, blend)	Blend(base, blend, BlendSoftLightf)',
		'#define BlendHardLight(base, blend)	BlendOverlay(blend, base)',
		'#define BlendColorDodge(base, blend)	Blend(base, blend, BlendColorDodgef)',
		'#define BlendColorBurn(base, blend)	Blend(base, blend, BlendColorBurnf)',
		'#define BlendLinearDodge				BlendAdd',
		'#define BlendLinearBurn				BlendSubstract',
		'#define BlendLinearLight(base, blend)	Blend(base, blend, BlendLinearLightf)',
		'#define BlendVividLight(base, blend)	Blend(base, blend, BlendVividLightf)',
		'#define BlendPinLight(base, blend)		Blend(base, blend, BlendPinLightf)',
		'#define BlendHardMix(base, blend)		Blend(base, blend, BlendHardMixf)',
		'#define BlendReflect(base, blend)		Blend(base, blend, BlendReflectf)',
		'#define BlendGlow(base, blend)			BlendReflect(blend, base)',
		'#define BlendPhoenix(base, blend)		(min(base, blend) - max(base, blend) + vec3(1.0))',
		'#define GammaCorrection(color, gamma)											pow(color, vec3(1.0 / gamma))',
		'#define LevelsControlInputRange(color, minInput, maxInput)						min(max(color - vec3(minInput), vec3(0.0)) / (vec3(maxInput) - vec3(minInput)), vec3(1.0))',
		'#define LevelsControlInput(color, minInput, gamma, maxInput)					GammaCorrection(LevelsControlInputRange(color, minInput, maxInput), gamma)',
		'#define LevelsControlOutputRange(color, minOutput, maxOutput)					mix(vec3(minOutput), vec3(maxOutput), color)',
		'#define LevelsControl(color, minInput, gamma, maxInput, minOutput, maxOutput)	LevelsControlOutputRange(LevelsControlInput(color, minInput, gamma, maxInput), minOutput, maxOutput)'
	].join('\n');

	module.exports = ShaderFragment;

/***/ },
/* 48 */
/***/ function(module, exports, __webpack_require__) {

	var MeshData = __webpack_require__(14);
	var PointLight = __webpack_require__(49);
	var DirectionalLight = __webpack_require__(51);
	var SpotLight = __webpack_require__(52);
	var Texture = __webpack_require__(53);
	var MathUtils = __webpack_require__(9);
	var TangentGenerator = __webpack_require__(57);
	var ShaderFragment = __webpack_require__(47);

	/**
	 * Builds shaders
	 */
	function ShaderBuilder() {}

	var defaultLight = new DirectionalLight();
	defaultLight.translation.setDirect(10, 10, 10);
	defaultLight.direction.setDirect(1, 1, 1).normalize();
	ShaderBuilder.defaultLight = defaultLight;

	ShaderBuilder.SKYBOX = null;
	ShaderBuilder.SKYSPHERE = null;
	ShaderBuilder.ENVIRONMENT_TYPE = 0;
	ShaderBuilder.GLOBAL_AMBIENT = [0, 0, 0];
	ShaderBuilder.CLEAR_COLOR = [0.3, 0.3, 0.3, 1];
	ShaderBuilder.USE_FOG = false;
	ShaderBuilder.FOG_SETTINGS = [0, 10000];
	ShaderBuilder.FOG_COLOR = [1, 1, 1];

	ShaderBuilder.uber = {
		defines: function (shader, attributeMap) {
			var keys = Object.keys(attributeMap);
			for (var i = 0, l = keys.length; i < l; i++) {
				shader.setDefine(keys[i], true);
			}
		},

		txMaps: function (shader, textureMaps) {
			var keys = Object.keys(textureMaps);
			for (var i = 0, l = keys.length; i < l; i++) {
				var type = keys[i];
				if (textureMaps[type] === undefined || textureMaps[type] === null) {
					continue;
				}

				if (type === 'SHADOW_MAP') {
					continue;
				}

				shader.setDefine(type, true);
			}
		},

		reflectivity: function (shader, material) {
			if (material.uniforms.reflectivity || material.uniforms.refractivity) {
				shader.setDefine('REFLECTIVE', true);
			} else {
				shader.removeDefine('REFLECTIVE');
			}
			shader.setDefine('REFLECTION_TYPE', material.uniforms.reflectionType !== undefined ? material.uniforms.reflectionType : 0);
		},

		sky: function (shader, material) {
			if (material.getTexture('LOCAL_ENVIRONMENT')) {
				material.setTexture('ENVIRONMENT_SPHERE', material.getTexture('LOCAL_ENVIRONMENT'));
				shader.setDefine('ENVIRONMENT_TYPE', 0);
				if (material.getTexture('ENVIRONMENT_CUBE')) {
					material.removeTexture('ENVIRONMENT_CUBE');
				}
			} else {
				if (ShaderBuilder.SKYBOX && (material.uniforms.reflectivity || material.uniforms.refractivity)) {
					material.setTexture('ENVIRONMENT_CUBE', ShaderBuilder.SKYBOX);
				} else if (material.getTexture('ENVIRONMENT_CUBE')) {
					material.removeTexture('ENVIRONMENT_CUBE');
				}
				if (ShaderBuilder.SKYSPHERE && (material.uniforms.reflectivity || material.uniforms.refractivity)) {
					material.setTexture('ENVIRONMENT_SPHERE', ShaderBuilder.SKYSPHERE);
					shader.setDefine('ENVIRONMENT_TYPE', ShaderBuilder.ENVIRONMENT_TYPE);
				} else if (material.getTexture('ENVIRONMENT_SPHERE')) {
					material.removeTexture('ENVIRONMENT_SPHERE');
				}
			}
		},

		uniforms: function (shader, textureMaps) {
			if (textureMaps.DIFFUSE_MAP) {
				var offset = textureMaps.DIFFUSE_MAP.offset;
				var repeat = textureMaps.DIFFUSE_MAP.repeat;
				shader.uniforms.offsetRepeat[0] = offset.x;
				shader.uniforms.offsetRepeat[1] = offset.y;
				shader.uniforms.offsetRepeat[2] = repeat.x;
				shader.uniforms.offsetRepeat[3] = repeat.y;
				shader.uniforms.lodBias = textureMaps.DIFFUSE_MAP.lodBias;
			} else {
				shader.uniforms.offsetRepeat[0] = 0;
				shader.uniforms.offsetRepeat[1] = 0;
				shader.uniforms.offsetRepeat[2] = 1;
				shader.uniforms.offsetRepeat[3] = 1;
				shader.uniforms.lodBias = 0;
			}
		},

		attributes: function (shader, attributeMap, textureMaps) {
			// Exclude in a nicer way
			var keys = Object.keys(shader.defines);
			for (var i = 0, l = keys.length; i < l; i++) {
				var attribute = keys[i];
				if (attribute === 'SHADOW_TYPE' ||
					attribute === 'JOINT_COUNT' ||
					attribute === 'WEIGHTS' ||
					attribute === 'PHYSICALLY_BASED_SHADING' ||
					attribute === 'ENVIRONMENT_TYPE' ||
					attribute === 'REFLECTIVE' ||
					attribute === 'DISCARD' ||
					attribute === 'OPACITY' ||
					attribute === 'FOG' ||
					attribute === 'REFLECTION_TYPE' ||
					attribute === 'SKIP_SPECULAR' ||
					attribute === 'LIGHT' ||
					attribute === 'COOKIE' ||
					attribute === 'TRANSPARENCY_BW' ||
					attribute === 'WRAP_AROUND') {
					continue;
				}
				if (!attributeMap[attribute] && !textureMaps[attribute]) {
					shader.removeDefine(attribute);
				}
			}
		},

		discard: function (shader, material) {
			// discard
			if (material.uniforms.discardThreshold >= 0.0) {
				shader.setDefine('DISCARD', true);
			} else {
				shader.removeDefine('DISCARD');
			}
		},

		opacity: function (shader, material) {
			// opacity
			var opacity = material.uniforms.opacity;
			if (opacity !== undefined && opacity < 1.0) {
				shader.setDefine('OPACITY', true);
			} else {
				shader.removeDefine('OPACITY');
			}

			// Alpha or "Black and white" transparency
			if (material.uniforms.useBWTransparency === true) {
				shader.setDefine('TRANSPARENCY_BW', true);
			} else {
				shader.removeDefine('TRANSPARENCY_BW');
			}
		},

		fog: function (shader) {
			// fog
			if (ShaderBuilder.USE_FOG) {
				shader.setDefine('FOG', true);
				shader.uniforms.fogSettings = ShaderBuilder.FOG_SETTINGS;
				shader.uniforms.fogColor = ShaderBuilder.FOG_COLOR;
			} else {
				shader.removeDefine('FOG');
			}
		},

		normalTangents: function (shader, shaderInfo) {
			//TODO: Hacky?
			if (shader.hasDefine('NORMAL') && shader.hasDefine('NORMAL_MAP') && !shaderInfo.meshData.getAttributeBuffer(MeshData.TANGENT)) {
				TangentGenerator.addTangentBuffer(shaderInfo.meshData);
			}
		},

		processor: function (shader, shaderInfo) {
			var attributeMap = shaderInfo.meshData.attributeMap;
			var material = shaderInfo.material;
			var textureMaps = material._textureMaps;

			shader.uniforms.clearColor = ShaderBuilder.CLEAR_COLOR;

			ShaderBuilder.uber.reflectivity(shader, material);
			ShaderBuilder.uber.sky(shader, material);


			ShaderBuilder.uber.defines(shader, attributeMap);
			ShaderBuilder.uber.txMaps(shader, textureMaps);


			ShaderBuilder.uber.uniforms(shader, textureMaps);
			ShaderBuilder.uber.attributes(shader, attributeMap, textureMaps);

			ShaderBuilder.uber.discard(shader, material);
			ShaderBuilder.uber.opacity(shader, material);

			ShaderBuilder.uber.fog(shader);

			shader.setDefine('SKIP_SPECULAR', true);
			ShaderBuilder.uber.normalTangents(shader, shaderInfo);
		}
	};

	var lightDefines = [];

	ShaderBuilder.light = {
		pointLight: function (light, uniforms, pointIndex) {
			var uniform = uniforms.pointLights = uniforms.pointLights || [];

			var ind = pointIndex * 8; // 2 vec4 = 8 floats

			var translation = light.translation;
			uniform[ind + 0] = translation.x;
			uniform[ind + 1] = translation.y;
			uniform[ind + 2] = translation.z;
			uniform[ind + 3] = light.range;

			var color = light.color;
			uniform[ind + 4] = color.x * light.intensity;
			uniform[ind + 5] = color.y * light.intensity;
			uniform[ind + 6] = color.z * light.intensity;
			uniform[ind + 7] = light.specularIntensity;

			lightDefines.push('P');
		},
		directionalLight: function (light, uniforms, directionalIndex) {
			var uniform = uniforms.directionalLights = uniforms.directionalLights || [];

			var ind = directionalIndex * 8; // 2 vec4 = 8 floats

			var direction = light.direction;
			uniform[ind + 0] = direction.x;
			uniform[ind + 1] = direction.y;
			uniform[ind + 2] = direction.z;
			uniform[ind + 3] = 0; // padding

			var color = light.color;
			uniform[ind + 4] = color.x * light.intensity;
			uniform[ind + 5] = color.y * light.intensity;
			uniform[ind + 6] = color.z * light.intensity;
			uniform[ind + 7] = light.specularIntensity;

			lightDefines.push('D');
		},
		spotLight: function (light, uniforms, spotIndex) {
			var uniform = uniforms.spotLights = uniforms.spotLights || [];

			var ind = spotIndex * 16; // 4 vec4 = 16 floats
			uniform[ind + 0] = light.translation.x;
			uniform[ind + 1] = light.translation.y;
			uniform[ind + 2] = light.translation.z;
			uniform[ind + 3] = light.range;

			uniform[ind + 4] = light.color.x * light.intensity;
			uniform[ind + 5] = light.color.y * light.intensity;
			uniform[ind + 6] = light.color.z * light.intensity;
			uniform[ind + 7] = light.specularIntensity;

			uniform[ind + 8] = light.direction.x;
			uniform[ind + 9] = light.direction.y;
			uniform[ind + 10] = light.direction.z;
			uniform[ind + 11] = 0; // padding

			uniform[ind + 12] = Math.cos(light.angle * MathUtils.DEG_TO_RAD / 2);
			uniform[ind + 13] = light.penumbra !== undefined ? Math.sin(light.penumbra * MathUtils.DEG_TO_RAD / 4) : 0;
			uniform[ind + 14] = 0; // padding
			uniform[ind + 15] = 0; // padding

			lightDefines.push('S');
		},
		shadows: function (light, uniforms, i, shader, shaderInfo, shadowIndex) {
			var useLightCookie = light.lightCookie instanceof Texture;

			if ((useLightCookie || light.shadowCaster) && light.shadowSettings.shadowData) {
				var shadowData = light.shadowSettings.shadowData;

				if (light.shadowCaster) {
					uniforms['shadowMaps' + i] = 'SHADOW_MAP' + i;
					shaderInfo.material.setTexture('SHADOW_MAP' + i, shadowData.shadowResult);

					var uniform = uniforms.shadowData = uniforms.shadowData || [];

					var ind = shadowIndex * 8;

					var translationData = shadowData.lightCamera.translation;
					uniform[ind + 0] = translationData.x;
					uniform[ind + 1] = translationData.y;
					uniform[ind + 2] = translationData.z;
					uniform[ind + 3] = light.shadowSettings.shadowOffset;

					uniform[ind + 4] = shadowData.cameraScale;
					uniform[ind + 5] = light.shadowSettings.darkness;
					if (light.shadowSettings.shadowType === 'PCF') {
						uniform[ind + 6] = light.shadowSettings.resolution[0];
						uniform[ind + 7] = light.shadowSettings.resolution[1];
					} else {
						uniform[ind + 6] = 0;
						uniform[ind + 7] = 0;
					}

					shadowIndex++;

					lightDefines.push('H', light.shadowSettings.shadowType === 'PCF' ? 1 : light.shadowSettings.shadowType === 'VSM' ? 2 : 0);
				}

				if (useLightCookie) {
					uniforms['lightCookie' + i] = 'LIGHT_COOKIE' + i;
					shaderInfo.material.setTexture('LIGHT_COOKIE' + i, light.lightCookie);
					lightDefines.push('C');
					shader.setDefine('COOKIE', true);
				} else {
					shader.removeDefine('COOKIE');
				}

				uniforms['shadowLightMatrices' + i] = shadowData.vpm;
			}

			return shadowIndex;
		},
		processor: function (shader, shaderInfo) {
			var uniforms = shader.uniforms;
			uniforms.totalAmbient = uniforms.totalAmbient || [0.1, 0.1, 0.1];
			shaderInfo.material.uniforms.totalAmbient = shaderInfo.material.uniforms.totalAmbient || [0.1, 0.1, 0.1];
			var materialAmbient = shaderInfo.material.uniforms.materialAmbient || uniforms.materialAmbient || [0.1, 0.1, 0.1, 1.0];
			var totalAmbient = shaderInfo.material.uniforms.totalAmbient;
			if (shaderInfo.material.multiplyAmbient) {
				totalAmbient[0] = materialAmbient[0] * ShaderBuilder.GLOBAL_AMBIENT[0];
				totalAmbient[1] = materialAmbient[1] * ShaderBuilder.GLOBAL_AMBIENT[1];
				totalAmbient[2] = materialAmbient[2] * ShaderBuilder.GLOBAL_AMBIENT[2];
			} else {
				totalAmbient[0] = materialAmbient[0] + ShaderBuilder.GLOBAL_AMBIENT[0];
				totalAmbient[1] = materialAmbient[1] + ShaderBuilder.GLOBAL_AMBIENT[1];
				totalAmbient[2] = materialAmbient[2] + ShaderBuilder.GLOBAL_AMBIENT[2];
			}

			var receiveShadows = shaderInfo.renderable &&
				shaderInfo.renderable.meshRendererComponent &&
				shaderInfo.renderable.meshRendererComponent.receiveShadows;
			if (receiveShadows) {
				shader.setDefine('RECEIVE_SHADOW', true);
			} else {
				shader.removeDefine('RECEIVE_SHADOW');
			}

			if (!shader.frameStart) {
				var lights = shaderInfo.lights;
				for (var i = 0; i < lights.length; i++) {
					var light = lights[i];
					var useLightCookie = light.lightCookie instanceof Texture;

					if ((useLightCookie || light.shadowCaster) && light.shadowSettings.shadowData) {
						var shadowData = light.shadowSettings.shadowData;

						if (light.shadowCaster) {
							shaderInfo.material.setTexture('SHADOW_MAP' + i, shadowData.shadowResult);
						}
						if (useLightCookie) {
							shaderInfo.material.setTexture('LIGHT_COOKIE' + i, light.lightCookie);
						}
					} else {
						shaderInfo.material.removeTexture('SHADOW_MAP' + i);
						shaderInfo.material.removeTexture('LIGHT_COOKIE' + i);
					}
				}

				return;
			}

			// code below only has to be once per frame
			uniforms.materialEmissive = uniforms.materialEmissive || 'EMISSIVE';
			uniforms.materialDiffuse = uniforms.materialDiffuse || 'DIFFUSE';
			uniforms.materialSpecular = uniforms.materialSpecular || 'SPECULAR';

			var pointIndex = 0;
			var directionalIndex = 0;
			var spotIndex = 0;
			var shadowIndex = 0;

			var lights = shaderInfo.lights;
			if (lights.length > 0) {
				for (var i = 0; i < lights.length; i++) {
					var light = lights[i];

					if (light instanceof PointLight) {
						ShaderBuilder.light.pointLight(light, uniforms, pointIndex);
						pointIndex++;
					} else if (light instanceof DirectionalLight) {
						ShaderBuilder.light.directionalLight(light, uniforms, directionalIndex);
						directionalIndex++;
					} else if (light instanceof SpotLight) {
						ShaderBuilder.light.spotLight(light, uniforms, spotIndex);
						spotIndex++;
					}

					shadowIndex = ShaderBuilder.light.shadows(light, uniforms, i, shader, shaderInfo, shadowIndex);
				}

				var lightStr = lightDefines.join('');
				shader.setDefine('LIGHT', lightStr);
				lightDefines.length = 0;
			} else {
				shader.removeDefine('LIGHT');
			}
		},
		builder: function (shader, shaderInfo) {
			var prevertex = [];
			var vertex = [];
			var prefragment = [];
			var fragment = [];

			prevertex.push(
				'const mat4 ScaleMatrix = mat4(0.5, 0.0, 0.0, 0.0, 0.0, 0.5, 0.0, 0.0, 0.0, 0.0, 0.5, 0.0, 0.5, 0.5, 0.5, 1.0);'
			);

			prefragment.push(
				'uniform vec3 totalAmbient;',

				'uniform vec4 materialEmissive;',
				'uniform vec4 materialDiffuse;',
				'uniform vec4 materialSpecular;',
				'uniform vec2 wrapSettings;',

				// 'float VsmFixLightBleed(in float pMax, in float amount) {',
				// 	'return clamp((pMax - amount) / (1.0 - amount), 0.0, 1.0);',
				// '}',

				'float ChebychevInequality(in vec2 moments, in float t) {',
					'if ( t <= moments.x ) return 1.0;',
					'float variance = moments.y - (moments.x * moments.x);',
					'variance = max(variance, 0.02);',
					'float d = t - moments.x;',
					'return variance / (variance + d * d);',
				'}'
			);

			fragment.push(
				'#if defined(SPECULAR_MAP) && defined(TEXCOORD0)',
					'float specularStrength = texture2D(specularMap, texCoord0).x;',
				'#else',
					'float specularStrength = 1.0;',
				'#endif',

				'vec3 totalDiffuse = vec3(0.0);',
				'vec3 totalSpecular = vec3(0.0);'
			);

			var lights = shaderInfo.lights;
			if (lights.length > 0) {
				fragment.push(
					'vec3 normalizedViewPosition = normalize(viewPosition);'
				);

				var pointIndex = 0;
				var directionalIndex = 0;
				var spotIndex = 0;
				var shadowIndex = 0;

				for (var i = 0; i < lights.length; i++) {
					var light = lights[i];
					if (light instanceof PointLight) {
						pointIndex++;
					} else if (light instanceof DirectionalLight) {
						directionalIndex++;
					} else if (light instanceof SpotLight) {
						spotIndex++;
					}

					if (light.lightCookie instanceof Texture || light.shadowCaster) {
						shadowIndex++;
					}
				}
				if (pointIndex > 0) {
					prefragment.push(
						'uniform vec4 pointLights[' + (pointIndex * 2) + '];'
					);
				}
				if (directionalIndex > 0) {
					prefragment.push(
						'uniform vec4 directionalLights[' + (directionalIndex * 2) + '];'
					);
				}
				if (spotIndex > 0) {
					prefragment.push(
						'uniform vec4 spotLights[' + (spotIndex * 4) + '];'
					);
				}
				if (shadowIndex > 0) {
					prefragment.push(
						ShaderFragment.methods.unpackDepth,
						'uniform vec4 shadowData[' + (shadowIndex * 2) + '];',
						'float texture2DCompare(sampler2D depths, vec2 uv, float compare) {',
							'return step(unpackDepth(texture2D(depths, uv)), compare);',
						'}'
					);
				}

				pointIndex = 0;
				directionalIndex = 0;
				spotIndex = 0;
				shadowIndex = 0;

				for (var i = 0; i < lights.length; i++) {
					var light = lights[i];

					fragment.push(
						'{',
							'float shadow = 1.0;'
					);

					var useLightCookie = light.lightCookie instanceof Texture;
					if (light.shadowCaster || useLightCookie) {
						prevertex.push(
							'uniform mat4 shadowLightMatrices' + i + ';',
							'varying vec4 shadowLightDepths' + i + ';'
						);

						vertex.push(
							'shadowLightDepths' + i + ' = ScaleMatrix * shadowLightMatrices' + i + ' * worldPos;'
						);

						if (light.shadowCaster) {
							prefragment.push(
								'uniform sampler2D shadowMaps' + i + ';'
							);
							fragment.push(
								'float shadowOffset' + i + ' = shadowData[' + (shadowIndex * 2 + 0) + '].w;',
								'float shadowDarkness' + i + ' = shadowData[' + (shadowIndex * 2 + 1) + '].y;'
							);
							if (light.shadowSettings.shadowType === 'PCF') {
								fragment.push(
									'vec2 shadowMapSizes' + i + ' = shadowData[' + (shadowIndex * 2 + 1) + '].zw;'
								);
							} else if (light.shadowSettings.shadowType === 'VSM') {
								fragment.push(
									'vec3 shadowLightPositions' + i + ' = shadowData[' + (shadowIndex * 2 + 0) + '].xyz;',
									'float cameraScales' + i + ' = shadowData[' + (shadowIndex * 2 + 1) + '].x;'
								);
							}
						}
						if (useLightCookie) {
							prefragment.push(
								'uniform sampler2D lightCookie' + i + ';'
							);
						}

						prefragment.push(
							'varying vec4 shadowLightDepths' + i + ';'
						);

						fragment.push(
							'vec3 depth = shadowLightDepths' + i + '.xyz / shadowLightDepths' + i + '.w;'
						);

						if (light.shadowCaster) {
							shadowIndex++;
							fragment.push(
								'#ifdef RECEIVE_SHADOW',
								'depth.z += shadowOffset' + i + ';',
								'if (depth.x >= 0.0 && depth.x <= 1.0 && depth.y >= 0.0 && depth.y <= 1.0 && shadowLightDepths' + i + '.z >= 0.0 && depth.z <= 1.0) {'
							);
							if (light.shadowSettings.shadowType === 'PCF') {
								fragment.push(
									'float xPixelOffset = 1.0 / shadowMapSizes' + i + '.x;',
									'float yPixelOffset = 1.0 / shadowMapSizes' + i + '.y;',
									'float shadowRadius = 1.25;',

									'float dx0 = -shadowRadius * xPixelOffset;',
									'float dy0 = -shadowRadius * yPixelOffset;',
									'float dx1 = shadowRadius * xPixelOffset;',
									'float dy1 = shadowRadius * yPixelOffset;',

									'shadow = 1.0 - (',
										'texture2DCompare(shadowMaps' + i + ', depth.xy + vec2(dx0, dy0), depth.z) +',
										'texture2DCompare(shadowMaps' + i + ', depth.xy + vec2(0.0, dy0), depth.z) +',
										'texture2DCompare(shadowMaps' + i + ', depth.xy + vec2(dx1, dy0), depth.z) +',
										'texture2DCompare(shadowMaps' + i + ', depth.xy + vec2(dx0, 0.0), depth.z) +',
										'texture2DCompare(shadowMaps' + i + ', depth.xy, depth.z) +',
										'texture2DCompare(shadowMaps' + i + ', depth.xy + vec2(dx1, 0.0), depth.z) +',
										'texture2DCompare(shadowMaps' + i + ', depth.xy + vec2(dx0, dy1), depth.z) +',
										'texture2DCompare(shadowMaps' + i + ', depth.xy + vec2(0.0, dy1), depth.z) +',
										'texture2DCompare(shadowMaps' + i + ', depth.xy + vec2(dx1, dy1), depth.z)',
									') * (shadowDarkness' + i + ' / 9.0);'
								);
							} else if (light.shadowSettings.shadowType === 'VSM') {
								fragment.push(
									'depth.z = length(vWorldPos.xyz - shadowLightPositions' + i + ') * cameraScales' + i + ';',
									'vec4 texel = texture2D(shadowMaps' + i + ', depth.xy);',
									'vec2 moments = vec2(texel.x, texel.y);',
									'shadow = ChebychevInequality(moments, depth.z);',
									// 'shadow = VsmFixLightBleed(shadow, 0.5);'
									'shadow = pow(shadow, shadowDarkness' + i + ' * 8.0);'
								);
							} else {
								fragment.push(
									'shadow = 1.0 - texture2DCompare(shadowMaps' + i + ', depth.xy, depth.z) * shadowDarkness' + i + ';'
								);
							}
							fragment.push(
								'} else {',
									'shadow = 1.0;',
								'}',
								'shadow = clamp(shadow, 0.0, 1.0);',
								'#endif'
							);
						}
					}

					if (light instanceof PointLight) {
						fragment.push(
							'vec4 pointLight' + i + ' = pointLights[' + (pointIndex * 2 + 0) + '];',
							'vec4 pointLightColor' + i + ' = pointLights[' + (pointIndex * 2 + 1) + '];'
						);

						fragment.push(
							'vec3 lVector = normalize(pointLight' + i + '.xyz - vWorldPos.xyz);',
							'float lDistance = 1.0 - min((length(pointLight' + i + '.xyz - vWorldPos.xyz) / pointLight' + i + '.w), 1.0);',

							'float dotProduct = dot(N, lVector);',

							'float pointDiffuseWeightFull = max(dotProduct, 0.0);',
							'float pointDiffuseWeightHalf = max(mix(dotProduct, 1.0, wrapSettings.x), 0.0);',
							'vec3 pointDiffuseWeight = mix(vec3(pointDiffuseWeightFull), vec3(pointDiffuseWeightHalf), wrapSettings.y);',

							'totalDiffuse += materialDiffuse.rgb * pointLightColor' + i + '.rgb * pointDiffuseWeight * lDistance * shadow;',

							'vec3 pointHalfVector = normalize(lVector + normalizedViewPosition);',
							'float pointDotNormalHalf = max(dot(N, pointHalfVector), 0.0);',
							'float pointSpecularWeight = pointLightColor' + i + '.a * specularStrength * max(pow(pointDotNormalHalf, materialSpecular.a), 0.0);',

							'#ifdef PHYSICALLY_BASED_SHADING',
								'float specularNormalization = (materialSpecular.a + 2.0001 ) / 8.0;',
								'vec3 schlick = materialSpecular.rgb + vec3(1.0 - materialSpecular.rgb) * pow(1.0 - dot(lVector, pointHalfVector), 5.0);',
								'totalSpecular += schlick * pointLightColor' + i + '.rgb * pointSpecularWeight * pointDiffuseWeight * lDistance * specularNormalization * shadow;',
							'#else',
								'totalSpecular += materialSpecular.rgb * pointLightColor' + i + '.rgb * pointSpecularWeight * pointDiffuseWeight * lDistance * shadow;',
							'#endif'
						);

						pointIndex++;
					} else if (light instanceof DirectionalLight) {
						fragment.push(
							'vec3 directionalLightDirection' + i + ' = directionalLights[' + (directionalIndex * 2 + 0) + '].xyz;',
							'vec4 directionalLightColor' + i + ' = directionalLights[' + (directionalIndex * 2 + 1) + '];'
						);

						fragment.push(
							'vec3 dirVector = normalize(-directionalLightDirection' + i + ');',
							'float dotProduct = dot(N, dirVector);',

							'float dirDiffuseWeightFull = max(dotProduct, 0.0);',
							'float dirDiffuseWeightHalf = max(mix(dotProduct, 1.0, wrapSettings.x), 0.0);',
							'vec3 dirDiffuseWeight = mix(vec3(dirDiffuseWeightFull), vec3(dirDiffuseWeightHalf), wrapSettings.y);',

							'vec3 cookie = vec3(1.0);'
						);
						if (useLightCookie) {
							fragment.push(
								'vec4 cookieTex = texture2D(lightCookie' + i + ', depth.xy);',
								'cookie = cookieTex.rgb * cookieTex.a;'
							);
						}
						fragment.push(
							'totalDiffuse += materialDiffuse.rgb * directionalLightColor' + i + '.rgb * dirDiffuseWeight * shadow * cookie;',

							'vec3 dirHalfVector = normalize(dirVector + normalizedViewPosition);',
							'float dirDotNormalHalf = max(dot(N, dirHalfVector), 0.0);',
							'float dirSpecularWeight = directionalLightColor' + i + '.a * specularStrength * max(pow(dirDotNormalHalf, materialSpecular.a), 0.0);',

							'#ifdef PHYSICALLY_BASED_SHADING',
								'float specularNormalization = (materialSpecular.a + 2.0001) / 8.0;',
								'vec3 schlick = materialSpecular.rgb + vec3(1.0 - materialSpecular.rgb) * pow(1.0 - dot(dirVector, dirHalfVector), 5.0);',
								'totalSpecular += schlick * directionalLightColor' + i + '.rgb * dirSpecularWeight * dirDiffuseWeight * specularNormalization * shadow * cookie;',
							'#else',
								'totalSpecular += materialSpecular.rgb * directionalLightColor' + i + '.rgb * dirSpecularWeight * dirDiffuseWeight * shadow * cookie;',
							'#endif'
						);

						directionalIndex++;
					} else if (light instanceof SpotLight) {
						fragment.push(
							'vec4 spotLight' + i + ' = spotLights[' + (spotIndex * 4 + 0) + '];',
							'vec4 spotLightColor' + i + ' = spotLights[' + (spotIndex * 4 + 1) + '];',
							'vec3 spotLightDirection' + i + ' = spotLights[' + (spotIndex * 4 + 2) + '].xyz;',
							'float spotLightAngle' + i + ' = spotLights[' + (spotIndex * 4 + 3) + '].x;',
							'float spotLightPenumbra' + i + ' = spotLights[' + (spotIndex * 4 + 3) + '].y;'
						);

						fragment.push(
							'vec3 lVector = normalize(spotLight' + i + '.xyz - vWorldPos.xyz);',
							'float lDistance = 1.0 - min((length(spotLight' + i + '.xyz - vWorldPos.xyz) / spotLight' + i + '.w), 1.0);',

							'float spotEffect = dot(normalize(-spotLightDirection' + i + '), lVector);',

							'if (spotEffect > spotLightAngle' + i + ') {',
								'if (spotLightPenumbra' + i + ' > 0.0) {',
									'spotEffect = (spotEffect - spotLightAngle' + i + ') / spotLightPenumbra' + i + ';',
									'spotEffect = clamp(spotEffect, 0.0, 1.0);',
								'} else {',
									'spotEffect = 1.0;',
								'}',

								'float dotProduct = dot(N, lVector);',

								'float spotDiffuseWeightFull = max(dotProduct, 0.0);',
								'float spotDiffuseWeightHalf = max(mix(dotProduct, 1.0, wrapSettings.x), 0.0);',
								'vec3 spotDiffuseWeight = mix(vec3(spotDiffuseWeightFull), vec3(spotDiffuseWeightHalf), wrapSettings.y);',

								'vec3 cookie = vec3(1.0);'
						);
						if (useLightCookie) {
							fragment.push(
								'vec4 cookieTex = texture2D(lightCookie' + i + ', depth.xy);',
								'cookie = cookieTex.rgb * cookieTex.a;'
							);
						}
						fragment.push(
								'totalDiffuse += materialDiffuse.rgb * spotLightColor' + i + '.rgb * spotDiffuseWeight * lDistance * spotEffect * shadow * cookie;',

								'vec3 spotHalfVector = normalize(lVector + normalizedViewPosition);',
								'float spotDotNormalHalf = max(dot(N, spotHalfVector), 0.0);',
								'float spotSpecularWeight = spotLightColor' + i + '.a * specularStrength * max(pow(spotDotNormalHalf, materialSpecular.a), 0.0);',

								'#ifdef PHYSICALLY_BASED_SHADING',
									'float specularNormalization = (materialSpecular.a + 2.0001) / 8.0;',
									'vec3 schlick = materialSpecular.rgb + vec3(1.0 - materialSpecular.rgb) * pow(1.0 - dot(lVector, spotHalfVector), 5.0);',
									'totalSpecular += schlick * spotLightColor' + i + '.rgb * spotSpecularWeight * spotDiffuseWeight * lDistance * specularNormalization * spotEffect * shadow * cookie;',
								'#else',
									'totalSpecular += materialSpecular.rgb * spotLightColor' + i + '.rgb * spotSpecularWeight * spotDiffuseWeight * lDistance * spotEffect * shadow * cookie;',
								'#endif',
							'}'
						);

						spotIndex++;
					}

					fragment.push(
						'}'
					);
				}
			}

			fragment.push(
				'#if defined(EMISSIVE_MAP) && defined(TEXCOORD0)',
					'vec3 emissive = vec3(0.0);',
				'#else',
					'vec3 emissive = materialEmissive.rgb;',
				'#endif',

				// '#if defined(MULTIPLY_AMBIENT)',
				// 	'vec3 ambient = globalAmbient * materialAmbient.rgb;',
				// '#else',
				// 	'vec3 ambient = globalAmbient + materialAmbient.rgb;',
				// '#endif',

				'#ifdef SKIP_SPECULAR',
					'final_color.xyz = final_color.xyz * (emissive + totalDiffuse + totalAmbient);',
				'#else',
					'final_color.xyz = final_color.xyz * (emissive + totalDiffuse + totalAmbient) + totalSpecular;',
				'#endif',

				'#if defined(EMISSIVE_MAP) && defined(TEXCOORD0)',
					'final_color.rgb += texture2D(emissiveMap, texCoord0).rgb * materialEmissive.rgb;',
				'#endif'
			);

			ShaderBuilder.light.prevertex = prevertex.join('\n');
			ShaderBuilder.light.vertex = vertex.join('\n');
			ShaderBuilder.light.prefragment = prefragment.join('\n');
			ShaderBuilder.light.fragment = fragment.join('\n');
		}
	};

	ShaderBuilder.animation = {
		processor: function (shader, shaderInfo) {
			var pose = shaderInfo.currentPose;
			if (pose) {
				if (!shader.uniforms.jointPalette) {
					shader.uniforms.jointPalette = ShaderBuilder.animation.jointPalette;
				}
				// var maxUniforms = Math.floor(Math.max(Capabilities.maxVertexUniformVectors - 10, 0)); // Just estimate available
				// shader.setDefine('JOINT_COUNT', Math.min(shaderInfo.meshData.paletteMap.length * 3, maxUniforms));
				shader.setDefine('JOINT_COUNT', shaderInfo.meshData.paletteMap.length * 3);
			} else {
				shader.removeDefine('JOINT_COUNT');
			}
		},
		jointPalette: function (shaderInfo) {
			var skMesh = shaderInfo.meshData;
			var pose = shaderInfo.currentPose;
			if (pose) {
				var palette = pose._matrixPalette;
				var store = skMesh.store;
				if (!store) {
					store = new Float32Array(skMesh.paletteMap.length * 12);
					skMesh.store = store;
				}
				var refMat;
				for (var index = 0; index < skMesh.paletteMap.length; index++) {
					refMat = palette[skMesh.paletteMap[index]];
					for (var i = 0; i < 12; i++) {
						store[index * 12 + i] = refMat.data[ShaderBuilder.animation.order[i]];
					}
					/*
					for (var row = 0; row < 3; row++) {
						for (var col = 0; col < 4; col++) {
							// Transposed, so we can pad with translation
							store[index * 12 + row * 4 + col] = refMat.data[col * 4 + row];
						}
					}*/
				}
				return store;
			}
		},
		order: [
			0, 4, 8, 12,
			1, 5, 9, 13,
			2, 6, 10, 14
		],
		prevertex: [
			'#if defined(JOINT_COUNT) && defined(WEIGHTS) && defined(JOINTIDS)',
				'attribute vec4 vertexJointIDs;',
				'attribute vec4 vertexWeights;',
				'uniform vec4 jointPalette[JOINT_COUNT];',
			'#endif'
		].join('\n'),
		vertex: [
			'#if defined(JOINT_COUNT) && defined(WEIGHTS) && defined(JOINTIDS)',

			'int x = 3*int(vertexJointIDs.x);',
			'int y = 3*int(vertexJointIDs.y);',
			'int z = 3*int(vertexJointIDs.z);',
			'int w = 3*int(vertexJointIDs.w);',

			'mat4 mat = mat4(0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0);',

			'mat += mat4(',
			'	jointPalette[x+0].x, jointPalette[x+1].x, jointPalette[x+2].x, 0,',
			'	jointPalette[x+0].y, jointPalette[x+1].y, jointPalette[x+2].y, 0,',
			'	jointPalette[x+0].z, jointPalette[x+1].z, jointPalette[x+2].z, 0,',
			'	jointPalette[x+0].w, jointPalette[x+1].w, jointPalette[x+2].w, 1',
			') * vertexWeights.x;',
			'mat += mat4(',
			'	jointPalette[y+0].x, jointPalette[y+1].x, jointPalette[y+2].x, 0,',
			'	jointPalette[y+0].y, jointPalette[y+1].y, jointPalette[y+2].y, 0,',
			'	jointPalette[y+0].z, jointPalette[y+1].z, jointPalette[y+2].z, 0,',
			'	jointPalette[y+0].w, jointPalette[y+1].w, jointPalette[y+2].w, 1',
			') * vertexWeights.y;',
			'mat += mat4(',
			'	jointPalette[z+0].x, jointPalette[z+1].x, jointPalette[z+2].x, 0,',
			'	jointPalette[z+0].y, jointPalette[z+1].y, jointPalette[z+2].y, 0,',
			'	jointPalette[z+0].z, jointPalette[z+1].z, jointPalette[z+2].z, 0,',
			'	jointPalette[z+0].w, jointPalette[z+1].w, jointPalette[z+2].w, 1',
			') * vertexWeights.z;',
			'mat += mat4(',
			'	jointPalette[w+0].x, jointPalette[w+1].x, jointPalette[w+2].x, 0,',
			'	jointPalette[w+0].y, jointPalette[w+1].y, jointPalette[w+2].y, 0,',
			'	jointPalette[w+0].z, jointPalette[w+1].z, jointPalette[w+2].z, 0,',
			'	jointPalette[w+0].w, jointPalette[w+1].w, jointPalette[w+2].w, 1',
			') * vertexWeights.w;',

			'wMatrix = wMatrix * mat / mat[3][3];',
			'#ifdef NORMAL',
				'nMatrix = nMatrix * mat3(mat) / mat[3][3];',
			'#endif',
			'#endif'
		].join('\n')
	};

	module.exports = ShaderBuilder;

/***/ },
/* 49 */
/***/ function(module, exports, __webpack_require__) {

	var Light = __webpack_require__(50);

	/**
	 * A omni-directional source of light. So far it has the same effect as {@link Light}<br>
	 * @example-link http://code.gooengine.com/latest/visual-test/goo/renderer/light/Lights-vtest.html Working example
	 * @extends Light
	 * @param {Vector3} [color=(1, 1, 1)] The color of the light
	 */
	function PointLight(color) {
		Light.call(this, color);

		/**
		 * The range of the light (default is 1000)
		 * @type {number}
		 */
		this.range = 1000;

		// @ifdef DEBUG
		Object.seal(this);
		// @endif
	}

	PointLight.prototype = Object.create(Light.prototype);
	PointLight.prototype.constructor = PointLight;

	/**
	 * Updates the light's translation
	 * @private
	 * @param {Transform} transform
	 */
	PointLight.prototype.update = function (transform) {
		transform.matrix.getTranslation(this.translation);
	};

	PointLight.prototype.copy = function (source) {
		Light.prototype.copy.call(this, source);

		this.range = source.range;

		return this;
	};

	PointLight.prototype.clone = function () {
		var clone = new PointLight(this.color.clone());
		clone.copy(this);
		return clone;
	};

	module.exports = PointLight;

/***/ },
/* 50 */
/***/ function(module, exports, __webpack_require__) {

	var Vector3 = __webpack_require__(8);

	/**
	 * A plain light source in the scene, to be handled by shaders<br>
	 * @example-link http://code.gooengine.com/latest/visual-test/goo/renderer/light/Lights-vtest.html Working example
	 * @param {Vector3} [color=(1, 1, 1)] The color of the light
	 */
	function Light(color) {
		/**
		 * The light's translation in world space
		 * @type {Vector3}
		 */
		this.translation = new Vector3();

		/**
		 * The color of the light
		 * @type {Vector3}
		 */
		this.color = color ? color.clone() : new Vector3(1, 1, 1);

		/**
		 * The intensity of the light (typically between 0 and 1)
		 * @type {number}
		 */
		this.intensity = 1;

		/**
		 * The specular intensity of the light (typically between 0 and 1)
		 * @type {number}
		 */
		this.specularIntensity = 1;

		/**
		 * Dictates wether this light will 'cast' shadows or not
		 * @type {boolean}
		 * @default
		 */
		this.shadowCaster = false;

		/**
		 * By default lights shine a single color on surfaces. If however this parameter is used then the light will project a texture (called 'light cookie') on surfaces. The light cookie will be multiplied with the color of the light
		 * @type {null}
		 */
		this.lightCookie = null;

		/**
		 * @type {Object}
		 * @property {number} size 2000
		 * @property {number} near 1
		 * @property {number} far 1000
		 * @property {Array<number>} resolution 512x512
		 * @property {Vector3} upVector UNIT_Y
		 * @property {number} darkness Shadow contribution
		 * @property {string} shadowType Possible values 'VSM' = Variance Shadow Maps, 'PCF' = Percentage Closer Filtering, 'Basic' = No filtering
		 */
		this.shadowSettings = {
			size: 100,
			near: 1,
			far: 1000,
			resolution: [512, 512],
			upVector: Vector3.UNIT_Y.clone(),
			darkness: 1.0,
			shadowOffset: -0.001,
			shadowType: 'VSM'
		};
		//! AT: please extract this in its own class

		this.changedProperties = false;
		this.changedColor = false;
	}

	Light.prototype.destroy = function (renderer) {
		var shadowSettings = this.shadowSettings;
		if (shadowSettings.shadowData) {
			if (shadowSettings.shadowData.shadowTarget) {
				shadowSettings.shadowData.shadowTarget.destroy(renderer.context);
			}
			if (shadowSettings.shadowData.shadowTargetDown) {
				shadowSettings.shadowData.shadowTargetDown.destroy(renderer.context);
			}
			if (shadowSettings.shadowData.shadowBlurred) {
				shadowSettings.shadowData.shadowBlurred.destroy(renderer.context);
			}
		}
		delete shadowSettings.shadowData;
	};

	// should be overridable by light type (some may have more/less allocated resources)
	Light.prototype.invalidateHandles = function (renderer) {
		var shadowSettings = this.shadowSettings;
		if (shadowSettings.shadowData) {
			if (shadowSettings.shadowData.shadowTarget) {
				renderer.invalidateRenderTarget(shadowSettings.shadowData.shadowTarget);
			}
			if (shadowSettings.shadowData.shadowTargetDown) {
				renderer.invalidateRenderTarget(shadowSettings.shadowData.shadowTargetDown);
			}
			if (shadowSettings.shadowData.shadowBlurred) {
				renderer.invalidateRenderTarget(shadowSettings.shadowData.shadowBlurred);
			}
		}
	};

	Light.prototype.copy = function (source) {
		this.translation.copy(source.translation);
		this.color.copy(source.color);
		this.intensity = source.intensity;
		this.specularIntensity = source.specularIntensity;
		this.shadowCaster = source.shadowCaster;

		if (source.lightCookie) {
			this.lightCookie = source.lightCookie.clone();
		}

		this.shadowSettings.size = source.shadowSettings.size;
		this.shadowSettings.near = source.shadowSettings.near;
		this.shadowSettings.far = source.shadowSettings.far;
		this.shadowSettings.resolution[0] = source.shadowSettings.resolution[0];
		this.shadowSettings.resolution[1] = source.shadowSettings.resolution[1];
		this.shadowSettings.upVector.copy(source.shadowSettings.upVector);
		this.shadowSettings.darkness = source.shadowSettings.darkness;
		this.shadowSettings.shadowType = source.shadowSettings.shadowType;

		// since these are brand new they should probably be whatever value they are set in the constructor
		this.changedProperties = source.changedProperties; // false?
		this.changedColor = source.changedColor; // false?

		return this;
	};

	module.exports = Light;

/***/ },
/* 51 */
/***/ function(module, exports, __webpack_require__) {

	var Vector3 = __webpack_require__(8);
	var Light = __webpack_require__(50);

	/**
	 * A directional light
	 * @example-link http://code.gooengine.com/latest/visual-test/goo/renderer/light/Lights-vtest.html Working example
	 * @extends Light
	 * @param {Vector3} [color=(1, 1, 1)] The color of the light
	 */
	function DirectionalLight(color) {
		Light.call(this, color);

		/**
		 * The direction vector of the light
		 * @readonly
		 * @type {Vector3}
		 */
		this.direction = new Vector3();

		// @ifdef DEBUG
		Object.seal(this);
		// @endif
	}

	DirectionalLight.prototype = Object.create(Light.prototype);
	DirectionalLight.prototype.constructor = DirectionalLight;

	/**
	 * Updates the light's translation and orientation
	 * @hidden
	 * @param {Transform} transform
	 */
	DirectionalLight.prototype.update = function (transform) {
		transform.matrix.getTranslation(this.translation);
		this.direction.setDirect(0.0, 0.0, -1.0);
		this.direction.applyPostVector(transform.matrix);
	};

	DirectionalLight.prototype.copy = function (source) {
		Light.prototype.copy.call(this, source);

		this.direction.copy(source.direction);

		return this;
	};

	DirectionalLight.prototype.clone = function () {
		var clone = new DirectionalLight(this.color.clone());
		clone.copy(this);
		return clone;
	};

	module.exports = DirectionalLight;

/***/ },
/* 52 */
/***/ function(module, exports, __webpack_require__) {

	var Vector3 = __webpack_require__(8);
	var Light = __webpack_require__(50);

	/**
	 * The SpotLight can be viewed as two cones with their apexes located at the light's location.
	 * The properties angle sets the angle (in degrees) for which the outer cone
	 * deviates from the light's direction. The exponent property sets the angle for the inner cone.
	 * The angle property is also known as the outer angle or falloff. The exponent property is also known as
	 * the inner angle or hotspot.
	 * @example-link http://code.gooengine.com/latest/visual-test/goo/renderer/light/Lights-vtest.html Working example
	 * @extends Light
	 * @param {Vector3} [color=(1, 1, 1)] The color of the light
	 */
	function SpotLight(color) {
		Light.call(this, color);

		/**
		 * The direction vector of the light
		 * @readonly
		 * @type {Vector3}
		 */
		this.direction = new Vector3();

		/**
		 * The range of the light (default is 1000)
		 * @type {number}
		 */
		this.range = 1000;

		/**
		 * The angle (in degrees) of the cone of light that this spotlight projects (default is 45)
		 * @type {number}
		 */
		this.angle = 45;

		/**
		 * The angle to where light is full strength. Then it falls off linearly to the angle-value; penumbra is always smaller than angle. Set to null if the penumbra should be the same as the angle.
		 * @type {number}
		 */
		this.penumbra = null;

		/** @type {number} */
		this.exponent = 16.0;

		// @ifdef DEBUG
		Object.seal(this);
		// @endif
	}

	SpotLight.prototype = Object.create(Light.prototype);
	SpotLight.prototype.constructor = SpotLight;

	/**
	 * Updates the light's translation and orientation
	 * @hidden
	 * @param {Transform} transform
	 */
	SpotLight.prototype.update = function (transform) {
		transform.matrix.getTranslation(this.translation);

		this.direction.setDirect(0.0, 0.0, -1.0);
		this.direction.applyPostVector(transform.matrix);
	};

	SpotLight.prototype.copy = function (source) {
		Light.prototype.copy.call(this, source);

		source.direction.copy(this.direction);
		this.range = source.range;
		this.angle = source.angle;
		this.penumbra = source.penumbra;
		this.exponent = source.exponent;

		return this;
	};

	SpotLight.prototype.clone = function () {
		var clone = new SpotLight(this.color.clone());
		clone.copy(this);
		return clone;
	};

	module.exports = SpotLight;

/***/ },
/* 53 */
/***/ function(module, exports, __webpack_require__) {

	var Vector2 = __webpack_require__(19);
	var PromiseUtils = __webpack_require__(54);
	var ObjectUtils = __webpack_require__(6);

	/**
	 * <code>Texture</code> defines a texture object to be used to display an image on a piece of geometry. The image to be displayed is
	 *        defined by the <code>Image</code> class. All attributes required for texture mapping are contained within this class. This includes
	 *        mipmapping if desired, magnificationFilter options, apply options and correction options. Default values are as follows:
	 *        minificationFilter - NearestNeighborNoMipMaps, magnificationFilter - NearestNeighbor, wrap - EdgeClamp on S, T and R, apply - Modulate,
	 *        environment - None.
	 * @param {Image} image Image to use as base for texture
	 * @param {Object} settings Texturing settings
	 * @param {string} [settings.wrapS='Repeat'] possible values:
	 *		<ul>
	 *			<li>'Repeat' = Repeat texture (ignore integer part of texture coords)
	 *			<li>'MirroredRepeat' = Repeat with reversed direction on odd integer part of texture coords
	 *			<li>'EdgeClamp' = Clamp texture coord range to 0..1 and use edge color
	 *		</ul>
	 * @param {string} [settings.wrapT='Repeat'] possible values:
	 *		<ul>
	 *			<li>'Repeat' = Repeat texture (ignore integer part of texture coords)
	 *			<li>'MirroredRepeat' = Repeat with reversed direction on odd integer part of texture coords
	 *			<li>'EdgeClamp' = Clamp texture coord range to 0..1 and use edge color
	 *		</ul>
	 * @param {string} [settings.magFilter='Bilinear'] possible values:
	 *		<ul>
	 *			<li>'NearestNeighbor' =
	 *			<li>'Bilinear' =
	 *		</ul>
	 * @param {string} [settings.minFilter='TriLinear'] possible values:
	 *		<ul>
	 *			<li>'NearestNeighborNoMipMaps' =
	 *			<li>'NearestNeighborNearestMipMap' =
	 *			<li>'NearestNeighborLinearMipMap' =
	 *			<li>'BilinearNoMipMaps' =
	 *			<li>'BilinearNearestMipMap' =
	 *			<li>'Trilinear' =
	 *		</ul>
	 * @param {number} [settings.anisotropy=1] Amount of anisotropic filtering (1=1x, 4=4x etc, max usually 4 or 16. Card max in Capabilities.maxAnisotropy)
	 * @param {string} [settings.format='RGBA'] possible values:
	 *		<ul>
	 *			<li>'RGBA' =
	 *			<li>'RGB' =
	 *			<li>'Alpha' =
	 *			<li>'Luminance' =
	 *			<li>'LuminanceAlpha' =
	 *		</ul>
	 * @param {string} [settings.type='UnsignedByte'] possible values:
	 *		<ul>
	 *			<li>'UnsignedByte' =
	 *			<li>'UnsignedShort565' =
	 *			<li>'UnsignedShort4444' =
	 *			<li>'UnsignedShort5551' =
	 *			<li>'Float' =
	 *		</ul>
	 * @param {Array} [settings.offset=(0, 0)] Texture offset
	 * @param {Array} [settings.repeat=(1, 1)] Texture repeat/scale
	 * @param {boolean} [settings.generateMipmaps='true'] Automatically generate mipmaps
	 * @param {boolean} [settings.premultiplyAlpha='false'] Premultiply alpha
	 * @param {number} [settings.unpackAlignment=1] Unpack alignment setting
	 * @param {boolean} [settings.flipY='true'] Flip texture in y-axis
	 * @param {number} width Width of the texture
	 * @param {number} height Height of the texture
	 */
	function Texture(image, settings, width, height) {
		this.glTexture = null;

		settings = settings || {};

		ObjectUtils.copyOptions(this, settings, {
			wrapS: 'Repeat',
			wrapT: 'Repeat',
			magFilter: 'Bilinear',
			minFilter: 'Trilinear',
			format: 'RGBA',
			type: 'UnsignedByte',
			generateMipmaps: true,
			premultiplyAlpha: false,
			unpackAlignment: 1,
			flipY: true
		});

		/**
		 * The anisotropic filtering level.
		 * @example-link http://code.gooengine.com/latest/visual-test/goo/renderer/texture/AnisotropicFiltering/Anisotropic-vtest.html Working example
		 * @type {number}
		 */
		this.anisotropy = settings.anisotropy !== undefined ? settings.anisotropy : 1;

		this.variant = '2D'; // CUBE

		this.offset = settings.offset ?	Vector2.fromAny(settings.offset) : new Vector2(0, 0);
		this.repeat = settings.repeat ? Vector2.fromAny(settings.repeat) : new Vector2(1, 1);

		this.lodBias = 0.0;

		this.hasBorder = false;

		this.needsUpdate = false;
		this.updateCallback = null;
		this.readyCallback = null;

		this._originalImage = null;
		this._originalWidth = 0;
		this._originalHeight = 0;

		this.image = null;
		if (image) {
			this.setImage(image, width, height, settings);
		}

		/**
		 * If the Texture was set to load lazily in the TextureHandler, then this method can be used to load the image at a later point. This function returns a promise that resolves when the image was loaded.
		 * @type {Function}
		 */
		this.loadImage = PromiseUtils.resolve.bind(null, this);

		this.textureRecord = {};

		// @ifdef DEBUG
		Object.seal(this);
		// @endif
	}

	/**
	* Checks if the texture's data is ready.
	* @returns {boolean} True if ready.
	*/
	Texture.prototype.checkDataReady = function () {
		return this.image && (this.image.dataReady || this.image instanceof HTMLImageElement) || this.readyCallback !== null && this.readyCallback();
	};

	/**
	* Checks if the texture needs an update.
	* @returns {boolean} True if needed.
	*/
	Texture.prototype.checkNeedsUpdate = function () {
		//! AT: what's the precedence here? || first and then && or the other way around?
		return this.needsUpdate || this.updateCallback !== null && this.updateCallback();
	};

	/**
	 * Marks the texture as needing to be updated by the engine.
	 */
	Texture.prototype.setNeedsUpdate = function () {
		this.needsUpdate = true;
	};

	//! AT: this takes the same parameters as the Texture function but in a different order!
	/**
	 * Sets an image on the texture object.
	 *
	 * @param {Image} image The image to set. Can be an Image, TypedArray or an array of Images (for cubemaps)
	 * @param {number} [width]
	 * @param {number} [height]
	 */
	Texture.prototype.setImage = function (image, width, height, settings) {
		//! AT: this is not a general pattern; it is applied here only because of the complexity of this function
		this._originalImage = image;

		this.image = image; //! AT: is this always overriden? if so then why set it?

		var data = image instanceof Array ? image[0] : image;
		if (data instanceof Uint8Array || data instanceof Uint8ClampedArray || data instanceof Uint16Array || data instanceof Float32Array) {
			width = width || image.width;
			height = height || image.height;
			if (width !== undefined && height !== undefined) {
				this.image = {
					data: image,
					width: width,
					height: height,
					isData: true,
					dataReady: true
				};

				if (data instanceof Uint8Array || data instanceof Uint8ClampedArray) {
					this.type = settings.type || 'UnsignedByte';
				} else if (data instanceof Uint16Array) {
					this.type = settings.type || 'UnsignedShort565';
					this.format = settings.format || 'RGB';
				} else if (data instanceof Float32Array) {
					this.type = settings.type || 'Float';
					this.format = settings.format || 'RGBA';
				}
			} else {
				throw new Error('Data textures need width and height');
			}
		} else {
			if (image instanceof Array) {
				this.image = {
					data: image
				};
			}
			if (data instanceof HTMLCanvasElement) {
				this.image.dataReady = true;
			}
		}
		this.setNeedsUpdate();

		//! AT: this is not a general pattern; it is applied here only because of the complexity of this function
		// these are delayed here in case width and height are modified in this function
		this._originalWidth = width;
		this._originalHeight = height;
	};

	/**
	 * Releases the allocated texture
	 * @param {WebGLRenderingContext} context
	 */
	Texture.prototype.destroy = function (context) {
		context.deleteTexture(this.glTexture);
		this.glTexture = null;
	};

	/**
	 * Returns the number of bytes this texture occupies in memory
	 * @returns {number}
	 */
	Texture.prototype.getSizeInMemory = function () {
		var size;

		if (!this.image) { return 0; }
		var width = this.image.width || this.image.length;
		var height = this.image.height || 1;

		size = width * height;

		if (this.format === 'Luminance' || this.format === 'Alpha') {
			size *= 1;
		} else if (this.format === 'Lumin`anceAlpha') {
			size *= 2;
		} else if (this.format === 'RGB') {
			size *= 3; // some dubious video cards may use 4 bits anyway
		} else if (this.format === 'RGBA') {
			size *= 4;
		} else if (this.format === 'PrecompressedDXT1') {
			size *= 4 / 8; // 8 : 1 ratio
		} else if (this.format === 'PrecompressedDXT1A') {
			size *= 4 / 6; // 6 : 1 ratio
		} else if (this.format === 'PrecompressedDXT3' || this.format === 'PrecompressedDXT5') {
			size *= 4 / 4; // 4 : 1 ratio
		}

		// account for mip maps
		if (this.generateMipmaps) {
			size = Math.ceil(size * 4 / 3);
		}

		return size;
	};

	/**
	 * Returns a clone of this plane
	 * @returns {Texture}
	 */
	Texture.prototype.clone = function () {
		// reconstructing original settings object passed to the constructor
		var settings = {
			wrapS: this.wrapS,
			wrapT: this.wrapT,
			magFilter: this.magFilter,
			minFilter: this.minFilter,
			anisotropy: this.anisotropy,
			format: this.format,
			type: this.type,
			offset: this.offset,
			repeat: this.repeat,
			generateMipmaps: this.generateMipmaps,
			premultiplyAlpha: this.premultiplyAlpha,
			unpackAlignment: this.unpackAlignment,
			flipY: this.flipY
		};

		var clone = new Texture(this._originalImage, settings, this._originalWidth, this._originalHeight);
		clone.variant = this.variant;
		clone.lodBias = this.lodBias;
		clone.hasBorder = this.hasBorder;
		return clone;
	};

	Texture.CUBE_FACES = ['PositiveX', 'NegativeX', 'PositiveY', 'NegativeY', 'PositiveZ', 'NegativeZ'];

	module.exports = Texture;

/***/ },
/* 54 */
/***/ function(module, exports, __webpack_require__) {

	var RSVP = __webpack_require__(55);

	/**
	 * Provides promise-related utility methods
	 */
	function PromiseUtils() {}

	//! AT: converting from PromiseUtils.createPromise to new RSVP.Promise is going to be trivial
	/**
	 * Same as ES6 `new Promise`
	 * @param fun
	 * @returns {RSVP.Promise}
	 */
	PromiseUtils.createPromise = function (fun) {
		var promise = new RSVP.Promise();

		fun(function (value) {
			promise.resolve(value);
		}, function (reason) {
			promise.reject(reason);
		});

		return promise;
	};

	//! AT: in line with the native Promise.resolve
	/**
	 * Creates a promise that resolves with the given argument.
	 * @param value
	 */
	PromiseUtils.resolve = function (value) {
		var promise = new RSVP.Promise();
		promise.resolve(value);
		return promise;
	};

	//! AT: in line with the native Promise.reject
	/**
	 * Creates a promise that resolves with the given argument.
	 * @param reason
	 */
	PromiseUtils.reject = function (reason) {
		var promise = new RSVP.Promise();
		promise.reject(reason);
		return promise;
	};


	var createDummyPromiseWarn = false;
	/**
	 * Create a promise that resolves or rejects immediately with the given argument.
	 * @deprecated Use PromiseUtils.resolve/reject instead.
	 * @param {any} arg
	 * @param {any} error
	 * @returns {RSVP.Promise}
	 */
	PromiseUtils.createDummyPromise = function (arg, error) {
		if (!createDummyPromiseWarn) {
			createDummyPromiseWarn = true;
			console.warn('PromiseUtils.createDummyPromise is deprecated; please consider using PromiseUtils.resolve/reject instead');
		}

		var promise = new RSVP.Promise();
		if (error) {
			promise.reject(error);
		} else {
			promise.resolve(arg);
		}
		return promise;
	};


	/**
	 * Returns a promise that resolves when all given promises are resolved or rejected.
	 * Like RSVP.all(), except that instead of rejecting, this promise always resolves.
	 *
	 * @param {Array} promises
	 * @returns {RSVP.Promise} that resolves with the results of the promises. If a
	 * promise fails, the result of that promise will be the error. But the returned
	 * promise will always resolve with an array of objects.
	 */
	PromiseUtils.optimisticAll = function (promises) {
		var resolved = 0,
			len = promises.length,
			results = [],
			promise = new RSVP.Promise();

		if (len > 0) {
			for (var i = 0; i < len; i++) {
				(function (i) {
					promises[i].then(function (result) {
						results[i] = result;
						resolved++;
						if (resolved === len) {
							promise.resolve(results);
						}
					},
					function (error) {
						results[i] = error;
						resolved++;
						if (resolved === len) {
							promise.resolve(results);
						}
					});
				})(i);
			}
		}
		else {
			promise.resolve(results);
		}
		return promise;
	};

	/**
	 * Creates a promise that is resolved within a given amount of time
	 * @param value
	 * @param {number} time
	 * @returns {Promise}
	 */
	PromiseUtils.delay = function (value, time) {
		var promise = new RSVP.Promise();
		setTimeout(function () {
			promise.resolve(value);
		}, time);
		return promise;
	};

	// the doc doesn't align with half of what this function actually does
	/**
	 * Create a promise that resolves or rejects after the specified delay with the given argument.
	 * @deprecated Deprecated as of v0.14.x and scheduled for removal in v0.16.0; consider using
	 * PromiseUtils.delay instead
	 * @param {number} delay in ms
	 * @returns {RSVP.Promise}
	 */
	PromiseUtils.defer = function (delay, arg) {
		var p1, p2, promise;
		promise = new RSVP.Promise();
		if (arg.apply) {
			p1 = new RSVP.Promise();
			p2 = p1.then(function () {
				return arg();
			});
			setTimeout(function () {
				p1.resolve();
			}, delay);
			return p2;
		} else {
			setTimeout(function () {
				promise.resolve(arg);
			}, delay);
		}
		return promise;
	};

	module.exports = PromiseUtils;


/***/ },
/* 55 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {var config = {};

	var browserGlobal = (typeof window !== 'undefined') ? window : {};
	var MutationObserver = browserGlobal.MutationObserver || browserGlobal.WebKitMutationObserver;

	if (typeof process !== 'undefined' &&
		{}.toString.call(process) === '[object process]') {
		config.async = function (callback, binding) {
			process.nextTick(function () {
				callback.call(binding);
			});
		};
	} else if (MutationObserver) {
		var queue = [];

		var observer = new MutationObserver(function () {
			var toProcess = queue.slice();
			queue = [];

			toProcess.forEach(function (tuple) {
				var callback = tuple[0], binding = tuple[1];
				callback.call(binding);
			});
		});

		var element = document.createElement('div');
		observer.observe(element, { attributes: true });

		// Chrome Memory Leak: https://bugs.webkit.org/show_bug.cgi?id=93661
		window.addEventListener('unload', function () {
			observer.disconnect();
			observer = null;
		});

		config.async = function (callback, binding) {
			queue.push([callback, binding]);
			element.setAttribute('drainQueue', 'drainQueue');
		};
	} else {
		config.async = function (callback, binding) {
			setTimeout(function () {
				callback.call(binding);
			}, 1);
		};
	}

	var Event = function (type, options) {
		this.type = type;

		for (var option in options) {
			if (!options.hasOwnProperty(option)) {
				continue;
			}

			this[option] = options[option];
		}
	};

	var indexOf = function (callbacks, callback) {
		for (var i = 0, l = callbacks.length; i < l; i++) {
			if (callbacks[i][0] === callback) {
				return i;
			}
		}

		return -1;
	};

	var callbacksFor = function (object) {
		var callbacks = object._promiseCallbacks;

		if (!callbacks) {
			callbacks = object._promiseCallbacks = {};
		}

		return callbacks;
	};

	var EventTarget = {
		mixin: function (object) {
			object.on = this.on;
			object.off = this.off;
			object.trigger = this.trigger;
			return object;
		},

		on: function (eventNames, callback, binding) {
			var allCallbacks = callbacksFor(this), callbacks, eventName;
			eventNames = eventNames.split(/\s+/);
			binding = binding || this;

			while (eventName = eventNames.shift()) {
				callbacks = allCallbacks[eventName];

				if (!callbacks) {
					callbacks = allCallbacks[eventName] = [];
				}

				if (indexOf(callbacks, callback) === -1) {
					callbacks.push([callback, binding]);
				}
			}
		},

		off: function (eventNames, callback) {
			var allCallbacks = callbacksFor(this), callbacks, eventName, index;
			eventNames = eventNames.split(/\s+/);

			while (eventName = eventNames.shift()) {
				if (!callback) {
					allCallbacks[eventName] = [];
					continue;
				}

				callbacks = allCallbacks[eventName];

				index = indexOf(callbacks, callback);

				if (index !== -1) {
					callbacks.splice(index, 1);
				}
			}
		},

		trigger: function (eventName, options) {
			var allCallbacks = callbacksFor(this),
				callbacks, callbackTuple, callback, binding, event;

			if (callbacks = allCallbacks[eventName]) {
				for (var i = 0, l = callbacks.length; i < l; i++) {
					callbackTuple = callbacks[i];
					callback = callbackTuple[0];
					binding = callbackTuple[1];

					if (typeof options !== 'object') {
						options = { detail: options };
					}

					event = new Event(eventName, options);
					callback.call(binding, event);
				}
			}
		}
	};

	var Promise = function () {
		this.on('promise:resolved', function (event) {
			this.trigger('success', { detail: event.detail });
		}, this);

		this.on('promise:failed', function (event) {
			this.trigger('error', { detail: event.detail });
		}, this);
	};

	var noop = function () {
	};

	var invokeCallback = function (type, promise, callback, event) {
		var hasCallback = typeof callback === 'function',
			value, error, succeeded, failed;

		if (hasCallback) {
			try {
				value = callback(event.detail);
				succeeded = true;
			} catch (e) {
				failed = true;
				error = e;
			}
		} else {
			value = event.detail;
			succeeded = true;
		}

		if (value && typeof value.then === 'function') {
			value.then(function (value) {
				promise.resolve(value);
			}, function (error) {
				promise.reject(error);
			});
		} else if (hasCallback && succeeded) {
			promise.resolve(value);
		} else if (failed) {
			promise.reject(error);
		} else {
			promise[type](value);
		}
	};

	Promise.prototype = {
		then: function (done, fail) {
			var thenPromise = new Promise();

			if (this.isResolved) {
				config.async(function () {
					invokeCallback('resolve', thenPromise, done, { detail: this.resolvedValue });
				}, this);
			}

			if (this.isRejected) {
				config.async(function () {
					invokeCallback('reject', thenPromise, fail, { detail: this.rejectedValue });
				}, this);
			}

			this.on('promise:resolved', function (event) {
				invokeCallback('resolve', thenPromise, done, event);
			});

			this.on('promise:failed', function (event) {
				invokeCallback('reject', thenPromise, fail, event);
			});

			return thenPromise;
		},

		resolve: function (value) {
			resolve(this, value);

			this.resolve = noop;
			this.reject = noop;
		},

		reject: function (value) {
			reject(this, value);

			this.resolve = noop;
			this.reject = noop;
		}
	};

	function resolve(promise, value) {
		config.async(function () {
			promise.trigger('promise:resolved', { detail: value });
			promise.isResolved = true;
			promise.resolvedValue = value;
		});
	}

	function reject(promise, value) {
		config.async(function () {
			promise.trigger('promise:failed', { detail: value });
			promise.isRejected = true;
			promise.rejectedValue = value;
		});
	}

	function all(promises) {
		var i, results = [];
		var allPromise = new Promise();
		var remaining = promises.length;

		if (remaining === 0) {
			allPromise.resolve([]);
		}

		var resolve = function (index, value) {
			results[index] = value;
			if (--remaining === 0) {
				allPromise.resolve(results);
			}
		};

		var resolver = function (index) {
			return function (value) {
				resolve(index, value);
			};
		};

		var reject = function (error) {
			allPromise.reject(error);
		};

		for (i = 0; i < remaining; i++) {
			promises[i].then(resolver(i), reject);
		}
		return allPromise;
	}

	EventTarget.mixin(Promise.prototype);

	function configure(name, value) {
		config[name] = value;
	}

	module.exports = {
		Promise: Promise,
		Event: Event,
		EventTarget: EventTarget,
		all: all,
		configure: configure
	};

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(56)))

/***/ },
/* 56 */
/***/ function(module, exports) {

	// shim for using process in browser

	var process = module.exports = {};
	var queue = [];
	var draining = false;
	var currentQueue;
	var queueIndex = -1;

	function cleanUpNextTick() {
	    draining = false;
	    if (currentQueue.length) {
	        queue = currentQueue.concat(queue);
	    } else {
	        queueIndex = -1;
	    }
	    if (queue.length) {
	        drainQueue();
	    }
	}

	function drainQueue() {
	    if (draining) {
	        return;
	    }
	    var timeout = setTimeout(cleanUpNextTick);
	    draining = true;

	    var len = queue.length;
	    while(len) {
	        currentQueue = queue;
	        queue = [];
	        while (++queueIndex < len) {
	            if (currentQueue) {
	                currentQueue[queueIndex].run();
	            }
	        }
	        queueIndex = -1;
	        len = queue.length;
	    }
	    currentQueue = null;
	    draining = false;
	    clearTimeout(timeout);
	}

	process.nextTick = function (fun) {
	    var args = new Array(arguments.length - 1);
	    if (arguments.length > 1) {
	        for (var i = 1; i < arguments.length; i++) {
	            args[i - 1] = arguments[i];
	        }
	    }
	    queue.push(new Item(fun, args));
	    if (queue.length === 1 && !draining) {
	        setTimeout(drainQueue, 0);
	    }
	};

	// v8 likes predictible objects
	function Item(fun, array) {
	    this.fun = fun;
	    this.array = array;
	}
	Item.prototype.run = function () {
	    this.fun.apply(null, this.array);
	};
	process.title = 'browser';
	process.browser = true;
	process.env = {};
	process.argv = [];
	process.version = ''; // empty string to avoid regexp issues
	process.versions = {};

	function noop() {}

	process.on = noop;
	process.addListener = noop;
	process.once = noop;
	process.off = noop;
	process.removeListener = noop;
	process.removeAllListeners = noop;
	process.emit = noop;

	process.binding = function (name) {
	    throw new Error('process.binding is not supported');
	};

	process.cwd = function () { return '/' };
	process.chdir = function (dir) {
	    throw new Error('process.chdir is not supported');
	};
	process.umask = function() { return 0; };


/***/ },
/* 57 */
/***/ function(module, exports, __webpack_require__) {

	var Vector2 = __webpack_require__(19);
	var Vector3 = __webpack_require__(8);
	var MeshData = __webpack_require__(14);

	/**
	 * The TangentGenerator can generate and add a buffer with tangent information to a MeshData
	 */
	function TangentGenerator() {}

	/**
	 * Generates and adds a buffer with tangent information to a MeshData object
	 * @param {MeshData} meshData MeshData object to use for generating tangent coords
	 * @param {number} [uvUnit=0] Texture coord index to use as base for tangent generation
	 */
	TangentGenerator.addTangentBuffer = function (meshData, uvUnit) {
		uvUnit = uvUnit || 0;

		var vertexBuffer = meshData.getAttributeBuffer(MeshData.POSITION);
		if (!vertexBuffer) {
			return;
		}

		var normalBuffer = meshData.getAttributeBuffer(MeshData.NORMAL);
		if (!normalBuffer) {
			return;
		}

		var textureBuffer = meshData.getAttributeBuffer('TEXCOORD' + uvUnit);
		if (!textureBuffer && uvUnit !== 0) {
			textureBuffer = meshData.getAttributeBuffer(MeshData.TEXCOORD0);
		}
		if (!textureBuffer) {
			return;
		}

		var indexBuffer = meshData.getIndexBuffer();
		if (!indexBuffer) {
			return;
		}

		var vertexCount = meshData.vertexCount;
		var triangleCount = meshData.indexCount / 3; // TODO: Handle other primitives than triangles

		var tan1 = [];
		var tan2 = [];
		for (var i = 0; i < vertexCount; i++) {
			tan1[i] = new Vector3();
			tan2[i] = new Vector3();
		}

		function getVector2Array(buf) {
			var arr = [];
			for (var i = 0; i < buf.length; i += 2) {
				arr.push(new Vector2(buf[i + 0], buf[i + 1]));
			}
			return arr;
		}

		function getVector3Array(buf) {
			var arr = [];
			for (var i = 0; i < buf.length; i += 3) {
				arr.push(new Vector3(buf[i + 0], buf[i + 1], buf[i + 2]));
			}
			return arr;
		}

		var vertex = getVector3Array(vertexBuffer);
		var normal = getVector3Array(normalBuffer);
		var texcoord = getVector2Array(textureBuffer);

		for (var a = 0; a < triangleCount; a++) {
			var i1 = indexBuffer[a * 3];
			var i2 = indexBuffer[a * 3 + 1];
			var i3 = indexBuffer[a * 3 + 2];

			var v1 = vertex[i1];
			var v2 = vertex[i2];
			var v3 = vertex[i3];

			var w1 = texcoord[i1];
			var w2 = texcoord[i2];
			var w3 = texcoord[i3];

			var x1 = v2.x - v1.x;
			var x2 = v3.x - v1.x;
			var y1 = v2.y - v1.y;
			var y2 = v3.y - v1.y;
			var z1 = v2.z - v1.z;
			var z2 = v3.z - v1.z;

			var s1 = w2.x - w1.x;
			var s2 = w3.x - w1.x;
			var t1 = w2.y - w1.y;
			var t2 = w3.y - w1.y;

			var r = 1.0 / (s1 * t2 - s2 * t1);
			if (isFinite(r) === false) {
				continue;
			}
			var sdir = new Vector3((t2 * x1 - t1 * x2) * r, (t2 * y1 - t1 * y2) * r, (t2 * z1 - t1 * z2) * r);
			var tdir = new Vector3((s1 * x2 - s2 * x1) * r, (s1 * y2 - s2 * y1) * r, (s1 * z2 - s2 * z1) * r);

			tan1[i1].add(sdir);
			tan1[i2].add(sdir);
			tan1[i3].add(sdir);

			tan2[i1].add(tdir);
			tan2[i2].add(tdir);
			tan2[i3].add(tdir);
		}

		meshData.attributeMap[MeshData.TANGENT] = MeshData.createAttribute(4, 'Float');
		meshData.rebuildData(meshData.vertexCount, meshData.indexCount, true);
		var tangentBuffer = meshData.getAttributeBuffer(MeshData.TANGENT);

		var calc1 = new Vector3();
		var calc2 = new Vector3();
		for (var a = 0; a < vertexCount; a++) {
			var n = normal[a];
			var t = tan1[a];

			// Gram-Schmidt orthogonalize
			var dot = n.dot(t);
			calc1.copy(t).sub(calc2.copy(n).scale(dot)).normalize();
			tangentBuffer[a * 4 + 0] = calc1.x;
			tangentBuffer[a * 4 + 1] = calc1.y;
			tangentBuffer[a * 4 + 2] = calc1.z;

			// Calculate handedness
			dot = calc1.copy(n).cross(t).dot(tan2[a]);
			var w = dot < 0.0 ? -1.0 : 1.0;
			tangentBuffer[a * 4 + 3] = w;
		}

		return tangentBuffer;
	};

	module.exports = TangentGenerator;

/***/ },
/* 58 */,
/* 59 */,
/* 60 */,
/* 61 */,
/* 62 */,
/* 63 */,
/* 64 */,
/* 65 */,
/* 66 */,
/* 67 */,
/* 68 */,
/* 69 */,
/* 70 */,
/* 71 */,
/* 72 */,
/* 73 */,
/* 74 */,
/* 75 */,
/* 76 */,
/* 77 */,
/* 78 */,
/* 79 */,
/* 80 */,
/* 81 */,
/* 82 */,
/* 83 */,
/* 84 */,
/* 85 */
/***/ function(module, exports, __webpack_require__) {

	var RSVP = __webpack_require__(55);
	var PromiseUtils = __webpack_require__(54);

	/**
	 * Base class for resource handlers, used to load all types of resources into the engine.
	 * All the resource types in the bundle (noted by their extension) need to have a registered config
	 * handler.
	 * To handle a new type of component, create a class that inherits from this class, and override {update}.
	 * In your class, call <code>@_register('yourResourceExtension')</code> to _register
	 * the handler with the loader.
	 *
	 * @param {World} world The goo world
	 * @param {Function} getConfig The config loader function. See {DynamicLoader._loadRef}.
	 * @param {Function} updateObject The handler function. See {DynamicLoader.update}.
	 * @hidden
	 */
	function ConfigHandler(world, getConfig, updateObject, loadObject) {
		this.world = world;
		this.getConfig = getConfig;
		this.updateObject = updateObject;
		this.loadObject = loadObject;
		this._objects = new Map();
		this._loading = new Map();
	}

	/**
	 * Method for creating empty engine object for ref. Should be overwritten in subclasses.
	 * @returns {Object} the newly created Entity, Material or other engine object
	 * @private
	 */
	ConfigHandler.prototype._create = function () {
		return {};
	};

	/**
	 * Remove the engine object denoted by the given ref. Should be overridden in subclasses.
	 * This method is called by #{DynamicLoader} to remove resources from the engine.
	 * Synchronous, returns nothing.
	 * @param {string} ref
	 * @private
	 */
	ConfigHandler.prototype._remove = function (ref) {
		this._objects.delete(ref);
	};

	/**
	 * Preparing config by populating it with defaults. Should be overwritten in subclasses.
	 * @param {Object} config
	 * @private
	 */
	ConfigHandler.prototype._prepare = function (/*config*/) {};

	/**
	 * Loads object for given ref
	 * @param {string} ref
	 * @param {Object} options
	 * @private
	 */
	ConfigHandler.prototype._load = function (ref, options) {
		return this.loadObject(ref, options);
	};

	ConfigHandler.prototype.load = function (ref, options) {
		var type = ref.substr(ref.lastIndexOf('.') + 1);
		if (type !== this.constructor._type) {
			throw new Error('Trying to load type' + type + ' with handler for ' + this._type);
		}

		if (!options) {
			options = {};
		}

		if (this._loading.has(ref) && !(options.instantiate && ConfigHandler.getTypeForRef(ref) === 'machine')) {
			return this._loading.get(ref);
		} else if (this._objects.has(ref) && !options.reload) {
			return PromiseUtils.resolve(this._objects.get(ref));
		} else {
			var promise = this.getConfig(ref, options).then(function (config) {
				return this.update(ref, config, options);
			}.bind(this))
			.then(function (object) {
				this._loading.delete(ref);
				return object;
			}.bind(this))
			.then(null, function (err) {
				this._loading.delete(ref);
				throw err;
			}.bind(this));

			return promise;
		}
	};

	ConfigHandler.prototype.clear = function () {
		var promises = [];
		this._objects.forEach(function (value, ref) {
			promises.push(this.update(ref, null, {}));
		}.bind(this));

		this._objects.clear();
		this._loading.clear();

		return RSVP.all(promises);
	};

	/**
	 * Update engine object based on the config. Should be overridden in subclasses.
	 * This method is called by #{DynamicLoader} to load new resources into the engine.
	 *
	 * @param {string} ref The ref of this config
	 * @param {Object} config
	 * @returns {RSVP.Promise} promise that resolves with the created object when loading is done.
	 */
	ConfigHandler.prototype.update = function (ref, config, options) {
		var promise = this._update(ref, config, options).then(function (object) {
			this._loading.delete(ref);
			return object;
		}.bind(this));

		this._loading.set(ref, promise);

		return promise;
	};

	ConfigHandler.getTypeForRef = function (ref) {
		return ref.substr(ref.lastIndexOf('.') + 1).toLowerCase();
	};

	ConfigHandler.prototype._update = function (ref, config, options) {
		if (!config) {
			this._remove(ref, options);
			return PromiseUtils.resolve();
		}

		if (!options) {
			options = {};
		}

		if (!this._objects.has(ref) || (options.instantiate && ConfigHandler.getTypeForRef(ref) === 'machine')) {
			this._objects.set(ref, this._create());
		}
		this._prepare(config);
		return PromiseUtils.resolve(this._objects.get(ref));
	};

	ConfigHandler.handlerClasses = {};

	/**
	 * Get a handler class for the specified type of resource. The resource can be e.g. 'texture', 'mesh', etc.
	 * @param {string} type
	 * @returns {Class} A subclass of {ConfigHandler}, or null if no registered handler for the given type was found.
	 */
	ConfigHandler.getHandler = function (type) {
		return ConfigHandler.handlerClasses[type];
	};

	/**
	 * Register a handler for a component type. Called in the class body of subclasses.
	 * @param {string} type
	 * @param {Class} klass the class to register for this component type
	 */
	ConfigHandler._registerClass = function (type, klass) {
		klass._type = type;
		return ConfigHandler.handlerClasses[type] = klass;
	};

	module.exports = ConfigHandler;

/***/ },
/* 86 */
/***/ function(module, exports) {

	/**
	 * Utilities for arrays and typed arrays
	 */
	function ArrayUtils() {}

	/**
	 * Create a typed array view on an ArrayBuffer, using the supplied pointer. Notice that this
	 * does not copy any elements, if you make changes to the returned array, the original
	 * ArrayBuffer will be modified.
	 *
	 * @param {ArrayBuffer} arrayBuffer
	 * @param {Array} pointer Array [start, length, format] where start is the start byte offset
	 * in the buffer, length is the number of values of the given format, and format is a string
	 * denoting the data format:
	 * 'float32' creates a Float32Array
	 * 'uint32'
	 * 'uint16'
	 * 'uint8'
	 *
	 * @returns Typed array
	 */
	ArrayUtils.getTypedArray = function (arrayBuffer, pointer) {
		var start = pointer[0];
		var length = pointer[1];
		var format = pointer[2];

		if (format === 'float32') {
			return new Float32Array(arrayBuffer, start, length);
		}
		else if (format === 'uint8') {
			return new Uint8Array(arrayBuffer, start, length);
		}
		else if (format === 'uint16') {
			return new Uint16Array(arrayBuffer, start, length);
		}
		else if (format === 'uint32') {
			return new Uint32Array(arrayBuffer, start, length);
		}
		else {
			throw new Error('Binary format ' + format + ' is not supported');
		}
	};

	ArrayUtils.remove = function (array, value, equals) {
		var idx = -1;
		if (typeof equals === 'function') {
			for (var i = 0; i < array.length; i++) {
				if (equals(array[i], value)) {
					idx = i;
					break;
				}
			}
		}
		else {
			idx = array.indexOf(value);
		}
		if (idx > -1) {
			array.splice(idx, 1);
		}
	};

	/**
	 * Returns the first element in the supplied array for which the supplied predicate is true
	 * @param array
	 * @param predicate
	 * @returns {*}
	 */
	ArrayUtils.find = function (array, predicate) {
		for (var i = 0; i < array.length; i++) {
			if (predicate(array[i])) {
				return array[i];
			}
		}
		return null;
	};

	/**
	 * Returns an array of keys for the given Set or Map
	 * @param {(Set|Map)} collection
	 * @returns {Array}
	 */
	ArrayUtils.fromKeys = function (collection) {
		var array = [];

		collection.forEach(function (value, key) {
			array.push(key);
		});
	//		var iterator = collection.keys();
	//		var entry = iterator.next();
	//		while (!entry.done) {
	//			array.push(entry.value);
	//			entry = iterator.next();
	//		}
		return array;
	};

	/**
	 * Returns an array of values for the given Set or Map
	 * @param {(Set|Map)} collection
	 * @returns {Array}
	 */
	ArrayUtils.fromValues = function (collection) {
		var array = [];

		collection.forEach(function (value) {
			array.push(value);
		});
	//		var iterator = collection.values();
	//		var entry = iterator.next();
	//		while (!entry.done) {
	//			array.push(entry.value);
	//			entry = iterator.next();
	//		}
		return array;
	};

	module.exports = ArrayUtils;


/***/ },
/* 87 */,
/* 88 */
/***/ function(module, exports, __webpack_require__) {

	var PromiseUtils = __webpack_require__(54);

	/**
	 * Base class for component handlers. All different types of components that an entity
	 * can have need to have a registered component handler. To handle a new type of component,
	 * create a class that inherits from this class, and override {_prepare}, {_create}, {update} and {remove}
	 * as needed ({update} must be overridden). In your class, call <code>@_register('yourComponentType')</code> to _register
	 * the handler with the loader.
	 *
	 * @param {World} world The goo world
	 * @param {Function} getConfig The config loader function. See {DynamicLoader._loadRef}.
	 * @param {Function} updateObject The handler function. See {DynamicLoader.update}.
	 * @returns {ComponentHandler}
	 * @hidden
	 */
	function ComponentHandler(world, getConfig, updateObject, loadObject) {
		//! schteppe: this._type seem to be assumed to be set by the subclass. Why not pass it as a parameter to this constructor?
		this.world = world;
		this.getConfig = getConfig;
		this.updateObject = updateObject;
		this.loadObject = loadObject;
	}

	/**
	 * Prepare component. Set defaults on config here.
	 * @param {Object} config
	 * @private
	 */
	ComponentHandler.prototype._prepare = function (/*config*/) {};

	/**
	 * Create engine component object based on the config. Should be overridden in subclasses.
	 * @param {Entity} entity The entity on which this component should be added.
	 * @returns {Component} the created component object
	 * @private
	 * @abstract
	 */
	ComponentHandler.prototype._create = function () {
		throw new Error('ComponentHandler._create is abstract, use ComponentHandler.getHandler(type)');
	};

	/**
	 * Remove engine component object. Should be overridden in subclasses.
	 * @param {Entity} entity The entity from which this component should be removed.
	 * @private
	 */
	ComponentHandler.prototype._remove = function (entity) {
		entity.clearComponent(this._type);
	};

	/**
	 * Loads object for given ref
	 * @param {string} ref
	 * @param {Object} options
	 * @private
	 */
	ComponentHandler.prototype._load = function (ref, options) {
		return this.loadObject(ref, options);
	};

	/**
	 * Update engine component object based on the config. Should be overridden in subclasses.
	 * This method is called by #{EntityHandler} to load new component configs into the engine.
	 * @param {Entity} entity The entity on which this component should be added.
	 * @param {Object} config
	 * @param {Object} options
	 * @returns {RSVP.Promise} promise that resolves with the created component when loading is done.
	 */
	ComponentHandler.prototype.update = function (entity, config/*, options*/) {
		if (!entity) {
			return PromiseUtils.reject('Entity is missing');
		}
		if (!config) {
			this._remove(entity);
			return PromiseUtils.resolve();
		}
		var component = entity.getComponent(this._type);
		if (!component) {
			component = this._create();
			entity.setComponent(component);
		}
		this._prepare(config);

		return PromiseUtils.resolve(component);
	};


	ComponentHandler.handlerClasses = {};

	/**
	 * Get a handler class for the specified type of component. The type can be e.g. 'camera', 'transform', etc.
	 * The type name should not end with "Component".
	 * @param {string} type
	 * @returns {Class} A subclass of {ComponentHandler}, or null if no registered handler for the given type was found.
	 */
	ComponentHandler.getHandler = function (type) {
		return ComponentHandler.handlerClasses[type];
	};

	/**
	 * Register a handler for a component type. Called in the class body of subclasses.
	 * @param {string} type
	 * @param {Class} klass the class to register for this component type
	 */
	ComponentHandler._registerClass = function (type, klass) {
		ComponentHandler.handlerClasses[type] = klass;
	};

	module.exports = ComponentHandler;


/***/ },
/* 89 */,
/* 90 */,
/* 91 */,
/* 92 */,
/* 93 */,
/* 94 */,
/* 95 */,
/* 96 */,
/* 97 */,
/* 98 */,
/* 99 */
/***/ function(module, exports, __webpack_require__) {

	var ObjectUtils = __webpack_require__(6);

	/**
	 * Object-related utilities
	 * @target-class ObjectUtil ObjectUtil constructor
	 * @require-pathvar ObjectUtil = require('../util/ObjectUtil');
	 * @group util
	 * @deprecated Deprecated as of 0.14.x and scheduled for removal in 0.16.0; The class has been renamed to `goo/util/ObjectUtils`
	 */
	module.exports = ObjectUtils;

/***/ },
/* 100 */,
/* 101 */,
/* 102 */,
/* 103 */,
/* 104 */,
/* 105 */,
/* 106 */,
/* 107 */,
/* 108 */,
/* 109 */,
/* 110 */,
/* 111 */,
/* 112 */
/***/ function(module, exports, __webpack_require__) {

	var MeshData = __webpack_require__(14);
	var Capabilities = __webpack_require__(17);
	var Vector3 = __webpack_require__(8);

	/**
	 * Combines the MeshData of passed-in entities into one new MeshData. This can be useful to reduce draw calls.
	 * Combination is currently limited to 65536 vertices.
	 * Keep in mind that combined MeshData can only use one diffuse color texture, so this is best suited for MeshData that can share the same texture.
	 * @example
	 * var meshBuilder = new MeshBuilder();
	 * var transform = new Transform();
	 *
	 * var box1 = new Box(0.3, 1, 1.6);
	 * var box2 = new Box(0.2, 0.15, 0.7);
	 *
	 * transform.translation.setDirect(0, 0, 1.3);
	 * transform.update();
	 * meshBuilder.addMeshData(box1, transform);
	 *
	 * transform.translation.setDirect(0, 0, 0);
	 * transform.update();
	 * meshBuilder.addMeshData(box2, transform);
	 *
	 * var meshData = meshBuilder.build()[0];
	 * goo.world.createEntity( meshData, new Material(ShaderLib.simpleLit)).addToWorld();

	 */
	function MeshBuilder() {
		this.meshDatas = [];

		this.vertexData = {};
		this.indexData = [];
		this.vertexCounter = 0;
		this.indexCounter = 0;

		this.indexLengths = [];
		this.indexModes = [];
	}

	/**
	 * add the MeshData of an entity to this MeshBuilder
	 * @param {Entity} entity
	 */
	MeshBuilder.prototype.addEntity = function (entity) {
		var that = this;
		entity.traverse(function (entity) {
			if (entity.meshDataComponent) {
				that.addMeshData(entity.meshDataComponent.meshData, entity.transformComponent.sync().worldTransform);
			}
		});
	};

	// var normalMatrix = new Matrix3();
	var vert = new Vector3();
	/**
	 * add MeshData to this MeshBuilder
	 * @param {MeshData} meshData
	 */
	MeshBuilder.prototype.addMeshData = function (meshData, transform) {
		if (!Capabilities.ElementIndexUInt) {
			if (meshData.vertexCount >= 65536) {
				throw new Error('Maximum number of vertices for a mesh to add is 65535. Got: ' + meshData.vertexCount);
			} else if (this.vertexCounter + meshData.vertexCount >= 65536) {
				this._generateMesh();
			}
		}

		var matrix = transform.matrix;
		var rotation = transform.rotation;
		// Matrix3.invert(transform.rotation, normalMatrix);
		// Matrix3.transpose(normalMatrix, normalMatrix);

		var attributeMap = meshData.attributeMap;
		var keys = Object.keys(attributeMap);

		for (var ii = 0, l = keys.length; ii < l; ii++) {
			var key = keys[ii];
			var map = attributeMap[key];
			var attribute = this.vertexData[key];
			if (!attribute) {
				this.vertexData[key] = {};
				attribute = this.vertexData[key];
				attribute.array = [];
				attribute.map = {
					count: map.count,
					type: map.type,
					stride: map.stride,
					offset: map.offset,
					normalized: map.normalized
				};
			}

			var view = meshData.getAttributeBuffer(key);

			var viewLength = view.length;
			var array = attribute.array;
			var count = map.count;
			var vertexPos = this.vertexCounter * count;
			if (key === MeshData.POSITION) {
				for (var i = 0; i < viewLength; i += count) {
					vert.setDirect(view[i + 0], view[i + 1], view[i + 2]);
					vert.applyPostPoint(matrix);
					array[vertexPos + i + 0] = vert.x;
					array[vertexPos + i + 1] = vert.y;
					array[vertexPos + i + 2] = vert.z;
				}
			} else if (key === MeshData.NORMAL) {
				for (var i = 0; i < viewLength; i += count) {
					vert.setDirect(view[i + 0], view[i + 1], view[i + 2]);
					vert.applyPost(rotation);
					array[vertexPos + i + 0] = vert.x;
					array[vertexPos + i + 1] = vert.y;
					array[vertexPos + i + 2] = vert.z;
				}
			} else if (key === MeshData.TANGENT) {
				for (var i = 0; i < viewLength; i += count) {
					vert.setDirect(view[i + 0], view[i + 1], view[i + 2]);
					vert.applyPost(rotation);
					array[vertexPos + i + 0] = vert.x;
					array[vertexPos + i + 1] = vert.y;
					array[vertexPos + i + 2] = vert.z;
					array[vertexPos + i + 3] = view[i + 3];
				}
			} else {
				for (var i = 0; i < viewLength; i++) {
					array[vertexPos + i] = view[i];
				}
			}
		}
		var indices = meshData.getIndexBuffer();
		for (var i = 0, l = meshData.indexCount; i < l; i++) {
			this.indexData[this.indexCounter + i] = indices[i] + this.vertexCounter;
		}
		this.vertexCounter += meshData.vertexCount;
		this.indexCounter += meshData.indexCount;

		if (meshData.indexLengths) {
			this.indexLengths = this.indexLengths.concat(meshData.indexLengths);
		} else {
			this.indexLengths = this.indexLengths.concat(meshData.getIndexBuffer().length);
		}

		this.indexModes = this.indexModes.concat(meshData.indexModes);
	};

	MeshBuilder.prototype._generateMesh = function () {
		var attributeMap = {};
		for (var key in this.vertexData) {
			var data = this.vertexData[key];
			attributeMap[key] = data.map;
		}

		var meshData = new MeshData(attributeMap, this.vertexCounter, this.indexCounter);
		for (var key in this.vertexData) {
			var data = this.vertexData[key].array;
			meshData.getAttributeBuffer(key).set(data);
		}
		meshData.getIndexBuffer().set(this.indexData);

		meshData.indexLengths = this.indexLengths;
		meshData.indexModes = this.indexModes;

		// Diet down the index arrays
		var indexMode = meshData.indexModes[0];
		var indexCount = 0;
		var indexModes = [];
		var indexLengths = [];
		for (var i = 0; i < meshData.indexModes.length; i++) {
			var mode = meshData.indexModes[i];
			if (indexMode !== mode) {
				indexModes.push(indexMode);
				indexLengths.push(indexCount);
				indexMode = mode;
				indexCount = 0;
			}
			indexCount += meshData.indexLengths[i];
			if (i === meshData.indexModes.length - 1) {
				indexModes.push(mode);
				indexLengths.push(indexCount);
				indexMode = mode;
				indexCount = 0;
			}
		}
		meshData.indexLengths = indexLengths;
		meshData.indexModes = indexModes;

		this.meshDatas.push(meshData);

		this.vertexData = {};
		this.indexData = [];
		this.vertexCounter = 0;
		this.indexCounter = 0;
		this.indexLengths = [];
		this.indexModes = [];
	};

	/**
	 * build the unified MeshData from all the added MeshData so far and then reset in the internal state.
	 * @returns {Array<MeshData>} array of meshData, but currently there will only be one entry so you can always use [0].
	 * In the future we might create multiple entries if we hit the 65536 vertices limit instead of throwing an error.
	 */
	MeshBuilder.prototype.build = function () {
		if (this.vertexCounter > 0) {
			this._generateMesh();
		}

		return this.meshDatas;
	};

	/**
	 * reset in the internal state.
	 */
	MeshBuilder.prototype.reset = function () {
		this.meshDatas = [];

		this.vertexData = {};
		this.indexData = [];
		this.vertexCounter = 0;
		this.indexCounter = 0;

		this.indexLengths = [];
		this.indexModes = [];
	};

	module.exports = MeshBuilder;

/***/ },
/* 113 */,
/* 114 */,
/* 115 */,
/* 116 */,
/* 117 */
/***/ function(module, exports, __webpack_require__) {

	var MeshData = __webpack_require__(14);
	var Vector3 = __webpack_require__(8);
	var ObjectUtils = __webpack_require__(6);

	/**
	 * A 3D object representing a cylinder.
	 * @extends MeshData
	 * @param {number} [radialSamples=8] Number of slices
	 * @param {number} [radiusTop=0.5] Radius of the cylinder at the top.
	 * @param {number} [radiusBottom=radiusTop] Radius of the cylinder at the bottom. Defaults to radiusTop.
	 * @param {number} [height=1] Height
	 */
	function Cylinder(radialSamples, radiusTop, radiusBottom, height) {
		if (arguments.length === 1 && arguments[0] instanceof Object) {
			var props = arguments[0];
			radialSamples = props.radialSamples;
			radiusTop = props.radiusTop;
			radiusBottom = props.radiusBottom;
			height = props.height;
		}
		this.radialSamples = radialSamples || 8;
		this.radiusTop = typeof radiusTop === 'undefined' ? 0.5 : radiusTop;
		this.radiusBottom = typeof radiusBottom === 'undefined' ? this.radiusTop : radiusBottom;
		this.height = typeof height === 'undefined' ? 1 : height;

		var attributeMap = MeshData.defaultMap([MeshData.POSITION, MeshData.NORMAL, MeshData.TEXCOORD0]);
		MeshData.call(this, attributeMap, this.radialSamples * 4 + 2 + 2, (this.radialSamples * 3) * 4);

		// could be done better with 2 triangle fans and a triangle strip
		this.indexModes = ['Triangles'];

		this.rebuild();
	}

	Cylinder.prototype = Object.create(MeshData.prototype);
	Cylinder.prototype.constructor = Cylinder;

	/**
	 * Builds or rebuilds the mesh data.
	 * @returns {Cylinder} Self for chaining.
	 */
	Cylinder.prototype.rebuild = function () {
		var verts = [];
		var norms = [];
		var tex = [];
		var indices = [];
		var height = this.height;
		var halfHeight = height / 2;
		var radiusTop = this.radiusTop;
		var radiusBottom = this.radiusBottom;
		var radialSamples = this.radialSamples;

		var ak = Math.PI * 2 / radialSamples;
		var at = 1 / radialSamples;

		var lastIndex = radialSamples * 4 + 2 + 2 - 1;
		var normal = new Vector3();

		var tan = 0;
		if (height) {
			tan = Math.tan((radiusBottom - radiusTop) / height);
		}

		for (var i = 0, k = 0, t = 0; i < radialSamples; i++, k += ak, t += at) {
			var cos = Math.cos(k);
			var sin = Math.sin(k);
			var xTop = cos * radiusTop;
			var yTop = sin * radiusTop;
			var xBottom = cos * radiusBottom;
			var yBottom = sin * radiusBottom;

			verts.push(
				xTop, yTop, halfHeight, // disk top
				xBottom, yBottom, -halfHeight, // disk bottom
				xTop, yTop, halfHeight,  // side top
				xBottom, yBottom, -halfHeight  // side bottom
			);

			normal.setDirect(cos, sin, tan);
			normal.normalize();

			norms.push(
				0, 0, 1,
				0, 0, -1,
				normal.x, normal.y, normal.z,
				normal.x, normal.y, normal.z
				//cos, sin, 0,
				//cos, sin, 0
			);

			tex.push(
				cos / 4 + 0.25, sin / 4 + 0.75,
				cos / 4 + 0.25, sin / 4 + 0.25,
				0.5, t,
				1.0, t
			);
		}

		verts.push(
			radiusTop, 0.0, halfHeight,
			radiusBottom, 0.0, -halfHeight
		);

		norms.push(
			1.0, 0.0, 0.0,
			1.0, 0.0, 0.0
		);

		tex.push(
			0.5, 1.0,
			1.0, 1.0
		);

		for (var i = 0; i < radialSamples - 1; i++) {
			indices.push(
				lastIndex, i * 4 + 0, i * 4 + 4,
				i * 4 + 1, lastIndex - 1, i * 4 + 5,
				i * 4 + 4 + 2, i * 4 + 2, i * 4 + 4 + 3,
				i * 4 + 2, i * 4 + 3, i * 4 + 4 + 3
			);
		}

		indices.push(
			lastIndex, i * 4 + 0, 0,
			i * 4 + 1, lastIndex - 1, 0 + 1,
			i * 4 + 4, i * 4 + 2, i * 4 + 5,
			i * 4 + 2, i * 4 + 3, i * 4 + 5
		);

		verts.push(
			0, 0, -halfHeight,
			0, 0, halfHeight
		);

		norms.push(
			0, 0, -0.5,
			0, 0, 0.5
		);

		tex.push(
			0.25, 0.25,
			0.25, 0.75
		);

		this.getAttributeBuffer(MeshData.POSITION).set(verts);
		this.getAttributeBuffer(MeshData.NORMAL).set(norms);
		this.getAttributeBuffer(MeshData.TEXCOORD0).set(tex);
		this.getIndexBuffer().set(indices);

		return this;
	};

	/**
	 * Returns a clone of this cylinder
	 * @returns {Cylinder}
	 */
	Cylinder.prototype.clone = function () {
		var options = ObjectUtils.shallowSelectiveClone(this, ['radialSamples', 'radiusTop', 'radiusBottom', 'height']);

		return new Cylinder(options);
	};

	module.exports = Cylinder;

/***/ },
/* 118 */,
/* 119 */,
/* 120 */
/***/ function(module, exports, __webpack_require__) {

	var Vector2 = __webpack_require__(19);
	var Vector3 = __webpack_require__(8);
	var Vector4 = __webpack_require__(11);
	var Matrix4 = __webpack_require__(33);
	var Plane = __webpack_require__(121);
	var MathUtils = __webpack_require__(9);
	var Ray = __webpack_require__(122);
	var BoundingBox = __webpack_require__(7);
	var BoundingSphere = __webpack_require__(13);
	var BoundingVolume = __webpack_require__(12);

	/**
	 * This class represents a view into a 3D scene and how that view should map to a 2D rendering surface.
	 * @param {number} [fov=45] The full vertical angle of view, in degrees.
	 * @param {number} [aspect=1] Aspect ratio of the 3D canvas used.
	 * @param {number} [near=1] Near plane clip distance.
	 * @param {number} [far=1000] Far plane clip distance.
	 */

	function Camera(fov, aspect, near, far) {
		fov = typeof fov !== 'undefined' ? fov : 45;
		aspect = typeof aspect !== 'undefined' ? aspect : 1;
		near = typeof near !== 'undefined' ? near : 1;
		far = typeof far !== 'undefined' ? far : 1000;

		// These need an onFrameChange() after being modified
		this.translation = new Vector3(0, 0, 0);
		this._left = new Vector3(-1, 0, 0);
		this._up = new Vector3(0, 1, 0);
		this._direction = new Vector3(0, 0, -1);

		// These need an onFrustumChange() after being modified
		this.size = 0.5; // hack
		this._frustumNear = this.near = 1.0;
		this._frustumFar = this.far = 2.0;
		this._frustumLeft = this.left = -0.5;
		this._frustumRight = this.right = 0.5;
		this._frustumTop = this.top = 0.5;
		this._frustumBottom = this.bottom = -0.5;

		// Used to speed up world-plane normal calculation in onFrameChange. Only calculated when frustum values are changed
		this._coeffLeft = new Vector2();
		this._coeffRight = new Vector2();
		this._coeffBottom = new Vector2();
		this._coeffTop = new Vector2();

		// These need an onViewPortChange() after being modified
		this._viewPortLeft = 0.0;
		this._viewPortRight = 1.0;
		this._viewPortTop = 1.0;
		this._viewPortBottom = 0.0;

		this._worldPlane = [];
		for (var i = 0; i < Camera.FRUSTUM_PLANES; i++) {
			this._worldPlane[i] = new Plane();
		}

		this.projectionMode = Camera.Perspective;
		this.lockedRatio = false;
		this.aspect = aspect;

		this._updateMVMatrix = true;
		this._updateInverseMVMatrix = true;
		this._updatePMatrix = true;
		this._updateMVPMatrix = true;
		this._updateInverseMVPMatrix = true;

		// NB: These matrices are column-major.
		this.modelView = new Matrix4();
		this.modelViewInverse = new Matrix4();
		this.projection = new Matrix4();
		this.modelViewProjection = new Matrix4();
		this.modelViewProjectionInverse = new Matrix4();

		//! AT: unused?
		this._planeState = 0;
		this._clipPlane = new Vector4();
		this._qCalc = new Vector4();

		this._corners = [];
		for (var i = 0; i < 8; i++) {
			this._corners.push(new Vector3());
		}
		this._extents = new Vector3();

		// Temp decl
		this.vNearPlaneCenter = new Vector3();
		this.vFarPlaneCenter = new Vector3();

		this.calcLeft = new Vector3();
		this.calcUp = new Vector3();

		this.changedProperties = true;

		this.setFrustumPerspective(fov, aspect, near, far);
		this.onFrameChange();

		// @ifdef DEBUG
		Object.seal(this);
		// @endif
	}

	var newDirection = new Vector3(); // tmp

	// Planes of the frustum
	Camera.LEFT_PLANE = 0;
	Camera.RIGHT_PLANE = 1;
	Camera.BOTTOM_PLANE = 2;
	Camera.TOP_PLANE = 3;
	Camera.FAR_PLANE = 4;
	Camera.NEAR_PLANE = 5;
	Camera.FRUSTUM_PLANES = 6;

	//! schteppe: Why not capital letters for the following?

	/**
	 * Projection mode for perspective frustum
	 */
	Camera.Perspective = 0;
	/**
	 * Projection mode for parallel/ortographic frustum
	 */
	Camera.Parallel = 1;
	Camera.Custom = 2;

	/**
	 * Intersection response from camera.intersect
	 */
	Camera.Outside = 0;
	/**
	 * Intersection response from camera.intersect
	 */
	Camera.Inside = 1;
	/**
	 * Intersection response from camera.intersect
	 */
	Camera.Intersects = 2;

	/**
	 * Ensure our up, left and direction are unit-length vectors.
	 */
	Camera.prototype.normalize = function () {
		this._left.normalize();
		this._up.normalize();
		this._direction.normalize();
		this.onFrameChange();
	};

	/**
	 * Sets the projection mode of the camera. (Camera.Perspective / Camera.Parallel)
	 *
	 * @param {ProjectionMode} projectionMode The new projection mode - Camera.Perspective or Camera.Parallel
	 */
	Camera.prototype.setProjectionMode = function (projectionMode) {
		this.projectionMode = projectionMode;
		this.update();
	};

	/**
	 * Sets the frustum plane values of this camera using the given perspective values.
	 *
	 * @param {number} fov The full angle of view on the Y axis, in degrees.
	 * @param {number} aspect The aspect ratio of our view (generally in [0, 1]). Often this is canvas width / canvas height.
	 * @param {number} near Near plane value
	 * @param {number} far Far plane value
	 */
	Camera.prototype.setFrustumPerspective = function (fov, aspect, near, far) {
		if (fov !== undefined && fov !== null) {
			this.fov = fov;
		}
		if (aspect !== undefined && aspect !== null) {
			this.aspect = aspect;
		}
		if (near !== undefined && near !== null) {
			this.near = near;
		}
		if (far !== undefined && far !== null) {
			this.far = far;
		}

		if (this.fov !== undefined) {
			var h = Math.tan(this.fov * MathUtils.DEG_TO_RAD * 0.5) * this.near;
			var w = h * this.aspect;
			this._frustumLeft = -w;
			this._frustumRight = w;
			this._frustumBottom = -h;
			this._frustumTop = h;
			this._frustumNear = this.near;
			this._frustumFar = this.far;

			// handle invalid frustum-far
			if (this._frustumFar - this._frustumNear < MathUtils.EPSILON) {
				this._frustumFar = this._frustumNear + MathUtils.EPSILON;
			}

			this.onFrustumChange();
		}
	};

	/**
	 * Sets the frustum plane values of this camera using the given values.
	 *
	 * @param {number} near
	 * @param {number} far
	 * @param {number} left
	 * @param {number} right
	 * @param {number} top
	 * @param {number} bottom
	 */
	Camera.prototype.setFrustum = function (near, far, left, right, top, bottom, aspect) {
		if (near !== undefined && near !== null) {
			this.near = near;
		}
		if (far !== undefined && far !== null) {
			this.far = far;
		}

		if (left !== undefined && left !== null) {
			this.left = left;
		}
		if (right !== undefined && right !== null) {
			this.right = right;
		}
		if (top !== undefined && top !== null) {
			this.top = top;
		}
		if (bottom !== undefined && bottom !== null) {
			this.bottom = bottom;
		}
		if (aspect !== undefined && aspect !== null) {
			this.aspect = aspect;
		}

		this._frustumNear = this.near;
		this._frustumFar = this.far;
		this._frustumLeft = this.left * this.aspect;
		this._frustumRight = this.right * this.aspect;
		this._frustumTop = this.top;
		this._frustumBottom = this.bottom;

		// handle invalid frustum-far
		if (this._frustumFar - this._frustumNear < MathUtils.EPSILON) {
			this._frustumFar = this._frustumNear + MathUtils.EPSILON;
		}

		this.onFrustumChange();
	};

	/**
	 * Copy the settings of a source camera to this camera.
	 *
	 * @param {Camera} source
	 */
	Camera.prototype.copy = function (source) {
		this.translation.set(source.translation);
		this._left.set(source._left);
		this._up.set(source._up);
		this._direction.set(source._direction);

		this.fov = source.fov;
		this.aspect = source.aspect;

		this.near = source.near;
		this.far = source.far;
		this.left = source.left;
		this.right = source.right;
		this.top = source.top;
		this.bottom = source.bottom;

		this._frustumLeft = source._frustumLeft;
		this._frustumRight = source._frustumRight;
		this._frustumBottom = source._frustumBottom;
		this._frustumTop = source._frustumTop;
		this._frustumNear = source._frustumNear;
		this._frustumFar = source._frustumFar;

		this.projectionMode = source.projectionMode;

		this.onFrustumChange();
		this.onFrameChange();

		return this;
	};

	/**
	 * Sets the location and the left, up and direction axes of the camera.
	 *
	 * @param {Vector3} location
	 * @param {Vector3} left
	 * @param {Vector3} up
	 * @param {Vector3} direction
	 */
	Camera.prototype.setFrame = function (location, left, up, direction) {
		this._left.set(left);
		this._up.set(up);
		this._direction.set(direction);
		this.translation.set(location);

		this.onFrameChange();
	};

	/**
	 * A convenience method for auto-setting the frame based on a world position the user desires the camera to look at. It points the camera towards
	 * the given position using the difference between that position and the current camera location as a direction vector and the general
	 * worldUpVector to compute up and left camera vectors.
	 *
	 * @param {Vector3} pos Where to look at in terms of world coordinates.
	 * @param {Vector3} worldUpVector A vector indicating the up direction of the world. (often Vector3.UNIT_Y or Vector3.UNIT_Z).
	 */
	Camera.prototype.lookAt = function (pos, worldUpVector) {
		newDirection.set(pos).sub(this.translation).normalize();

		// check to see if we haven't really updated camera -- no need to call
		// sets.
		if (newDirection.equals(this._direction)) {
			return;
		}
		this._direction.set(newDirection);

		this._up.set(worldUpVector).normalize();
		if (this._up.equals(Vector3.ZERO)) {
			this._up.set(Vector3.UNIT_Y);
		}
		this._left.set(this._up).cross(this._direction).normalize();
		if (this._left.equals(Vector3.ZERO)) {
			if (this._direction.x !== 0.0) {
				this._left.setDirect(this._direction.y, -this._direction.x, 0);
			} else {
				this._left.setDirect(0, this._direction.z, -this._direction.y);
			}
		}
		this._up.set(this._direction).cross(this._left).normalize();

		this.onFrameChange();
	};

	/**
	 * Forces all aspect of the camera to be updated from internal values, and sets all dirty flags to true so that the next apply() call will fully
	 * set this camera to the render context.
	 */
	Camera.prototype.update = function () {
		this.onFrustumChange();
		this.onFrameChange();
	};

	/**
	 * Checks a bounding volume against the planes of this camera's frustum and returns if it is completely inside of, outside of, or intersecting.
	 * Example returns are Camera.Inside, Camera.Outside or Camera.Intersects.
	 *
	 * @param {BoundingVolume} bound The BoundingVolume to check for culling.
	 * @returns {number} Intersection type.
	 */
	Camera.prototype.contains = function (bound) {
		if (!bound) {
			return Camera.Inside;
		}

		var rVal = Camera.Inside;

		for (var planeCounter = Camera.FRUSTUM_PLANES - 1; planeCounter >= 0; planeCounter--) {
			switch (bound.whichSide(this._worldPlane[planeCounter])) {
				case BoundingVolume.Inside:
					return Camera.Outside;
				case BoundingVolume.Outside:
					break;
				case BoundingVolume.Intersects:
					rVal = Camera.Intersects;
					break;
			}
		}

		return rVal;
	};

	/**
	 * Updates internal frustum coefficient values to reflect the current frustum plane values.
	 * This is an optimization to move normalization/rotation of plane normals out to be done
	 * only when the frustum values change.
	 */
	Camera.prototype.onFrustumChange = function () {
		if (this.projectionMode === Camera.Perspective) {
			this._coeffLeft.setDirect(-this._frustumNear, -this._frustumLeft).normalize();
			this._coeffRight.setDirect(this._frustumNear, this._frustumRight).normalize();
			this._coeffBottom.setDirect(this._frustumNear, -this._frustumBottom).normalize();
			this._coeffTop.setDirect(-this._frustumNear, this._frustumTop).normalize();
		} else if (this.projectionMode === Camera.Parallel) {
			if (this._frustumRight > this._frustumLeft) {
				this._coeffLeft.setDirect(-1, 0);
				this._coeffRight.setDirect(1, 0);
			} else {
				this._coeffLeft.setDirect(1, 0);
				this._coeffRight.setDirect(-1, 0);
			}

			if (this._frustumTop > this._frustumBottom) {
				this._coeffBottom.setDirect(-1, 0);
				this._coeffTop.setDirect(1, 0);
			} else {
				this._coeffBottom.setDirect(1, 0);
				this._coeffTop.setDirect(-1, 0);
			}
		}

		this._updatePMatrix = true;
		this._updateMVPMatrix = true;
		this._updateInverseMVMatrix = true;
		this._updateInverseMVPMatrix = true;

		this.changedProperties = true;
	};

	/**
	 * Updates the values of the world planes associated with this camera.
	 */
	Camera.prototype.onFrameChange = function () {
		var plane;

		// left plane
		plane = this._worldPlane[Camera.LEFT_PLANE];

		plane.normal.x = this._left.x * this._coeffLeft.x + this._direction.x * this._coeffLeft.y;
		plane.normal.y = this._left.y * this._coeffLeft.x + this._direction.y * this._coeffLeft.y;
		plane.normal.z = this._left.z * this._coeffLeft.x + this._direction.z * this._coeffLeft.y;
		plane.constant = this.translation.dot(plane.normal);

		// right plane
		plane = this._worldPlane[Camera.RIGHT_PLANE];
		plane.normal.x = this._left.x * this._coeffRight.x + this._direction.x * this._coeffRight.y;
		plane.normal.y = this._left.y * this._coeffRight.x + this._direction.y * this._coeffRight.y;
		plane.normal.z = this._left.z * this._coeffRight.x + this._direction.z * this._coeffRight.y;
		plane.constant = this.translation.dot(plane.normal);

		// bottom plane
		plane = this._worldPlane[Camera.BOTTOM_PLANE];
		plane.normal.x = this._up.x * this._coeffBottom.x + this._direction.x * this._coeffBottom.y;
		plane.normal.y = this._up.y * this._coeffBottom.x + this._direction.y * this._coeffBottom.y;
		plane.normal.z = this._up.z * this._coeffBottom.x + this._direction.z * this._coeffBottom.y;
		plane.constant = this.translation.dot(plane.normal);

		// top plane
		plane = this._worldPlane[Camera.TOP_PLANE];
		plane.normal.x = this._up.x * this._coeffTop.x + this._direction.x * this._coeffTop.y;
		plane.normal.y = this._up.y * this._coeffTop.x + this._direction.y * this._coeffTop.y;
		plane.normal.z = this._up.z * this._coeffTop.x + this._direction.z * this._coeffTop.y;
		plane.constant = this.translation.dot(plane.normal);

		if (this.projectionMode === Camera.Parallel) {
			if (this._frustumRight > this._frustumLeft) {
				this._worldPlane[Camera.LEFT_PLANE].constant += this._frustumLeft;
				this._worldPlane[Camera.RIGHT_PLANE].constant -= this._frustumRight;
			} else {
				this._worldPlane[Camera.LEFT_PLANE].constant -= this._frustumLeft;
				this._worldPlane[Camera.RIGHT_PLANE].constant += this._frustumRight;
			}

			if (this._frustumBottom > this._frustumTop) {
				this._worldPlane[Camera.TOP_PLANE].constant += this._frustumTop;
				this._worldPlane[Camera.BOTTOM_PLANE].constant -= this._frustumBottom;
			} else {
				this._worldPlane[Camera.TOP_PLANE].constant -= this._frustumTop;
				this._worldPlane[Camera.BOTTOM_PLANE].constant += this._frustumBottom;
			}
		}

		var dirDotLocation = this._direction.dot(this.translation);

		// far plane
		plane = this._worldPlane[Camera.FAR_PLANE];
		plane.normal.x = -this._direction.x;
		plane.normal.y = -this._direction.y;
		plane.normal.z = -this._direction.z;
		plane.constant = -(dirDotLocation + this._frustumFar);

		// near plane
		plane = this._worldPlane[Camera.NEAR_PLANE];
		plane.normal.x = this._direction.x;
		plane.normal.y = this._direction.y;
		plane.normal.z = this._direction.z;
		plane.constant = dirDotLocation + this._frustumNear;

		this._updateMVMatrix = true;
		this._updateMVPMatrix = true;
		this._updateInverseMVMatrix = true;
		this._updateInverseMVPMatrix = true;
	};

	/**
	 * Updates the value of our projection matrix.
	 */
	Camera.prototype.updateProjectionMatrix = function () {
		var d = this.projection.data;
		var right = this._frustumRight;
		var left = this._frustumLeft;
		var top = this._frustumTop;
		var bottom = this._frustumBottom;
		var far = this._frustumFar;
		var near = this._frustumNear;

		if (this.projectionMode === Camera.Parallel) {

			d[0] = 2.0 / (right - left);
			d[1] = 0.0;
			d[2] = 0.0;
			d[3] = 0.0;
			d[4] = 0.0;
			d[5] = 2.0 / (top - bottom);
			d[6] = 0.0;
			d[7] = 0.0;
			d[8] = 0.0;
			d[9] = 0.0;
			d[10] = -2.0 / (far - near);
			d[11] = 0.0;
			d[12] = -(right + left) / (right - left);
			d[13] = -(top + bottom) / (top - bottom);
			d[14] = -(far + near) / (far - near);
			d[15] = 1.0;

		} else if (this.projectionMode === Camera.Perspective) {

			d[0] = 2.0 * near / (right - left);
			d[1] = 0.0;
			d[2] = 0.0;
			d[3] = 0.0;
			d[4] = 0.0;
			d[5] = 2.0 * near / (top - bottom);
			d[6] = 0.0;
			d[7] = 0.0;
			d[8] = (right + left) / (right - left);
			d[9] = (top + bottom) / (top - bottom);
			d[10] = -(far + near) / (far - near);
			d[11] = -1.0;
			d[12] = 0.0;
			d[13] = 0.0;
			d[14] = -(2.0 * far * near) / (far - near);
			d[15] = 0.0;

		}
	};

	/**
	 * Updates the value of our model view matrix.
	 */
	Camera.prototype.updateModelViewMatrix = function () {
		this.modelView.setIdentity();

		var d = this.modelView.data;

		d[0] = -this._left.x;
		d[4] = -this._left.y;
		d[8] = -this._left.z;

		d[1] = this._up.x;
		d[5] = this._up.y;
		d[9] = this._up.z;

		d[2] = -this._direction.x;
		d[6] = -this._direction.y;
		d[10] = -this._direction.z;

		d[12] = this._left.dot(this.translation);
		d[13] = -this._up.dot(this.translation);
		d[14] = this._direction.dot(this.translation);
	};

	/**
	 * Calculate a Pick Ray using the given screen position at the near plane of this camera and the camera's position in space.
	 *
	 * @param {number} screenX The screen x position.
	 * @param {number} screenY The screen y position.
	 * @param {number} screenWidth The screen width.
	 * @param {number} screenHeight The screen height.
	 * @param {Ray} [store] The Ray to store the result in. If null, a new Ray is created and returned.
	 * @returns {Ray} The resulting Ray.
	 */
	Camera.prototype.getPickRay = function (screenX, screenY, screenWidth, screenHeight, store) {
		if (!store) {
			store = new Ray();
		}
		this.getWorldCoordinates(screenX, screenY, screenWidth, screenHeight, 0, store.origin);
		this.getWorldCoordinates(screenX, screenY, screenWidth, screenHeight, 0.3, store.direction).sub(store.origin).normalize();
		return store;
	};

	/**
	 * Converts a local x, y screen position and depth value to world coordinates based on the current settings of this camera.
	 * This function calls getWorldCoordinates after converting zDepth to screen space.
	 *
	 * @param {number} screenX The screen x position.
	 * @param {number} screenY The screen y position.
	 * @param {number} screenWidth The screen width.
	 * @param {number} screenHeight The screen height.
	 * @param {number} zDepth The depth into the camera view in world distance.
	 * @param {Vector3} [store] Use to avoid object creation. if not null, the results are stored in the given vector and returned. Otherwise, a new vector is
	 *            created.
	 * @returns {Vector3} Vector containing the world coordinates.
	 */
	Camera.prototype.getWorldPosition = function (screenX, screenY, screenWidth, screenHeight, zDepth, store) {
		if (this.projectionMode === Camera.Parallel) {
			zDepth = ((zDepth - this.near) / (this.far - this.near));
		} else {
			// http://www.sjbaker.org/steve/omniv/love_your_z_buffer.html
			zDepth = MathUtils.clamp(zDepth, this.near, this.far);
			zDepth = (this.far / (this.far - this.near)) + ((this.far * this.near / (this.near - this.far)) / zDepth);
		}
		return this.getWorldCoordinates(screenX, screenY, screenWidth, screenHeight, zDepth, store);
	};

	/**
	 * Converts a local x, y screen position and depth value to world coordinates based on the current settings of this camera.
	 *
	 * @param {number} screenX The screen x position (x=0 is the leftmost coordinate of the screen).
	 * @param {number} screenY The screen y position (y=0 is the top of the screen).
	 * @param {number} screenWidth The screen width.
	 * @param {number} screenHeight The screen height.
	 * @param {number} zDepth The {@link http://www.sjbaker.org/steve/omniv/love_your_z_buffer.html non linear depth} between 0 and 1 into the camera view. 0 indicates the near plane of the camera and 1 indicates the far plane.
	 * @param {Vector3} [store] Use to avoid object creation. If not null, the results are stored in the given vector and returned. Otherwise, a new vector is
	 *            created.
	 * @returns {Vector3} Vector containing the world coordinates.
	 */
	Camera.prototype.getWorldCoordinates = function (screenX, screenY, screenWidth, screenHeight, zDepth, store) {
		if (!store) {
			store = new Vector3();
		}
		this.checkInverseModelViewProjection();
		var position = new Vector4();

		var x = (screenX / screenWidth - this._viewPortLeft) / (this._viewPortRight - this._viewPortLeft) * 2 - 1;
		var y = ((screenHeight - screenY) / screenHeight - this._viewPortBottom) / (this._viewPortTop - this._viewPortBottom) * 2 - 1;

		/*
		var aspect = this.aspect / (screenWidth / screenHeight);
		if (aspect > 1) {
			y *= aspect;
		} else if (aspect < 1) {
			x /= aspect;
		}
		*/

		position.setDirect(x, y, zDepth * 2 - 1, 1);
		position.applyPost(this.modelViewProjectionInverse);
		if (position.w !== 0.0) {
			position.scale(1.0 / position.w);
		}
		store.x = position.x;
		store.y = position.y;
		store.z = position.z;

		return store;
	};

	/**
	 * Converts a position in world coordinate space to an x, y screen position and non linear depth value using the current settings of this camera.
	 *
	 * @param {Vector3} worldPos The position in world space to retrieve screen coordinates for.
	 * @param {number} screenWidth The screen width.
	 * @param {number} screenHeight The screen height.
	 * @param {Vector3} [store] Use to avoid object creation. if not null, the results are stored in the given vector and returned. Otherwise, a new vector is
	 *            created.
	 * @returns {Vector3} Vector containing the screen coordinates as x and y and the distance as a non linear value between the near (0) and far (1) planes.
	 */
	Camera.prototype.getScreenCoordinates = function (worldPosition, screenWidth, screenHeight, store) {
		store = this.getNormalizedDeviceCoordinates(worldPosition, store);

		/*
		var aspect = this.aspect / (screenWidth / screenHeight);
		if (aspect > 1) {
			store.y /= aspect;
		} else if (aspect < 1) {
			store.x *= aspect;
		}
		*/

		store.x = (store.x + 1) * (this._viewPortRight - this._viewPortLeft) / 2 * screenWidth;
		store.y = (1 - store.y) * (this._viewPortTop - this._viewPortBottom) / 2 * screenHeight;
		store.z = (store.z + 1) / 2;

		return store;
	};

	/**
	 * Converts a position in world coordinate space to a x, y, z frustum position using the current settings of this camera.
	 *
	 * @param {Vector3} worldPos the position in space to retrieve frustum coordinates for.
	 * @param {Vector3} [store] Use to avoid object creation. if not null, the results are stored in the given vector and returned.
	 *        Otherwise, a new vector is created.
	 * @returns {Vector3} Vector containing the x, y and z frustum position.
	 */
	Camera.prototype.getFrustumCoordinates = function (worldPosition, store) {
		store = this.getNormalizedDeviceCoordinates(worldPosition, store);

		store.x = (store.x + 1) * (this._frustumRight - this._frustumLeft) / 2 + this._frustumLeft;
		store.y = (store.y + 1) * (this._frustumTop - this._frustumBottom) / 2 + this._frustumBottom;
		store.z = (store.z + 1) * (this._frustumFar - this._frustumNear) / 2 + this._frustumNear;

		return store;
	};

	/**
	 * Converts a position in world coordinate space to normalized device coordinates by applying the modelViewProjection from this camera.
	 *
	 * @param {Vector3} worldPos The position in space to retrieve coordinates for.
	 * @param {Vector3} [store] Use to avoid object creation. If not null, the results are stored in the given vector and returned.
	 *        Otherwise, a new vector is created.
	 * @returns {Vector3} Vector containing the x, y and z normalized device coordinates.
	 */
	Camera.prototype.getNormalizedDeviceCoordinates = function (worldPosition, store) {
		if (!store) {
			store = new Vector3();
		}
		this.checkModelViewProjection();
		var position = new Vector4();
		position.setDirect(worldPosition.x, worldPosition.y, worldPosition.z, 1);
		position.applyPost(this.modelViewProjection);
		if (position.w !== 0.0) {
			position.scale(1.0 / position.w);
		}
		store.x = position.x;
		store.y = position.y;
		store.z = position.z;

		return store;
	};

	/**
	 * Update the modelView matrix if necessary.
	 */
	Camera.prototype.checkModelView = function () {
		if (this._updateMVMatrix) {
			this.updateModelViewMatrix();
			this._updateMVMatrix = false;
		}
	};

	/**
	 * Update the projection matrix if necessary.
	 */
	Camera.prototype.checkProjection = function () {
		if (this._updatePMatrix) {
			this.updateProjectionMatrix();
			this._updatePMatrix = false;
		}
	};

	/**
	 * Update the modelViewProjection matrix if necessary.
	 */
	Camera.prototype.checkModelViewProjection = function () {
		if (this._updateMVPMatrix) {
			this.checkModelView();
			this.checkProjection();
			// because these are transposed, we need to flip order
			this.modelViewProjection.mul2(this.getProjectionMatrix(), this.getViewMatrix());
			this._updateMVPMatrix = false;
		}
	};

	/**
	 * Update the inverse modelView matrix if necessary.
	 */
	Camera.prototype.checkInverseModelView = function () {
		if (this._updateInverseMVMatrix) {
			this.checkModelView();
			this.modelViewInverse.copy(this.modelView).invert();
			//Matrix4.invert(this.modelView, this.modelViewInverse);
			this._updateInverseMVMatrix = false;
		}
	};

	/**
	 * Update the inverse modelViewProjection matrix if necessary.
	 */
	Camera.prototype.checkInverseModelViewProjection = function () {
		if (this._updateInverseMVPMatrix) {
			this.checkModelViewProjection();
			this.modelViewProjectionInverse.copy(this.modelViewProjection).invert();
			//Matrix4.invert(this.modelViewProjection, this.modelViewProjectionInverse);
			this._updateInverseMVPMatrix = false;
		}
	};

	/**
	 * @returns {Matrix4} The modelView matrix.
	 */
	Camera.prototype.getViewMatrix = function () {
		this.checkModelView();
		return this.modelView;
	};

	/**
	 * @returns {Matrix4} The projection matrix.
	 */
	Camera.prototype.getProjectionMatrix = function () {
		this.checkProjection();
		return this.projection;
	};

	/**
	 * @returns {Matrix4} The modelViewProjection matrix.
	 */
	Camera.prototype.getViewProjectionMatrix = function () {
		this.checkModelViewProjection();
		return this.modelViewProjection;
	};

	/**
	 * @returns {Matrix4} The modelViewInverse matrix.
	 */
	Camera.prototype.getViewInverseMatrix = function () {
		this.checkInverseModelView();
		return this.modelViewInverse;
	};

	/**
	 * @returns {Matrix4} The modelViewProjectionInverse matrix.
	 */
	Camera.prototype.getViewProjectionInverseMatrix = function () {
		this.checkInverseModelViewProjection();
		return this.modelViewProjectionInverse;
	};

	/**
	 * Compress this camera's near and far frustum planes to be smaller if possible,
	 * using the given bounds as a measure.
	 * @param {BoundingVolume} sceneBounds The scene bounds.
	 */
	Camera.prototype.pack = function (sceneBounds) {
		var center = sceneBounds.center;
		var corners = this._corners;
		var extents = this._extents;

		for (var i = 0; i < corners.length; i++) {
			corners[i].set(center);
		}

		if (sceneBounds instanceof BoundingBox) {
			extents.setDirect(sceneBounds.xExtent, sceneBounds.yExtent, sceneBounds.zExtent);
		} else if (sceneBounds instanceof BoundingSphere) {
			extents.setDirect(sceneBounds.radius, sceneBounds.radius, sceneBounds.radius);
		}

		corners[0].addDirect(extents.x, extents.y, extents.z);
		corners[1].addDirect(extents.x, -extents.y, extents.z);
		corners[2].addDirect(extents.x, extents.y, -extents.z);
		corners[3].addDirect(extents.x, -extents.y, -extents.z);
		corners[4].addDirect(-extents.x, extents.y, extents.z);
		corners[5].addDirect(-extents.x, -extents.y, extents.z);
		corners[6].addDirect(-extents.x, extents.y, -extents.z);
		corners[7].addDirect(-extents.x, -extents.y, -extents.z);

		var mvMatrix = this.getViewMatrix();
		var optimalCameraNear = Number.MAX_VALUE;
		var optimalCameraFar = -Number.MAX_VALUE;
		var position = new Vector4();
		for (var i = 0; i < corners.length; i++) {
			position.setDirect(corners[i].x, corners[i].y, corners[i].z, 1);
			position.applyPre(mvMatrix);

			optimalCameraNear = Math.min(-position.z, optimalCameraNear);
			optimalCameraFar = Math.max(-position.z, optimalCameraFar);
		}

		optimalCameraNear = Math.min(Math.max(this._frustumNear, optimalCameraNear), this._frustumFar);
		optimalCameraFar = Math.max(optimalCameraNear, Math.min(this._frustumFar, optimalCameraFar));

		var change = optimalCameraNear / this._frustumNear;
		this._frustumLeft = this._frustumLeft * change;
		this._frustumRight = this._frustumRight * change;
		this._frustumTop = this._frustumTop * change;
		this._frustumBottom = this._frustumBottom * change;

		this._frustumNear = optimalCameraNear;
		this._frustumFar = optimalCameraFar;
	};

	Camera.prototype.calculateFrustumCorners = function (fNear, fFar) {
		fNear = fNear !== undefined ? fNear : this._frustumNear;
		fFar = fFar !== undefined ? fFar : this._frustumFar;

		var fNearPlaneHeight = (this._frustumTop - this._frustumBottom) * fNear * 0.5 / this._frustumNear;
		var fNearPlaneWidth = (this._frustumRight - this._frustumLeft) * fNear * 0.5 / this._frustumNear;

		var fFarPlaneHeight = (this._frustumTop - this._frustumBottom) * fFar * 0.5 / this._frustumNear;
		var fFarPlaneWidth = (this._frustumRight - this._frustumLeft) * fFar * 0.5 / this._frustumNear;

		if (this.projectionMode === Camera.Parallel) {
			fNearPlaneHeight = (this._frustumTop - this._frustumBottom) * 0.5;
			fNearPlaneWidth = (this._frustumRight - this._frustumLeft) * 0.5;

			fFarPlaneHeight = (this._frustumTop - this._frustumBottom) * 0.5;
			fFarPlaneWidth = (this._frustumRight - this._frustumLeft) * 0.5;
		}

		var vNearPlaneCenter = this.vNearPlaneCenter;
		var vFarPlaneCenter = this.vFarPlaneCenter;

		var direction = this.calcLeft;

		direction.set(this._direction).scale(fNear);
		vNearPlaneCenter.set(this.translation).add(direction);
		direction.set(this._direction).scale(fFar);
		vFarPlaneCenter.set(this.translation).add(direction);

		var left = this.calcLeft;
		var up = this.calcUp;

		left.set(this._left).scale(fNearPlaneWidth);
		up.set(this._up).scale(fNearPlaneHeight);
		this._corners[0].set(vNearPlaneCenter).sub(left).sub(up);
		this._corners[1].set(vNearPlaneCenter).add(left).sub(up);
		this._corners[2].set(vNearPlaneCenter).add(left).add(up);
		this._corners[3].set(vNearPlaneCenter).sub(left).add(up);

		left.set(this._left).scale(fFarPlaneWidth);
		up.set(this._up).scale(fFarPlaneHeight);
		this._corners[4].set(vFarPlaneCenter).sub(left).sub(up);
		this._corners[5].set(vFarPlaneCenter).add(left).sub(up);
		this._corners[6].set(vFarPlaneCenter).add(left).add(up);
		this._corners[7].set(vFarPlaneCenter).sub(left).add(up);

		return this._corners;
	};

	/**
	 * Clip using an oblique frustum different from the the view frustum
	 * @param {Vector4} clipPlane Clipping plane. (nx, ny, nz, constant)
	 */
	Camera.prototype.setToObliqueMatrix = function (clipPlane) {
		var transformedClipPlane = this._clipPlane.set(clipPlane);

		// bring the clip-plane into camera space which is needed for the calculation
		transformedClipPlane.w = 0;
		transformedClipPlane.applyPost(this.getViewMatrix());
		transformedClipPlane.w = this.translation.y * clipPlane.y - clipPlane.w;

		// calculate oblique camera projection matrix
		this._updatePMatrix = true;
		var projection = this.getProjectionMatrix();

		this._qCalc.setDirect(
			(MathUtils.sign(transformedClipPlane.x) + projection[8]) / projection[0],
			(MathUtils.sign(transformedClipPlane.y) + projection[9]) / projection[5],
			-1,
			(1.0 + projection[10]) / projection[14]
		);

		transformedClipPlane.scale(2.0 / transformedClipPlane.dot(this._qCalc));

		projection[2] = transformedClipPlane.x;
		projection[6] = transformedClipPlane.y;
		projection[10] = transformedClipPlane.z + 1.0;
		projection[14] = transformedClipPlane.w;

		this._updateMVPMatrix = true;
		this._updateInverseMVPMatrix = true;
	};

	Camera.prototype.clone = function () {
		var clone = new Camera(this.fov, this.aspect, this.near, this.far);
		clone.copy(this);
		return clone;
	};

	module.exports = Camera;


/***/ },
/* 121 */
/***/ function(module, exports, __webpack_require__) {

	var Vector3 = __webpack_require__(8);

	/**
	 * A representation of a mathematical plane using a normal vector and a plane constant (d) whose absolute value represents the distance
	 *        from the origin to the plane. It is generally calculated by taking a point (X) on the plane and finding its dot-product with the plane's
	 *        normal vector. In other words: d = N dot X
	 * @param {Vector3} normal Normal of the plane.
	 * @param {number} constant The plane offset along the normal.
	 */
	function Plane(normal, constant) {
		this.normal = normal ? normal.clone() : Vector3.UNIT_Y.clone();
		this.constant = isNaN(constant) ? 0 : constant;

		// @ifdef DEBUG
		Object.seal(this);
		// @endif
	}

	// TODO: add Object.freeze? - Object.freeze is still too slow unfortunately
	Plane.XZ = new Plane(Vector3.UNIT_Y, 0);
	Plane.XY = new Plane(Vector3.UNIT_Z, 0);
	Plane.YZ = new Plane(Vector3.UNIT_X, 0);

	/**
	 * @param {Vector3} point
	 * @returns {number} The distance from this plane to a provided point. If the point is on the negative side of the plane the distance returned is negative,
	 *         otherwise it is positive. If the point is on the plane, it is zero.
	 */
	Plane.prototype.pseudoDistance = function (point) {
		return this.normal.dot(point) - this.constant;
	};

	/**
	 * Sets this plane to the plane defined by the given three points.
	 * @param {Vector3} pointA
	 * @param {Vector3} pointB
	 * @param {Vector3} pointC
	 * @returns {Plane} Self for chaining.
	 */
	Plane.prototype.setPlanePoints = function (pointA, pointB, pointC) {
		this.normal.set(pointB).sub(pointA);
		this.normal.cross(new Vector3(pointC.x - pointA.x, pointC.y - pointA.y, pointC.z - pointA.z)).normalize();
		this.constant = this.normal.dot(pointA);
		return this;
	};

	/**
	 * Reflects an incoming vector across the normal of this Plane.
	 * @param {Vector3} unitVector the incoming vector. Must be a unit vector.
	 * @param {Vector3} [store] Vector to store the result in. May be the same as the unitVector.
	 * @returns {Vector3} The reflected vector.
	 */
	Plane.prototype.reflectVector = function (unitVector, store) {
		var result = store;
		if (typeof result === 'undefined') {
			result = new Vector3();
		}

		var dotProd = this.normal.dot(unitVector) * 2;
		result.set(unitVector).sub(new Vector3(this.normal.x * dotProd, this.normal.y * dotProd, this.normal.z * dotProd));
		return result;
	};

	var p0 = new Vector3();

	/**
	 * Get the intersection of a ray with a plane.
	 * @param {Ray} ray
	 * @param {Vector3} [store]
	 * @param {boolean} [suppressWarnings=false]
	 * @param {boolean} [precision=1e-8]
	 * @returns {Vector3} The store, or new Vector3 if no store was given. In the case where the ray is parallel with the plane, null is returned (and a warning is printed to console).
	 */
	Plane.prototype.rayIntersect = function (ray, store, suppressWarnings, precision) {
		//! AT: the only function with a suppressWarnings
		precision = typeof precision === 'undefined' ? 1e-7 : precision;
		store = store || new Vector3();

		var lDotN = ray.direction.dot(this.normal);
		if (Math.abs(lDotN) < precision) {
			//! AT: this is the only function where we have this suppressWarnings mechanism
			if (!suppressWarnings) {
				console.warn('Ray parallel with plane');
			}
			return null;
		}

		var pMinusL0DotN = p0.set(this.normal)
			.scale(this.constant)
			.sub(ray.origin)
			.dot(this.normal);

		return store.set(ray.direction)
			.scale(pMinusL0DotN / lDotN)
			.add(ray.origin);
	};

	/**
	 * Copies data from another plane
	 * @param source {Plane} Source plane to copy from
	 * @returns {Plane} Returns self to allow chaining
	 */
	Plane.prototype.copy = function (source) {
		this.normal.copy(source.normal);
		this.constant = source.constant;
		return this;
	};

	/**
	 * Returns a clone of this plane
	 * @returns {Plane}
	 */
	Plane.prototype.clone = function () {
		return new Plane(this.normal.clone(), this.constant);
	};

	module.exports = Plane;


/***/ },
/* 122 */
/***/ function(module, exports, __webpack_require__) {

	var Vector3 = __webpack_require__(8);
	var MathUtils = __webpack_require__(9);

	/**
	 * Constructs a new ray with an origin at (0, 0, 0) and a direction of (0, 0, 1).
	 */
	function Ray(origin, direction) {
		this.origin = origin ? origin.clone() : new Vector3();
		this.direction = direction ? direction.clone() : Vector3.UNIT_Z.clone();

		// @ifdef DEBUG
		Object.seal(this);
		// @endif
	}

	var tmpVec1 = new Vector3();
	var tmpVec2 = new Vector3();
	var tmpVec3 = new Vector3();
	var tmpVec4 = new Vector3();
	var tmpVec5 = new Vector3();

	/**
	 * Check for intersection of this ray and and a quad or triangle, either just inside the shape or for the plane defined by the shape (doPlanar == true)
	 *
	 * @param polygonVertices 3 or 4 vector3s defining a triangle or quad
	 * @param [doPlanar]
	 * @param locationStore Vector3 to store our intersection point in.
	 * @returns true if this ray intersects a polygon described by the given vertices.
	 */
	Ray.prototype.intersects = function (polygonVertices, doPlanar, locationStore, skipBackSide) {
		if (polygonVertices.length === 3) {
			return this.intersectsTriangle(polygonVertices[0], polygonVertices[1], polygonVertices[2], doPlanar, locationStore, skipBackSide);
		} else if (polygonVertices.length === 4) {
			return this.intersectsTriangle(polygonVertices[0], polygonVertices[1], polygonVertices[2], doPlanar, locationStore, skipBackSide)
				|| this.intersectsTriangle(polygonVertices[0], polygonVertices[2], polygonVertices[3], doPlanar, locationStore, skipBackSide);
		}
		return false;
	};

	/**
	 * Ray vs triangle implementation.
	 *
	 * @param pointA First
	 * @param pointB
	 * @param pointC
	 * @param [doPlanar]
	 * @param [locationStore]
	 * @returns true if this ray intersects a triangle formed by the given three points.
	 */
	Ray.prototype.intersectsTriangle = function (pointA, pointB, pointC, doPlanar, locationStore, skipBackSide) {
		var edge1 = tmpVec2.set(pointB).sub(pointA);
		var edge2 = tmpVec3.set(pointC).sub(pointA);
		var norm = tmpVec4.set(edge1).cross(edge2);

		var dirDotNorm = this.direction.dot(norm);
		var sign;
		if (dirDotNorm > MathUtils.EPSILON) {
			sign = 1.0;
		} else if (dirDotNorm < -MathUtils.EPSILON) {
			if (skipBackSide) {
				return false;
			}
			sign = -1.0;
			dirDotNorm = -dirDotNorm;
		} else {
			// ray and triangle/quad are parallel
			return false;
		}

		var diff = tmpVec1.set(this.origin).sub(pointA);

		var dirDotDiffxEdge2 = sign * this.direction.dot(tmpVec5.copy(diff).cross(edge2));
		var result = false;
		if (dirDotDiffxEdge2 >= 0.0) {
			var dirDotEdge1xDiff = sign * this.direction.dot(edge1.cross(diff));
			if (dirDotEdge1xDiff >= 0.0) {
				if (dirDotDiffxEdge2 + dirDotEdge1xDiff <= dirDotNorm) {
					var diffDotNorm = -sign * diff.dot(norm);
					if (diffDotNorm >= 0.0) {
						// ray intersects triangle
						// if storage vector is null, just return true,
						if (!locationStore) {
							return true;
						}
						// else fill in.
						var inv = 1.0 / dirDotNorm;
						var t = diffDotNorm * inv;
						if (!doPlanar) {
							locationStore.set(this.origin).addDirect(this.direction.x * t, this.direction.y * t, this.direction.z * t);
						} else {
							// these weights can be used to determine
							// interpolated values, such as texture coord.
							// eg. texcoord s, t at intersection point:
							// s = w0 * s0 + w1 * s1 + w2 * s2;
							// t = w0 * t0 + w1 * t1 + w2 * t2;
							var w1 = dirDotDiffxEdge2 * inv;
							var w2 = dirDotEdge1xDiff * inv;
							// float w0 = 1.0 - w1 - w2;
							locationStore.setDirect(t, w1, w2);
						}
						result = true;
					}
				}
			}
		}
		return result;
	};

	/**
	 * @param worldVertices an array (size 3 or 4) of vectors describing a polygon
	 * @returns the distance from our origin to the primitive or Infinity if we do not intersect.
	 */
	Ray.prototype.getDistanceToPrimitive = function (worldVertices) {
		// Intersection test
		var intersect = tmpVec1;
		if (this.intersects(worldVertices, false, intersect)) {
			return this.origin.distance(intersect.x, intersect.y, intersect.z);
		}
		return Infinity;
	};

	/**
	 * @param plane
	 * @param locationStore if not null, and this ray intersects the plane, the world location of the point of intersection is stored in this vector.
	 * @returns true if the ray collides with the given Plane
	 */
	Ray.prototype.intersectsPlane = function (plane, locationStore) {
		var normal = plane.normal;
		var denominator = normal.dot(this.direction);

		if (Math.abs(denominator) < 0.00001) {
			return false; // coplanar
		}

		var numerator = -normal.dot(this.origin) + plane.constant;
		var ratio = numerator / denominator;

		if (ratio < 0.00001) {
			return false; // intersects behind origin
		}

		if (locationStore) {
			locationStore.set(this.direction).scale(ratio).add(this.origin);
		}

		return true;
	};

	/**
	 * @param {Vector3} point
	 * @param {Vector3} [store] if not null, the closest point is stored in this param
	 * @returns the squared distance from this ray to the given point.
	 */
	Ray.prototype.distanceSquared = function (point, store) {
		var vectorA = tmpVec1;

		vectorA.set(point).sub(this.origin);
		var t0 = this.direction.dot(vectorA);
		if (t0 > 0) {
			// d = |P - (O + t * D)|
			vectorA.set(this.direction).scale(t0);
			vectorA.add(this.origin);
		} else {
			// ray is closest to origin point
			vectorA.set(this.origin);
		}

		// Save away the closest point if requested
		if (store) {
			store.set(vectorA);
		}

		vectorA.sub(point);
		return vectorA.lengthSquared();
	};

	Ray.prototype.copy = function (source) {
		this.origin.copy(source.origin);
		this.direction.copy(source.direction);
	};

	Ray.prototype.clone = function () {
		return new Ray(this.origin.clone(), this.direction.clone());
	};

	module.exports = Ray;

/***/ },
/* 123 */
/***/ function(module, exports, __webpack_require__) {

	var Capabilities = __webpack_require__(17);
	var RendererRecord = __webpack_require__(124);
	var RendererUtils = __webpack_require__(18);
	var TextureCreator = __webpack_require__(125);
	var RenderTarget = __webpack_require__(133);
	var Vector4 = __webpack_require__(11);
	var Texture = __webpack_require__(53);
	__webpack_require__(127); // todo: unused?
	var Material = __webpack_require__(30);
	var RenderQueue = __webpack_require__(43);
	var ShaderLib = __webpack_require__(46);
	var ShadowHandler = __webpack_require__(134);
	var RenderStats = __webpack_require__(138);
	var SystemBus = __webpack_require__(44);
	var TaskScheduler = __webpack_require__(139);
	var RenderInfo = __webpack_require__(140);
	var MathUtils = __webpack_require__(9);

	var STUB_METHOD = function () {};

	/**
	 * The renderer handles displaying of graphics data to a render context.
	 * It accepts an object containing the settings for the renderer.
	 *
	 * @param {Object} parameters Renderer settings.
	 * @param {boolean} [parameters.alpha=false] Enables the possibility to render non-opaque pixels.
	 * @param {boolean} [parameters.premultipliedAlpha=true] Whether the colors are premultiplied with the alpha channel.
	 * @param {boolean} [parameters.antialias=true] Enables antialiasing.
	 * @param {boolean} [parameters.stencil=false] Enables the stencil buffer.
	 * @param {boolean} [parameters.preserveDrawingBuffer=false]
	 * @param {boolean} [parameters.useDevicePixelRatio=false] Take into account the device pixel ratio (for retina screens etc).
	 * @param {canvas} [parameters.canvas] If not supplied, Renderer will create a new canvas.
	 * @param {function (string)} [parameters.onError] Called with message when error occurs.
	 */
	function Renderer(parameters) {
		parameters = parameters || {};

		var _canvas = parameters.canvas;
		if (_canvas === undefined) {
			_canvas = document.createElement('canvas');
			_canvas.width = 500;
			_canvas.height = 500;
		}
		_canvas.screencanvas = true; // CocoonJS support
		this.domElement = _canvas;

		this._alpha = parameters.alpha !== undefined ? parameters.alpha : false;
		this._premultipliedAlpha = parameters.premultipliedAlpha !== undefined ? parameters.premultipliedAlpha : true;
		this._antialias = parameters.antialias !== undefined ? parameters.antialias : true;
		this._stencil = parameters.stencil !== undefined ? parameters.stencil : false;
		this._preserveDrawingBuffer = parameters.preserveDrawingBuffer !== undefined ? parameters.preserveDrawingBuffer : false;
		this._useDevicePixelRatio = parameters.useDevicePixelRatio !== undefined ? parameters.useDevicePixelRatio : false;
		this._onError = parameters.onError;

		this._contextSettings = {
			alpha: this._alpha,
			premultipliedAlpha: this._premultipliedAlpha,
			antialias: this._antialias,
			stencil: this._stencil,
			preserveDrawingBuffer: this._preserveDrawingBuffer
		};

		/** @type {WebGLRenderingContext} */
		this.context = null;
		this.establishContext();

		this._setupContextLost();

		if (parameters.debug) {
			this.setupDebugging(parameters);
		}

		/** @type {RendererRecord} */
		this.rendererRecord = new RendererRecord();

		this.maxTextureSize = !isNaN(parameters.maxTextureSize) ? Math.min(parameters.maxTextureSize, Capabilities.maxTexureSize) : Capabilities.maxTexureSize;
		this.maxCubemapSize = !isNaN(parameters.maxTextureSize) ? Math.min(parameters.maxTextureSize, Capabilities.maxCubemapSize) : Capabilities.maxCubemapSize;

		/** Can be one of: <ul><li>lowp</li><li>mediump</li><li>highp</li></ul>
		 * If the shader doesn't specify a precision, a string declaring this precision will be added.
		 * @type {string}
		 */
		this.shaderPrecision = parameters.shaderPrecision || 'highp';
		if (this.shaderPrecision === 'highp' && Capabilities.vertexShaderHighpFloat.precision > 0 && Capabilities.fragmentShaderHighpFloat.precision > 0) {
			this.shaderPrecision = 'highp';
		} else if (this.shaderPrecision !== 'lowp' && Capabilities.vertexShaderMediumpFloat.precision > 0 && Capabilities.fragmentShaderMediumpFloat.precision > 0) {
			this.shaderPrecision = 'mediump';
		} else {
			this.shaderPrecision = 'lowp';
		}

		/**
		 * Used to scale down/up the pixels in the canvas. If you set downScale=2, you will get half the number of pixels in X and Y. Default is 1.
		 * @type {number}
		 */
		this.downScale = parameters.downScale || 1;

		//! AT: why are there 2 clear colors?
		// Default setup
		/**
		 * Current clear color of the scene. Use .setClearColor() to set it.
		 * @type {Vector4}
		 * @readonly
		 */
		this.clearColor = new Vector4();
		// You need 64 bits for number equality
		this._clearColor = new Vector4();
		this.setClearColor(0.3, 0.3, 0.3, 1.0);


		/** @type {number} */
		this.viewportX = 0;
		/** @type {number} */
		this.viewportY = 0;
		/** @type {number} */
		this.viewportWidth = 0;
		/** @type {number} */
		this.viewportHeight = 0;
		/** @type {number} */
		this.currentWidth = 0;
		/** @type {number} */
		this.currentHeight = 0;
		/**
		 * @type {number}
		 * @readonly
		 */
		this.devicePixelRatio = 1;

		//this.overrideMaterial = null;
		this._overrideMaterials = [];
		this._mergedMaterial = new Material('Merged Material');

		this.renderQueue = new RenderQueue();

		this.info = new RenderStats();

		this.shadowHandler = new ShadowHandler();

		// Hardware picking
		this.hardwarePicking = null;

		SystemBus.addListener('goo.setClearColor', function (color) {
			this.setClearColor.apply(this, color);
		}.bind(this));

		// ---
		//! AT: ugly fix for the resizing style-less canvas to 1 px for desktop
		// apparently this is the only way to find out the user zoom level

		if (document.createElementNS) {
			this.svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
			this.svg.setAttribute('xmlns', 'http://www.w3.org/2000/svg');
			this.svg.setAttribute('version', '1.1');
			this.svg.style.position = 'absolute';
			this.svg.style.display = 'none';
			document.body.appendChild(this.svg);
		} else {
			//! AT: placeholder to avoid another conditional below in checkResize
			this.svg = { currentScale: 1 };
		}

		// Dan: Since GooRunner.clear() wipes all listeners from SystemBus,
		//      this needs to be re-added here again for each new GooRunner/Renderer
		//      cycle.
		SystemBus.addListener('goo.setCurrentCamera', function (newCam) {
			Renderer.mainCamera = newCam.camera;
			this.checkResize(Renderer.mainCamera);
		}.bind(this));

		this._definesIndices = [];

		// @ifdef DEBUG
		Object.seal(this);
		// @endif
	}

	/**
	 *Enables debug mode on the webgl context for easier development.
	 *
	 * @param {Object} parameters
	 * @param {boolean} parameters.validate
	 */
	Renderer.prototype.setupDebugging = function (parameters) {
		// XXX: This is a temporary solution to easily enable webgl debugging during development...
		var request = new XMLHttpRequest();
		request.open('GET', '/js/goo/lib/webgl-debug.js', false);
		request.onreadystatechange = function () {
			if (request.readyState === 4) {
				if (request.status >= 200 && request.status <= 299) {
					// Yes, eval is intended, sorry checkstyle
					window['eval'].call(window, request.responseText);
				}
			}
		};
		request.send(null);

		if (typeof (window.WebGLDebugUtils) === 'undefined') {
			console.warn('You need to include webgl-debug.js in your script definition to run in debug mode.');
		} else {
			console.log('Running in webgl debug mode.');
			if (parameters.validate) {
				console.log('Running with "undefined arguments" validation.');
				this.context = window.WebGLDebugUtils.makeDebugContext(this.context, this.onDebugError.bind(this), validateNoneOfTheArgsAreUndefined);
			} else {
				this.context = window.WebGLDebugUtils.makeDebugContext(this.context, this.onDebugError.bind(this));
			}
		}
	};

	/**
	 *Fetches a working webgl context element and sets it to the Renderer.
	 *
	 */
	Renderer.prototype.establishContext = function () {
		if (window.WebGLRenderingContext) {
			//! AT: this list may require cleanup
			var contextNames = ['experimental-webgl', 'webgl', 'moz-webgl', 'webkit-3d'];
			for (var i = 0; i < contextNames.length; i++) {
				try {
					this.context = this.domElement.getContext(contextNames[i], this._contextSettings);
					if (this.context && typeof this.context.getParameter === 'function') {
						// WebGL is supported & enabled
						break;
					}
				} catch (e) {
					// nothing
				}
			}
			if (!this.context) {
				// WebGL is supported but disabled
				throw new Error('WebGL is supported but disabled');
			}
		}

		var context = this.context;

		context.clearDepth(1);
		context.clearStencil(0);
		context.stencilMask(0);

		context.enable(context.DEPTH_TEST);
		context.depthFunc(context.LEQUAL);

		//! AT: is this still necessary?
		if (context.getShaderPrecisionFormat === undefined) {
			this.context.getShaderPrecisionFormat = function () {
				return {
					rangeMin: 1,
					rangeMax: 1,
					precision: 1
				};
			};
		}

		Capabilities.init(this.context);
	};

	/**
	 * Sets up handlers for context lost/restore.
	 * @private
	 */
	Renderer.prototype._setupContextLost = function () {
		this.domElement.addEventListener('webglcontextlost', function (event) {
			event.preventDefault();
			SystemBus.emit('goo.contextLost');
		}, false);

		this.domElement.addEventListener('webglcontextrestored', function () {
			this._restoreContext();
			SystemBus.emit('goo.contextRestored');
		}.bind(this), false);
	};

	/**
	 * Restores the webgl context.
	 * @private
	 */
	Renderer.prototype._restoreContext = STUB_METHOD; // will be overriden

	function validateNoneOfTheArgsAreUndefined(functionName, args) {
		for (var ii = 0; ii < args.length; ++ii) {
			if (args[ii] === undefined) {
				console.error('undefined passed to gl.' + functionName + '('
					+ window.WebGLDebugUtils.glFunctionArgsToString(functionName, args) + ')');
			}
		}
	}

	/**
	 * Outputs the webgl errors with the respective erroring function name and arguments using console.error.
	 * @param {Object} err
	 * @param {string} functionName
	 * @param {Array} args
	 */
	Renderer.prototype.onDebugError = function (err, functionName, args) {
		// Based on the default error handler in WebGLDebugUtils
		// apparently we can't do args.join(',');
		var message = 'WebGL error ' + window.WebGLDebugUtils.glEnumToString(err) + ' in ' + functionName + '(';
		for (var ii = 0; ii < args.length; ++ii) {
			message += ((ii === 0) ? '' : ', ') +
				window.WebGLDebugUtils.glFunctionArgToString(functionName, ii, args[ii]);
		}
		message += ')';
		console.error(message);
		if (this._onError) {
			this._onError(message);
		}
	};

	Renderer.mainCamera = null;

	/**
	 * Checks if this.domElement.offsetWidth or Height / this.downScale is unequal to this.domElement.width or height.
	 * If that is the case it will call this.setSize.
	 * Also checks if the camera aspect changed and updates it by calling camera.setFrustumPerspective().
	 *
	 * @param {Camera} [camera] optional camera argument.
	 */
	Renderer.prototype.checkResize = function (camera, skipSetSize) {
		var devicePixelRatio = this.devicePixelRatio = this._useDevicePixelRatio && window.devicePixelRatio ? window.devicePixelRatio / this.svg.currentScale : 1;

		var adjustWidth, adjustHeight;
		if (navigator.isCocoonJS) {
			adjustWidth = window.innerWidth;
			adjustHeight = window.innerHeight;
		} else {
			adjustWidth = this.domElement.offsetWidth;
			adjustHeight = this.domElement.offsetHeight;
		}
		adjustWidth = Math.max(adjustWidth * devicePixelRatio / this.downScale, 1);
		adjustHeight = Math.max(adjustHeight * devicePixelRatio / this.downScale, 1);

		var fullWidth = adjustWidth;
		var fullHeight = adjustHeight;

		if (camera && camera.lockedRatio === true && camera.aspect) {
			adjustWidth = adjustHeight * camera.aspect;
		}

		var aspect = adjustWidth / adjustHeight;
		if (!skipSetSize) {
			this.setSize(adjustWidth, adjustHeight, fullWidth, fullHeight);
		}

		if (camera && camera.lockedRatio === false && camera.aspect !== aspect) {
			camera.aspect = aspect;
			if (camera.projectionMode === 0) {
				camera.setFrustumPerspective();
			} else {
				camera.setFrustum();
			}
			camera.onFrameChange();
		}
	};

	/**
	 * Sets this.domElement.width and height using the parameters.
	 * Then it calls this.setViewport(0, 0, width, height);
	 * Finally it resets the hardwarePicking.pickingTarget.
	 *
	 * @param {number} width Aspect ratio corrected width.
	 * @param {number} height Aspect ratio corrected height.
	 * @param {number} [fullWidth] Full viewport width.
	 * @param {number} [fullHeight] Full viewport height.
	 */
	Renderer.prototype.setSize = function (width, height, fullWidth, fullHeight) {
		if (fullWidth === undefined) {
			fullWidth = width;
		}
		if (fullHeight === undefined) {
			fullHeight = height;
		}

		this.domElement.width = fullWidth;
		this.domElement.height = fullHeight;

		if (width > fullWidth) {
			var mult = fullWidth / width;
			width = fullWidth;
			height = fullHeight * mult;
		}

		var w = (fullWidth - width) * 0.5;
		var h = (fullHeight - height) * 0.5;

		if (w !== this.viewportX || h !== this.viewportY ||
			width !== this.viewportWidth || height !== this.viewportHeight) {
			this.setViewport(w, h, width, height);

			if (this.hardwarePicking !== null) {
				this.hardwarePicking.pickingTarget = null;
			}
		}
	};

	/**
	 * Sets this.viewportX and viewportY to the parameters or to 0.
	 * Sets this.viewportWidth and viewportHeight to the parameters or to this.domElement.width and height.
	 * Finally it calls this.context.viewport(x, y, w, h) with the resulting values.
	 * @param {number} [x] optional x coordinate.
	 * @param {number} [y] optional y coordinate.
	 * @param {number} [width] optional width coordinate.
	 * @param {number} [height] optional height coordinate.
	 */
	Renderer.prototype.setViewport = function (x, y, width, height) {
		this.viewportX = x !== undefined ? x : 0;
		this.viewportY = y !== undefined ? y : 0;

		this.viewportWidth = width !== undefined ? width : this.domElement.width;
		this.viewportHeight = height !== undefined ? height : this.domElement.height;

		this.context.viewport(this.viewportX, this.viewportY, this.viewportWidth, this.viewportHeight);

		SystemBus.emit('goo.viewportResize', {
			x: this.viewportX,
			y: this.viewportY,
			width: this.viewportWidth,
			height: this.viewportHeight
		}, true);
	};

	/**
	 * Set the background color of the 3D view. All colors are defined in the range 0.0 - 1.0.
	 *
	 * @param {number} r Red value.
	 * @param {number} g Green value.
	 * @param {number} b Blue value.
	 * @param {number} a Alpha value.
	 */
	Renderer.prototype.setClearColor = function (r, g, b, a) {
		//! AT: is exact equality important here?
		if (this._clearColor.r === r &&
			this._clearColor.g === g &&
			this._clearColor.b === b &&
			this._clearColor.a === a
		) {
			return;
		}

		this._clearColor.r = r;
		this._clearColor.g = g;
		this._clearColor.b = b;
		this._clearColor.a = a;
		this.clearColor.copy(this._clearColor);
		this.context.clearColor(r, g, b, a);
	};

	/**
	 * Binds the given BufferData's buffer, or creates a buffer and bind it if none exist.
	 *
	 * @param {BufferData} bufferData BufferData to bind.
	 */
	Renderer.prototype.bindData = function (bufferData) {
		var glBuffer = bufferData.glBuffer;
		var context = this.context;

		if (glBuffer !== null) {
			this.setBoundBuffer(glBuffer, bufferData.target);
			if (bufferData._dataNeedsRefresh) {
				context.bufferSubData(RendererUtils.getGLBufferTarget(context, bufferData.target), 0, bufferData.data);
				bufferData._dataNeedsRefresh = false;
			}
		} else {
			glBuffer = context.createBuffer();
			bufferData.glBuffer = glBuffer;

			this.rendererRecord.invalidateBuffer(bufferData.target);
			this.setBoundBuffer(glBuffer, bufferData.target);
			context.bufferData(RendererUtils.getGLBufferTarget(context, bufferData.target), bufferData.data, RendererUtils.getGLBufferUsage(context, bufferData._dataUsage));
		}
	};

	/**
	 * Update the data buffer of an attribute at it's offset location.
	 *
	 * @param {ArrayBuffer} attributeData New attribute data buffer.
	 * @param {number} offset The starting location offset to the attribute buffer.
	 */
	Renderer.prototype.updateAttributeData = function (attributeData, offset) {
		this.context.bufferSubData(this.context.ARRAY_BUFFER, offset, attributeData);
	};

	Renderer.prototype.setShadowType = function (type) {
		this.shadowHandler.shadowType = type;
	};

	/**
	 * Update the shadowHandler for the provided entities and lights.
	 *
	 * @param {SimplePartitioner} partitioner The partitioner used to determine what gets to be shadowed.
	 * @param {Array<Entity>} entities Array of all the entities to cast shadows.
	 * @param {Array<Light>} lights Array of all the lights to cast shadows for.
	 */
	Renderer.prototype.updateShadows = function (partitioner, entities, lights) {
		this.shadowHandler.checkShadowRendering(this, partitioner, entities, lights);
	};

	/**
	 * Preloads a texture.
	 *
	 * @param {WebGLRenderingContext} context
	 * @param {Texture} texture
	 */
	Renderer.prototype.preloadTexture = function (context, texture) {
		//! schteppe: Is there any case where we want to preload a texture to another context than this.context?

		// REVIEW: Veeeeery similar to loadTexture. Merge?
		//! AT: the code will diverge; it was initially copy-pasted and adapted to suit the need, but it will have to be iterated on; adding more ifs for different code paths is not gonna make the code nicer

		// this.bindTexture(context, texture, unit, record);
		// context.activeTexture(context.TEXTURE0 + unit); // do I need this?

		//! schteppe: What if the .glTexture is not allocated yet?
		context.bindTexture(RendererUtils.getGLType(context, texture.variant), texture.glTexture);

		// set alignment to support images with width % 4 !== 0, as
		// images are not aligned
		context.pixelStorei(context.UNPACK_ALIGNMENT, texture.unpackAlignment);

		// Using premultiplied alpha
		context.pixelStorei(context.UNPACK_PREMULTIPLY_ALPHA_WEBGL, texture.premultiplyAlpha);

		// set if we want to flip on Y
		context.pixelStorei(context.UNPACK_FLIP_Y_WEBGL, texture.flipY);

		// TODO: Check for the restrictions of using npot textures
		// see: http://www.khronos.org/webgl/wiki/WebGL_and_OpenGL_Differences#Non-Power_of_Two_Texture_Support
		// TODO: Add "usesMipmaps" to check if minfilter has mipmap mode

		var image = texture.image;
		if (texture.variant === '2D') {
			if (!image) {
				context.texImage2D(context.TEXTURE_2D, 0, RendererUtils.getGLInternalFormat(context, texture.format), texture.width, texture.height, 0,
					RendererUtils.getGLInternalFormat(context, texture.format), RendererUtils.getGLDataType(context, texture.type), null);
			} else {
				if (!image.isCompressed && (texture.generateMipmaps || image.width > this.maxTextureSize || image.height > this.maxTextureSize)) {
					this.checkRescale(texture, image, image.width, image.height, this.maxTextureSize);
					image = texture.image;
				}

				if (image.isData === true) {
					if (image.isCompressed) {
						this.loadCompressedTexture(context, context.TEXTURE_2D, texture, image.data);
					} else {
						context.texImage2D(context.TEXTURE_2D, 0, RendererUtils.getGLInternalFormat(context, texture.format), image.width,
							image.height, texture.hasBorder ? 1 : 0, RendererUtils.getGLInternalFormat(context, texture.format), RendererUtils.getGLDataType(context, texture.type), image.data);
					}
				} else {
					context.texImage2D(context.TEXTURE_2D, 0, RendererUtils.getGLInternalFormat(context, texture.format), RendererUtils.getGLInternalFormat(context, texture.format), RendererUtils.getGLDataType(context, texture.type), image);
				}

				if (texture.generateMipmaps && !image.isCompressed) {
					context.generateMipmap(context.TEXTURE_2D);
				}
			}
		} else if (texture.variant === 'CUBE') {
			if (image && !image.isData && (texture.generateMipmaps || image.width > this.maxCubemapSize || image.height > this.maxCubemapSize)) {
				for (var i = 0; i < Texture.CUBE_FACES.length; i++) {
					if (image.data[i] && !image.data[i].buffer ) {
						RendererUtils.scaleImage(texture, image.data[i], image.width, image.height, this.maxCubemapSize, i);
					} else {
						// REVIEW: Hard coded background color that should be determined by Create?
						RendererUtils.getBlankImage(texture, [0.3, 0.3, 0.3, 0], image.width, image.height, this.maxCubemapSize, i);
					}
				}
				texture.image.width = Math.min(this.maxCubemapSize, MathUtils.nearestPowerOfTwo(texture.image.width));
				texture.image.height = Math.min(this.maxCubemapSize, MathUtils.nearestPowerOfTwo(texture.image.height));
				image = texture.image;
			}

			for (var faceIndex = 0; faceIndex < Texture.CUBE_FACES.length; faceIndex++) {
				var face = Texture.CUBE_FACES[faceIndex];

				if (!image) {
					context.texImage2D(RendererUtils.getGLCubeMapFace(context, face), 0, RendererUtils.getGLInternalFormat(context, texture.format), texture.width, texture.height, 0,
						RendererUtils.getGLInternalFormat(context, texture.format), RendererUtils.getGLDataType(context, texture.type), null);
				} else {
					if (image.isData === true) {
						if (image.isCompressed) {
							this.loadCompressedTexture(context, RendererUtils.getGLCubeMapFace(context, face), texture, image.data[faceIndex]);
						} else {
							context.texImage2D(RendererUtils.getGLCubeMapFace(context, face), 0, RendererUtils.getGLInternalFormat(context, texture.format), image.width,
								image.height, texture.hasBorder ? 1 : 0, RendererUtils.getGLInternalFormat(context, texture.format), RendererUtils.getGLDataType(context, texture.type), image.data[faceIndex]);
						}
					} else {
						context.texImage2D(RendererUtils.getGLCubeMapFace(context, face), 0, RendererUtils.getGLInternalFormat(context, texture.format), RendererUtils.getGLInternalFormat(context, texture.format), RendererUtils.getGLDataType(context, texture.type), image.data[faceIndex]);
					}
				}
			}

			if (image && texture.generateMipmaps && !image.isCompressed) {
				context.generateMipmap(context.TEXTURE_CUBE_MAP);
			}
		}
	};

	/**
	 * Preloads the textures of a material.
	 *
	 * @private
	 * @param {Material} material
	 * @param {Array} queue
	 */
	Renderer.prototype.preloadTextures = function (material, queue) {
		var context = this.context;
		var textureKeys = Object.keys(material._textureMaps);

		// for (var i = 0; i < textureKeys.length; i++) {
		// gotta simulate lexical scoping
		textureKeys.forEach(function (textureKey) {
			var texture = material.getTexture(textureKey);

			if (texture === undefined) {
				return;
			}

			var textureList = texture;
			if (texture instanceof Array === false) {
				textureList = [texture];
			}

			// for (var j = 0; j < textureList.length; j++) {
			// gotta simulate lexical scoping
			textureList.forEach(function (texture) {
				if (!texture) { return; }
				queue.push(function () {
					if (texture instanceof RenderTarget === false &&
						(texture.image === undefined || texture.checkDataReady() === false)
					) {
						if (texture.variant === '2D') {
							texture = TextureCreator.DEFAULT_TEXTURE_2D;
						} else if (texture.variant === 'CUBE') {
							texture = TextureCreator.DEFAULT_TEXTURE_CUBE;
						}
					}

					if (texture.glTexture === null) {
						texture.glTexture = context.createTexture();
						this.preloadTexture(context, texture);
						texture.needsUpdate = false;
					} else if (texture instanceof Texture && texture.checkNeedsUpdate()) {
						this.preloadTexture(context, texture);
						texture.needsUpdate = false;
					}
				}.bind(this));
			}, this);
		}, this);
	};

	var preloadMaterialsRenderInfo = new RenderInfo();

	/**
	 * Preloads textures that come with the materials on the supplied "renderables".
	 *
	 * @param {Array} renderList An array of all the "renderables".
	 * @returns {RSVP.Promise}
	 */
	Renderer.prototype.preloadMaterials = function (renderList) {
		var queue = [];
		var renderInfo = preloadMaterialsRenderInfo;
		renderInfo.reset();

		if (Array.isArray(renderList)) {
			for (var i = 0; i < renderList.length; i++) {
				var renderable = renderList[i];
				if (renderable.isSkybox && this._overrideMaterials.length > 0) {
					continue;
				}

				// this function does so much more than I need it to do
				// I only need the material of the renderable
				renderInfo.fill(renderable);

				for (var j = 0; j < renderInfo.materials.length; j++) {
					this.preloadTextures(renderInfo.materials[j], queue);
				}
			}
		} else {
			renderInfo.fill(renderList);
			for (var j = 0; j < renderInfo.materials.length; j++) {
				this.preloadTextures(renderInfo.materials[j], queue);
			}
		}

		return TaskScheduler.each(queue);
	};

	/**
	 * Preprocesses a shader and compiles it.
	 *
	 * @private
	 * @param {Material} material
	 * @param {RenderInfo} renderInfo
	 */
	Renderer.prototype.precompileShader = function (material, renderInfo) {
		var shader = material.shader;

		shader.updateProcessors(renderInfo);
		this.findOrCacheMaterialShader(material, renderInfo);
		shader = material.shader;
		shader.precompile(this);
	};

	/**
	 * Remove all shaders from cache.
	 */
	Renderer.prototype.clearShaderCache = function () {
		this.rendererRecord.shaderCache.clear();
	};

	/**
	 * Precompiles shaders of the supplied "renderables".
	 *
	 * @param {Array} renderList An array of all the "renderables".
	 * @param {Array<Light>} lights
	 */
	Renderer.prototype.precompileShaders = function (renderList, lights) {
		var renderInfo = new RenderInfo();

		if (lights) {
			renderInfo.lights = lights;
		}

		var queue = [];

		if (Array.isArray(renderList)) {
			for (var i = 0; i < renderList.length; i++) {
				var renderable = renderList[i];
				if (renderable.isSkybox && this._overrideMaterials.length > 0) {
					continue;
				}
				renderInfo.fill(renderable);

				for (var j = 0; j < renderInfo.materials.length; j++) {
					renderInfo.material = renderInfo.materials[j];
					this.precompileShader(renderInfo.materials[j], renderInfo, queue);
				}
			}
		} else {
			renderInfo.fill(renderList);
			for (var j = 0; j < renderInfo.materials.length; j++) {
				renderInfo.material = renderInfo.materials[j];
				this.precompileShader(renderInfo.materials[j], renderInfo, queue);
			}
		}

		return TaskScheduler.each(queue);
	};

	//! MF: This method appears to be unused, and it's way of using renderInfo.fill might be questionable.
	/**
	 * Creates buffers of the supplied renderList.
	 *
	 * @hidden
	 * @param {Array} renderList An array of "renderables".
	 */
	Renderer.prototype.preloadBuffers = function (renderList) {
		var renderInfo = new RenderInfo();

		if (Array.isArray(renderList)) {
			for (var i = 0; i < renderList.length; i++) {
				var renderable = renderList[i];
				if (renderable.isSkybox && this._overrideMaterials.length > 0) {
					continue;
				}
				renderInfo.fill(renderable);
				for (var j = 0; j < renderInfo.materials.length; j++) {
					renderInfo.material = renderInfo.materials[j];
					this.preloadBuffer(renderable, renderInfo.materials[j], renderInfo);
				}
			}
		} else {
			renderInfo.fill(renderList);
			for (var j = 0; j < renderInfo.materials.length; j++) {
				renderInfo.material = renderInfo.materials[j];
				this.preloadBuffer(renderList, renderInfo.materials[j], renderInfo);
			}
		}
	};

	/**
	 * Creates buffers of the supplied "renderables".
	 *
	 * @hidden
	 * @param {Array} renderables
	 * @param {Material} material
	 * @param {RenderInfo} renderInfo
	 */
	Renderer.prototype.preloadBuffer = function (renderables, material, renderInfo) {
		var meshData = renderInfo.meshData;
		if (meshData.vertexData === null || meshData.vertexData !== null && meshData.vertexData.data.byteLength === 0 || meshData.indexData !== null
			&& meshData.indexData.data.byteLength === 0) {
			return;
		}
		this.bindData(meshData.vertexData);
		if (meshData.getIndexBuffer() !== null) {
			this.bindData(meshData.getIndexData());
		}

		var materials = renderInfo.materials;
		var flatOrWire = null;
		var originalData = meshData;

		var count;
		if (this._overrideMaterials.length === 0) {
			count = materials.length;
		} else {
			count = this._overrideMaterials.length;
		}

		for (var i = 0; i < count; i++) {
			var material = null, orMaterial = null;

			if (i < materials.length) {
				material = materials[i];
			}
			if (i < this._overrideMaterials.length) {
				orMaterial = this._overrideMaterials[i];
			}

			if (material && orMaterial) {
				this._override(orMaterial, material, this._mergedMaterial);
				material = this._mergedMaterial;
			} else if (orMaterial) {
				material = orMaterial;
			}

			if (!material.shader) {
				if (!material.errorOnce) {
					console.warn('No shader set on material: ' + material.name);
					material.errorOnce = true;
				}
				continue;
			} else {
				material.errorOnce = false;
			}

			if (material.wireframe && flatOrWire !== 'wire') {
				if (!meshData.wireframeData) {
					meshData.wireframeData = meshData.buildWireframeData();
				}
				meshData = meshData.wireframeData;
				this.bindData(meshData.vertexData);
				flatOrWire = 'wire';
			} else if (material.flat && flatOrWire !== 'flat') {
				if (!meshData.flatMeshData) {
					meshData.flatMeshData = meshData.buildFlatMeshData();
				}
				meshData = meshData.flatMeshData;
				this.bindData(meshData.vertexData);
				flatOrWire = 'flat';
			} else if (!material.wireframe && !material.flat && flatOrWire !== null) {
				meshData = originalData;
				this.bindData(meshData.vertexData);
				flatOrWire = null;
			}
		}
	};

	var renderRenderInfo = new RenderInfo();

	var startEachShaderFrame = function (shader) {
		shader.startFrame();
	};

	/**
	 * Renders a "renderable" or a list of renderables. Handles all setup and updates of materials/shaders and states.
	 * @param {Array<Entity>} renderList A list of "renderables". Eg Entities with the right components or objects with mesh data, material and transform.
	 * @param {Camera} camera Main camera for rendering.
	 * @param {Array<Light>} lights Lights used in the rendering.
	 * @param {RenderTarget} [renderTarget=null] Optional rendertarget to use as target for rendering, or null to render to the screen.
	 * @param {(boolean|Object)} [clear=false] true/false to clear or not clear all types, or an object in the form <code>{color:true/false, depth:true/false, stencil:true/false}</code>
	 * @param {Array<Material>} [overrideMaterials] Optional list of materials to override the renderList materials.
	 */
	Renderer.prototype.render = function (renderList, camera, lights, renderTarget, clear, overrideMaterials) {
		if (overrideMaterials) {
			this._overrideMaterials = (overrideMaterials instanceof Array) ? overrideMaterials : [overrideMaterials];
		} else {
			this._overrideMaterials = [];
		}
		if (!camera) {
			return;
		} else if (Renderer.mainCamera === null && !renderTarget) {
			Renderer.mainCamera = camera;
		}

		this.setRenderTarget(renderTarget);

		if (clear === undefined || clear === null || clear === true) {
			this.clear();
		} else if (typeof clear === 'object') {
			this.clear(clear.color, clear.depth, clear.stencil);
		}

		this.rendererRecord.shaderCache.forEach(startEachShaderFrame);

		var renderInfo = renderRenderInfo;
		renderInfo.reset();
		renderInfo.camera = camera;
		renderInfo.mainCamera = Renderer.mainCamera;
		renderInfo.lights = lights;
		renderInfo.shadowHandler = this.shadowHandler;
		renderInfo.renderer = this;

		if (Array.isArray(renderList)) {
			this.renderQueue.sort(renderList, camera);

			for (var i = 0; i < renderList.length; i++) {
				var renderable = renderList[i];
				if (renderable.isSkybox && this._overrideMaterials.length > 0) {
					continue;
				}
				renderInfo.fill(renderable);
				this.renderMesh(renderInfo);
			}
		} else {
			renderInfo.fill(renderList);
			this.renderMesh(renderInfo);
		}

		// TODO: shouldnt we check for generateMipmaps setting on rendertarget?
		if (
			renderTarget &&
			renderTarget.generateMipmaps &&
			MathUtils.isPowerOfTwo(renderTarget.width) &&
			MathUtils.isPowerOfTwo(renderTarget.height)
		) {
			this.updateRenderTargetMipmap(renderTarget);
		}
	};

	/*
	REVIEW:
	+ it is not called from anywhere outside of the renderer and it probably is not of public interest so it should be private
	+ moreover it does not change `this` in any way nor does it need to belong to instances of Renderer - it can be only a helper function
	+ it could also use a description of what it's supposed to do
	 */
	/**
	 * Fills the store parameter with the combined properties of mat1 and mat2.
	 *
	 * @param {Material} mat1
	 * @param {Material} mat2
	 * @param {Material} store
	 */
	Renderer.prototype._override = function (mat1, mat2, store) {
		store.empty();
		var keys = Object.keys(store);
		for (var i = 0, l = keys.length; i < l; i++) {
			var key = keys[i];

			var storeVal = store[key];
			var mat1Val = mat1[key];
			var mat2Val = mat2[key];
			if (storeVal instanceof Object && key !== 'shader') {
				var matkeys = Object.keys(mat1Val);
				for (var j = 0, l2 = matkeys.length; j < l2; j++) {
					var prop = matkeys[j];
					storeVal[prop] = mat1Val[prop];
				}
				var matkeys = Object.keys(mat2Val);
				for (var j = 0, l2 = matkeys.length; j < l2; j++) {
					var prop = matkeys[j];
					if (storeVal[prop] === undefined) {
						storeVal[prop] = mat2Val[prop];
					}
				}
			} else {
				if (mat1Val !== undefined) {
					store[key] = mat1Val;
				} else {
					store[key] = mat2Val;
				}
			}
		}
	};

	/**
	 * Renders a mesh from a RenderInfo.
	 *
	 * @param {RenderInfo} renderInfo
	 */
	Renderer.prototype.renderMesh = function (renderInfo) {
		var meshData = renderInfo.meshData;
		if (!meshData || meshData.vertexData === null || meshData.vertexData !== null && meshData.vertexData.data.byteLength === 0 || meshData.indexData !== null
			&& meshData.indexData.data.byteLength === 0) {
			return;
		}

		this.bindData(meshData.vertexData);

		if (meshData._attributeDataNeedsRefresh) {
			meshData._dirtyAttributeNames.forEach(function (name) {
				this.updateAttributeData(meshData.dataViews[name], meshData.attributeMap[name].offset);
			}, this);

			meshData._attributeDataNeedsRefresh = false;
			meshData._dirtyAttributeNames.clear();
		}

		var materials = renderInfo.materials;

		/*if (this.overrideMaterial !== null) {
			materials = this.overrideMaterial instanceof Array ? this.overrideMaterial : [this.overrideMaterial];
		}*/

		var flatOrWire = null;
		var originalData = meshData;

		// number of materials to render - own materials or overriding materials
		var count = 0;
		if (this._overrideMaterials.length === 0) {
			count = materials.length;
		} else {
			count = this._overrideMaterials.length;
		}

		for (var i = 0; i < count; i++) {
			this.renderMeshMaterial(i, materials, flatOrWire, originalData, renderInfo);
		}
	};

	/**
	 * Call the shader processors of the given material and update material cache.
	 *
	 * @param {Material} material
	 * @param {RenderInfo} renderInfo
	 */
	Renderer.prototype.callShaderProcessors = function (material, renderInfo) {
		// Check for caching of shader that use defines
		material.shader.updateProcessors(renderInfo);
		this.findOrCacheMaterialShader(material, renderInfo);
	};

	/**
	 * Render a material with the given parameters.
	 *
	 * @param {number} materialIndex
	 * @param {Array<Material>} materials
	 * @param {boolean} flatOrWire
	 * @param {MeshData} originalData
	 * @param {RenderInfo} renderInfo
	 */
	Renderer.prototype.renderMeshMaterial = function (materialIndex, materials, flatOrWire, originalData, renderInfo) {
		var material = null, orMaterial = null;

		if (materialIndex < materials.length) {
			material = materials[materialIndex];
		}
		if (materialIndex < this._overrideMaterials.length) {
			orMaterial = this._overrideMaterials[materialIndex];
		}

		material = this.configureRenderInfo(renderInfo, materialIndex, material, orMaterial, originalData, flatOrWire);
		var meshData = renderInfo.meshData;

		this.callShaderProcessors(material, renderInfo);

		material.shader.apply(renderInfo, this);

		this.updateDepthTest(material);
		this.updateCulling(material);
		this.updateBlending(material);
		this.updateOffset(material);
		this.updateTextures(material);

		this.updateLineAndPointSettings(material);

		this._checkDualTransparency(material, meshData);

		this.updateCulling(material);
		this._drawBuffers(meshData);

		this.info.calls++;
		this.info.vertices += meshData.vertexCount;
		this.info.indices += meshData.indexCount;
	};

	/**
	 * Draw the buffers of a MeshData using the specified index-mode.
	 *
	 * @param {MeshData} meshData
	 */
	Renderer.prototype._drawBuffers = function (meshData) {
		if (meshData.getIndexBuffer() !== null) {
			this.bindData(meshData.getIndexData());
			if (meshData.getIndexLengths() !== null) {
				this.drawElementsVBO(meshData.getIndexBuffer(), meshData.getIndexModes(), meshData.getIndexLengths());
			} else {
				this.drawElementsVBO(meshData.getIndexBuffer(), meshData.getIndexModes(), [meshData.getIndexBuffer().length]);
			}
		} else {
			if (meshData.getIndexLengths() !== null) {
				this.drawArraysVBO(meshData.getIndexModes(), meshData.getIndexLengths());
			} else {
				this.drawArraysVBO(meshData.getIndexModes(), [meshData.vertexCount]);
			}
		}
	};

	/**
	 * Decides which MeshData and Material to set on the renderInfo parameter object, also returns the specified material.
	 *
	 * @param {RenderInfo} renderInfo
	 * @param {number} materialIndex
	 * @param {Material} material
	 * @param {Material} orMaterial
	 * @param {MeshData} originalData
	 * @param {string} flatOrWire Can be one of 'flat' or 'wire'
	 * @returns {Material}
	 */
	Renderer.prototype.configureRenderInfo = function (renderInfo, materialIndex, material, orMaterial, originalData, flatOrWire) {
		var meshData = renderInfo.meshData;
		if (materialIndex < this._overrideMaterials.length) {
			orMaterial = this._overrideMaterials[materialIndex];
		}

		if (material && orMaterial && orMaterial.fullOverride !== true) {
			this._override(orMaterial, material, this._mergedMaterial);
			material = this._mergedMaterial;
		} else if (orMaterial) {
			material = orMaterial;
		}

		if (!material.shader) {
			if (!material.errorOnce) {
				console.warn('No shader set on material: ' + material.name);
				material.errorOnce = true;
			}
			return;
		} else {
			material.errorOnce = false;
		}

		if (material.wireframe && flatOrWire !== 'wire') {
			if (!meshData.wireframeData) {
				meshData.wireframeData = meshData.buildWireframeData();
			}
			meshData = meshData.wireframeData;
			this.bindData(meshData.vertexData);
			flatOrWire = 'wire';
		} else if (material.flat && flatOrWire !== 'flat') {
			if (!meshData.flatMeshData) {
				meshData.flatMeshData = meshData.buildFlatMeshData();
			}
			meshData = meshData.flatMeshData;
			this.bindData(meshData.vertexData);
			flatOrWire = 'flat';
		} else if (!material.wireframe && !material.flat && flatOrWire !== null) {
			meshData = originalData;
			this.bindData(meshData.vertexData);
			flatOrWire = null;
		}


		renderInfo.material = material;
		renderInfo.meshData = meshData;
		return material;
	};

	/**
	 * Finds shader of the material in the cache, or add it to the cache if not added yet. Then update the uniforms to the cached shader.
	 *
	 * @param {Material} material
	 * @param {RenderInfo} renderInfo
	 */
	Renderer.prototype.findOrCacheMaterialShader = function (material, renderInfo) {
		// check defines. if no hit in cache -> add to cache. if hit in cache,
		// replace with cache version and copy over uniforms.

		var shader = material.shader;
		var shaderCache = this.rendererRecord.shaderCache;
		shader.endFrame();

		var defineKey = shader.getDefineKey(this._definesIndices);

		var cachedShader = shaderCache.get(defineKey);
		if (cachedShader === material.shader) {
			return;
		}

		if (cachedShader) {
			cachedShader.defines = {};
			if (material.shader.defines) {
				var keys = Object.keys(material.shader.defines);
				for (var i = 0, l = keys.length; i < l; i++) {
					var key = keys[i];
					cachedShader.defines[key] = material.shader.defines[key];
				}
				cachedShader.defineKey = material.shader.defineKey;
			}

			var uniforms = material.shader.uniforms;
			var keys = Object.keys(uniforms);
			for (var i = 0, l = keys.length; i < l; i++) {
				var key = keys[i];
				var origUniform = cachedShader.uniforms[key] = uniforms[key];
				if (origUniform instanceof Array) {
					cachedShader.uniforms[key] = origUniform.slice(0);
				}
			}
			material.shader = cachedShader;
		} else {
			if (shader.builder) {
				shader.builder(shader, renderInfo);
			}

			shader = shader.clone();
			shaderCache.set(defineKey, shader);
			material.shader = shader;
		}
	};

	/**
	 * Checks a material for dualTransparency and if enabled, draws the MeshData buffers again with inverse cullFace.
	 *
	 * @param {Material} material
	 * @param {MeshData} meshData
	 */
	Renderer.prototype._checkDualTransparency = function (material, meshData) {
		if (material.dualTransparency) {
			var savedCullFace = material.cullState.cullFace;
			var newCullFace = savedCullFace === 'Front' ? 'Back' : 'Front';
			material.cullState.cullFace = newCullFace;

			this.updateCulling(material);
			this._drawBuffers(meshData);

			material.cullState.cullFace = savedCullFace;
		}
	};

	/**
	 * Read pixels from current framebuffer to a typed array (ArrayBufferView).
	 *
	 * @param {number} x x offset of rectangle to read from.
	 * @param {number} y y offset of rectangle to read from.
	 * @param {number} width width of rectangle to read from.
	 * @param {number} height height of rectangle to read from.
	 * @param {ArrayBufferView} store ArrayBufferView to store data in (Uint8Array).
	 */
	Renderer.prototype.readPixels = function (x, y, width, height, store) {
		store = store || new Uint8Array(width * height * 4);
		var context = this.context;
		context.readPixels(x, y, width, height, context.RGBA, context.UNSIGNED_BYTE, store);
		return store;
	};

	/**
	 * Read pixels from a texture to a typed array (ArrayBufferView).
	 *
	 * @param {Texture} texture texture to read pixels from.
	 * @param {number} x x offset of rectangle to read from.
	 * @param {number} y y offset of rectangle to read from.
	 * @param {number} width width of rectangle to read from.
	 * @param {number} height height of rectangle to read from.
	 * @param {ArrayBufferView} store ArrayBufferView to store data in (Uint8Array).
	 */
	Renderer.prototype.readTexturePixels = function (texture, x, y, width, height, store) {
		store = store || new Uint8Array(width * height * 4);
		var context = this.context;
		var glFrameBuffer = context.createFramebuffer();
		context.bindFramebuffer(context.FRAMEBUFFER, glFrameBuffer);
		context.framebufferTexture2D(context.FRAMEBUFFER, context.COLOR_ATTACHMENT0,
			context.TEXTURE_2D, texture.glTexture, 0);
		if (context.checkFramebufferStatus(context.FRAMEBUFFER) === context.FRAMEBUFFER_COMPLETE) {
			context.readPixels(x, y, width, height, context.RGBA, context.UNSIGNED_BYTE, store);
		}
		return store;
	};

	/**
	 * Draws a vertex buffer object (VBO) using drawElements.
	 *
	 * @param {BufferData} indices The index-buffer.
	 * @param {Array<string>} indexModes Array of index-modes.
	 * @param {Array<number>} indexLengths Array of index-counts per index-mode.
	 */
	Renderer.prototype.drawElementsVBO = function (indices, indexModes, indexLengths) {
		var offset = 0;
		var indexModeCounter = 0;
		var type = indices.type = indices.type || RendererUtils.getGLArrayType(this.context, indices);
		var byteSize = RendererUtils.getGLByteSize(indices);

		for (var i = 0; i < indexLengths.length; i++) {
			var count = indexLengths[i];
			var glIndexMode = RendererUtils.getGLIndexMode(this.context, indexModes[indexModeCounter]);

			this.context.drawElements(glIndexMode, count, type, offset * byteSize);

			offset += count;

			if (indexModeCounter < indexModes.length - 1) {
				indexModeCounter++;
			}
		}
	};

	/**
	 * Draws a vertex buffer object (VBO) using drawArrays.
	 *
	 * @param {Array<string>} indexModes Array of index-modes.
	 * @param {Array<number>} indexLengths Array of index-counts per index-mode.
	 */
	Renderer.prototype.drawArraysVBO = function (indexModes, indexLengths) {
		var offset = 0;
		var indexModeCounter = 0;

		for (var i = 0; i < indexLengths.length; i++) {
			var count = indexLengths[i];
			var glIndexMode = RendererUtils.getGLIndexMode(this.context, indexModes[indexModeCounter]);

			this.context.drawArrays(glIndexMode, offset, count);

			offset += count;

			if (indexModeCounter < indexModes.length - 1) {
				indexModeCounter++;
			}
		}
	};

	/**
	 * Render entities to be used with the Renderer.pick.
	 *
	 * @param {Array<Entity>} renderList A list of "renderables". Eg Entities with the right components or objects with mesh data, material and transform.
	 * @param {Camera} camera Main camera for rendering to pick.
	 * @param {(boolean|Object)} [clear=false] true/false to clear or not clear all types, or an object in the form <code>{color:true/false, depth:true/false, stencil:true/false}</code>
	 * @param {boolean} skipUpdateBuffer
	 * @param {boolean} doScissor
	 * @param {number} clientX scissor position X.
	 * @param {number} clientY scissor position Y.
	 * @param {Material} customPickingMaterial Custom picking material.
	 * @param {boolean} skipOverride
	 */
	Renderer.prototype.renderToPick = function (renderList, camera, clear, skipUpdateBuffer, doScissor, clientX, clientY, customPickingMaterial, skipOverride) {
		if (this.viewportWidth * this.viewportHeight === 0) {
			return;
		}
		var pickingResolutionDivider = 4;
		if (this.hardwarePicking === null) {
			var pickingMaterial = Material.createEmptyMaterial(ShaderLib.pickingShader, 'pickingMaterial');
			pickingMaterial.blendState = {
				blending: 'NoBlending',
				blendEquation: 'AddEquation',
				blendSrc: 'SrcAlphaFactor',
				blendDst: 'OneMinusSrcAlphaFactor'
			};
			pickingMaterial.wireframe = false;

			this.hardwarePicking = {
				pickingTarget: new RenderTarget(this.viewportWidth / pickingResolutionDivider, this.viewportHeight / pickingResolutionDivider, {
					minFilter: 'NearestNeighborNoMipMaps',
					magFilter: 'NearestNeighbor'
				}),
				pickingMaterial: pickingMaterial,
				pickingBuffer: new Uint8Array(4),
				clearColorStore: new Vector4()
			};
			skipUpdateBuffer = false;
		} else if (this.hardwarePicking.pickingTarget === null) {
			this.hardwarePicking.pickingTarget = new RenderTarget(this.viewportWidth / pickingResolutionDivider, this.viewportHeight / pickingResolutionDivider, {
					minFilter: 'NearestNeighborNoMipMaps',
					magFilter: 'NearestNeighbor'
				});
			skipUpdateBuffer = false;
		}

		if (!skipUpdateBuffer) {
			this.hardwarePicking.clearColorStore.set(this.clearColor);
			if (doScissor && clientX !== undefined && clientY !== undefined) {
				var devicePixelRatio = this._useDevicePixelRatio && window.devicePixelRatio ? window.devicePixelRatio / this.svg.currentScale : 1;

				var x = Math.floor((clientX * devicePixelRatio - this.viewportX) / pickingResolutionDivider);
				var y = Math.floor((this.viewportHeight - (clientY * devicePixelRatio - this.viewportY)) / pickingResolutionDivider);
				this.context.enable(this.context.SCISSOR_TEST);
				this.context.scissor(x, y, 1, 1);
			}

			var pickList = [];
			for (var i = 0, l = renderList.length; i < l; i++) {
				var entity = renderList[i];
				if (!entity.meshRendererComponent || entity.meshRendererComponent.isPickable) {
					pickList.push(entity);
				}
			}

			if (skipOverride) {
				this.render(pickList, camera, [], this.hardwarePicking.pickingTarget, clear);
			} else {
				this.render(pickList, camera, [], this.hardwarePicking.pickingTarget, clear, customPickingMaterial || this.hardwarePicking.pickingMaterial);
			}

			if (doScissor) {
				this.context.disable(this.context.SCISSOR_TEST);
			}
		} else {
			this.setRenderTarget(this.hardwarePicking.pickingTarget);
		}
	};

	/**
	 * Determine what entity ID is at a specific pixel of the camera.
	 *
	 * @param {number} clientX pixel position X to pick at.
	 * @param {number} clientY pixel position Y to pick at.
	 * @param {Object} pickingStore An object with variables 'id' and 'depth' to be populated by the function.
	 * @param {Camera} camera Same camera that was used with Renderer.renderToPick.
	 */
	Renderer.prototype.pick = function (clientX, clientY, pickingStore, camera) {
		if (this.viewportWidth * this.viewportHeight === 0) {
			pickingStore.id = -1;
			pickingStore.depth = 0;
			return;
		}
		var devicePixelRatio = this._useDevicePixelRatio && window.devicePixelRatio ? window.devicePixelRatio / this.svg.currentScale : 1;

		var pickingResolutionDivider = 4;
		var x = Math.floor((clientX * devicePixelRatio - this.viewportX) / pickingResolutionDivider);
		var y = Math.floor((this.viewportHeight - (clientY * devicePixelRatio - this.viewportY)) / pickingResolutionDivider);

		this.readPixels(x, y, 1, 1, this.hardwarePicking.pickingBuffer);

		var id = this.hardwarePicking.pickingBuffer[0] * 255.0 + this.hardwarePicking.pickingBuffer[1] - 1;
		var depth = (this.hardwarePicking.pickingBuffer[2] / 255.0 + (this.hardwarePicking.pickingBuffer[3] / (255.0 * 255.0))) * camera.far;
		pickingStore.id = id;
		pickingStore.depth = depth;
	};

	/**
	 * Update the webgl contexts line and point settings.
	 *
	 * @param {Material} material
	 */
	Renderer.prototype.updateLineAndPointSettings = function (material) {
		var record = this.rendererRecord.lineRecord;
		var lineWidth = material.lineWidth || 1;

		if (record.lineWidth !== lineWidth) {
			this.context.lineWidth(lineWidth);
			record.lineWidth = lineWidth;
		}
	};

	/**
	 * Update the webgl contexts depth test settings.
	 *
	 * @param {Material} material
	 */
	Renderer.prototype.updateDepthTest = function (material) {
		var record = this.rendererRecord.depthRecord;
		var depthState = material.depthState;

		if (record.enabled !== depthState.enabled) {
			if (depthState.enabled) {
				this.context.enable(this.context.DEPTH_TEST);
			} else {
				this.context.disable(this.context.DEPTH_TEST);
			}
			record.enabled = depthState.enabled;
		}
		if (record.write !== depthState.write) {
			if (depthState.write) {
				this.context.depthMask(true);
			} else {
				this.context.depthMask(false);
			}
			record.write = depthState.write;
		}
		if (record.depthFunc !== depthState.depthFunc) {
			this.context.depthFunc(RendererUtils.getGLDepthFunc(this.context, depthState.depthFunc));
			record.depthFunc = depthState.depthFunc;
		}
	};

	/**
	 * Update the webgl contexts culling settings.
	 *
	 * @param {Material} material
	 */
	Renderer.prototype.updateCulling = function (material) {
		var record = this.rendererRecord.cullRecord;
		var cullFace = material.cullState.cullFace;
		var frontFace = material.cullState.frontFace;
		var enabled = material.cullState.enabled;

		if (record.enabled !== enabled) {
			if (enabled) {
				this.context.enable(this.context.CULL_FACE);
			} else {
				this.context.disable(this.context.CULL_FACE);
			}
			record.enabled = enabled;
		}

		if (record.cullFace !== cullFace) {
			var glCullFace = cullFace === 'Front' ? this.context.FRONT : cullFace === 'Back' ? this.context.BACK
				: this.context.FRONT_AND_BACK;
			this.context.cullFace(glCullFace);
			record.cullFace = cullFace;
		}

		if (record.frontFace !== frontFace) {
			switch (frontFace) {
				case 'CCW':
					this.context.frontFace(this.context.CCW);
					break;
				case 'CW':
					this.context.frontFace(this.context.CW);
					break;
			}
			record.frontFace = frontFace;
		}
	};

	/**
	 * Update the webgl contexts settings concerning textures.
	 * updates the material textures if necessary.
	 *
	 * @param {Material} material
	 */
	Renderer.prototype.updateTextures = function (material) {
		var context = this.context;
		var textureSlots = material.shader.textureSlots;

		for (var i = 0; i < textureSlots.length; i++) {
			var textureSlot = textureSlots[i];
			var texture = material.getTexture(textureSlot.mapping);

			if (texture === undefined) {
				if (textureSlot.format === 'sampler2D') {
					texture = TextureCreator.DEFAULT_TEXTURE_2D;
				} else if (textureSlot.format === 'samplerCube') {
					texture = TextureCreator.DEFAULT_TEXTURE_CUBE;
				}
			}

			var textureList = texture;
			if (texture instanceof Array === false) {
				textureList = [texture];
			}

			for (var j = 0; j < textureList.length; j++) {
				texture = textureList[j];

				var texIndex = textureSlot.index instanceof Array ? textureSlot.index[j] : textureSlot.index;

				if (texture === null || texture instanceof RenderTarget && texture.glTexture === null ||
					texture instanceof RenderTarget === false && (texture.image === undefined ||
						texture.checkDataReady() === false)) {
					if (textureSlot.format === 'sampler2D') {
						texture = TextureCreator.DEFAULT_TEXTURE_2D;
					} else if (textureSlot.format === 'samplerCube') {
						texture = TextureCreator.DEFAULT_TEXTURE_CUBE;
					}
				}

				var unitrecord = this.rendererRecord.textureRecord[texIndex];
				if (unitrecord === undefined) {
					unitrecord = this.rendererRecord.textureRecord[texIndex] = {};
				}

				if (texture.glTexture === null) {
					texture.glTexture = context.createTexture();
					this.updateTexture(context, texture, texIndex, unitrecord);
					texture.needsUpdate = false;
				} else if (texture instanceof RenderTarget === false && texture.checkNeedsUpdate()) {
					this.updateTexture(context, texture, texIndex, unitrecord);
					texture.needsUpdate = false;
				} else {
					this.bindTexture(context, texture, texIndex, unitrecord);
				}

				var imageObject = texture.image !== undefined ? texture.image : texture;
				var isTexturePowerOfTwo = MathUtils.isPowerOfTwo(imageObject.width) && MathUtils.isPowerOfTwo(imageObject.height);
				this.updateTextureParameters(texture, isTexturePowerOfTwo);
			}
		}
	};

	/**
	 * Update the webgl contexts settings of a single texture, such as filtering and wrapping.
	 *
	 * @param {Texture} texture
	 * @param {boolean} isImagePowerOfTwo
	 */
	Renderer.prototype.updateTextureParameters = function (texture, isImagePowerOfTwo) {
		var context = this.context;

		var texrecord = texture.textureRecord;

		var glType = RendererUtils.getGLType(context, texture.variant);
		if (texrecord.magFilter !== texture.magFilter) {
			context.texParameteri(glType, context.TEXTURE_MAG_FILTER, RendererUtils.getGLMagFilter(context, texture.magFilter));
			texrecord.magFilter = texture.magFilter;
		}
		var minFilter = isImagePowerOfTwo ? texture.minFilter : RendererUtils.getFilterFallback(texture.minFilter);
		if (texrecord.minFilter !== minFilter) {
			context.texParameteri(glType, context.TEXTURE_MIN_FILTER, RendererUtils.getGLMinFilter(context, minFilter));
			texrecord.minFilter = minFilter;
		}

		// repeating NPOT textures are not supported in webgl https://www.khronos.org/webgl/wiki/WebGL_and_OpenGL_Differences
		var wrapS = isImagePowerOfTwo ? texture.wrapS : 'EdgeClamp';
		if (texrecord.wrapS !== wrapS) {
			var glwrapS = RendererUtils.getGLWrap(context, wrapS);
			context.texParameteri(glType, context.TEXTURE_WRAP_S, glwrapS);
			texrecord.wrapS = wrapS;
		}
		var wrapT = isImagePowerOfTwo ? texture.wrapT : 'EdgeClamp';
		if (texrecord.wrapT !== wrapT) {
			var glwrapT = RendererUtils.getGLWrap(context, wrapT);
			context.texParameteri(glType, context.TEXTURE_WRAP_T, glwrapT);
			texrecord.wrapT = wrapT;
		}

		if (Capabilities.TextureFilterAnisotropic && texture.type !== 'Float') {
			var anisotropy = texture.anisotropy;
			if (texrecord.anisotropy !== anisotropy) {
				context.texParameterf(glType, Capabilities.TextureFilterAnisotropic.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(anisotropy, Capabilities.maxAnisotropy));
				texrecord.anisotropy = anisotropy;
			}
		}
	};

	/**
	 * Binds a texture to webgl.
	 *
	 * @param {WebGLRenderingContext} context
	 * @param {Texture} texture
	 * @param {number} unit The index for the textureRecord.
	 * @param {Object} record
	 */
	Renderer.prototype.bindTexture = function (context, texture, unit, record) {
		if (record.boundTexture === undefined || texture.glTexture !== undefined && record.boundTexture !== texture.glTexture) {
			context.activeTexture(context.TEXTURE0 + unit);
			context.bindTexture(RendererUtils.getGLType(context, texture.variant), texture.glTexture);
			record.boundTexture = texture.glTexture;
		}
	};

	/**
	 * Unbinds a texture from webgl.
	 *
	 * @param {WebGLRenderingContext} context
	 * @param {Texture} texture
	 * @param {number} unit The index for the textureRecord.
	 * @param {Object} record
	 */
	Renderer.prototype.unbindTexture = function (context, texture, unit, record) {
		context.activeTexture(context.TEXTURE0 + unit);
		context.bindTexture(RendererUtils.getGLType(context, texture.variant), null);
		record.boundTexture = undefined;
	};

	/**
	 * Loads a compressed texture into webgl and optionally generates mipmaps.
	 *
	 * @param {WebGLRenderingContext} context
	 * @param {number} target For example context.TEXTURE_2D.
	 * @param {Texture} texture
	 * @param {(Uint8Array|ArrayBufferView)} imageData The image data object.
	 */
	Renderer.prototype.loadCompressedTexture = function (context, target, texture, imageData) {
		var mipSizes = texture.image.mipmapSizes;
		var dataOffset = 0, dataLength = 0;
		var width = texture.image.width, height = texture.image.height;
		var ddsExt = Capabilities.CompressedTextureS3TC;

		if (!ddsExt) {
			texture.image = undefined;
			texture.needsUpdate = true;
			console.warn('Tried to load unsupported compressed texture.');
			return;
		}

		var internalFormat = ddsExt.COMPRESSED_RGBA_S3TC_DXT5_EXT;
		if (texture.format === 'PrecompressedDXT1') {
			internalFormat = ddsExt.COMPRESSED_RGB_S3TC_DXT1_EXT;
		} else if (texture.format === 'PrecompressedDXT1A') {
			internalFormat = ddsExt.COMPRESSED_RGBA_S3TC_DXT1_EXT;
		} else if (texture.format === 'PrecompressedDXT3') {
			internalFormat = ddsExt.COMPRESSED_RGBA_S3TC_DXT3_EXT;
		} else if (texture.format === 'PrecompressedDXT5') {
			internalFormat = ddsExt.COMPRESSED_RGBA_S3TC_DXT5_EXT;
		} else {
			throw new Error('Unhandled compression format: ' + imageData.getDataFormat().name());
		}

		if (typeof mipSizes === 'undefined' || mipSizes === null) {
			if (imageData instanceof Uint8Array) {
				context.compressedTexImage2D(target, 0, internalFormat, width, height, 0, imageData);
			} else {
				context.compressedTexImage2D(target, 0, internalFormat, width, height, 0, new Uint8Array(imageData.buffer, imageData.byteOffset,
					imageData.byteLength));
			}
		} else {
			texture.generateMipmaps = false;
			if (imageData instanceof Array) {
				for (var i = 0; i < imageData.length; i++) {
					context.compressedTexImage2D(target, i, internalFormat, width, height, 0, imageData[i]);
					//! SH: REVIEW: this operation is being done many times, not very DRY; also Math.floor is practically as fast as ~~, does the same thing, and is more readable. http://jsperf.com/jsfvsbitnot/15
					width = ~~(width / 2) > 1 ? ~~(width / 2) : 1;
					height = ~~(height / 2) > 1 ? ~~(height / 2) : 1;
				}
			} else {
				for (var i = 0; i < mipSizes.length; i++) {
					dataLength = mipSizes[i];
					context.compressedTexImage2D(target, i, internalFormat, width, height, 0, new Uint8Array(imageData.buffer, imageData.byteOffset
						+ dataOffset, dataLength));
					width = ~~(width / 2) > 1 ? ~~(width / 2) : 1;
					height = ~~(height / 2) > 1 ? ~~(height / 2) : 1;
					dataOffset += dataLength;
				}
			}

			var expectedMipmaps = 1 + Math.ceil(Math.log(Math.max(texture.image.height, texture.image.width)) / Math.log(2));
			var size = mipSizes[mipSizes.length - 1];
			if (mipSizes.length < expectedMipmaps) {
				for (var i = mipSizes.length; i < expectedMipmaps; i++) {
					size = ~~((width + 3) / 4) * ~~((height + 3) / 4) * texture.image.bpp * 2;
					context.compressedTexImage2D(target, i, internalFormat, width, height, 0, new Uint8Array(size));
					width = ~~(width / 2) > 1 ? ~~(width / 2) : 1;
					height = ~~(height / 2) > 1 ? ~~(height / 2) : 1;
				}
			}
		}
	};

	/**
	 * Updates a texture in webgl with the Texture objects settings.
	 *
	 * @param {WebGLRenderingContext} context
	 * @param {Texture} texture
	 * @param {number} unit
	 * @param {Object} record
	 */
	Renderer.prototype.updateTexture = function (context, texture, unit, record) {
		// this.bindTexture(context, texture, unit, record);
		context.activeTexture(context.TEXTURE0 + unit);
		context.bindTexture(RendererUtils.getGLType(context, texture.variant), texture.glTexture);
		record.boundTexture = texture.glTexture;

		// set alignment to support images with width % 4 !== 0, as
		// images are not aligned
		context.pixelStorei(context.UNPACK_ALIGNMENT, texture.unpackAlignment);

		// Using premultiplied alpha
		context.pixelStorei(context.UNPACK_PREMULTIPLY_ALPHA_WEBGL, texture.premultiplyAlpha);

		// set if we want to flip on Y
		context.pixelStorei(context.UNPACK_FLIP_Y_WEBGL, texture.flipY);

		// TODO: Check for the restrictions of using npot textures
		// see: http://www.khronos.org/webgl/wiki/WebGL_and_OpenGL_Differences#Non-Power_of_Two_Texture_Support
		// TODO: Add "usesMipmaps" to check if minfilter has mipmap mode

		var image = texture.image;
		if (texture.variant === '2D') {
			if (!image) {
				context.texImage2D(context.TEXTURE_2D, 0, RendererUtils.getGLInternalFormat(context, texture.format), texture.width, texture.height, 0,
					RendererUtils.getGLInternalFormat(context, texture.format), RendererUtils.getGLDataType(context, texture.type), null);
			} else {
				if (!(image instanceof HTMLVideoElement) && !image.isCompressed && (texture.generateMipmaps || texture.wrapS !== 'EdgeClamp' || texture.wrapT !== 'EdgeClamp' || image.width > this.maxTextureSize || image.height > this.maxTextureSize)) {
					this.checkRescale(texture, image, image.width, image.height, this.maxTextureSize);
					image = texture.image;
				}

				if (image.isData === true) {
					if (image.isCompressed) {
						this.loadCompressedTexture(context, context.TEXTURE_2D, texture, image.data);
					} else {
						context.texImage2D(context.TEXTURE_2D, 0, RendererUtils.getGLInternalFormat(context, texture.format), image.width,
							image.height, texture.hasBorder ? 1 : 0, RendererUtils.getGLInternalFormat(context, texture.format), RendererUtils.getGLDataType(context, texture.type), image.data);
					}
				} else {
					context.texImage2D(context.TEXTURE_2D, 0, RendererUtils.getGLInternalFormat(context, texture.format), RendererUtils.getGLInternalFormat(context, texture.format), RendererUtils.getGLDataType(context, texture.type), image);
				}

				if (texture.generateMipmaps && !image.isCompressed) {
					context.generateMipmap(context.TEXTURE_2D);
				}
			}
		} else if (texture.variant === 'CUBE') {
			if (image && !image.isData && (texture.generateMipmaps || image.width > this.maxCubemapSize || image.height > this.maxCubemapSize)) {
				for (var i = 0; i < Texture.CUBE_FACES.length; i++) {
					if (image.data[i] && !image.data[i].buffer ) {
						RendererUtils.scaleImage(texture, image.data[i], image.width, image.height, this.maxCubemapSize, i);
					} else {
						RendererUtils.getBlankImage(texture, [0.3, 0.3, 0.3, 0], image.width, image.height, this.maxCubemapSize, i);
					}
				}
				texture.image.width = Math.min(this.maxCubemapSize, MathUtils.nearestPowerOfTwo(texture.image.width));
				texture.image.height = Math.min(this.maxCubemapSize, MathUtils.nearestPowerOfTwo(texture.image.height));
				image = texture.image;
			}

			for (var faceIndex = 0; faceIndex < Texture.CUBE_FACES.length; faceIndex++) {
				var face = Texture.CUBE_FACES[faceIndex];

				if (!image) {
					context.texImage2D(RendererUtils.getGLCubeMapFace(context, face), 0, RendererUtils.getGLInternalFormat(context, texture.format), texture.width, texture.height, 0,
						RendererUtils.getGLInternalFormat(context, texture.format), RendererUtils.getGLDataType(context, texture.type), null);
				} else {
					if (image.isData === true) {
						if (image.isCompressed) {
							this.loadCompressedTexture(context, RendererUtils.getGLCubeMapFace(context, face), texture, image.data[faceIndex]);
						} else {
							context.texImage2D(RendererUtils.getGLCubeMapFace(context, face), 0, RendererUtils.getGLInternalFormat(context, texture.format), image.width,
								image.height, texture.hasBorder ? 1 : 0, RendererUtils.getGLInternalFormat(context, texture.format), RendererUtils.getGLDataType(context, texture.type), image.data[faceIndex]);
						}
					} else {
						context.texImage2D(RendererUtils.getGLCubeMapFace(context, face), 0, RendererUtils.getGLInternalFormat(context, texture.format), RendererUtils.getGLInternalFormat(context, texture.format), RendererUtils.getGLDataType(context, texture.type), image.data[faceIndex]);
					}
				}
			}

			if (image && texture.generateMipmaps && !image.isCompressed) {
				context.generateMipmap(context.TEXTURE_CUBE_MAP);
			}
		}
	};

	/**
	 * Updates a texture in webgl with the Texture objects settings.
	 *
	 * @param {Texture} texture
	 * @param {Image} image Can be an Image, TypedArray or an array of Images (for cubemaps).
	 * @param {number} width The new image width.
	 * @param {number} height The new image height.
	 * @param {number} maxSize
	 * @param {number} index
	 */
	Renderer.prototype.checkRescale = function (texture, image, width, height, maxSize, index) {
		RendererUtils.scaleImage(texture, image, width, height, maxSize, index);
	};

	/**
	 * Update the blend settings on the webgl context.
	 *
	 * @param {Material} material
	 */
	Renderer.prototype.updateBlending = function (material) {
		var blendRecord = this.rendererRecord.blendRecord;
		var context = this.context;

		var blending = material.blendState.blending;
		if (blending !== blendRecord.blending) {
			if (blending === 'NoBlending') {
				context.disable(context.BLEND);
			} else if (blending === 'AdditiveBlending') {
				context.enable(context.BLEND);
				context.blendEquation(context.FUNC_ADD);
				context.blendFunc(context.SRC_ALPHA, context.ONE);
			} else if (blending === 'SubtractiveBlending') {
				// TODO: Find blendFuncSeparate() combination
				context.enable(context.BLEND);
				context.blendEquation(context.FUNC_REVERSE_SUBTRACT);
				context.blendFunc(context.SRC_ALPHA, context.ONE);
			} else if (blending === 'MultiplyBlending') {
				// TODO: Find blendFuncSeparate() combination
				context.enable(context.BLEND);
				context.blendEquation(context.FUNC_ADD);
				context.blendFunc(context.DST_COLOR, context.ONE_MINUS_SRC_ALPHA);
			} else if (blending === 'AlphaBlending') {
				context.enable(context.BLEND);
				context.blendEquation(context.FUNC_ADD);
				context.blendFunc(context.SRC_ALPHA, context.ONE_MINUS_SRC_ALPHA);
			} else if (blending === 'TransparencyBlending') {
				context.enable(context.BLEND);
				context.blendEquationSeparate(
					context.FUNC_ADD,
					context.FUNC_ADD
				);
				context.blendFuncSeparate(
					context.SRC_ALPHA,
					context.ONE_MINUS_SRC_ALPHA,
					context.ONE,
					context.ONE_MINUS_SRC_ALPHA
				);
			} else if (blending === 'CustomBlending') {
				context.enable(context.BLEND);
			} else if (blending === 'SeparateBlending') {
				context.enable(context.BLEND);
				context.blendEquationSeparate(
						RendererUtils.getGLBlendParam(context, material.blendState.blendEquationColor),
						RendererUtils.getGLBlendParam(context, material.blendState.blendEquationAlpha));
				context.blendFuncSeparate(
					RendererUtils.getGLBlendParam(context, material.blendState.blendSrcColor),
					RendererUtils.getGLBlendParam(context, material.blendState.blendDstColor),
					RendererUtils.getGLBlendParam(context, material.blendState.blendSrcAlpha),
					RendererUtils.getGLBlendParam(context, material.blendState.blendDstAlpha));
			} else {
				context.enable(context.BLEND);
				context.blendEquationSeparate(context.FUNC_ADD, context.FUNC_ADD);
				context.blendFuncSeparate(context.SRC_ALPHA, context.ONE_MINUS_SRC_ALPHA, context.ONE,
					context.ONE_MINUS_SRC_ALPHA);
			}

			blendRecord.blending = blending;
		}

		if (blending === 'CustomBlending') {
			var blendEquation = material.blendState.blendEquation;
			var blendSrc = material.blendState.blendSrc;
			var blendDst = material.blendState.blendDst;

			if (blendEquation !== blendRecord.blendEquation) {
				context.blendEquation(RendererUtils.getGLBlendParam(context, blendEquation));
				blendRecord.blendEquation = blendEquation;
			}

			if (blendSrc !== blendRecord.blendSrc || blendDst !== blendRecord.blendDst) {
				context.blendFunc(RendererUtils.getGLBlendParam(context, blendSrc), RendererUtils.getGLBlendParam(context, blendDst));

				blendRecord.blendSrc = blendSrc;
				blendRecord.blendDst = blendDst;
			}
		} else {
			blendRecord.blendEquation = null;
			blendRecord.blendSrc = null;
			blendRecord.blendDst = null;
		}
	};

	/**
	 * Updates the polygon offset settings on the webgl context.
	 *
	 * @param {Material} material
	 */
	Renderer.prototype.updateOffset = function (material) {
		var offsetRecord = this.rendererRecord.offsetRecord;
		var context = this.context;

		var enabled = material.offsetState.enabled;
		var factor = material.offsetState.factor;
		var units = material.offsetState.units;

		if (offsetRecord.enabled !== enabled) {
			if (enabled) {
				context.enable(context.POLYGON_OFFSET_FILL);
			} else {
				context.disable(context.POLYGON_OFFSET_FILL);
			}

			offsetRecord.enabled = enabled;
		}

		if (enabled && (offsetRecord.factor !== factor || offsetRecord.units !== units)) {
			context.polygonOffset(factor, units);

			offsetRecord.factor = factor;
			offsetRecord.units = units;
		}
	};

	/**
	 * Binds a buffer to the webgl context.
	 *
	 * @param {WebGLBuffer} buffer
	 * @param {string} target for example 'ArrayBuffer'.
	 */
	Renderer.prototype.setBoundBuffer = function (buffer, target) {
		var targetBuffer = this.rendererRecord.currentBuffer[target];
		if (!targetBuffer.valid || targetBuffer.buffer !== buffer) {
			this.context.bindBuffer(RendererUtils.getGLBufferTarget(this.context, target), buffer);
			targetBuffer.buffer = buffer;
			targetBuffer.valid = true;
			if (target === 'ArrayBuffer') {
				this.rendererRecord.attributeCache.length = 0;
			}
		}
	};

	/**
	 * Binds vertex attributes to the webgl context.
	 *
	 * @param {number} attribIndex
	 * @param {Object} attribute See MeshData.createAttribute for definition.
	 */
	Renderer.prototype.bindVertexAttribute = function (attribIndex, attribute) {
		var hashKey = this.rendererRecord.attributeCache[attribIndex];
		if (hashKey !== attribute.hashKey) {
			this.context.vertexAttribPointer(attribIndex, attribute.count, RendererUtils.getGLDataType(this.context, attribute.type), attribute.normalized, attribute.stride, attribute.offset);
			this.rendererRecord.attributeCache[attribIndex] = attribute.hashKey;
		}
	};

	/**
	 * Clears the webgl context with the specified options.
	 *
	 * @param {boolean} color
	 * @param {boolean} depth
	 * @param {boolean} stencil
	 */
	Renderer.prototype.clear = function (color, depth, stencil) {
		var bits = 0;

		if (color === undefined || color) {
			bits |= this.context.COLOR_BUFFER_BIT;
		}
		if (depth === undefined || depth) {
			bits |= this.context.DEPTH_BUFFER_BIT;
		}
		if (stencil === undefined || stencil) {
			bits |= this.context.STENCIL_BUFFER_BIT;
		}

		var record = this.rendererRecord.depthRecord;
		if (record.write !== true) {
			this.context.depthMask(true);
			record.write = true;
		}

		if (bits) {
			this.context.clear(bits);
		}
	};

	/**
	 * Flushes the webgl context.
	 *
	 */
	Renderer.prototype.flush = function () {
		this.context.flush();
	};

	/**
	 * calls finish on the webgl context.
	 *
	 */
	Renderer.prototype.finish = function () {
		this.context.finish();
	};

	// ---------------------------------------------

	/**
	 * Setup a Frame Buffer Object with the supplied render target.
	 *
	 * @param {WebGLFramebuffer} framebuffer
	 * @param {RenderTarget} renderTarget
	 * @param {number} textureTarget For instance context.TEXTURE_2D.
	 */
	Renderer.prototype.setupFrameBuffer = function (framebuffer, renderTarget, textureTarget) {
		this.context.bindFramebuffer(this.context.FRAMEBUFFER, framebuffer);
		this.context.framebufferTexture2D(this.context.FRAMEBUFFER, this.context.COLOR_ATTACHMENT0, textureTarget,
			renderTarget.glTexture, 0);
	};

	/**
	 * Setup an Render Buffer Object with the supplied render target.
	 *
	 * @param {WebGLRenderbuffer} renderbuffer
	 * @param {RenderTarget} renderTarget
	 */
	Renderer.prototype.setupRenderBuffer = function (renderbuffer, renderTarget) {
		var context = this.context;
		context.bindRenderbuffer(context.RENDERBUFFER, renderbuffer);

		if (renderTarget.depthBuffer && !renderTarget.stencilBuffer) {
			context.renderbufferStorage(context.RENDERBUFFER, context.DEPTH_COMPONENT16, renderTarget.width,
				renderTarget.height);
			context.framebufferRenderbuffer(context.FRAMEBUFFER, context.DEPTH_ATTACHMENT,
				context.RENDERBUFFER, renderbuffer);
		} else if (renderTarget.depthBuffer && renderTarget.stencilBuffer) {
			context.renderbufferStorage(context.RENDERBUFFER, context.DEPTH_STENCIL, renderTarget.width,
				renderTarget.height);
			context.framebufferRenderbuffer(context.FRAMEBUFFER, context.DEPTH_STENCIL_ATTACHMENT,
				context.RENDERBUFFER, renderbuffer);
		} else {
			this.context
				.renderbufferStorage(context.RENDERBUFFER, context.RGBA4, renderTarget.width, renderTarget.height);
		}
	};

	/**
	 * Binds the supplied render target's FBO to the webgl context.
	 * Creates FBO and RBO for the render target if not set already.
	 *
	 * @param {RenderTarget} renderTarget
	 */
	Renderer.prototype.setRenderTarget = function (renderTarget) {
		var context = this.context;
		if (renderTarget && !renderTarget._glFrameBuffer) {
			if (renderTarget.depthBuffer === undefined) {
				renderTarget.depthBuffer = true;
			}
			if (renderTarget.stencilBuffer === undefined) {
				renderTarget.stencilBuffer = true;
			}

			if (renderTarget.glTexture === null) {
				renderTarget.glTexture = this.context.createTexture();
			}

			// Setup texture, create render and frame buffers
			var isTargetPowerOfTwo = MathUtils.isPowerOfTwo(renderTarget.width) && MathUtils.isPowerOfTwo(renderTarget.height);
			var glFormat = RendererUtils.getGLInternalFormat(context, renderTarget.format);
			var glType = RendererUtils.getGLDataType(context, renderTarget.type);

			renderTarget._glFrameBuffer = this.context.createFramebuffer();
			renderTarget._glRenderBuffer = this.context.createRenderbuffer();

			this.context.bindTexture(context.TEXTURE_2D, renderTarget.glTexture);
			this.updateTextureParameters(renderTarget, isTargetPowerOfTwo);

			this.context
				.texImage2D(context.TEXTURE_2D, 0, glFormat, renderTarget.width, renderTarget.height, 0, glFormat, glType, null);

			this.setupFrameBuffer(renderTarget._glFrameBuffer, renderTarget, context.TEXTURE_2D);
			this.setupRenderBuffer(renderTarget._glRenderBuffer, renderTarget);

			if (renderTarget.generateMipmaps && isTargetPowerOfTwo) {
				this.context.generateMipmap(context.TEXTURE_2D);
			}

			// Release everything
			this.context.bindTexture(context.TEXTURE_2D, null);
			this.context.bindRenderbuffer(context.RENDERBUFFER, null);
			this.context.bindFramebuffer(context.FRAMEBUFFER, null);
		}

		var framebuffer, width, height, vx, vy;

		if (renderTarget) {
			framebuffer = renderTarget._glFrameBuffer;

			vx = 0;
			vy = 0;
			width = renderTarget.width;
			height = renderTarget.height;
		} else {
			framebuffer = null;

			vx = this.viewportX;
			vy = this.viewportY;
			width = this.viewportWidth;
			height = this.viewportHeight;
		}

		if (framebuffer !== this.rendererRecord.currentFrameBuffer) {
			context.bindFramebuffer(context.FRAMEBUFFER, framebuffer);
			context.viewport(vx, vy, width, height);

			this.rendererRecord.currentFrameBuffer = framebuffer;

			// Need to force rebinding of textures on framebuffer change (TODO: verify this)
			this.rendererRecord.textureRecord = [];
		}

		this.currentWidth = width;
		this.currentHeight = height;
	};

	/**
	 * Updates the render targets mipmaps.
	 *
	 * @param {RenderTarget} renderTarget
	 */
	Renderer.prototype.updateRenderTargetMipmap = function (renderTarget) {
		var context = this.context;
		context.bindTexture(context.TEXTURE_2D, renderTarget.glTexture);
		context.generateMipmap(context.TEXTURE_2D);
		context.bindTexture(context.TEXTURE_2D, null);
	};

	/**
	 * Deallocates a meshdata with the Renderer's webgl context.
	 *
	 * @param {MeshData} meshData
	 */
	Renderer.prototype._deallocateMeshData = function (meshData) {
		meshData.destroy(this.context);
	};

	/**
	 * Deallocates a texture with the Renderer's webgl context.
	 *
	 * @param {Texture} texture
	 */
	Renderer.prototype._deallocateTexture = function (texture) {
		texture.destroy(this.context);
	};

	/**
	 * Deallocates a render target with the Renderer's webgl context.
	 *
	 * @param {RenderTarget} renderTarget
	 */
	Renderer.prototype._deallocateRenderTarget = function (renderTarget) {
		renderTarget.destroy(this.context);
	};

	/**
	 * Deallocates a shader.
	 *
	 * @param {Shader} shader
	 */
	Renderer.prototype._deallocateShader = function (shader) {
		shader.destroy();
	};

	module.exports = Renderer;


/***/ },
/* 124 */
/***/ function(module, exports) {

	/**
	 * Holds the renderer's state
	 * @hidden
	 */
	function RendererRecord() {
		this.currentBuffer = {
			'ArrayBuffer': {
				buffer: null,
				valid: false
			},
			'ElementArrayBuffer': {
				buffer: null,
				valid: false
			}
		};
		this.currentFrameBuffer = null;
		this.clippingTestValid = false;
		this.clippingTestEnabled = false;
		this.clips = [];
		this.enabledTextures = 0;
		this.texturesValid = false;
		this.currentTextureArraysUnit = 0;

		this.textureRecord = [];

		this.usedProgram = null;
		this.boundAttributes = [];
		this.enabledAttributes = [];
		this.newlyEnabledAttributes = [];

		this.depthRecord = {}; // these can be initialized with their default values
		this.cullRecord = {};
		this.blendRecord = {};
		this.offsetRecord = {};
		this.lineRecord = {};
		this.pointRecord = {};

		this.shaderCache = new Map();
		this.attributeCache = [];

		// @ifdef DEBUG
		Object.seal(this);
		// @endif
	}

	RendererRecord.prototype.invalidateBuffer = function (target) {
		this.currentBuffer[target].buffer = null;
		this.currentBuffer[target].valid = false;
	};

	module.exports = RendererRecord;

/***/ },
/* 125 */
/***/ function(module, exports, __webpack_require__) {

	var Texture = __webpack_require__(53);
	var MathUtils = __webpack_require__(9);
	var TextureHandler = __webpack_require__(126);
	var Ajax = __webpack_require__(132);
	var StringUtils = __webpack_require__(36);
	var PromiseUtils = __webpack_require__(54);
	var RSVP = __webpack_require__(55);

	//! AT: shouldn't this stay in util?

	/**
	 * Takes away the pain of creating textures of various sorts.
	 * @param {Settings} settings Texturing settings
	 */
	function TextureCreator() {
		var ajax = this.ajax = new Ajax();
		this.textureHandler = new TextureHandler(
			{},
			function (ref, options) {
				return ajax.load(ref, options ? options.noCache : false);
			},
			function () {},
			function (ref, options) {
				return ajax.load(ref, options ? options.noCache : false);
			}
		);
	}

	//! AT: unused?
	TextureCreator.UNSUPPORTED_FALLBACK = '.png';
	TextureCreator.clearCache = function () {};

	/**
	 * Releases any references to cached objects
	 */
	TextureCreator.prototype.clear = function () {
		this.ajax.clear();
		this.textureHandler.clear();
	};

	/**
	 * Creates a texture and loads an image into it.
	 * @param {string} imageUrl
	 * @param {Object} settings passed to the {Texture} constructor
	 * @returns {RSVP.Promise} Returns a promise that will resolve with the created Texture.
	 * @example
	 * new TextureCreator().loadTexture2D('goo.jpg').then(function (texture) {
	 *     material.setTexture('DIFFUSE_MAP', texture);
	 * }, function () {
	 *     console.error('Error loading image.');
	 * });
	 */
	TextureCreator.prototype.loadTexture2D = function (imageUrl, settings) {
		var id = StringUtils.createUniqueId('texture');
		settings = settings || {};
		settings.imageRef = imageUrl;

		var texture = this.textureHandler._create();
		this.textureHandler._objects.set(id, texture);
		return this.textureHandler.update(id, settings);
	};

	/**
	 * Creates a texture and loads a video into it
	 * @param {string} videoURL
	 * @param {Object} [options]
	 * @param {boolean} [options.loop=true]
	 * @param {boolean} [options.autoPlay=true]
	 * @param {boolean} [options.wrapS='EdgeClamp']
	 * @param {boolean} [options.wrapT='EdgeClamp']
	 * @returns {RSVP.Promise} Returns a promise that will resolve with the created Texture.
	 * @example
	 * new TextureCreator().loadTexture2D('goo.mp4').then(function (texture) {
	 *     material.setTexture('DIFFUSE_MAP', texture);
	 * }, function () {
	 *     console.error('Error loading video texture.');
	 * });
	 */
	TextureCreator.prototype.loadTextureVideo = function (videoURL, options) {
		var id = StringUtils.createUniqueId('texture');
		options = options || {};
		options.imageRef = videoURL;
		options.loop = options.loop !== undefined ? options.loop : true;
		options.wrapS = options.wrapS !== undefined ? options.wrapS : 'EdgeClamp';
		options.wrapT = options.wrapT !== undefined ? options.wrapT : 'EdgeClamp';
		options.autoPlay = options.autoPlay !== undefined ? options.autoPlay : true;
		options.texture = options.texture !== undefined ? options.texture : { dontwait: true };

		var texture = this.textureHandler._create();
		this.textureHandler._objects.set(id, texture);

		return this.textureHandler.update(id, options, options);
	};

	/**
	 * Creates a video texture streamed from the webcam.
	 * @returns {RSVP.Promise} A promise that will resolve with the created Texture.
	 * @example
	 * new TextureCreator().loadTextureWebCam().then(function (texture) {
	 *     material.setTexture('DIFFUSE_MAP', texture);
	 * }, function () {
	 *     console.error('Error loading webcam texture.');
	 * });
	 */
	TextureCreator.prototype.loadTextureWebCam = function () {

		return PromiseUtils.createPromise(function (resolve, reject) {
			var video = document.createElement('video');
			video.autoplay = true;
			video.loop = true;

			var texture = new Texture(video, {
				wrapS: 'EdgeClamp',
				wrapT: 'EdgeClamp'
			});

			texture.readyCallback = function () {
				if (video.readyState >= 3) {
					video.width = video.videoWidth;
					video.height = video.videoHeight;

					// set minification filter based on pow2
					if (!(MathUtils.isPowerOfTwo(video.width) && MathUtils.isPowerOfTwo(video.height))) {
						texture.generateMipmaps = false;
						texture.minFilter = 'BilinearNoMipMaps';
					}

					video.dataReady = true;

					return true;
				}

				return false;
			};

			texture.updateCallback = function () {
				return !video.paused;
			};

			// Webcam video
			window.URL = window.URL || window.webkitURL;
			navigator.getUserMedia = navigator.getUserMedia || navigator.webkitGetUserMedia || navigator.mozGetUserMedia || navigator.msGetUserMedia;
			if (navigator.getUserMedia) {
				navigator.getUserMedia({
					video: true
				}, function (stream) {
					video.src = window.URL.createObjectURL(stream);
					resolve(texture);
				}, reject);
			} else {
				reject(new Error('No support for WebCam getUserMedia found!'));
			}
		});
	};

	/**
	 * Loads an array of six images into a Texture.
	 * @param {Array} imageDataArray Array containing images, image elements or image urls. [left, right, bottom, top, back, front]
	 * @param {Object} settings Settings object to pass to the Texture constructor
	 * @returns {RSVP.Promise} A promise that will resolve with the resulting Texture
	 */
	TextureCreator.prototype.loadTextureCube = function (imageDataArray, settings) {
		var texture = new Texture(null, settings);
		texture.variant = 'CUBE';

		var promises = imageDataArray.map(function (queryImage) {
			return PromiseUtils.createPromise(function (resolve, reject) {
				if (typeof queryImage === 'string') {
					this.ajax._loadImage(queryImage).then(resolve, reject);
				} else {
					resolve(queryImage);
				}
			}.bind(this));
		}.bind(this));

		return RSVP.all(promises).then(function (images) {
			return PromiseUtils.createPromise(function (resolve, reject) {
				var width = images[0].width;
				var height = images[0].height;
				for (var i = 0; i < 6; i++) {
					var image = images[i];
					if (width !== image.width || height !== image.height) {
						texture.generateMipmaps = false;
						texture.minFilter = 'BilinearNoMipMaps';
						reject(new Error('The images passed to loadTextureCube() must be of the same size!'));
						return;
					}
				}

				texture.setImage(images);
				texture.image.dataReady = true;
				texture.image.width = width;
				texture.image.height = height;

				resolve(texture);
			});
		});
	};

	//! AT: unused
	TextureCreator._globalCallback = null;
	TextureCreator._finishedLoading = function (image) {
		if (TextureCreator._globalCallback) {
			try {
				TextureCreator._globalCallback(image);
			} catch (e) {
				console.error('Error in texture callback:', e);
			}
		}
	};

	// Add Object.freeze when fast enough in browsers
	var colorInfo = new Uint8Array([255, 255, 255, 255]);
	TextureCreator.DEFAULT_TEXTURE_2D = new Texture(colorInfo, null, 1, 1);
	TextureCreator.DEFAULT_TEXTURE_CUBE = new Texture([colorInfo, colorInfo, colorInfo, colorInfo, colorInfo, colorInfo], null, 1, 1);
	TextureCreator.DEFAULT_TEXTURE_CUBE.variant = 'CUBE';

	module.exports = TextureCreator;


/***/ },
/* 126 */
/***/ function(module, exports, __webpack_require__) {

	var ConfigHandler = __webpack_require__(85);
	var Texture = __webpack_require__(53);
	var DdsLoader = __webpack_require__(127);
	var CrunchLoader = __webpack_require__(129);
	var TgaLoader = __webpack_require__(130);
	var PromiseUtils = __webpack_require__(54);
	var ObjectUtils = __webpack_require__(6);
	var CanvasUtils = __webpack_require__(131);
	var StringUtils = __webpack_require__(36);
	var SystemBus = __webpack_require__(44);
	var MathUtils = __webpack_require__(9);

	/**
	 * Handler for loading materials into engine
	 * @extends ConfigHandler
	 * @param {World} world
	 * @param {Function} getConfig
	 * @param {Function} updateObject
	 * @private
	 */
	function TextureHandler() {
		ConfigHandler.apply(this, arguments);
		SystemBus.addListener('playStateChanged', function (playState) {
			this._objects.forEach(function (texture) {
				if (texture.image && texture.image.play && texture.image.pause) {
					var video = texture.image;
					if (playState === 'play') {
						video.play();
					} else if (playState === 'stop') {
						video.pause();
						video.currentTime = 0;
					} else if (playState === 'pause') {
						video.pause();
					}
				}
			});
		}.bind(this));
	}

	TextureHandler.prototype = Object.create(ConfigHandler.prototype);
	TextureHandler.prototype.constructor = TextureHandler;
	ConfigHandler._registerClass('texture', TextureHandler);

	TextureHandler.minFilters = [
		'NearestNeighborNoMipMaps',
		'NearestNeighborNearestMipMap',
		'NearestNeighborLinearMipMap',
		'BilinearNoMipMaps',
		'BilinearNearestMipMap',
		'Trilinear'
	];

	TextureHandler.magFilters = [
		'NearestNeighbor',
		'Bilinear'
	];

	TextureHandler.noMipMapAlternatives = {
		'NearestNeighborNoMipMaps': 'NearestNeighborNoMipMaps',
		'NearestNeighborNearestMipMap': 'NearestNeighborNoMipMaps',
		'NearestNeighborLinearMipMap': 'NearestNeighborNoMipMaps',
		'BilinearNoMipMaps': 'BilinearNoMipMaps',
		'BilinearNearestMipMap': 'BilinearNoMipMaps',
		'Trilinear': 'BilinearNoMipMaps'
	};

	TextureHandler.loaders = {
		dds: DdsLoader,
		crn: CrunchLoader, // TODO: not working atm.
		tga: TgaLoader
	};

	// Dummy textures to use while loading image
	TextureHandler.WHITE = new Uint8Array([255, 255, 255, 255]);
	TextureHandler.BLACK = new Uint8Array([0, 0, 0, 255]);

	/**
	 * Preparing texture config by populating it with defaults.
	 * @param {Object} config
	 * @private
	 */
	TextureHandler.prototype._prepare = function (config) {
		ObjectUtils.defaults(config, {
			wrapS: 'Repeat',
			wrapT: 'Repeat',
			magFilter: 'Bilinear',
			minFilter: 'Trilinear',
			anisotropy: 1,
			offset: [0, 0],
			repeat: [1, 1],
			flipY: true,
			lodBias: 0.0,
			loop: true
		});
	};

	/**
	 * Removes a texture
	 * @param {string} ref
	 * @private
	 */
	TextureHandler.prototype._remove = function (ref) {
		var texture = this._objects.get(ref);
		if (texture && this.world.gooRunner) {
			texture.destroy(this.world.gooRunner.renderer.context);
		}
		this._objects.delete(ref);
	};

	/**
	 * Creates an empty Texture.
	 * @returns {Texture}
	 * @private
	 */
	TextureHandler.prototype._create = function () {
		return new Texture();
	};


	TextureHandler.prototype._loadWebSupportedImage = function (texture, config, options) {
		return this.loadObject(config.imageRef, options).then(function (image) {
			if (texture.image !== image) {
				texture.setImage(image);
			}
			return texture;
		});
	};

	TextureHandler.prototype._loadSpecialImage = function (texture, config, type/*, options*/) {
		// Special (dds, tga, crn)
		var Loader = TextureHandler.loaders[type];
		var imageRef = config.imageRef;
		return this.loadObject(imageRef)
		.then(function (data) {
			if (data && data.preloaded) {
				ObjectUtils.extend(texture.image, data.image);
				texture.format = data.format;
				texture.setNeedsUpdate();
				return texture;
			}
			var loader = new Loader();
			loader.load(data, texture, config.flipY, 0, data.byteLength);
			return texture;
		});
	};

	TextureHandler.prototype._loadVideo = function (texture, config, options) {
		// Video
		return this.loadObject(config.imageRef, options).then(function (video) {
			video.width = video.videoWidth;
			video.height = video.videoHeight;
			video.loop = config.loop !== undefined ? config.loop : true;

			if (!(MathUtils.isPowerOfTwo(video.width) && MathUtils.isPowerOfTwo(video.height))) {
				texture.generateMipmaps = false;
				texture.minFilter = 'BilinearNoMipMaps';
			}
			texture.setImage(video);
			texture.updateCallback = function () {
				return !video.paused;
			};
			if (config.autoPlay !== false && !options.editMode) {
				video.play();
			}
			else {
				video.pause();
				video.currentTime = 0;
			}
			return texture;
		});
	};

	TextureHandler.prototype._loadImage = function (texture, config, options) {
		var imageRef = config.imageRef;
		var path = StringUtils.parseURL(imageRef).path;
		var type = path.substr(path.lastIndexOf('.') + 1).toLowerCase();
		if (TextureHandler.loaders[type]) {
			return this._loadSpecialImage(texture, config, type, options);
		}
		if (['jpg', 'jpeg', 'png', 'gif'].indexOf(type) !== -1) {
			return this._loadWebSupportedImage(texture, config, options);
		}
		if (['mp4', 'ogv', 'webm'].indexOf(type) !== -1) {
			return this._loadVideo(texture, config, options);
		}

		return PromiseUtils.reject(new Error('Unknown image type: ' + type));
	};

	/**
	 * Adds/updates/removes a texture
	 * @param {string} ref
	 * @param {Object} config
	 * @param {Object} options
	 * @returns {RSVP.Promise} Resolves with the updated texture or null if removed
	 */
	TextureHandler.prototype._update = function (ref, config, options) {
		var that = this;
		return ConfigHandler.prototype._update.call(this, ref, config, options).then(function (texture) {
			if (!texture) { return; }
			var ret;

			// Wrap
			if (texture.wrapS !== config.wrapS || texture.wrapT !== config.wrapT) {
				texture.setNeedsUpdate();
			}
			texture.wrapS = config.wrapS;
			texture.wrapT = config.wrapT;

			// SH: Why do we need to check this?
			if (TextureHandler.magFilters.indexOf(config.magFilter) !== -1) {
				texture.magFilter = config.magFilter;
			}
			if (TextureHandler.minFilters.indexOf(config.minFilter) !== -1) {
				texture.minFilter = config.generateMipmaps !== false ?
					config.minFilter :
					TextureHandler.noMipMapAlternatives[config.minFilter];
			}

			texture.anisotropy = Math.max(config.anisotropy, 1);

			texture.offset.setDirect(config.offset[0], config.offset[1]);
			texture.repeat.setDirect(config.repeat[0], config.repeat[1]);
			texture.lodBias = config.lodBias;

			if (texture.flipY !== config.flipY) {
				texture.flipY = config.flipY;
				texture.setNeedsUpdate();
			}

			if (texture.generateMipmaps !== config.generateMipmaps) {
				texture.generateMipmaps = config.generateMipmaps !== false;
				texture.setNeedsUpdate();
			}

			texture.updateCallback = null;

			if (config.imageRef) {
				if (!config.lazy) {
					ret = that._loadImage(texture, config, options);
				} else {
					texture.loadImage = function () {
						return that._loadImage(texture, config, options);
					};
					ret = texture;
				}
			} else if (config.svgData) {
				// Load SVG data
				ret = PromiseUtils.createPromise(function (resolve, reject) {
					CanvasUtils.renderSvgToCanvas(config.svgData, {}, function (canvas) {
						if (canvas) {
							texture.setImage(canvas);
							resolve(texture);
						} else {
							reject('could not render svg to canvas');
						}
					});
				});
			} else {
				// Blank
				// console.warn('Texture ' + ref + ' has no imageRef');
				// texture.setImage(TextureHandler.WHITE, 1, 1);
				ret = texture;
			}
			if (options && options.texture && options.texture.dontwait) {
				return texture;
			} else {
				return ret;
			}
		});
	};

	module.exports = TextureHandler;


/***/ },
/* 127 */
/***/ function(module, exports, __webpack_require__) {

	var DdsUtils = __webpack_require__(128);
	var Capabilities = __webpack_require__(17);

	function DdsPixelFormat() {
		this.dwSize = 0;
		this.dwFlags = 0;
		this.dwFourCC = 0;
		this.dwRGBBitCount = 0;
		this.dwRBitMask = 0;
		this.dwGBitMask = 0;
		this.dwBBitMask = 0;
		this.dwABitMask = 0;
	}

	DdsPixelFormat.HEADER_OFFSET = 19;

	// ---- VALUES USED IN dwFlags ----
	// Texture contains alpha data; dwABitMask contains valid data.
	DdsPixelFormat.DDPF_ALPHAPIXELS = 0x1;
	// Used in some older DDS files for alpha channel only uncompressed data (dwRGBBitCount contains the alpha channel
	// bitcount; dwABitMask contains valid data)
	DdsPixelFormat.DDPF_ALPHA = 0x2;
	// Texture contains compressed RGB data; dwFourCC contains valid data.
	DdsPixelFormat.DDPF_FOURCC = 0x4;
	// Texture contains uncompressed RGB data; dwRGBBitCount and the RGB masks (dwRBitMask, dwGBitMask, dwBBitMask)
	// contain valid data.
	DdsPixelFormat.DDPF_RGB = 0x40;
	// Used in some older DDS files for YUV uncompressed data (dwRGBBitCount contains the YUV bit count; dwRBitMask
	// contains the Y mask, dwGBitMask contains the U mask, dwBBitMask contains the V mask)
	DdsPixelFormat.DDPF_YUV = 0x200;
	// Used in some older DDS files for single channel color uncompressed data (dwRGBBitCount contains the luminance
	// channel bit count; dwRBitMask contains the channel mask). Can be combined with DDPF_ALPHAPIXELS for a two channel
	// DDS file.
	DdsPixelFormat.DDPF_LUMINANCE = 0x20000;
	// ---- /end VALUES USED IN dwFlags ----

	DdsPixelFormat.read = function (data) { // Int32Array
		var format = new DdsPixelFormat();
		format.dwSize = data[DdsPixelFormat.HEADER_OFFSET + 0];
		if (format.dwSize !== 32) {
			throw new Error('invalid pixel format size: ' + format.dwSize);
		}
		format.dwFlags = data[DdsPixelFormat.HEADER_OFFSET + 1];
		format.dwFourCC = data[DdsPixelFormat.HEADER_OFFSET + 2];
		format.dwRGBBitCount = data[DdsPixelFormat.HEADER_OFFSET + 3];
		format.dwRBitMask = data[DdsPixelFormat.HEADER_OFFSET + 4];
		format.dwGBitMask = data[DdsPixelFormat.HEADER_OFFSET + 5];
		format.dwBBitMask = data[DdsPixelFormat.HEADER_OFFSET + 6];
		format.dwABitMask = data[DdsPixelFormat.HEADER_OFFSET + 7];
		return format;
	};

	function DdsHeader() {
		this.dwSize = 0;
		this.dwFlags = 0;
		this.dwHeight = 0;
		this.dwWidth = 0;
		this.dwLinearSize = 0;
		this.dwDepth = 0;
		this.dwMipMapCount = 0;
		this.dwAlphaBitDepth = 0;
		this.dwReserved1 = [];
		this.ddpf = null;
		this.dwCaps = 0;
		this.dwCaps2 = 0;
		this.dwCaps3 = 0;
		this.dwCaps4 = 0;
		this.dwTextureStage = 0;
	}

	// Required caps flag.
	DdsHeader.DDSD_CAPS = 0x1;
	// Required caps flag.
	DdsHeader.DDSD_HEIGHT = 0x2;
	// Required caps flag.
	DdsHeader.DDSD_WIDTH = 0x4;
	// Required when pitch is provided for an uncompressed texture.
	DdsHeader.DDSD_PITCH = 0x8;
	// Required caps flag.
	DdsHeader.DDSD_PIXELFORMAT = 0x1000;
	// Required in a mipmapped texture.
	DdsHeader.DDSD_MIPMAPCOUNT = 0x20000;
	// Required when pitch is provided for a compressed texture.
	DdsHeader.DDSD_LINEARSIZE = 0x80000;
	// Required in a depth texture.
	DdsHeader.DDSD_DEPTH = 0x800000;
	// ---- /end VALUES USED IN dwFlags ----

	// ---- VALUES USED IN dwCaps ----
	// Optional; must be used on any file that contains more than one surface (a mipmap, a cubic environment map, or
	// volume texture).
	DdsHeader.DDSCAPS_COMPLEX = 0x8;
	// Optional; should be used for a mipmap.
	DdsHeader.DDSCAPS_MIPMAP = 0x400000;
	// Required caps flag.
	DdsHeader.DDSCAPS_TEXTURE = 0x1000;
	// ---- /end VALUES USED IN dwCaps ----

	// ---- VALUES USED IN dwCaps2 ----
	// Required for a cube map.
	DdsHeader.DDSCAPS2_CUBEMAP = 0x200;
	// Required when these surfaces are stored in a cube map.
	DdsHeader.DDSCAPS2_CUBEMAP_POSITIVEX = 0x400;
	// Required when these surfaces are stored in a cube map.
	DdsHeader.DDSCAPS2_CUBEMAP_NEGATIVEX = 0x800;
	// Required when these surfaces are stored in a cube map.
	DdsHeader.DDSCAPS2_CUBEMAP_POSITIVEY = 0x1000;
	// Required when these surfaces are stored in a cube map.
	DdsHeader.DDSCAPS2_CUBEMAP_NEGATIVEY = 0x2000;
	// Required when these surfaces are stored in a cube map.
	DdsHeader.DDSCAPS2_CUBEMAP_POSITIVEZ = 0x4000;
	// Required when these surfaces are stored in a cube map.
	DdsHeader.DDSCAPS2_CUBEMAP_NEGATIVEZ = 0x8000;
	// Required for a volume texture.
	DdsHeader.DDSCAPS2_VOLUME = 0x200000;
	// ---- /end VALUES USED IN dwCaps2 ----

	DdsHeader.read = function (data) { // Int32Array
		var header = new DdsHeader();
		header.dwSize = data[1];
		if (header.dwSize !== 124) {
			throw new Error('invalid dds header size: ' + header.dwSize);
		}
		header.dwFlags = data[2];
		header.dwHeight = data[3];
		header.dwWidth = data[4];
		header.dwLinearSize = data[5];
		header.dwDepth = data[6];
		header.dwMipMapCount = data[7];
		header.dwAlphaBitDepth = data[8];
		for (var i = 0; i < header.dwReserved1.length; i++) {
			header.dwReserved1[i] = data[9 + i];
		}
		header.ddpf = DdsPixelFormat.read(data);
		header.dwCaps = data[27];
		header.dwCaps2 = data[28];
		header.dwCaps3 = data[29];
		header.dwCaps4 = data[30];
		header.dwTextureStage = data[31];

		var expectedMipmaps = 1 + Math.ceil(Math.log(Math.max(header.dwHeight, header.dwWidth)) / Math.log(2));

		if (DdsUtils.isSet(header.dwCaps, DdsHeader.DDSCAPS_MIPMAP)) {
			if (!DdsUtils.isSet(header.dwFlags, DdsHeader.DDSD_MIPMAPCOUNT)) {
				header.dwMipMapCount = expectedMipmaps;
			} else if (header.dwMipMapCount !== expectedMipmaps) {
				console.warn('Got ' + header.dwMipMapCount + ' mipmaps, expected ' + expectedMipmaps);
			}
		} else {
			header.dwMipMapCount = 1;
		}

		return header;
	};

	function DdsImageInfo() {
		this.flipVertically = false;
		this.bpp = 0;
		this.header = null;
		this.headerDX10 = null;
		this.mipmapByteSizes = [];
	}

	DdsImageInfo.prototype.calcMipmapSizes = function (compressed) {
		var width = this.header.dwWidth;
		var height = this.header.dwHeight;
		var size = 0;

		for (var i = 0; i < this.header.dwMipMapCount; i++) {
			size = compressed ? ~~((width + 3) / 4) * ~~((height + 3) / 4) * this.bpp * 2 : ~~(width * height * this.bpp / 8);
			this.mipmapByteSizes.push(~~((size + 3) / 4) * 4);
			width = ~~(width / 2) > 1 ? ~~(width / 2) : 1;
			height = ~~(height / 2) > 1 ? ~~(height / 2) : 1;
		}
	};

	/**
	 * Loads dds format images into a format usable by Goo.
	 * @private
	 */
	function DdsLoader() {
	}

	DdsLoader.updateDepth = function (image, info) {
		if (DdsUtils.isSet(info.header.dwCaps2, DdsHeader.DDSCAPS2_CUBEMAP)) {
			var depth = 0;
			if (DdsUtils.isSet(info.header.dwCaps2, DdsHeader.DDSCAPS2_CUBEMAP_POSITIVEX)) {
				depth++;
			}
			if (DdsUtils.isSet(info.header.dwCaps2, DdsHeader.DDSCAPS2_CUBEMAP_NEGATIVEX)) {
				depth++;
			}
			if (DdsUtils.isSet(info.header.dwCaps2, DdsHeader.DDSCAPS2_CUBEMAP_POSITIVEY)) {
				depth++;
			}
			if (DdsUtils.isSet(info.header.dwCaps2, DdsHeader.DDSCAPS2_CUBEMAP_NEGATIVEY)) {
				depth++;
			}
			if (DdsUtils.isSet(info.header.dwCaps2, DdsHeader.DDSCAPS2_CUBEMAP_POSITIVEZ)) {
				depth++;
			}
			if (DdsUtils.isSet(info.header.dwCaps2, DdsHeader.DDSCAPS2_CUBEMAP_NEGATIVEZ)) {
				depth++;
			}

			if (depth !== 6) {
				throw new Error('Cubemaps without all faces defined are not currently supported.');
			}

			image.depth = depth;
		} else {
			// make sure we have at least depth of 1.
			image.depth = (info.header.dwDepth > 0 ? info.header.dwDepth : 1);
		}
	};

	DdsLoader.readDXT = function (imgData, totalSize, info, texture) {
		texture.image.isCompressed = true;

		if (!info.flipVertically) {
			return new Uint8Array(imgData.buffer, imgData.byteOffset + 0, totalSize);
		}

		// NB: since UNPACK_FLIP_Y_WEBGL doesn't handle compressed textures, we have to do it manually.
		var mipWidth = info.header.dwWidth;
		var mipHeight = info.header.dwHeight;

		// flip!
		var rVal = new Uint8Array(totalSize);
		var offset = 0;
		for (var mip = 0; mip < info.header.dwMipMapCount; mip++) {
			var data = imgData.subarray(offset, offset + info.mipmapByteSizes[mip]);

			var flipped = DdsUtils.flipDXT(data, mipWidth, mipHeight, texture.format);
			rVal.set(flipped, offset);
			offset += flipped.length;

			mipWidth = ~~(mipWidth / 2) > 1 ? ~~(mipWidth / 2) : 1;
			mipHeight = ~~(mipHeight / 2) > 1 ? ~~(mipHeight / 2) : 1;
		}
		return rVal;
	};

	DdsLoader.readUncompressed = function (imgData, totalSize, useRgb, useLum, useAlpha, useAlphaPixels, info, texture) {
		var redLumShift = DdsUtils.shiftCount(info.header.ddpf.dwRBitMask);
		var greenShift = DdsUtils.shiftCount(info.header.ddpf.dwGBitMask);
		var blueShift = DdsUtils.shiftCount(info.header.ddpf.dwBBitMask);
		var alphaShift = DdsUtils.shiftCount(info.header.ddpf.dwABitMask);

		var sourcebytesPP = ~~(info.header.ddpf.dwRGBBitCount / 8);
		var targetBytesPP = DdsUtils.getComponents(texture.format) * 1; // 1 byte per unsignedbyte store

		var rVal = new Uint8Array(totalSize);

		var mipWidth = info.header.dwWidth;
		var mipHeight = info.header.dwHeight;
		var dstOffset = 0, srcOffset = 0;
		var i = 0;
		var b = [];
		for (i = 0; i < sourcebytesPP; i++) {
			b.push(0);
		}

		for (var mip = 0; mip < info.header.dwMipMapCount; mip++) {
			for (var y = 0; y < mipHeight; y++) {
				for (var x = 0; x < mipWidth; x++) {
					for (i = 0; i < sourcebytesPP; i++) {
						b[i] = imgData[srcOffset++];
					}

					i = DdsUtils.getIntFromBytes(b);

					var redLum = ((i & info.header.ddpf.dwRBitMask) >> redLumShift);
					var green = ((i & info.header.ddpf.dwGBitMask) >> greenShift);
					var blue = ((i & info.header.ddpf.dwBBitMask) >> blueShift);
					var alpha = ((i & info.header.ddpf.dwABitMask) >> alphaShift);

					// Uncompressed, so handled by UNPACK_FLIP_Y_WEBGL instead.
					// if (info.flipVertically) {
					// dstOffset = ((mipHeight - y - 1) * mipWidth + x) * targetBytesPP;
					// }

					if (useAlpha) {
						rVal[dstOffset++] = alpha;
					} else if (useLum) {
						rVal[dstOffset++] = redLum;
						if (useAlphaPixels) {
							rVal[dstOffset++] = alpha;
						}
					} else if (useRgb) {
						rVal[dstOffset++] = redLum;
						rVal[dstOffset++] = green;
						rVal[dstOffset++] = blue;
						if (useAlphaPixels) {
							rVal[dstOffset++] = alpha;
						}
					}
				}
			}

			dstOffset += mipWidth * mipHeight * targetBytesPP;

			mipWidth = ~~(mipWidth / 2) > 1 ? ~~(mipWidth / 2) : 1;
			mipHeight = ~~(mipHeight / 2) > 1 ? ~~(mipHeight / 2) : 1;
		}

		return rVal;
	};

	DdsLoader.populate = function (texture, info, data) {
		var flags = info.header.ddpf.dwFlags;

		var compressedFormat = DdsUtils.isSet(flags, DdsPixelFormat.DDPF_FOURCC);
		var rgb = DdsUtils.isSet(flags, DdsPixelFormat.DDPF_RGB);
		var alphaPixels = DdsUtils.isSet(flags, DdsPixelFormat.DDPF_ALPHAPIXELS);
		var lum = DdsUtils.isSet(flags, DdsPixelFormat.DDPF_LUMINANCE);
		var alpha = DdsUtils.isSet(flags, DdsPixelFormat.DDPF_ALPHA);
		texture.type = 'UnsignedByte';

		if (compressedFormat) {
			var fourCC = info.header.ddpf.dwFourCC;
			// DXT1 format
			if (fourCC === DdsUtils.getIntFromString('DXT1')) {
				info.bpp = 4;
				// if (isSet(flags, DdsPixelFormat.DDPF_ALPHAPIXELS)) {
				// XXX: many authoring tools do not set alphapixels, so we'll error on the side of alpha
	//				console.info('DDS format: DXT1A');
				texture.format = 'PrecompressedDXT1A';
				// } else {
				// logger.finest('DDS format: DXT1');
				// texture.setDataFormat(ImageDataFormat.PrecompressedDXT1);
				// }
			}

			// DXT3 format
			else if (fourCC === DdsUtils.getIntFromString('DXT3')) {
	//				console.info('DDS format: DXT3');
				info.bpp = 8;
				texture.format = 'PrecompressedDXT3';
			}

			// DXT5 format
			else if (fourCC === DdsUtils.getIntFromString('DXT5')) {
	//				console.info('DDS format: DXT5');
				info.bpp = 8;
				texture.format = 'PrecompressedDXT5';
			}

			// DXT10 info present...
			else if (fourCC === DdsUtils.getIntFromString('DX10')) {
				// switch (info.headerDX10.dxgiFormat) {
				// case DXGI_FORMAT_BC4_UNORM:
				// console.info('DXGI format: BC4_UNORM');
				// info.bpp = 4;
				// texture.setDataFormat(ImageDataFormat.PrecompressedLATC_L);
				// break;
				// case DXGI_FORMAT_BC5_UNORM:
				// console.info('DXGI format: BC5_UNORM');
				// info.bpp = 8;
				// texture.setDataFormat(ImageDataFormat.PrecompressedLATC_LA);
				// break;
				// default:
				// throw new Error('dxgiFormat not supported: ' + info.headerDX10.dxgiFormat);
				// }
				throw new Error('dxt10 LATC formats not supported currently: ' + info.headerDX10.dxgiFormat);
			}

			// DXT2 format - unsupported
			else if (fourCC === DdsUtils.getIntFromString('DXT2')) {
				throw new Error('DXT2 is not supported.');
			}

			// DXT4 format - unsupported
			else if (fourCC === DdsUtils.getIntFromString('DXT4')) {
				throw new Error('DXT4 is not supported.');
			}

			// Unsupported compressed type.
			else {
				throw new Error('unsupported compressed dds format found (' + fourCC + ')');
			}
		}

		// not a compressed format
		else {
			// TODO: more use of bit masks?
			// TODO: Use bit size instead of hardcoded 8 bytes? (need to also implement in readUncompressed)

			info.bpp = info.header.ddpf.dwRGBBitCount;

			// One of the RGB formats?
			if (rgb) {
				if (alphaPixels) {
	//					console.info('DDS format: uncompressed rgba');
					texture.format = 'RGBA';
				} else {
	//					console.info('DDS format: uncompressed rgb ');
					texture.format = 'RGB';
				}
			}

			// A luminance or alpha format
			else if (lum || alphaPixels) {
				if (lum && alphaPixels) {
	//					console.info('DDS format: uncompressed LumAlpha');
					texture.format = 'LuminanceAlpha';
				}

				else if (lum) {
	//					console.info('DDS format: uncompressed Lum');
					texture.format = 'Luminance';
				}

				else if (alpha) {
	//					console.info('DDS format: uncompressed Alpha');
					texture.format = 'Alpha';
				}
			} // end luminance/alpha type

			// Unsupported type.
			else {
				throw new Error('unsupported uncompressed dds format found.');
			}
		}

		info.calcMipmapSizes(compressedFormat);
		texture.image.mipmapSizes = (info.mipmapByteSizes);

		// Add up total byte size of single depth layer
		var totalSize = 0;
		for (var i = 0; i < info.mipmapByteSizes.length; i++) {
			totalSize += info.mipmapByteSizes[i];
		}

		// Go through and load in image data
		var imageData = [];
		for (var i = 0; i < texture.image.depth; i++) {
			// read in compressed data
			if (compressedFormat) {
				imageData.push(DdsLoader.readDXT(data, totalSize, info, texture));
			}

			// read in uncompressed data
			else if (rgb || lum || alpha) {
				imageData.push(DdsLoader.readUncompressed(data, totalSize, rgb, lum, alpha, alphaPixels, info, texture));
			}
		}

		// set on image
		texture.image.data = texture.image.depth === 1 ? imageData[0] : imageData;
		texture.image.useArrays = true;
	};

	DdsLoader.prototype.load = function (buffer, tex, flipped, arrayByteOffset, arrayByteLength) {
		var header = new Int32Array(buffer, arrayByteOffset + 0, 32);

		// Read and check magic word...
		var dwMagic = header[0];
		if (dwMagic !== DdsUtils.getIntFromString('DDS ')) {
			throw new Error('Not a dds file.');
		}
	//		console.info('Reading DDS file.');

		// Create our data store;
		var info = new DdsImageInfo();

		info.flipVertically = flipped;

		// Read standard dds header
		info.header = DdsHeader.read(header);

		// if applicable, read DX10 header
		info.headerDX10 = info.header.ddpf.dwFourCC === DdsUtils.getIntFromString('DX10') ? DdsHeader.read(Int32Array.create(buffer,
			arrayByteOffset + 128, 5)) : null;

		// Create our new image
		var image = tex.image;
		if (typeof image === 'undefined' || image === null) {
			image = {};
			tex.image = image;
		}
		image.width = info.header.dwWidth;
		image.height = info.header.dwHeight;

		// update depth based on flags / header
		DdsLoader.updateDepth(image, info);

		// add our format and image data.
		var contentOffset = 128 + (info.headerDX10 ? 20 : 0);
		DdsLoader.populate(tex, info, new Uint8Array(buffer, arrayByteOffset + contentOffset, arrayByteLength - contentOffset));

		if (!info.mipmapByteSizes || info.mipmapByteSizes.length < 2) {
			tex.minFilter = 'BilinearNoMipMaps';
		}

		image.bpp = info.bpp;
		image.dataReady = true;
		image.isData = true;
		tex.needsUpdate = true;
	};

	DdsLoader.prototype.isSupported = function () {
		return !!Capabilities.CompressedTextureS3TC;
	};

	DdsLoader.prototype.toString = function () {
		return 'DdsLoader';
	};

	module.exports = DdsLoader;

/***/ },
/* 128 */
/***/ function(module, exports, __webpack_require__) {

	var Capabilities = __webpack_require__(17);

	function DdsUtils() {}

	DdsUtils.isSupported = function () {
		return !!Capabilities.CompressedTextureS3TC;
	};

	/**
	 * Get the necessary bit shifts needed to align mask with 0.
	 * @param mask the bit mask to test
	 * @returns number of bits to shift to the right to align mask with 0.
	 */
	DdsUtils.shiftCount = function (mask) {
		if (mask === 0) {
			return 0;
		}

		var i = 0;
		while ((mask & 0x1) === 0) {
			mask >>= 1;
			i++;
			if (i > 32) {
				throw new Error('invalid mask!');
			}
		}

		return i;
	};

	/**
	 * Check a value against a bit mask to see if it is set.
	 * @param value the value to check
	 * @param bitMask our mask
	 * @returns true if the mask passes
	 */
	DdsUtils.isSet = function (value, bitMask) {
		return (value & bitMask) === bitMask;
	};

	/**
	 * Get the string as a dword int value.
	 * @param string our string... should only be 1-4 chars long. Expected to be 1 byte chars.
	 * @returns the int value
	 */
	DdsUtils.getIntFromString = function (string) {
		var bytes = [];
		for (var i = 0; i < string.length; i++) {
			bytes[i] = string.charCodeAt(i);
		}
		return DdsUtils.getIntFromBytes(bytes);
	};

	/**
	 * Get the byte array as a dword int value.
	 * @param bytes our array... should only be 1-4 bytes long.
	 * @returns the int value
	 */
	DdsUtils.getIntFromBytes = function (bytes) {
		var rVal = 0;
		rVal |= (bytes[0] & 0xff) << 0;
		if (bytes.length > 1) {
			rVal |= (bytes[1] & 0xff) << 8;
		}
		if (bytes.length > 2) {
			rVal |= (bytes[2] & 0xff) << 16;
		}
		if (bytes.length > 3) {
			rVal |= (bytes[3] & 0xff) << 24;
		}
		return rVal;
	};

	DdsUtils.getComponents = function (format) {
		switch (format) {
			case 'Alpha':
				return 1;
			case 'RGB':
				return 3;
			case 'RGBA':
				return 4;
			case 'Luminance':
				return 1;
			case 'LuminanceAlpha':
				return 2;
			case 'PrecompressedDXT1':
				return 1;
			case 'PrecompressedDXT1A':
				return 1;
			case 'PrecompressedDXT3':
				return 2;
			case 'PrecompressedDXT5':
				return 2;
		}
		return 0;
	};

	/**
	 * Flip a dxt mipmap/image. Inspired by similar code in opentk and the nvidia sdk.
	 * @param rawData our unflipped image as raw bytes
	 * @param width our image's width
	 * @param height our image's height
	 * @param format our image's format
	 * @returns the flipped image as raw bytes.
	 */
	DdsUtils.flipDXT = function (rawData, width, height, format) {
		var returnData = new Uint8Array(rawData.length);

		var blocksPerColumn = width + 3 >> 2;
		var blocksPerRow = height + 3 >> 2;
		var bytesPerBlock = DdsUtils.getComponents(format) * 8;

		for (var sourceRow = 0; sourceRow < blocksPerRow; sourceRow++) {
			var targetRow = blocksPerRow - sourceRow - 1;
			for (var column = 0; column < blocksPerColumn; column++) {
				var target = (targetRow * blocksPerColumn + column) * bytesPerBlock;
				var source = (sourceRow * blocksPerColumn + column) * bytesPerBlock;
				switch (format) {
					case 'PrecompressedDXT1':
					case 'PrecompressedDXT1A':
						// case PrecompressedLATC_L:
						returnData[target + 0] = rawData[source + 0];
						returnData[target + 1] = rawData[source + 1];
						returnData[target + 2] = rawData[source + 2];
						returnData[target + 3] = rawData[source + 3];
						returnData[target + 4] = rawData[source + 7];
						returnData[target + 5] = rawData[source + 6];
						returnData[target + 6] = rawData[source + 5];
						returnData[target + 7] = rawData[source + 4];
						break;
					case 'PrecompressedDXT3':
						// Alpha
						returnData[target + 0] = rawData[source + 6];
						returnData[target + 1] = rawData[source + 7];
						returnData[target + 2] = rawData[source + 4];
						returnData[target + 3] = rawData[source + 5];
						returnData[target + 4] = rawData[source + 2];
						returnData[target + 5] = rawData[source + 3];
						returnData[target + 6] = rawData[source + 0];
						returnData[target + 7] = rawData[source + 1];
						// Color
						returnData[target + 8] = rawData[source + 8];
						returnData[target + 9] = rawData[source + 9];
						returnData[target + 10] = rawData[source + 10];
						returnData[target + 11] = rawData[source + 11];
						returnData[target + 12] = rawData[source + 15];
						returnData[target + 13] = rawData[source + 14];
						returnData[target + 14] = rawData[source + 13];
						returnData[target + 15] = rawData[source + 12];
						break;
					case 'PrecompressedDXT5':
						// Alpha, the first 2 bytes remain
						returnData[target + 0] = rawData[source + 0];
						returnData[target + 1] = rawData[source + 1];

						// extract 3 bits each and flip them
						DdsUtils.getBytesFromUInt24(returnData, target + 5, DdsUtils.flipUInt24(DdsUtils.getUInt24(rawData, source + 2)));
						DdsUtils.getBytesFromUInt24(returnData, target + 2, DdsUtils.flipUInt24(DdsUtils.getUInt24(rawData, source + 5)));

						// Color
						returnData[target + 8] = rawData[source + 8];
						returnData[target + 9] = rawData[source + 9];
						returnData[target + 10] = rawData[source + 10];
						returnData[target + 11] = rawData[source + 11];
						returnData[target + 12] = rawData[source + 15];
						returnData[target + 13] = rawData[source + 14];
						returnData[target + 14] = rawData[source + 13];
						returnData[target + 15] = rawData[source + 12];
						break;
					// case PrecompressedLATC_LA:
					// // alpha
					// System.arraycopy(rawData, source, returnData, target, 4);
					// returnData[target + 4] = rawData[source + 7];
					// returnData[target + 5] = rawData[source + 6];
					// returnData[target + 6] = rawData[source + 5];
					// returnData[target + 7] = rawData[source + 4];
					//
					// // Color
					// System.arraycopy(rawData, source + 8, returnData, target + 8, 4);
					// returnData[target + 12] = rawData[source + 15];
					// returnData[target + 13] = rawData[source + 14];
					// returnData[target + 14] = rawData[source + 13];
					// returnData[target + 15] = rawData[source + 12];
					// break;
				}
			}
		}
		return returnData;
	};

	// DXT5 Alpha block flipping, inspired by code from Evan Hart (nVidia SDK)
	DdsUtils.getUInt24 = function (input, offset) {
		var result = 0;
		result |= (input[offset + 0] & 0xff) << 0;
		result |= (input[offset + 1] & 0xff) << 8;
		result |= (input[offset + 2] & 0xff) << 16;
		return result;
	};

	DdsUtils.getBytesFromUInt24 = function (input, offset, uint24) {
		input[offset + 0] = (uint24 & 0x000000ff);
		input[offset + 1] = ((uint24 & 0x0000ff00) >> 8);
		input[offset + 2] = ((uint24 & 0x00ff0000) >> 16);
	};

	DdsUtils.ThreeBitMask = 0x7;

	DdsUtils.flipUInt24 = function (uint24) {
		var threeBits = [];
		for (var i = 0; i < 2; i++) {
			threeBits.push([0, 0, 0, 0]);
		}

		// extract 3 bits each into the array
		threeBits[0][0] = (uint24 & DdsUtils.ThreeBitMask);
		uint24 >>= 3;
		threeBits[0][1] = (uint24 & DdsUtils.ThreeBitMask);
		uint24 >>= 3;
		threeBits[0][2] = (uint24 & DdsUtils.ThreeBitMask);
		uint24 >>= 3;
		threeBits[0][3] = (uint24 & DdsUtils.ThreeBitMask);
		uint24 >>= 3;
		threeBits[1][0] = (uint24 & DdsUtils.ThreeBitMask);
		uint24 >>= 3;
		threeBits[1][1] = (uint24 & DdsUtils.ThreeBitMask);
		uint24 >>= 3;
		threeBits[1][2] = (uint24 & DdsUtils.ThreeBitMask);
		uint24 >>= 3;
		threeBits[1][3] = (uint24 & DdsUtils.ThreeBitMask);

		// stuff 8x 3bits into 3 bytes
		var result = 0;
		result |= threeBits[1][0] << 0;
		result |= threeBits[1][1] << 3;
		result |= threeBits[1][2] << 6;
		result |= threeBits[1][3] << 9;
		result |= threeBits[0][0] << 12;
		result |= threeBits[0][1] << 15;
		result |= threeBits[0][2] << 18;
		result |= threeBits[0][3] << 21;
		return result;
	};

	module.exports = DdsUtils;

/***/ },
/* 129 */
/***/ function(module, exports, __webpack_require__) {

	/*
	 * Copyright (c) 2012 Brandon Jones
	 *
	 * This software is provided 'as-is', without any express or implied
	 * warranty. In no event will the authors be held liable for any damages
	 * arising from the use of this software.
	 *
	 * Permission is granted to anyone to use this software for any purpose,
	 * including commercial applications, and to alter it and redistribute it
	 * freely, subject to the following restrictions:
	 *
	 *    1. The origin of this software must not be misrepresented; you must not
	 *    claim that you wrote the original software. If you use this software
	 *    in a product, an acknowledgment in the product documentation would be
	 *    appreciated but is not required.
	 *
	 *    2. Altered source versions must be plainly marked as such, and must not
	 *    be misrepresented as being the original software.
	 *
	 *    3. This notice may not be removed or altered from any source
	 *    distribution.
	 */

	__webpack_require__(127); // needed?
	var DdsUtils = __webpack_require__(128);
	var Capabilities = __webpack_require__(17);

	/**
	 * @private
	 */
	function CrunchLoader() {
	}

	CrunchLoader.cCRNFmtDXT1 = 0;
	CrunchLoader.cCRNFmtDXT3 = 1;
	CrunchLoader.cCRNFmtDXT5 = 2;

	CrunchLoader.prototype.arrayBufferCopy = function (src, dst, dstByteOffset, numBytes) {
		var dst32Offset = dstByteOffset / 4,
			tail = (numBytes % 4),
			src32 = new Uint32Array(src.buffer, 0, (numBytes - tail) / 4),
			dst32 = new Uint32Array(dst.buffer),
			i;

		for (i = 0; i < src32.length; i++) {
			dst32[dst32Offset + i] = src32[i];
		}
		for (i = numBytes - tail; i < numBytes; i++) {
			dst[dstByteOffset + i] = src[i];
		}
	};

	CrunchLoader.prototype.load = function (arrayBuffer, texture, flipped/*, arrayByteOffset, arrayByteLength*/) {
		if (typeof (window.CrunchModule) === 'undefined') {
			console.warn('Crunch library not loaded! Include a script tag pointing to lib/crunch/crunch.js in your html-file.');
			return;
		}

		var CrunchModule = window.CrunchModule;

		var bytes = new Uint8Array(arrayBuffer),
			srcSize = arrayBuffer.byteLength,
			src = CrunchModule._malloc(srcSize),
			format, dst, dstSize,
			width, height, levels, dxtData, i;

		this.arrayBufferCopy(bytes, CrunchModule.HEAPU8, src, srcSize);

		format = CrunchModule._crn_get_dxt_format(src, srcSize);

		var bpp;
		switch (format) {
			case CrunchLoader.cCRNFmtDXT1:
				texture.format = 'PrecompressedDXT1A';
				bpp = 4;
				break;
			case CrunchLoader.cCRNFmtDXT3:
				texture.format = 'PrecompressedDXT3';
				bpp = 8;
				break;
			case CrunchLoader.cCRNFmtDXT5:
				texture.format = 'PrecompressedDXT5';
				bpp = 8;
				break;
			default:
				console.error('Unsupported image format');
				return 0;
		}

		width = CrunchModule._crn_get_width(src, srcSize);
		height = CrunchModule._crn_get_height(src, srcSize);
		levels = CrunchModule._crn_get_levels(src, srcSize);
		dstSize = CrunchModule._crn_get_uncompressed_size(src, srcSize, 0);
		dst = CrunchModule._malloc(dstSize);

		var image = texture.image;
		if (typeof image === 'undefined' || image === null) {
			image = {};
			texture.image = image;
		}

		image.width = width;
		image.height = height;
		image.depth = 1;

		var imageData = [];
		texture.image.mipmapSizes = [];
		for (i = 0; i < levels; ++i) {
			if (i) {
				dstSize = CrunchModule._crn_get_uncompressed_size(src, srcSize, i);
			}
			CrunchModule._crn_decompress(src, srcSize, dst, dstSize, i);
			dxtData = new Uint8Array(CrunchModule.HEAPU8.buffer, dst, dstSize);
			if (flipped) {
				dxtData = DdsUtils.flipDXT(dxtData, width, height, texture.format);
			}

			imageData.push(dxtData);
			texture.image.mipmapSizes.push(dstSize);

			width *= 0.5;
			height *= 0.5;
		}

		texture.image.data = imageData;
		texture.image.useArrays = true;
		texture.type = 'UnsignedByte';
		texture.image.isCompressed = true;

		if (levels <= 1) {
			texture.minFilter = 'BilinearNoMipMaps';
		}

		image.bpp = bpp;
		image.dataReady = true;
		image.isData = true;
		texture.needsUpdate = true;

		CrunchModule._free(src);
		CrunchModule._free(dst);
	};

	/**
	 * Transcodes DXT into RGB565.
	 * Optimizations:
	 * 1. Use integer math to compute c2 and c3 instead of floating point
	 *    math.  Specifically:
	 *      c2 = 5/8 * c0 + 3/8 * c1
	 *      c3 = 3/8 * c0 + 5/8 * c1
	 *    This is about a 40% performance improvement.  It also appears to
	 *    match what hardware DXT decoders do, as the colors produced
	 *    by this integer math match what hardware produces, while the
	 *    floating point in dxtToRgb565Unoptimized() produce slightly
	 *    different colors (for one GPU this was tested on).
	 * 2. Unroll the inner loop.  Another ~10% improvement.
	 * 3. Compute r0, g0, b0, r1, g1, b1 only once instead of twice.
	 *    Another 10% improvement.
	 * 4. Use a Uint16Array instead of a Uint8Array.  Another 10% improvement.
	 * @author Evan Parker
	 * @param {Uint16Array} src The src DXT bits as a Uint16Array.
	 * @param {number} srcByteOffset
	 * @param {number} width
	 * @param {number} height
	 * @returns {Uint16Array} dst
	 */
	CrunchLoader.prototype.dxtToRgb565 = function (src, src16Offset, width, height) {
		var c = new Uint16Array(4);
		var dst = new Uint16Array(width * height);
		// var nWords = (width * height) / 4;
		var m = 0;
		var dstI = 0;
		var i = 0;
		var r0 = 0,
			g0 = 0,
			b0 = 0,
			r1 = 0,
			g1 = 0,
			b1 = 0;

		var blockWidth = width / 4;
		var blockHeight = height / 4;
		for (var blockY = 0; blockY < blockHeight; blockY++) {
			for (var blockX = 0; blockX < blockWidth; blockX++) {
				i = src16Offset + 4 * (blockY * blockWidth + blockX);
				c[0] = src[i];
				c[1] = src[i + 1];
				r0 = c[0] & 0x1f;
				g0 = c[0] & 0x7e0;
				b0 = c[0] & 0xf800;
				r1 = c[1] & 0x1f;
				g1 = c[1] & 0x7e0;
				b1 = c[1] & 0xf800;
				// Interpolate between c0 and c1 to get c2 and c3.
				// Note that we approximate 1/3 as 3/8 and 2/3 as 5/8 for
				// speed.  This also appears to be what the hardware DXT
				// decoder in many GPUs does :)
				c[2] = ((5 * r0 + 3 * r1) >> 3) | (((5 * g0 + 3 * g1) >> 3) & 0x7e0) | (((5 * b0 + 3 * b1) >> 3) & 0xf800);
				c[3] = ((5 * r1 + 3 * r0) >> 3) | (((5 * g1 + 3 * g0) >> 3) & 0x7e0) | (((5 * b1 + 3 * b0) >> 3) & 0xf800);
				m = src[i + 2];
				dstI = (blockY * 4) * width + blockX * 4;
				dst[dstI] = c[m & 0x3];
				dst[dstI + 1] = c[(m >> 2) & 0x3];
				dst[dstI + 2] = c[(m >> 4) & 0x3];
				dst[dstI + 3] = c[(m >> 6) & 0x3];
				dstI += width;
				dst[dstI] = c[(m >> 8) & 0x3];
				dst[dstI + 1] = c[(m >> 10) & 0x3];
				dst[dstI + 2] = c[(m >> 12) & 0x3];
				dst[dstI + 3] = c[(m >> 14)];
				m = src[i + 3];
				dstI += width;
				dst[dstI] = c[m & 0x3];
				dst[dstI + 1] = c[(m >> 2) & 0x3];
				dst[dstI + 2] = c[(m >> 4) & 0x3];
				dst[dstI + 3] = c[(m >> 6) & 0x3];
				dstI += width;
				dst[dstI] = c[(m >> 8) & 0x3];
				dst[dstI + 1] = c[(m >> 10) & 0x3];
				dst[dstI + 2] = c[(m >> 12) & 0x3];
				dst[dstI + 3] = c[(m >> 14)];
			}
		}
		return dst;
	};

	CrunchLoader.prototype.isSupported = function () {
		return !!Capabilities.CompressedTextureS3TC;
	};

	CrunchLoader.prototype.toString = function () {
		return 'CrunchLoader';
	};

	module.exports = CrunchLoader;

/***/ },
/* 130 */
/***/ function(module, exports) {

	/**
	 * @private
	 */
	function TgaLoader() {
		this.header = null;
		this.offset = 0;
		this.use_rle = false;
		this.use_pal = false;
		this.use_rgb = false;
		this.use_grey = false;
	}

	// TGA Constants
	TgaLoader.TYPE_NO_DATA = 0;
	TgaLoader.TYPE_INDEXED = 1;
	TgaLoader.TYPE_RGB = 2;
	TgaLoader.TYPE_GREY = 3;
	TgaLoader.TYPE_RLE_INDEXED = 9;
	TgaLoader.TYPE_RLE_RGB = 10;
	TgaLoader.TYPE_RLE_GREY = 11;

	TgaLoader.ORIGIN_MASK = 0x30;
	TgaLoader.ORIGIN_SHIFT = 0x04;
	TgaLoader.ORIGIN_BL = 0x00;
	TgaLoader.ORIGIN_BR = 0x01;
	TgaLoader.ORIGIN_UL = 0x02;
	TgaLoader.ORIGIN_UR = 0x03;


	/**
	 * Load and parse a TGA file
	 */
	TgaLoader.prototype.load = function (buffer, tex/*, flipped, arrayByteOffset, arrayByteLength*/) {
		this.loadData(new Uint8Array(buffer));
		var imageData = this.getCanvas();
		tex.setImage(imageData, imageData.width, imageData.height);
		//imageData.isData = true;
		imageData.dataReady = true;
		tex.needsUpdate = true;
	};

	/**
	 * Parse TGA data
	 *
	 * @param {Uint8Array} data - Binary data of the TGA file
	 */
	TgaLoader.prototype.loadData = function (data) {
		// Not enough data to contain header ?
		if (data.length < 19) {
			throw new Error('Targa::load() - Not enough data to contain header.');
		}

		// Read Header
		this.offset = 0;
		this.header = {
			id_length: data[this.offset++],
			colormap_type: data[this.offset++],
			image_type: data[this.offset++],
			colormap_index: data[this.offset++] | data[this.offset++] << 8,
			colormap_length: data[this.offset++] | data[this.offset++] << 8,
			colormap_size: data[this.offset++],
			origin: [
				data[this.offset++] | data[this.offset++] << 8,
				data[this.offset++] | data[this.offset++] << 8
			],
			width: data[this.offset++] | data[this.offset++] << 8,
			height: data[this.offset++] | data[this.offset++] << 8,
			pixel_size: data[this.offset++],
			flags: data[this.offset++]
		};

		// Assume it's a valid Targa file.
		this.checkHeader();
		if (this.header.id_length + this.offset > data.length) {
			throw new Error('Targa::load() - No data ?');
		}

		// Skip not needed data
		this.offset += this.header.id_length;

		// Get some informations.
		switch (this.header.image_type) {
			case TgaLoader.TYPE_RLE_INDEXED:
				this.use_rle = true;
				break;
			case TgaLoader.TYPE_INDEXED:
				this.use_pal = true;
				break;

			case TgaLoader.TYPE_RLE_RGB:
				this.use_rle = true;
				break;
			case TgaLoader.TYPE_RGB:
				this.use_rgb = true;
				break;

			case TgaLoader.TYPE_RLE_GREY:
				this.use_rle = true;
				break;
			case TgaLoader.TYPE_GREY:
				this.use_grey = true;
				break;
		}

		this.parse(data);
	};

	/**
	 * Check the header of TGA file to detect errors
	 *
	 * @throws Error
	 */
	TgaLoader.prototype.checkHeader = function () {
		switch (this.header.image_type) {
			// Check indexed type
			case TgaLoader.TYPE_INDEXED:
			case TgaLoader.TYPE_RLE_INDEXED:
				if (this.header.colormap_length > 256 || this.header.colormap_size !== 24 || this.header.colormap_type !== 1) {
					throw new Error("Targa::checkHeader() - Invalid type colormap data for indexed type");
				}
				break;

				// Check colormap type
			case TgaLoader.TYPE_RGB:
			case TgaLoader.TYPE_GREY:
			case TgaLoader.TYPE_RLE_RGB:
			case TgaLoader.TYPE_RLE_GREY:
				if (this.header.colormap_type) {
					throw new Error("Targa::checkHeader() - Invalid type colormap data for colormap type");
				}
				break;

				// What the need of a file without data ?
			case TgaLoader.TYPE_NO_DATA:
				throw new Error("Targa::checkHeader() - No data on this TGA file");

				// Invalid type ?
			default:
				throw new Error("Targa::checkHeader() - Invalid type '" + this.header.image_type + "'");
		}

		// Check image size
		if (this.header.width <= 0 || this.header.height <= 0) {
			throw new Error('Targa::checkHeader() - Invalid image size');
		}

		// Check pixel size
		if (this.header.pixel_size !== 8 && this.header.pixel_size !== 16 && this.header.pixel_size !== 24 && this.header.pixel_size !== 32) {
			throw new Error("Targa::checkHeader() - Invalid pixel size '" + this.header.pixel_size + "'");
		}
	};

	/**
	 * Parse data from TGA file
	 *
	 * @param {Uint8Array} data - Binary data of the TGA file
	 */
	TgaLoader.prototype.parse = function (data) {
		var _header,
			pixel_data,
			pixel_size,
			pixel_total;

		_header = this.header;
		// numAlphaBits = _header.flags & 0xf;
		pixel_size = _header.pixel_size >> 3;
		pixel_total = _header.width * _header.height * pixel_size;

		// Read palettes
		if (this.use_pal) {
			this.palettes = data.subarray(
				this.offset,
				this.offset += _header.colormap_length * pixel_size);
		}

		// Read LRE
		if (this.use_rle) {
			pixel_data = new Uint8Array(pixel_total);

			var c, count, i;
			var offset = 0;
			var pixels = new Uint8Array(pixel_size);

			while (offset < pixel_total) {
				c = data[this.offset++];
				count = (c & 0x7f) + 1;

				// RLE pixels.
				if (c & 0x80) {
					// Bind pixel tmp array
					for (i = 0; i < pixel_size; ++i) {
						pixels[i] = data[this.offset++];
					}

					// Copy pixel array
					for (i = 0; i < count; ++i) {
						pixel_data.set(pixels, offset + i * pixel_size);
					}

					offset += pixel_size * count;
				}

				// Raw pixels.
				else {
					count *= pixel_size;
					for (i = 0; i < count; ++i) {
						pixel_data[offset + i] = data[this.offset++];
					}
					offset += count;
				}
			}
		}

		// RAW Pixels
		else {
			pixel_data = data.subarray(
				this.offset,
				this.offset += (
				this.use_pal ? _header.width * _header.height : pixel_total));
		}

		this.image = pixel_data;
	};

	/**
	 * Return a ImageData object from a TGA file
	 *
	 * @param {imageData} imageData - Optional ImageData to work with
	 * @returns {imageData}
	 */
	TgaLoader.prototype.getImageData = function (imageData) {
		var width = this.header.width,
			height = this.header.height,
			x_start,
			y_start,
			x_step,
			y_step,
			y_end,
			x_end,
			func,
			data;

		data =
		// sent as argument
		imageData ||

		{
			width: width,
			height: height,
			data: new Uint8Array(width * height * 4)
		};

		// Check how we should write the pixels
		switch ((this.header.flags & TgaLoader.ORIGIN_MASK) >> TgaLoader.ORIGIN_SHIFT) {
			default:
			case TgaLoader.ORIGIN_UL:
				x_start = 0;
				x_step = 1;
				x_end = width;
				y_start = 0;
				y_step = 1;
				y_end = height;
				break;

			case TgaLoader.ORIGIN_BL:
				x_start = 0;
				x_step = 1;
				x_end = width;
				y_start = height - 1;
				y_step = -1;
				y_end = -1;
				break;

			case TgaLoader.ORIGIN_UR:
				x_start = width - 1;
				x_step = -1;
				x_end = -1;
				y_start = 0;
				y_step = 1;
				y_end = height;
				break;

			case TgaLoader.ORIGIN_BR:
				x_start = width - 1;
				x_step = -1;
				x_end = -1;
				y_start = height - 1;
				y_step = -1;
				y_end = -1;
				break;
		}

		// TODO: use this.header.origin[0-1] ?
		// x_start += this.header.origin[0];
		// y_start += this.header.origin[1];

		// Load the specify method
		func = 'getImageData' + (this.use_grey ? 'Grey' : '') + (this.header.pixel_size) + 'bits';
		this[func](data.data, y_start, y_step, y_end, x_start, x_step, x_end);
		return data;
	};

	/**
	 * Return a canvas with the TGA render on it
	 *
	 * @returns {canvas}
	 */
	TgaLoader.prototype.getCanvas = function () {
		var canvas = document.createElement('canvas');
		var ctx = canvas.getContext('2d');
		var imageData = ctx.createImageData(this.header.width, this.header.height);
		canvas.width = this.header.width;
		canvas.height = this.header.height;
		ctx.putImageData(this.getImageData(imageData), 0, 0);
		return canvas;
	};

	/**
	 * Return a dataURI of the TGA file
	 *
	 * @param {string} type - Optional image content-type to output (default: image/png)
	 * @returns {canvas}
	 */
	TgaLoader.prototype.getDataURL = function (type) {
		return this.getCanvas().toDataURL(type || "image/png");
	};

	/**
	 * Return a ImageData object from a TGA file (8bits)
	 *
	 * @param {imageData} imageData - ImageData to bind
	 * @param {int} y_start - start at y pixel.
	 * @param {int} x_start - start at x pixel.
	 * @param {int} y_step  - increment y pixel each time.
	 * @param {int} y_end   - stop at pixel y.
	 * @param {int} x_step  - increment x pixel each time.
	 * @param {int} x_end   - stop at pixel x.
	 * @returns {imageData}
	 */
	TgaLoader.prototype.getImageData8bits = function (imageData, y_start, y_step, y_end, x_start, x_step, x_end) {
		var image = this.image,
			colormap = this.palettes;
		var width = this.header.width;
		var color, i = 0,
			x, y;

		for (y = y_start; y !== y_end; y += y_step) {
			for (x = x_start; x !== x_end; x += x_step, i++) {
				color = image[i];
				imageData[(x + width * y) * 4 + 3] = 255;
				imageData[(x + width * y) * 4 + 2] = colormap[(color * 3) + 0];
				imageData[(x + width * y) * 4 + 1] = colormap[(color * 3) + 1];
				imageData[(x + width * y) * 4 + 0] = colormap[(color * 3) + 2];
			}
		}

		return imageData;
	};

	/**
	 * Return a ImageData object from a TGA file (16bits)
	 *
	 * @param {imageData} imageData - ImageData to bind
	 * @param {int} y_start - start at y pixel.
	 * @param {int} x_start - start at x pixel.
	 * @param {int} y_step  - increment y pixel each time.
	 * @param {int} y_end   - stop at pixel y.
	 * @param {int} x_step  - increment x pixel each time.
	 * @param {int} x_end   - stop at pixel x.
	 * @returns {imageData}
	 */
	TgaLoader.prototype.getImageData16bits = function (imageData, y_start, y_step, y_end, x_start, x_step, x_end) {
		var image = this.image;
		var width = this.header.width;
		var color, i = 0,
			x, y;

		for (y = y_start; y !== y_end; y += y_step) {
			for (x = x_start; x !== x_end; x += x_step, i += 2) {
				color = image[i + 0] + (image[i + 1] << 8); // Inversed ?
				imageData[(x + width * y) * 4 + 0] = (color & 0x7C00) >> 7;
				imageData[(x + width * y) * 4 + 1] = (color & 0x03E0) >> 2;
				imageData[(x + width * y) * 4 + 2] = (color & 0x001F) >> 3;
				imageData[(x + width * y) * 4 + 3] = (color & 0x8000) ? 0 : 255;
			}
		}

		return imageData;
	};

	/**
	 * Return a ImageData object from a TGA file (24bits)
	 *
	 * @param {imageData} imageData - ImageData to bind
	 * @param {int} y_start - start at y pixel.
	 * @param {int} x_start - start at x pixel.
	 * @param {int} y_step  - increment y pixel each time.
	 * @param {int} y_end   - stop at pixel y.
	 * @param {int} x_step  - increment x pixel each time.
	 * @param {int} x_end   - stop at pixel x.
	 * @returns {imageData}
	 */
	TgaLoader.prototype.getImageData24bits = function (imageData, y_start, y_step, y_end, x_start, x_step, x_end) {
		var image = this.image;
		var width = this.header.width;
		var i = 0,
			x, y;

		for (y = y_start; y !== y_end; y += y_step) {
			for (x = x_start; x !== x_end; x += x_step, i += 3) {
				imageData[(x + width * y) * 4 + 3] = 255;
				imageData[(x + width * y) * 4 + 2] = image[i + 0];
				imageData[(x + width * y) * 4 + 1] = image[i + 1];
				imageData[(x + width * y) * 4 + 0] = image[i + 2];
			}
		}

		return imageData;
	};

	/**
	 * Return a ImageData object from a TGA file (32bits)
	 *
	 * @param {imageData} imageData - ImageData to bind
	 * @param {int} y_start - start at y pixel.
	 * @param {int} x_start - start at x pixel.
	 * @param {int} y_step  - increment y pixel each time.
	 * @param {int} y_end   - stop at pixel y.
	 * @param {int} x_step  - increment x pixel each time.
	 * @param {int} x_end   - stop at pixel x.
	 * @returns {imageData}
	 */
	TgaLoader.prototype.getImageData32bits = function (imageData, y_start, y_step, y_end, x_start, x_step, x_end) {
		var image = this.image;
		var width = this.header.width;
		var i = 0,
			x, y;

		for (y = y_start; y !== y_end; y += y_step) {
			for (x = x_start; x !== x_end; x += x_step, i += 4) {
				imageData[(x + width * y) * 4 + 2] = image[i + 0];
				imageData[(x + width * y) * 4 + 1] = image[i + 1];
				imageData[(x + width * y) * 4 + 0] = image[i + 2];
				imageData[(x + width * y) * 4 + 3] = image[i + 3];
			}
		}

		return imageData;
	};

	/**
	 * Return a ImageData object from a TGA file (8bits grey)
	 *
	 * @param {imageData} imageData - ImageData to bind
	 * @param {int} y_start - start at y pixel.
	 * @param {int} x_start - start at x pixel.
	 * @param {int} y_step  - increment y pixel each time.
	 * @param {int} y_end   - stop at pixel y.
	 * @param {int} x_step  - increment x pixel each time.
	 * @param {int} x_end   - stop at pixel x.
	 * @returns {imageData}
	 */
	TgaLoader.prototype.getImageDataGrey8bits = function (imageData, y_start, y_step, y_end, x_start, x_step, x_end) {
		var image = this.image;
		var width = this.header.width;
		var color, i = 0,
			x, y;

		for (y = y_start; y !== y_end; y += y_step) {
			for (x = x_start; x !== x_end; x += x_step, i++) {
				color = image[i];
				imageData[(x + width * y) * 4 + 0] = color;
				imageData[(x + width * y) * 4 + 1] = color;
				imageData[(x + width * y) * 4 + 2] = color;
				imageData[(x + width * y) * 4 + 3] = 255;
			}
		}

		return imageData;
	};

	/**
	 * Return a ImageData object from a TGA file (16bits grey)
	 *
	 * @param {imageData} imageData - ImageData to bind
	 * @param {int} y_start - start at y pixel.
	 * @param {int} x_start - start at x pixel.
	 * @param {int} y_step  - increment y pixel each time.
	 * @param {int} y_end   - stop at pixel y.
	 * @param {int} x_step  - increment x pixel each time.
	 * @param {int} x_end   - stop at pixel x.
	 * @returns {imageData}
	 */
	TgaLoader.prototype.getImageDataGrey16bits = function (imageData, y_start, y_step, y_end, x_start, x_step, x_end) {
		var image = this.image;
		var width = this.header.width;
		var i = 0,
			x, y;

		for (y = y_start; y !== y_end; y += y_step) {
			for (x = x_start; x !== x_end; x += x_step, i += 2) {
				imageData[(x + width * y) * 4 + 0] = image[i + 0];
				imageData[(x + width * y) * 4 + 1] = image[i + 0];
				imageData[(x + width * y) * 4 + 2] = image[i + 0];
				imageData[(x + width * y) * 4 + 3] = image[i + 1];
			}
		}

		return imageData;
	};

	TgaLoader.prototype.isSupported = function () {
		return true;
	};

	TgaLoader.prototype.toString = function () {
		return "TgaLoader";
	};

	module.exports = TgaLoader;

/***/ },
/* 131 */
/***/ function(module, exports, __webpack_require__) {

	var PromiseUtils = __webpack_require__(54);
	var ObjectUtils = __webpack_require__(6);

	// TODO: make promise based instead of sending callbacks

	/**
	 * Provides useful canvas-related methods
	 */
	function CanvasUtils() {}

	// REVIEW: add documentation about what happens if the image is corrupt
	/**
	 * Loads an image element from a given URL and returns the image rendered on a canvas within a callback.
	 *
	 * @param {string} canvasPath	                 The URL to the image to render to the canvas.
	 * @param {Object} [options]
	 * @param {number} [options.width]             Resulting width of the canvas, falls back to image width.
	 * @param {number} [options.height]            Resulting height of the canvas, falls back to image height.
	 * @param {number} [options.sourceX]           Where to start clipping in x
	 * @param {number} [options.sourceY]           Where to start clipping in y
	 * @param {number} [options.sourceWidth]       The width of the clipped image
	 * @param {number} [options.sourceHeight]      The height of the clipped image
	 * @param {number} [options.destX]             Destination frame offset in x
	 * @param {number} [options.destY]             Destination frame offset in y
	 * @param {number} [options.destWidth]         Destination frame width
	 * @param {number} [options.destHeight]        Destination frame height
	 * @param {number} [options.resizeToFit=false] If true, the image is stretched to fit and centered on the canvas.
	 * @param {Function} callback
	 */
	CanvasUtils.loadCanvasFromPath = function (canvasPath, callback) {
		var options = {};
		if (arguments.length === 3) {
			// Called with loadCanvasFromPath(path, options, callback)
			options = arguments[1];
			callback = arguments[2];
		}

		// have the image load
		var img = new Image();
		img.onerror = function () {
			console.error('Failed to load svg!');
			callback();
		};
		img.src = canvasPath;

		// create an off screen canvas
		var canvas = document.createElement('canvas');

		// get its context
		var context = canvas.getContext('2d');

		img.onload = function () {
			// when ready, paint the image on the canvas

			if (img.width === 0 && img.height === 0) {
				// Could not load
				return callback();
			}

			ObjectUtils.defaults(options, {
				// Canvas size
				width: img.width,
				height: img.height,

				// Clipping window size & position
				sourceX: 0,
				sourceY: 0,
				sourceWidth: img.width,
				sourceHeight: img.height,

				// Destination window size & position
				destX: 0,
				destY: 0
			});

			ObjectUtils.defaults(options, {
				destWidth: options.width,
				destHeight: options.height
			});

			if (options.resizeToFit) {
				// preserve aspect ratio of input image and center it
				var ratio = options.sourceWidth / options.sourceHeight;
				if (ratio > 1) {
					options.destHeight = options.destWidth / ratio;
					options.destY = (options.height - options.destHeight) * 0.5;
				} else if (ratio < 1) {
					options.destWidth = options.destHeight * ratio;
					options.destX = (options.width - options.destWidth) * 0.5;
				}
			}

			// Set dimensions
			canvas.width = options.width;
			canvas.height = options.height;

			// Render to canvas
			context.drawImage(
				img,
				options.sourceX, options.sourceY,
				options.sourceWidth, options.sourceHeight,
				options.destX, options.destY,
				options.destWidth, options.destHeight
			);

			callback(canvas);
		};
	};

	/**
	 * Renders an SVG to a canvas element.
	 *
	 * @param {string} svgSource			The SVG XML source code
	 * @param {Object} options				Will be passed to loadCanvasFromPath.
	 * @param {Function} callback			Will be called when done. The single argument to this function will be the HTMLCanvasElement, or null if an error occurred.
	 * @example
	 * var data = '&lt;svg xmlns="http://www.w3.org/2000/svg" width=100 height=100&gt;&lt;rect x=0 y=0 width=100 height=100 fill="blue" /&gt;&lt;/svg&gt;';
	 * CanvasUtils.renderSvgToCanvas(data, {
	 *     resizeToFit:true,
	 *     width:100,
	 *     height:100
	 * }, function (canvas) {
	 *     // canvas is an HTMLCanvasElement
	 * });
	 */
	CanvasUtils.renderSvgToCanvas = function (svgSource, options, callback) {
		var url = 'data:image/svg+xml;base64,' + btoa(svgSource);

		CanvasUtils.loadCanvasFromPath(url, options, callback);
	};

	/**
	 * Takes a canvas element and returns it's image data as a matrix.
	 * Useful for things such as heightmap displacement from image source.
	 *
	 * @param canvas
	 * @returns {Array}
	 */
	CanvasUtils.getMatrixFromCanvas = function (canvas) {
		var context = canvas.getContext('2d');

		var getAt = function (x, y) {
			if (x < 0 || x > canvas.width || y < 0 || y > canvas.height) {
				return 0;
			} else {
				return context.getImageData(x, y, 1, 1).data[0] / 255;
			}
		};

		var matrix = [];
		for (var i = 0; i < canvas.width; i++) {
			matrix.push([]);
			for (var j = 0; j < canvas.height; j++) {
				matrix[i].push(getAt(i, canvas.height - (j + 1)));
			}
		}
		return matrix;
	};

	/**
	 *
	 * Convert SVG XML content to an HTMLImageElement.
	 * @param  {string} data
	 * @returns {RSVP.Promise} Promise that resolves with the Image.
	 */
	CanvasUtils.svgDataToImage = function (data) {
		var DOMURL = window.URL || window.webkitURL || window;

		var svg = new Blob([data], { type: 'image/svg+xml;charset=utf-8' });

		var img = new Image();
		img.src = DOMURL.createObjectURL(svg);

		return PromiseUtils.createPromise(function (resolve, reject) {
			img.onload = function () {
				resolve(img);
			};
			img.onerror = function () {
				reject('Could not load SVG image.');
			};
		});
	};

	module.exports = CanvasUtils;


/***/ },
/* 132 */
/***/ function(module, exports, __webpack_require__) {

	var TextureHandler = __webpack_require__(126);
	var PromiseUtils = __webpack_require__(54);
	var ObjectUtils = __webpack_require__(6);
	var StringUtils = __webpack_require__(36);
	var RSVP = __webpack_require__(55);

	/**
	 * Ajax helper class
	 * @param {string} rootPath
	 * @param {Object} options
	 */
	function Ajax(rootPath, options) {
		if (rootPath) {
			this._rootPath = rootPath;
			if (rootPath.slice(-1) !== '/') {
				this._rootPath += '/';
			}
		}
		this.options = options || {};
		this._cache = {};
	}

	/**
	 * Prefill ajax cache with data
	 * @param {Object} bundle Pairs of key-configs
	 * @param {boolean} [clear=false] If set to true will overwrite cache, otherwise extend it
	 */
	Ajax.prototype.prefill = function (bundle, clear) {
		if (clear) {
			this._cache = bundle;
		} else {
			ObjectUtils.extend(this._cache, bundle);
		}
	};

	/**
	 * Clears the ajax cache
	 * Is called by {@link DynamicLoader.clear}
	 */
	Ajax.prototype.clear = function () {
		this._cache = {};
	};

	/**
	 * Uses GET to retrieve data at a remote location.
	 * @hidden
	 * @param {Object} options
	 * @param {string} options.url
	 * @returns {Promise} Returns a promise that is resolved and rejected with the XMLHttpRequest.
	 */
	Ajax.prototype.get = function (options) {
		options = options || {};
		var url = options.url || '';

		var method = 'GET';

		var request = new XMLHttpRequest();

		request.open(method, url, true);
		if (options.responseType) {
			request.responseType = options.responseType;
		}

		return PromiseUtils.createPromise(function (resolve, reject) {
			var handleStateChange = function () {
				if (request.readyState === 4) {
					if (request.status >= 200 && request.status <= 299) {
						request.removeEventListener('readystatechange', handleStateChange);
						resolve(request);
					} else {
						request.removeEventListener('readystatechange', handleStateChange);
						reject(request.statusText);
					}
				}
			};

			request.addEventListener('readystatechange', handleStateChange);

			request.send();
		});
	};

	Ajax.ARRAY_BUFFER = 'arraybuffer';

	/**
	 * Allow cross-origin requests (CORS) for images.
	 * @type {boolean} [crossOrigin=false]
	 */
	Ajax.crossOrigin = false;


	var MIME_TYPES = {
		mp4: 'video/mp4',
		ogv: 'video/ogg',
		webm: 'video/webm'
	};

	/**
	 * Loads data at specified path which is returned in a Promise object.
	 *
	 * @param {string} path Path to whatever shall be loaded.
	 * @param {boolean} [reload=false] If set to true, reloads even if url is cached
	 *
	 * @returns {RSVP.Promise} The promise is resolved with the data loaded. If a parser is specified
	 * the data will be of the type resolved by the parser promise.
	 */
	Ajax.prototype.load = function (path, reload) {
		var that = this;
		var path2 = StringUtils.parseURL(path).path;//! AT: dunno what to call this
		var type = path2.substr(path2.lastIndexOf('.') + 1).toLowerCase();

		function typeInGroup(type, group) {
			return type && Ajax.types[group] && Ajax.types[group][type];
		}

		if (!path) {
			PromiseUtils.reject('Path was undefined'); //! AT: no return?
			// anyways, the engine should not call this method without a path
		}

		if (path.indexOf(Ajax.ENGINE_SHADER_PREFIX) === 0) {
			return PromiseUtils.resolve();
		}

		if (this._cache[path] && !reload) {
			if (typeInGroup(type, 'bundle')) {
				this.prefill(this._cache[path], reload);
			}
			if (this._cache[path] instanceof RSVP.Promise) {
				return this._cache[path];
			} else {
				return PromiseUtils.resolve(this._cache[path]);
			}
		}

		var url = this._rootPath ? this._rootPath + path : path;

		if (typeInGroup(type, 'image')) {
			this._cache[path] = this._loadImage(url);
			return this._cache[path];
		} else if (typeInGroup(type, 'video')) {
			this._cache[path] = this._loadVideo(url, MIME_TYPES[type]);
			return this._cache[path];
		} else if (typeInGroup(type, 'audio')) {
			this._cache[path] = this._loadAudio(url);
			return this._cache[path];
		}

		var ajaxProperties = {
			url: url
		};

		if (typeInGroup(type, 'binary')) {
			ajaxProperties.responseType = Ajax.ARRAY_BUFFER;
		}

		return this._cache[path] = this.get(ajaxProperties)
		.then(function (request) {
			if (typeInGroup(type, 'bundle')) {
				var bundle = JSON.parse(request.response);
				that.prefill(bundle, reload);
				return bundle;
			}
			if (typeInGroup(type, 'json')) {
				return JSON.parse(request.response);
			}
			return request.response;
		}).then(null, function (err) {
			throw new Error('Could not load data from ' + path + ', ' + err);
		});
	};

	Ajax.prototype.update = function (path, config) {
		this._cache[path] = config;
		return PromiseUtils.resolve(config);
	};

	/**
	 * Loads image data at specified path which is returned in a Promise object.
	 *
	 * @example
	 * loader.loadImage('resources/image.png').then(function (image) {
	 *   // handle {@link Image} image
	 * });
	 * @param {string} url Path to whatever shall be loaded.
	 * @returns {RSVP.Promise} The promise is resolved with an Image object.
	 */
	Ajax.prototype._loadImage = function (url) {
		window.URL = window.URL || window.webkitURL;
		var image = new Image();
		if (Ajax.crossOrigin) {
			image.crossOrigin = 'anonymous';
		}

		return PromiseUtils.createPromise(function (resolve, reject) {
			var onLoad = function loadHandler() {
				image.dataReady = true;
				if (window.URL && window.URL.revokeObjectURL !== undefined) {
					window.URL.revokeObjectURL(image.src);
				}
				image.removeEventListener('load', onLoad);
				image.removeEventListener('error', onError);
				resolve(image);
			};

			var onError = function errorHandler(e) {
				image.removeEventListener('load', onLoad);
				image.removeEventListener('error', onError);
				reject('Could not load image from ' + url + ', ' + e);
			};

			image.addEventListener('load', onLoad, false);
			image.addEventListener('error', onError, false);

			image.src = url;
		});
	};

	Ajax.prototype._loadVideo = function (url, mimeType) {
		var VIDEO_LOAD_TIMEOUT = 1000; // Timeout to 'canplay' event.
		var video = document.createElement('video');
		var iOS = /(iPad|iPhone|iPod)/g.test(navigator.userAgent);
		if (Ajax.crossOrigin) {
			video.crossOrigin = 'anonymous';
		}

		var promise = PromiseUtils.createPromise(function (resolve, reject) {
			var timeout;

			var _resolve = function () {
				if (!video.dataReady) {
					console.warn('Video is not ready');
				}
				video.removeEventListener('canplay', canPlay);
				video.removeEventListener('loadstart', loadStart);
				clearTimeout(timeout);
				resolve(video);
			};

			var canPlay = function () {
				video.dataReady = true;
				_resolve();
			};

			var loadStart = function () {
				if (iOS) {
					_resolve();
				}
				else {
					timeout = setTimeout(_resolve, VIDEO_LOAD_TIMEOUT);
				}
			};

			// iOS doesn't auto-load video
			video.addEventListener('canplay', canPlay, false);
			video.addEventListener('loadstart', loadStart, false);

			video.addEventListener('error', function (e) {
				reject('Could not load video from ' + url + ', ' + e);
			}, false);
		});

		var ajaxProperties = {
			url: url,
			responseType: Ajax.ARRAY_BUFFER
		};

		this.get(ajaxProperties).then(function (request) {
			var blob = new Blob([request.response], { type: mimeType });
			var url = window.URL.createObjectURL(blob);
			video.src = url;
		});

		return promise;
	};

	Ajax.prototype._loadAudio = function (url) {
		var ajaxProperties = {
			url: url,
			responseType: Ajax.ARRAY_BUFFER
		};
		return this.get(ajaxProperties).then(function (request) {
			return request.response;
		})
		.then(null, function (err) {
			throw new Error('Could not load data from ' + url + ', ' + err);
		});
	};

	// TODO Put this somewhere nicer
	Ajax.ENGINE_SHADER_PREFIX = 'GOO_ENGINE_SHADERS/';

	function addKeys(obj, keys) {
		for (var i = 0; i < keys.length; i++) {
			obj[keys[i]] = true;
		}
		return obj;
	}

	Ajax.types = {
		text: {
			vert: true,
			frag: true // + Scripts in the future
		},
		json: {
			shader: true,
			script: true,
			entity: true,
			material: true,
			scene: true,
			mesh: true,
			texture: true,
			skeleton: true,
			animation: true,
			clip: true,
			bundle: true,
			project: true,
			machine: true,
			posteffects: true,
			animstate: true,
			sound: true,
			environment: true,
			skybox: true
		},
		image: {
			jpg: true,
			jpeg: true,
			png: true,
			gif: true
		},
		video: {
			mp4: true,
			ogv: true,
			webm: true
		},
		binary: addKeys({
			dat: true,
			bin: true
		}, Object.keys(TextureHandler.loaders)),
		audio: {
			mp3: true,
			wav: true,
			ogg: true
		},
		bundle: {
			bundle: true
		}
	};

	Ajax.types.asset = addKeys(
		{},
		Object.keys(Ajax.types.image)
			.concat(Object.keys(Ajax.types.binary))
	);

	module.exports = Ajax;

/***/ },
/* 133 */
/***/ function(module, exports, __webpack_require__) {

	var Vector2 = __webpack_require__(19);
	var ObjectUtil = __webpack_require__(99);

	/**
	 * Creates a new RenderTarget object
	 *
	 * Post processing handler
	 * @param {number} width Width of rendertarget
	 * @param {number} height Height of rendertarget
	 * @param {Object} options Options
	 */
	function RenderTarget(width, height, options) {
		this.glTexture = null;
		this._glRenderBuffer = null;
		this._glFrameBuffer = null;

		this.width = Math.max(Math.floor(width), 1);
		this.height = Math.max(Math.floor(height), 1);

		ObjectUtil.copyOptions(this, options, {
			wrapS: 'EdgeClamp',
			wrapT: 'EdgeClamp',
			magFilter: 'Bilinear',
			minFilter: 'BilinearNoMipMaps',
			anisotropy: 1,
			format: 'RGBA',
			type: 'UnsignedByte',
			generateMipmaps: false,
			premultiplyAlpha: false,
			unpackAlignment: 1,
			flipY: true,
			depthBuffer: true,
			stencilBuffer: true
		});

		this.variant = '2D'; // CUBE

		this.offset = new Vector2(0, 0);
		this.repeat = new Vector2(1, 1);

		this.textureRecord = {};
	}

	RenderTarget.prototype.clone = function () {
		var tmp = new RenderTarget(this.width, this.height);

		tmp.wrapS = this.wrapS;
		tmp.wrapT = this.wrapT;

		tmp.magFilter = this.magFilter;
		tmp.minFilter = this.minFilter;

		tmp.anisotropy = this.anisotropy;

		tmp.format = this.format;
		tmp.type = this.type;
		tmp.variant = this.variant;

		tmp.offset.copy(this.offset);
		tmp.repeat.copy(this.repeat);

		tmp.generateMipmaps = this.generateMipmaps;
		tmp.premultiplyAlpha = this.premultiplyAlpha;
		tmp.unpackAlignment = this.unpackAlignment;
		tmp.flipY = this.flipY;

		tmp.depthBuffer = this.depthBuffer;
		tmp.stencilBuffer = this.stencilBuffer;

		return tmp;
	};

	/**
	 * Returns the number of bytes this render target occupies in memory
	 * @returns {number}
	 */
	RenderTarget.prototype.getSizeInMemory = function () {
		var size = this.width * this.height * 4;

		if (this.generateMipmaps) {
			size = Math.ceil(size * 4 / 3);
		}

		return size;
	};

	/**
	 * Deallocates all allocated resources from the WebGL context.
	 * @param  {WebGLRenderingContext} context
	 */
	RenderTarget.prototype.destroy = function (context) {
		if (this.glTexture) {
			context.deleteTexture(this.glTexture);
			this.glTexture = null;
		}
		if (this._glRenderBuffer) {
			context.deleteRenderbuffer(this._glRenderBuffer);
			this._glRenderBuffer = null;
		}
		if (this._glFrameBuffer) {
			context.deleteFramebuffer(this._glFrameBuffer);
			this._glFrameBuffer = null;
		}
	};

	module.exports = RenderTarget;


/***/ },
/* 134 */
/***/ function(module, exports, __webpack_require__) {

	var Capabilities = __webpack_require__(17);
	var Vector3 = __webpack_require__(8);
	var FullscreenPass = __webpack_require__(135);
	var Camera = __webpack_require__(120);
	var Material = __webpack_require__(30);
	var ShaderLib = __webpack_require__(46);
	var RenderTarget = __webpack_require__(133);
	var Vector4 = __webpack_require__(11);
	var PointLight = __webpack_require__(49);
	var SpotLight = __webpack_require__(52);

	/**
	 * Handles shadow techniques
	 */
	function ShadowHandler() {
		this.depthMaterial = new Material(ShaderLib.lightDepth, 'depthMaterial');
		this.depthMaterial.cullState.cullFace = 'Back';
		this.depthMaterial.fullOverride = true;
		this.fullscreenPass = new FullscreenPass();
		this.downsample = Material.createShader(ShaderLib.downsample, 'downsample');

		var sigma = 2;
		this.blurfilter = Material.createShader(ShaderLib.convolution, 'blurfilter');
		var kernelSize = 2 * Math.ceil(sigma * 3.0) + 1;
		this.blurfilter.defines = {
			KERNEL_SIZE_FLOAT: kernelSize.toFixed(1),
			KERNEL_SIZE_INT: kernelSize.toFixed(0)
		};
		this.blurfilter.uniforms.cKernel = ShaderLib.convolution.buildKernel(sigma);

		this.oldClearColor = new Vector4(0, 0, 0, 0);
		this.shadowClearColor = new Vector4(1, 1, 1, 1);

		this.renderList = [];
		this.shadowList = [];

		this.first = true;
	}

	var tmpVec = new Vector3();

	ShadowHandler.prototype._createShadowData = function (shadowSettings, renderer) {
		var shadowX = shadowSettings.resolution[0];
		var shadowY = shadowSettings.resolution[1];

		var linearFloat = !!Capabilities.TextureFloatLinear;

		if (shadowSettings.shadowData.shadowTarget) {
			renderer._deallocateRenderTarget(shadowSettings.shadowData.shadowTarget);
		}

		if (shadowSettings.shadowType === 'VSM') {
			var floatType = Capabilities.TextureHalfFloat ? 'HalfFloat' : 'Float';
			var type = {
				type: floatType
			};
			if (!linearFloat) {
				type.magFilter = 'NearestNeighbor';
				type.minFilter = 'NearestNeighborNoMipMaps';
			}
			if (shadowSettings.shadowData.shadowTargetDown) {
				renderer._deallocateRenderTarget(shadowSettings.shadowData.shadowTargetDown);
			}
			shadowSettings.shadowData.shadowTargetDown = new RenderTarget(shadowX / 2, shadowY / 2, type);
			if (shadowSettings.shadowData.shadowBlurred) {
				renderer._deallocateRenderTarget(shadowSettings.shadowData.shadowBlurred);
			}
			shadowSettings.shadowData.shadowBlurred = new RenderTarget(shadowX / 2, shadowY / 2, type);

			shadowSettings.shadowData.shadowTarget = new RenderTarget(shadowX, shadowY, {
				type: floatType,
				magFilter: 'NearestNeighbor',
				minFilter: 'NearestNeighborNoMipMaps'
			});
		} else {
			shadowSettings.shadowData.shadowTarget = new RenderTarget(shadowX, shadowY, {
				magFilter: 'NearestNeighbor',
				minFilter: 'NearestNeighborNoMipMaps'
			});
		}

		shadowSettings.shadowData.shadowResult = null;

		shadowSettings.shadowRecord.resolution = shadowSettings.shadowRecord.resolution || [];
		shadowSettings.shadowRecord.resolution[0] = shadowX;
		shadowSettings.shadowRecord.shadowType = shadowSettings.shadowType;
	};

	ShadowHandler.prototype.checkShadowRendering = function (renderer, partitioner, entities, lights) {
		if (this.first === true) {
			this.first = false;
			return;
		}
		for (var i = 0; i < lights.length; i++) {
			var light = lights[i];

			if (light.shadowCaster || light.lightCookie) {
				var shadowSettings = light.shadowSettings;

				if (!shadowSettings.shadowData) {
					shadowSettings.shadowData = {};
					shadowSettings.shadowRecord = {};
					shadowSettings.shadowData.lightCamera = new Camera(55, 1, 1, 1000);
				}

				var record = shadowSettings.shadowRecord;
				var lightCamera = shadowSettings.shadowData.lightCamera;

				// Update transformation
				lightCamera.translation.copy(light.translation);
				if (light.direction) {
					tmpVec.set(light.translation).add(light.direction);
					lightCamera.lookAt(tmpVec, shadowSettings.upVector);
				} else {
					lightCamera.lookAt(Vector3.ZERO, shadowSettings.upVector);
				}

				// Update settings
				if (!shadowSettings.shadowData.shadowTarget ||
					record.angle !== light.angle ||
					!record.resolution ||
					record.resolution[0] !== shadowSettings.resolution[0] ||
					record.resolution[1] !== shadowSettings.resolution[1] ||
					record.near !== shadowSettings.near ||
					record.far !== shadowSettings.far ||
					record.size !== shadowSettings.size
				) {
					if (!record.resolution ||
						record.resolution[0] !== shadowSettings.resolution[0] ||
						record.resolution[1] !== shadowSettings.resolution[1]) {
						this._createShadowData(shadowSettings, renderer);
					}

					if (light instanceof SpotLight) {
						lightCamera.setFrustumPerspective(light.angle, shadowSettings.resolution[0] / shadowSettings.resolution[1], shadowSettings.near, shadowSettings.far);
					} else if (light instanceof PointLight) {
						lightCamera.setFrustumPerspective(90, shadowSettings.resolution[0] / shadowSettings.resolution[1], shadowSettings.near, shadowSettings.far);
					} else {
						var radius = shadowSettings.size;
						lightCamera.setFrustum(shadowSettings.near, shadowSettings.far, -radius, radius, radius, -radius);
						lightCamera.projectionMode = Camera.Parallel;
					}

					lightCamera.update();

					record.resolution = record.resolution || [];
					record.resolution[0] = shadowSettings.resolution[0];
					record.resolution[1] = shadowSettings.resolution[1];
					record.angle = light.angle;
					record.near = shadowSettings.near;
					record.far = shadowSettings.far;
					record.size = shadowSettings.size;
				}

				if (shadowSettings.shadowType === 'VSM' && record.shadowType !== shadowSettings.shadowType) {
					this._createShadowData(shadowSettings, renderer);

					record.shadowType = shadowSettings.shadowType;
				}
				lightCamera.onFrameChange();

				var matrix = lightCamera.getViewProjectionMatrix().data;
				var vpm = shadowSettings.shadowData.vpm = shadowSettings.shadowData.vpm || [];
				for (var j = 0; j < 16; j++) {
					vpm[j] = matrix[j];
				}

				if (light.shadowCaster) {
					this.depthMaterial.shader.setDefine('SHADOW_TYPE', shadowSettings.shadowType === 'VSM' ? 2 : 0);
					this.depthMaterial.uniforms.cameraScale = 1.0 / (lightCamera.far - lightCamera.near);
					shadowSettings.shadowData.cameraScale = this.depthMaterial.uniforms.cameraScale;

					this.oldClearColor.copy(renderer.clearColor);
					renderer.setClearColor(this.shadowClearColor.r, this.shadowClearColor.g, this.shadowClearColor.b, this.shadowClearColor.a);

					this.shadowList.length = 0;
					for (var j = 0; j < entities.length; j++) {
						var entity = entities[j];
						if (entity.meshRendererComponent && entity.meshRendererComponent.castShadows && !entity.isSkybox) {
							this.shadowList.push(entity);
						}
					}
					partitioner.process(lightCamera, this.shadowList, this.renderList);
					renderer.render(this.renderList, lightCamera, [], shadowSettings.shadowData.shadowTarget, true, this.depthMaterial);

					switch (shadowSettings.shadowType) {
					case 'VSM':
						this.fullscreenPass.material.shader = this.downsample;
						this.fullscreenPass.render(renderer, shadowSettings.shadowData.shadowTargetDown, shadowSettings.shadowData.shadowTarget);

						this.fullscreenPass.material.shader = this.blurfilter;
						this.fullscreenPass.material.uniforms.uImageIncrement = [2 / shadowSettings.resolution[0], 0.0];
						this.fullscreenPass.render(renderer, shadowSettings.shadowData.shadowBlurred, shadowSettings.shadowData.shadowTargetDown);
						this.fullscreenPass.material.uniforms.uImageIncrement = [0.0, 2 / shadowSettings.resolution[1]];
						this.fullscreenPass.render(renderer, shadowSettings.shadowData.shadowTargetDown, shadowSettings.shadowData.shadowBlurred);

						shadowSettings.shadowData.shadowResult = shadowSettings.shadowData.shadowTargetDown;
						break;
					case 'PCF':
						shadowSettings.shadowData.shadowResult = shadowSettings.shadowData.shadowTarget;
						break;
					case 'Basic':
						shadowSettings.shadowData.shadowResult = shadowSettings.shadowData.shadowTarget;
						break;
					default:
						shadowSettings.shadowData.shadowResult = shadowSettings.shadowData.shadowTarget;
						break;
					}

					renderer.setClearColor(this.oldClearColor.r, this.oldClearColor.g, this.oldClearColor.b, this.oldClearColor.a);
				}
			}
		}
	};

	ShadowHandler.prototype.invalidateHandles = function (renderer) {
		this.fullscreenPass.invalidateHandles(renderer);
		renderer.invalidateMaterial(this.depthMaterial);
		renderer.invalidateShader(this.downsample);
		renderer.invalidateShader(this.blurfilter);
	};

	module.exports = ShadowHandler;

/***/ },
/* 135 */
/***/ function(module, exports, __webpack_require__) {

	var Material = __webpack_require__(30);
	var FullscreenUtils = __webpack_require__(136);
	var ShaderLib = __webpack_require__(46);
	var Pass = __webpack_require__(137);

	/**
	 * Fullscreen pass
	 * @param shader
	 */
	function FullscreenPass(shader) {
		this.material = new Material(shader || ShaderLib.simple);
		this.useReadBuffer = true;

		this.renderToScreen = false;

		this.renderable = {
			meshData: FullscreenUtils.quad,
			materials: [this.material]
		};

		this.enabled = true;
		this.clear = false;
		this.needsSwap = true;
		this.viewportSize = undefined;
	}

	FullscreenPass.prototype = Object.create(Pass.prototype);
	FullscreenPass.prototype.constructor = FullscreenPass;

	FullscreenPass.prototype.render = function (renderer, writeBuffer, readBuffer) {
		if (this.useReadBuffer) {
			this.material.setTexture('DIFFUSE_MAP', readBuffer);
		}

		if (this.renderToScreen) {
			renderer.render(this.renderable, FullscreenUtils.camera, [], null, this.clear);
		} else {
			renderer.render(this.renderable, FullscreenUtils.camera, [], writeBuffer, this.clear);
		}
	};

	FullscreenPass.prototype.destroy = function (/* renderer */) {
		this.material.shader.destroy();
	};

	FullscreenPass.prototype.invalidateHandles = function (renderer) {
		renderer.invalidateMaterial(this.renderable.materials[0]);
		renderer.invalidateMeshData(this.renderable.meshData);
	};

	module.exports = FullscreenPass;

/***/ },
/* 136 */
/***/ function(module, exports, __webpack_require__) {

	var Quad = __webpack_require__(28);
	var Camera = __webpack_require__(120);
	var Vector3 = __webpack_require__(8);

	/**
	 * Utility class with a default setup parallel camera and fullscreen quad for fullscreen pass usage
	 */
	function FullscreenUtils() {}

	var camera = new Camera();
	camera.projectionMode = Camera.Parallel;
	camera.setFrustum(0, 1, -1, 1, 1, -1);
	camera._left.copy(Vector3.UNIT_X).negate();
	camera._up.copy(Vector3.UNIT_Y);
	camera._direction.copy(Vector3.UNIT_Z);
	camera.onFrameChange();
	FullscreenUtils.camera = camera;

	FullscreenUtils.quad = new Quad(2, 2);

	module.exports = FullscreenUtils;

/***/ },
/* 137 */
/***/ function(module, exports) {

	/**
	 * Base pass class
	 */
	function Pass() {}

	Pass.prototype.destroy = function (/* renderer */) {};

	Pass.prototype.render = function (/* renderer, writeBuffer, readBuffer, delta, maskActive, camera, lights, clearColor */) {};

	Pass.prototype.updateSize = function (/* size, renderer */) {};

	Pass.prototype.invalidateHandles = function (/* renderer */) {};

	module.exports = Pass;

/***/ },
/* 138 */
/***/ function(module, exports) {

	function RenderStats() {
		this.reset();
	}

	RenderStats.prototype.reset = function () {
		this.calls = 0;
		this.vertices = 0;
		this.indices = 0;
	};

	RenderStats.prototype.toString = function () {
		return 'Calls: ' + this.calls +
			'<br/>Vertices: ' + this.vertices +
			'<br/>Indices: ' + this.indices;
	};

	module.exports = RenderStats;

/***/ },
/* 139 */
/***/ function(module, exports, __webpack_require__) {

	var PromiseUtils = __webpack_require__(54);

	var performance = typeof(window) !== 'undefined' ? window.performance : {};

	performance.now = (
		performance.now ||
		performance.mozNow ||
		performance.msNow ||
		performance.oNow ||
		performance.webkitNow ||
		function () {
			return Date.now();
		}
	);

	function TaskScheduler() {}

	TaskScheduler.maxTimePerFrame = 50;

	// Engine loop must be disabled while running this
	TaskScheduler.each = function (queue) {
		return PromiseUtils.createPromise(function (resolve) {
			var i = 0;

			function process() {
				var startTime = performance.now();
				while (i < queue.length && performance.now() - startTime < TaskScheduler.maxTimePerFrame) {
					queue[i]();
					i++;
				}

				if (i < queue.length) {
					// REVIEW: 4ms is 'lagom'? Should this number be hard-coded?
					//! AT: 4 ms is the minimum amount as specified by the HTML standard
					setTimeout(process, 4);
				} else {
					resolve();
				}
			}

			process();
		});
	};

	module.exports = TaskScheduler;

/***/ },
/* 140 */
/***/ function(module, exports, __webpack_require__) {

	var Entity = __webpack_require__(35);
	var Transform = __webpack_require__(41);

	/**
	 * Holds configuration data for renderable objects.
	 */

	function RenderInfo() {
		this.reset();

		// @ifdef DEBUG
		Object.seal(this);
		// @endif
	}

	/**
	 * Reset for switching renderable
	 */

	RenderInfo.prototype.reset = function () {
		this.renderable = null;
		this.lights = null;
		this.materials = null;
		this.meshData = null;
		this.camera = null;
		this.mainCamera = null;
		this.lights = null;
		this.shadowHandler = null;
		this.renderer = null;
		this.material = null;
		this.transform = null;
		this.currentPose = null;
	};

	/**
	 * Populates data from renderable
	 */

	RenderInfo.prototype.fill = function (renderable) {
		if (renderable instanceof Entity) {
			this.meshData = renderable.meshDataComponent.meshData;
			this.materials = renderable.meshRendererComponent.materials;
			this.transform = renderable.particleComponent ? Transform.IDENTITY : renderable.transformComponent.sync().worldTransform;
			if (renderable.meshDataComponent.currentPose) {
				this.currentPose = renderable.meshDataComponent.currentPose;
			} else {
				this.currentPose = null;
			}
		} else {
			this.meshData = renderable.meshData;
			this.materials = renderable.materials;
			this.transform = renderable.transform;
			if (renderable.currentPose) {
				this.currentPose = renderable.currentPose;
			} else {
				this.currentPose = null;
			}
		}

		this.renderable = renderable;
	};

	module.exports = RenderInfo;

/***/ },
/* 141 */,
/* 142 */,
/* 143 */,
/* 144 */,
/* 145 */,
/* 146 */,
/* 147 */,
/* 148 */,
/* 149 */,
/* 150 */,
/* 151 */,
/* 152 */,
/* 153 */,
/* 154 */,
/* 155 */,
/* 156 */,
/* 157 */,
/* 158 */,
/* 159 */,
/* 160 */,
/* 161 */,
/* 162 */,
/* 163 */,
/* 164 */,
/* 165 */
/***/ function(module, exports, __webpack_require__) {

	var Ray = __webpack_require__(122);

	/**
	 * BoundingPicker
	 */
	function BoundingPicker() {
	}

	var pickRay = new Ray();

	BoundingPicker.pick = function (world, camera, x, y) {
		var entities = world.entityManager.getEntities();
		return BoundingPicker.pickFromList(world, entities, camera, x, y);
	};

	BoundingPicker.pickFromList = function (world, entities, camera, x, y) {
		var renderer = world.gooRunner.renderer;
		camera.getPickRay(x, y, renderer.domElement.offsetWidth, renderer.domElement.offsetHeight, pickRay);
		// var dpx = renderer.devicePixelRatio;
		// camera.getPickRay(x * dpx, y * dpx, renderer.domElement.offsetWidth, renderer.domElement.offsetHeight, pickRay);

		var pickList = [];
		for (var i = 0; i < entities.length; i++) {
			var entity = entities[i];
			var meshRendererComponent = entity.meshRendererComponent;

			if (!meshRendererComponent || !meshRendererComponent.isPickable) {
				continue;
			}

			var result = meshRendererComponent.worldBound.intersectsRayWhere(pickRay);
			if (result && result.distances.length) {
				pickList.push({
					'entity': entity,
					'intersection': result
				});
			}
		}

		pickList.sort(function (a, b) {
			return a.intersection.distances[0] - b.intersection.distances[0];
		});

		return pickList;
	};

	module.exports = BoundingPicker;


/***/ },
/* 166 */,
/* 167 */,
/* 168 */,
/* 169 */,
/* 170 */,
/* 171 */,
/* 172 */,
/* 173 */
/***/ function(module, exports) {

	/**
	 * Provides easing functionality
	 */
	var Easing = {
		Linear: {
			None: function (k) {
				return k;
			},
			In: function (k) {
				return k;
			},
			Out: function (k) {
				return k;
			},
			InOut: function (k) {
				return k;
			}
		},
		Quadratic: {
			In: function (k) {
				return k * k;
			},
			Out: function (k) {
				return k * (2 - k);
			},
			InOut: function (k) {
				if ((k *= 2) < 1) {
					return 0.5 * k * k;
				}
				return - 0.5 * (--k * (k - 2) - 1);
			}
		},
		Cubic: {
			In: function (k) {
				return k * k * k;
			},
			Out: function (k) {
				return --k * k * k + 1;
			},
			InOut: function (k) {
				if ((k *= 2) < 1) {
					return 0.5 * k * k * k;
				}
				return 0.5 * ((k -= 2) * k * k + 2);
			}
		},
		Quartic: {
			In: function (k) {
				return k * k * k * k;
			},
			Out: function (k) {
				return 1 - (--k * k * k * k);
			},
			InOut: function (k) {
				if ((k *= 2) < 1) {
					return 0.5 * k * k * k * k;
				}
				return - 0.5 * ((k -= 2) * k * k * k - 2);
			}
		},
		Quintic: {
			In: function (k) {
				return k * k * k * k * k;
			},
			Out: function (k) {
				return --k * k * k * k * k + 1;
			},
			InOut: function (k) {
				if ((k *= 2) < 1) {
					return 0.5 * k * k * k * k * k;
				}
				return 0.5 * ((k -= 2) * k * k * k * k + 2);
			}
		},
		Sinusoidal: {
			In: function (k) {
				return 1 - Math.cos(k * Math.PI / 2);
			},
			Out: function (k) {
				return Math.sin(k * Math.PI / 2);
			},
			InOut: function (k) {
				return 0.5 * (1 - Math.cos(Math.PI * k));
			}
		},
		Exponential: {
			In: function (k) {
				return k === 0 ? 0 : Math.pow(1024, k - 1);
			},
			Out: function (k) {
				return k === 1 ? 1 : 1 - Math.pow(2, - 10 * k);
			},
			InOut: function (k) {
				if (k === 0) {
					return 0;
				}
				if (k === 1) {
					return 1;
				}
				if ((k *= 2) < 1) {
					return 0.5 * Math.pow(1024, k - 1);
				}
				return 0.5 * (- Math.pow(2, - 10 * (k - 1)) + 2);
			}
		},
		Circular: {
			In: function (k) {
				return 1 - Math.sqrt(1 - k * k);
			},
			Out: function (k) {
				return Math.sqrt(1 - (--k * k));
			},
			InOut: function (k) {
				if ((k *= 2) < 1) {
					return - 0.5 * (Math.sqrt(1 - k * k) - 1);
				}
				return 0.5 * (Math.sqrt(1 - (k -= 2) * k) + 1);
			}
		},
		Elastic: {
			In: function (k) {
				var s;
				var a = 0.1;
				var p = 0.4;

				if (k === 0) {
					return 0;
				}

				if (k === 1) {
					return 1;
				}

				if (!a || a < 1) {
					a = 1;
					s = p / 4;
				} else {
					s = p * Math.asin(1 / a) / (2 * Math.PI);
				}

				return - (a * Math.pow(2, 10 * (k -= 1)) * Math.sin((k - s) * (2 * Math.PI) / p));
			},
			Out: function (k) {
				var s;
				var a = 0.1;
				var p = 0.4;

				if (k === 0) {
					return 0;
				}

				if (k === 1) {
					return 1;
				}

				if (!a || a < 1) {
					a = 1;
					s = p / 4;
				} else {
					s = p * Math.asin(1 / a) / (2 * Math.PI);
				}

				return (a * Math.pow(2, - 10 * k) * Math.sin((k - s) * (2 * Math.PI) / p) + 1);
			},
			InOut: function (k) {
				var s;
				var a = 0.1;
				var p = 0.4;

				if (k === 0) {
					return 0;
				}

				if (k === 1) {
					return 1;
				}

				if (!a || a < 1) {
					a = 1;
					s = p / 4;
				} else {
					s = p * Math.asin(1 / a) / (2 * Math.PI);
				}

				if ((k *= 2) < 1) {
					return - 0.5 * (a * Math.pow(2, 10 * (k -= 1)) * Math.sin((k - s) * (2 * Math.PI) / p));
				}

				return a * Math.pow(2, -10 * (k -= 1)) * Math.sin((k - s) * (2 * Math.PI) / p) * 0.5 + 1;
			}
		},
		Back: {
			In: function (k) {
				var s = 1.70158;
				return k * k * ((s + 1) * k - s);
			},
			Out: function (k) {
				var s = 1.70158;
				return --k * k * ((s + 1) * k + s) + 1;
			},
			InOut: function (k) {
				var s = 1.70158 * 1.525;
				if ((k *= 2) < 1) {
					return 0.5 * (k * k * ((s + 1) * k - s));
				}
				return 0.5 * ((k -= 2) * k * ((s + 1) * k + s) + 2);
			}
		},
		Bounce: {
			In: function (k) {
				return 1 - Easing.Bounce.Out(1 - k);
			},
			Out: function (k) {
				if (k < (1 / 2.75)) {
					return 7.5625 * k * k;
				} else if (k < (2 / 2.75)) {
					return 7.5625 * (k -= (1.5 / 2.75)) * k + 0.75;
				} else if (k < (2.5 / 2.75)) {
					return 7.5625 * (k -= (2.25 / 2.75)) * k + 0.9375;
				} else {
					return 7.5625 * (k -= (2.625 / 2.75)) * k + 0.984375;
				}
			},
			InOut: function (k) {
				if (k < 0.5) {
					return Easing.Bounce.In(k * 2) * 0.5;
				}
				return Easing.Bounce.Out(k * 2 - 1) * 0.5 + 0.5;
			}
		}
	};

	module.exports = Easing;


/***/ },
/* 174 */,
/* 175 */,
/* 176 */,
/* 177 */,
/* 178 */,
/* 179 */,
/* 180 */,
/* 181 */,
/* 182 */,
/* 183 */,
/* 184 */,
/* 185 */,
/* 186 */,
/* 187 */,
/* 188 */,
/* 189 */,
/* 190 */,
/* 191 */,
/* 192 */,
/* 193 */,
/* 194 */
/***/ function(module, exports, __webpack_require__) {

	var Component = __webpack_require__(20);
	var Light = __webpack_require__(50);

	/**
	 * Defines a light<br>
	 * @example-link http://code.gooengine.com/latest/visual-test/goo/renderer/light/Lights-vtest.html Working example
	 * @param {Light} light Light to contain in this component (directional, spot, point)
	 * @extends Component
	 */
	function LightComponent(light) {
		Component.apply(this, arguments);

		this.type = 'LightComponent';

		/**
	     * Light contained in this component.
	     */
		this.light = light;

		/**
		 * @type {boolean}
		 * @default
		 */
		this.hidden = false;

		this._transformDirty = true;
		this._transformUpdatedListener = null;

		// @ifdef DEBUG
		Object.seal(this);
		// @endif
	}

	LightComponent.type = 'LightComponent';

	LightComponent.prototype = Object.create(Component.prototype);
	LightComponent.prototype.constructor = LightComponent;

	LightComponent.prototype.attached = function () {
		var that = this;
		this.entity.on('transformUpdated', this._transformUpdatedListener = function () {
			that._transformDirty = true;
		});
	};

	LightComponent.prototype.detached = function () {
		this.entity.off('transformUpdated', this._transformUpdatedListener);
		this._transformUpdatedListener = null;
	};

	LightComponent.prototype.updateLight = function (transform) {
		this.light.update(transform);
	};

	LightComponent.prototype.copy = function (source) {
		// has to be the same sort of light
		this.light.copy(source);

		// the status depends on the entity and its ancestors
		this.hidden = source.hidden;

		return this;
	};

	LightComponent.prototype.clone = function () {
		var clone = new LightComponent(this.light.clone());

		// this status needs updating
		clone.hidden = this.hidden;
		return clone;
	};

	LightComponent.applyOnEntity = function (obj, entity) {
		if (obj instanceof Light) {
			var lightComponent = new LightComponent(obj);
			entity.setComponent(lightComponent);
			return true;
		}
	};

	module.exports = LightComponent;

/***/ },
/* 195 */,
/* 196 */,
/* 197 */,
/* 198 */,
/* 199 */,
/* 200 */,
/* 201 */,
/* 202 */,
/* 203 */,
/* 204 */,
/* 205 */,
/* 206 */,
/* 207 */,
/* 208 */,
/* 209 */
/***/ function(module, exports) {

	/**
	 * Library of particles
	 * @example-link http://code.gooengine.com/latest/visual-test/goo/misc/ParticleLib/ParticleLib-vtest.html Working example
	 */
	function ParticleLib() {}

	/**
	 * Returns a set of parameters for a smoke particle emitter
	 */
	ParticleLib.getSmoke = function (options) {
		options = options || {};
		options.scale = typeof options.scale !== 'undefined' ? options.scale : 1;
		options.spread = typeof options.spread !== 'undefined' ? options.spread : 2;
		options.rate = typeof options.spread !== 'undefined' ? options.rate : 25;
		options.velocity = typeof options.velocity !== 'undefined' ? options.velocity :
			function (particle/*, particleEntity*/) {
				// not nice, will end up a square
				var vec3 = particle.velocity;
				vec3.x = (Math.random() - 0.5) * 2 * options.spread * options.scale;
				vec3.y = (Math.random() + 4.0) * 2 * options.scale;
				vec3.z = (Math.random() - 0.5) * 2 * options.spread * options.scale;
				return vec3;
			};
		options.color = options.color || [0, 0, 0];

		return {
			totalParticlesToSpawn: -1,
			releaseRatePerSecond: options.rate,
			minLifetime: 0.5,
			maxLifetime: 4.0,
			getEmissionVelocity: options.velocity,
			timeline: [{
				timeOffset: 0.0,
				spin: 0,
				mass: 1,
				size: 3.0 * options.scale,
				color: [options.color[0], options.color[1], options.color[2], 1]
			}, {
				timeOffset: 1.0,
				size: 6.0 * options.scale,
				color: [options.color[0], options.color[1], options.color[2], 0]
			}]
		};
	};

	/**
	 * Returns a set of parameters for a fire particle emitter
	 */
	ParticleLib.getFire = function (options) {
		options = options || {};
		options.scale = typeof options.scale !== 'undefined' ? options.scale : 1;
		options.spread = typeof options.spread !== 'undefined' ? options.spread : 2;
		options.velocity = typeof options.velocity !== 'undefined' ? options.velocity : 10;
		options.startColor = options.startColor || [1, 1, 0];
		options.endColor = options.endColor || [1, 0, 0];

		return {
			totalParticlesToSpawn: -1,
			releaseRatePerSecond: 30,
			minLifetime: 0.5,
			maxLifetime: 2.0,
			getEmissionVelocity: function (particle/*, particleEntity*/) {
				// not nice, will end up a square
				var vec3 = particle.velocity;
				vec3.x = (Math.random() - 0.5) * 2 * options.spread * options.scale;
				vec3.y = (Math.random() + 1.0) * options.velocity * options.scale;
				vec3.z = (Math.random() - 0.5) * 2 * options.spread * options.scale;
				return vec3;
			},
			timeline: [{
				timeOffset: 0.0,
				spin: 0,
				mass: 1,
				size: 2.0 * options.scale,
				color: [options.startColor[0], options.startColor[1], options.startColor[2], 0]
			}, {
				timeOffset: 0.05,
				color: [options.startColor[0], options.startColor[1], options.startColor[2], 1.0]
			}, {
				timeOffset: 0.45,
				color: [options.endColor[0], options.endColor[1], options.endColor[2], 0.8]
			}, {
				timeOffset: 0.5,
				size: 3.0 * options.scale,
				color: [0, 0, 0, 0]
			}]
		};
	};

	/**
	 * Returns a set of parameters for a snow particle emitter
	 */
	ParticleLib.getSnow = function (options) {
		options = options || {};
		options.scale = typeof options.scale !== 'undefined' ? options.scale : 2;
		options.spread = typeof options.spread !== 'undefined' ? options.spread : 50;
		options.velocity = typeof options.velocity !== 'undefined' ? options.velocity : 3;
		options.color = options.color || [1, 1, 1];

		return {
			particleCount: 1000,
			totalParticlesToSpawn: -1,
			releaseRatePerSecond: 50,
			minLifetime: 15.0,
			maxLifetime: 25.0,
			getEmissionPoint: function (particle/*, particleEntity*/) {
				var vec3 = particle.position;
				options.getEmissionPoint(vec3);
				return vec3;
			},
			getEmissionVelocity: function (particle/*, particleEntity*/) {
				var vec3 = particle.velocity;
				options.getEmissionVelocity(vec3);
				return vec3;
			},
			timeline: [{
				timeOffset: 0.0,
				spin: 0,
				mass: 1,
				size: 1.0 * options.scale,
				color: [options.color[0], options.color[1], options.color[2], 0.0]
			}, {
				timeOffset: 0.05,
				color: [options.color[0], options.color[1], options.color[2], 1.0]
			}, {
				timeOffset: 0.70,
				color: [options.color[0], options.color[1], options.color[2], 0.8]
			}, {
				timeOffset: 0.25,
				spin: 5,
				size: 0.5 * options.scale,
				color: [options.color[0], options.color[1], options.color[2], 0]
			}]
		};
	};

	module.exports = ParticleLib;

/***/ },
/* 210 */
/***/ function(module, exports, __webpack_require__) {

	var ParticleComponent = __webpack_require__(211);
	var MeshRendererComponent = __webpack_require__(215);
	var MeshDataComponent = __webpack_require__(216);
	var Texture = __webpack_require__(53);
	var ParticleEmitter = __webpack_require__(214);

	/**
	 * Provides utility methods for particle systems
	 */
	function ParticleSystemUtils() {}

	/**
	 * Creates an Entity based on an object holding particle emitter parameters and a material
	 * @hidden
	 * @param world
	 * @param particleParameters
	 * @param material
	 * @example-link http://code.gooengine.com/latest/visual-test/goo/misc/ParticleLib/ParticleLib-vtest.html Working example
	 * @returns {Entity}
	 */
	ParticleSystemUtils.createParticleSystemEntity = function (world, particleParameters, material) {
		// Create the particle cloud entity
		var particleSystemEntity = world.createEntity();

		// Set particle component
		var particleComponent = new ParticleComponent({
			particleCount: particleParameters.particleCount || 500
		});

		particleComponent.emitters.push(new ParticleEmitter(particleParameters));
		particleSystemEntity.setComponent(particleComponent);

		// Create meshData component using particle data
		var meshDataComponent = new MeshDataComponent(particleComponent.meshData);
		particleSystemEntity.setComponent(meshDataComponent);

		// Create meshRenderer component with material and shader
		var meshRendererComponent = new MeshRendererComponent();
		meshRendererComponent.materials.push(material);
		meshRendererComponent.cullMode = 'Never';
		particleSystemEntity.setComponent(meshRendererComponent);

		return particleSystemEntity;
	};

	/**
	 * Generates a radial gradient with multiple color stops; useful for water simple fire, snowflakes, water ripples and shockwaves
	 * @param {number} [size=64]
	 * @param {Object} [options]
	 * @returns {Texture}
	 */
	ParticleSystemUtils.createFlareTexture = function (size, options) {
		size = size || 64;

		//! AT: this modifies the original options object which is intrusive and bad
		options = options || {};
		options.startRadius = typeof options.startRadius !== 'undefined' ? options.startRadius : 0;
		options.endRadius = typeof options.endRadius !== 'undefined' ? options.endRadius : size / 2;
		options.steps = options.steps || [{ fraction: 0, value: 1 }, { fraction: 1, value: 0 }];
		// options array of (fraction, alpha)

		var canvas = document.createElement('canvas');
		canvas.width = size;
		canvas.height = size;
		var con2d = canvas.getContext('2d');

		var gradient = con2d.createRadialGradient(
			size / 2, size / 2, options.startRadius, size / 2, size / 2, options.endRadius);

		for (var i = 0; i < options.steps.length; i++) {
			var step = options.steps[i];
			gradient.addColorStop(step.fraction, 'rgba(255, 255, 255, ' + step.value + ')');
		}

		con2d.fillStyle = gradient;
		con2d.fillRect(0, 0, size, size);

		var imageData = con2d.getImageData(0, 0, size, size).data;
		imageData = new Uint8Array(imageData);

		var texture = new Texture(imageData, null, size, size);
		return texture;
	};

	/**
	 * Generates a texture of multiple trailing particles; useful for water splashes and sparks
	 * @param {number} [size=64]
	 * @param {Object} [options]
	 * @returns {Texture}
	 */
	ParticleSystemUtils.createSplashTexture = function (size, options) {
		size = size || 64;

		//! AT: this modifies the original options object which is intrusive and bad
		options = options || {};
		options.nTrails = typeof options.nTrails !== 'undefined' ? options.nTrails : 8;
		options.trailStartRadius = typeof options.trailStartRadius !== 'undefined' ? options.trailStartRadius : 1;
		options.trailEndRadius = typeof options.trailEndRadius !== 'undefined' ? options.trailEndRadius : 4;

		var canvas = document.createElement('canvas');
		canvas.width = size;
		canvas.height = size;
		var con2d = canvas.getContext('2d');

		// ----
		function circle(x, y, r) {
			var grad = con2d.createRadialGradient(x, y, 0, x, y, r);
			grad.addColorStop(0, 'rgba(255, 255, 255, 0.5)');
			grad.addColorStop(1, 'rgba(255, 255, 255, 0)');
			con2d.fillStyle = grad;
			con2d.fillRect(x - r, y - r, 2 * r, 2 * r);
		}

		var nSteps = 30;
		function trail(sx, sy, ex, ey, sr, er) {
			var ax = (ex - sx) / nSteps;
			var ay = (ey - sy) / nSteps;
			var ar = (er - sr) / nSteps;
			for (var i = 0, x = sx, y = sy, r = sr; i < nSteps; i++, x += ax, y += ay, r += ar) {
				circle(x, y, r);
			}
		}

		function splash(x, y, minInnerRadius, maxOuterRadius, startTrailRadius, endTrailRadius, n) {
			for (var i = 0; i < n; i++) {
				var angle = Math.random() * Math.PI * 2;
				var innerRadius = Math.random() * 4 + minInnerRadius;
				var outerRadius = Math.random() * 4 - maxOuterRadius;
				trail(
					x + Math.cos(angle) * innerRadius,
					y + Math.sin(angle) * innerRadius,
					x + Math.cos(angle) * outerRadius,
					y + Math.sin(angle) * outerRadius,
					startTrailRadius,
					endTrailRadius
				);
			}
		}
		// ----

		splash(size / 2, size / 2, ((size / 2) / 10) * 1, ((size / 2) / 10) * 9, options.trailStartRadius, options.trailEndRadius, options.nTrails);

		var imageData = con2d.getImageData(0, 0, size, size).data;
		imageData = new Uint8Array(imageData);

		var texture = new Texture(imageData, null, size, size);
		return texture;
	};

	/**
	 * Generates a texture of random fuzzy dots; useful for dust and plankton
	 * @param {number} [size=64]
	 * @param {Object} [options]
	 * @returns {Texture}
	 */
	ParticleSystemUtils.createPlanktonTexture = function (size, options) {
		size = size || 64;

		//! AT: this modifies the original options object which is intrusive and bad
		options = options || {};
		options.nPoints = typeof options.nPoints !== 'undefined' ? options.nPoints : 10;
		options.minRadius = typeof options.minRadius !== 'undefined' ? options.minRadius : 2;
		options.maxRadius = typeof options.maxRadius !== 'undefined' ? options.maxRadius : 5;

		var canvas = document.createElement('canvas');
		canvas.width = size;
		canvas.height = size;
		var con2d = canvas.getContext('2d');

		function circle(x, y, r) {
			var grad = con2d.createRadialGradient(x, y, 0, x, y, r);
			grad.addColorStop(0, 'rgba(255, 255, 255, 1)');
			grad.addColorStop(0.3, 'rgba(255, 255, 255, 1)');
			grad.addColorStop(1, 'rgba(255, 255, 255, 0)');
			con2d.fillStyle = grad;
			con2d.fillRect(x - r, y - r, 2 * r, 2 * r);
		}

		function soup(n) {
			for (var i = 0; i < n; i++) {
				var x = Math.random() * (size - options.maxRadius * 2) + options.maxRadius;
				var y = Math.random() * (size - options.maxRadius * 2) + options.maxRadius;
				circle(x, y, Math.random() * (options.maxRadius - options.minRadius) + options.minRadius);
			}
		}

		soup(options.nPoints);

		var imageData = con2d.getImageData(0, 0, size, size).data;
		imageData = new Uint8Array(imageData);

		var texture = new Texture(imageData, null, size, size);
		return texture;
	};

	/**
	 * Generates a texture of complex hexagonal snowflakes
	 * @param {number} [size=64]
	 * @param {Object} [options]
	 * @returns {Texture}
	 */
	ParticleSystemUtils.createSnowflakeTexture = function (size, options) {
		size = size || 64;

		//! AT: this modifies the original options object which is intrusive and bad
		// also, unused
		options = options || {};

		var canvas = document.createElement('canvas');
		canvas.width = size;
		canvas.height = size;
		var con2d = canvas.getContext('2d');

		function replicateRotated(n, fun) {
			var ak = 2 * Math.PI / n;
			for (var i = 0; i < n; i++) {
				con2d.rotate(ak);
				fun();
			}
		}

		function subSnow1() {
			con2d.beginPath();
			con2d.moveTo(0, 0);
			con2d.lineTo(0, 90);

			for (var i = 0; i < 6; i++) {
				con2d.moveTo(0, 25 + i * 10); con2d.lineTo(16 - i * 1.5, 35 + i * 10);
				con2d.moveTo(0, 25 + i * 10); con2d.lineTo(-(16 - i * 1.5), 35 + i * 10);
			}

			con2d.stroke();
		}

		con2d.strokeStyle = '#FFF';
		con2d.lineWidth = 4;
		con2d.lineCap = 'round';

		con2d.translate(size / 2, size / 2);
		con2d.scale(size / 100 / 2, size / 100 / 2);
		replicateRotated(7, subSnow1);


		var imageData = con2d.getImageData(0, 0, size, size).data;
		imageData = new Uint8Array(imageData);

		var texture = new Texture(imageData, null, size, size);
		return texture;
	};

	module.exports = ParticleSystemUtils;

/***/ },
/* 211 */
/***/ function(module, exports, __webpack_require__) {

	var Component = __webpack_require__(20);
	var Particle = __webpack_require__(212);
	var ParticleEmitter = __webpack_require__(214);
	var MeshData = __webpack_require__(14);

	/**
	 * Creates and modifies {@link MeshData} to simulate particle effects.<br /><br />ParticleComponents may have one or
	 * more emitters. Each emitter spawns particles, controlling spawn rate, lifetime, initial velocity vector and
	 * position of each particle. Each Particle System also contains a timeline describing changes each particle should
	 * perform over its lifetime, including:
	 * <ul>
	 * <li>Size of particle</li>
	 * <li>Color of particle</li>
	 * <li>Orientation of particle (rotation on screen plane)</li>
	 * <li>Texture coords used.</li>
	 * <li>Other user defined params.</li>
	 * </ul><br />
	 * External influences can exert on particles via a defined callback function system.<br /><br />
	 * Particles billboard toward the screen using a provided Camera as reference.
	 * @param {Object} [settings]
	 * @param {Array} [settings.emitters] Array of emitter settings
	 * @param {Array} [settings.timeline]
	 * @param {number} [settings.uRange=1]
	 * @param {number} [settings.vRange=1]
	 * @param {number} [settings.particleCount=100]
	 * @extends Component
	 */
	function ParticleComponent(settings) {
		Component.apply(this, arguments);

		this.type = 'ParticleComponent';

		Component.call(this);

		settings = settings || {};

		this.emitters = [];
		if (settings.emitters) {
			for ( var i = 0, max = settings.emitters.length; i < max; i++) {
				this.emitters.push(new ParticleEmitter(settings.emitters[i]));
			}
		}

		this.timeline = settings.timeline ? settings.timeline : [];

		this.uRange = isNaN(settings.uRange) ? 1 : settings.uRange;
		this.vRange = isNaN(settings.vRange) ? 1 : settings.vRange;

		var particleCount = isNaN(settings.particleCount) ? 100 : settings.particleCount;
		this.recreateParticles(particleCount);

		this.enabled = true;

		// @ifdef DEBUG
		Object.seal(this);
		// @endif
	}

	ParticleComponent.type = 'ParticleComponent';

	ParticleComponent.prototype = Object.create(Component.prototype);
	ParticleComponent.prototype.constructor = ParticleComponent;

	ParticleComponent.prototype.generateMeshData = function () {
		var attributeMap = MeshData.defaultMap([MeshData.POSITION, MeshData.COLOR, MeshData.TEXCOORD0]);
		this.meshData = new MeshData(attributeMap, this.particleCount * 4, this.particleCount * 6);
		this.meshData.vertexData.setDataUsage('DynamicDraw');

		// setup texture coords
		var uvBuffer = this.meshData.getAttributeBuffer(MeshData.TEXCOORD0);
		var indexBuffer = this.meshData.getIndexBuffer();
		for ( var i = 0, max = this.particleCount; i < max; i++) {
			uvBuffer.set([1.0, 0.0], i * 8 + 0);
			uvBuffer.set([1.0, 1.0], i * 8 + 2);
			uvBuffer.set([0.0, 1.0], i * 8 + 4);
			uvBuffer.set([0.0, 0.0], i * 8 + 6);

			indexBuffer.set([i * 4 + 0, i * 4 + 3, i * 4 + 1, i * 4 + 1, i * 4 + 3, i * 4 + 2], i * 6);
		}
	};

	ParticleComponent.prototype.recreateParticles = function (particleCount) {
		this.particleCount = particleCount;
		this.particles = [];
		for ( var i = 0; i < this.particleCount; i++) {
			this.particles[i] = new Particle(this, i);
		}
		this.generateMeshData();
	};

	module.exports = ParticleComponent;

/***/ },
/* 212 */
/***/ function(module, exports, __webpack_require__) {

	var ParticleUtils = __webpack_require__(213);
	var Vector3 = __webpack_require__(8);
	var Vector4 = __webpack_require__(11);
	var MeshData = __webpack_require__(14);

	var calcVec = new Vector3();

	/**
	 * Data object tracking a single particle in a particle component
	 */
	function Particle(particleComponent, index) {
		this.alive = false;
		this.position = new Vector3();
		this.velocity = new Vector3();
		this.lifeSpan = 0;
		this.parent = particleComponent;
		this.age = 0;
		this.index = index;
		this.color = new Vector4(1, 0, 0, 1);
		this.size = 0.0;
		this.spin = 0.0;
		this.mass = 1.0;
		this.emitter = null;
		this.uvIndex = 0;
		this.lastUVIndex = -1;
		this.bbX = new Vector3();
		this.bbY = new Vector3();
		this.lastColor = new Vector4();
	}

	/**
	 * Called by the particle system to 'respawn' this particle
	 * @private
	 * @param emitter
	 */
	Particle.prototype.respawnParticle = function (emitter) {
		this.emitter = emitter;
		this.lifeSpan = emitter.nextParticleLifeSpan();
		this.alive = true;
		this.age = 0;
	};

	var tmpArray = [];

	/**
	 * Called by the particle system each frame to update the position and other properties of the particle
	 * @private
	 * @param tpf
	 * @param particleEntity
	 */
	Particle.prototype.update = function (tpf, particleEntity) {
		if (!this.alive) {
			return;
		}

		this.age += tpf;

		if (this.age > this.lifeSpan) {
			this.kill();
			return;
		}

		this.position.addDirect(this.velocity.x * tpf, this.velocity.y * tpf, this.velocity.z * tpf);

		// set values from component timeline
		ParticleUtils.applyTimeline(this, this.emitter && this.emitter.timeline ? this.emitter.timeline : this.parent.timeline);

		// apply current color to mesh
		if (!this.lastColor.equals(this.color)) {
			var colorBuffer = this.parent.meshData.getAttributeBuffer(MeshData.COLOR);

			var offset = this.index * 16;

			colorBuffer[offset + 0 + 0] = this.color.r;
			colorBuffer[offset + 0 + 1] = this.color.g;
			colorBuffer[offset + 0 + 2] = this.color.b;
			colorBuffer[offset + 0 + 3] = this.color.a;

			colorBuffer[offset + 4 + 0] = this.color.r;
			colorBuffer[offset + 4 + 1] = this.color.g;
			colorBuffer[offset + 4 + 2] = this.color.b;
			colorBuffer[offset + 4 + 3] = this.color.a;

			colorBuffer[offset + 8 + 0] = this.color.r;
			colorBuffer[offset + 8 + 1] = this.color.g;
			colorBuffer[offset + 8 + 2] = this.color.b;
			colorBuffer[offset + 8 + 3] = this.color.a;

			colorBuffer[offset + 12 + 0] = this.color.r;
			colorBuffer[offset + 12 + 1] = this.color.g;
			colorBuffer[offset + 12 + 2] = this.color.b;
			colorBuffer[offset + 12 + 3] = this.color.a;

			this.lastColor.set(this.color);
		}

		// determine our particle plane
		if (this.emitter) {
			this.emitter.getParticleBillboardVectors(this, particleEntity);
		}
		if (this.spin === 0) {
			this.bbX.scale(this.size);
			this.bbY.scale(this.size);
		} else {
			var cA = Math.cos(this.spin) * this.size;
			var sA = Math.sin(this.spin) * this.size;
			var upX = this.bbY.x, upY = this.bbY.y, upZ = this.bbY.z;
			this.bbY.set(this.bbX);
			this.bbX.scale(cA).addDirect(upX * sA, upY * sA, upZ * sA);
			this.bbY.scale(-sA).addDirect(upX * cA, upY * cA, upZ * cA);
		}

		// apply billboard vectors to mesh verts
		var vertexBuffer = this.parent.meshData.getAttributeBuffer(MeshData.POSITION);

		var offset = this.index * 12;

		// bottom right point
		calcVec.set(this.position).sub(this.bbX).sub(this.bbY);
		vertexBuffer[offset + 0 + 0] = calcVec.x;
		vertexBuffer[offset + 0 + 1] = calcVec.y;
		vertexBuffer[offset + 0 + 2] = calcVec.z;

		// top right point
		calcVec.set(this.position).sub(this.bbX).add(this.bbY);
		vertexBuffer[offset + 3 + 0] = calcVec.x;
		vertexBuffer[offset + 3 + 1] = calcVec.y;
		vertexBuffer[offset + 3 + 2] = calcVec.z;

		// top left point
		calcVec.set(this.position).add(this.bbX).add(this.bbY);
		vertexBuffer[offset + 6 + 0] = calcVec.x;
		vertexBuffer[offset + 6 + 1] = calcVec.y;
		vertexBuffer[offset + 6 + 2] = calcVec.z;

		// bottom left corner
		calcVec.set(this.position).add(this.bbX).sub(this.bbY);
		vertexBuffer[offset + 9 + 0] = calcVec.x;
		vertexBuffer[offset + 9 + 1] = calcVec.y;
		vertexBuffer[offset + 9 + 2] = calcVec.z;

		if (this.lastUVIndex !== this.uvIndex) {
			var uvBuffer = this.parent.meshData.getAttributeBuffer(MeshData.TEXCOORD0);
			var uIndex = (this.uvIndex % this.parent.uRange) / this.parent.uRange;
			var vIndex = 1.0 - (Math.floor(this.uvIndex / this.parent.vRange) / this.parent.vRange);
			var uDelta = 1.0 / this.parent.uRange;
			var vDelta = 1.0 / this.parent.vRange;

			//! AT: why go through this array?! there's only 2 values; what's the point?
			tmpArray[0] = uIndex + uDelta;
			tmpArray[1] = vIndex - vDelta;
			uvBuffer.set(tmpArray, this.index * 8 + 0);

			tmpArray[0] = uIndex + uDelta;
			tmpArray[1] = vIndex;
			uvBuffer.set(tmpArray, this.index * 8 + 2);

			tmpArray[0] = uIndex;
			tmpArray[1] = vIndex;
			uvBuffer.set(tmpArray, this.index * 8 + 4);

			tmpArray[0] = uIndex;
			tmpArray[1] = vIndex - vDelta;
			uvBuffer.set(tmpArray, this.index * 8 + 6);

			this.lastUVIndex = this.uvIndex;
		}
	};

	/**
	 * Called by update to mark this particle as dead/reusable
	 * @private
	 */
	Particle.prototype.kill = function () {
		this.alive = false;
		// collapse particle to a single point, effectively hiding it from view.
		var vertexBuffer = this.parent.meshData.getAttributeBuffer(MeshData.POSITION);
		var pointA = vertexBuffer.subarray(this.index * 12, this.index * 12 + 3);
		vertexBuffer.set(pointA, this.index * 12 + 3);
		vertexBuffer.set(pointA, this.index * 12 + 6);
		vertexBuffer.set(pointA, this.index * 12 + 9);
	};

	module.exports = Particle;

/***/ },
/* 213 */
/***/ function(module, exports, __webpack_require__) {

	var Vector3 = __webpack_require__(8);

	/**
	 * Various helper utils for particle systems.
	 */
	function ParticleUtils() {}

	ParticleUtils.getRandomVelocityOffY = function (store, minOffsetAngle, maxOffsetAngle, scale, particleEntity) {
		var randomAngle = minOffsetAngle + Math.random() * (maxOffsetAngle - minOffsetAngle);
		var randomDir = Math.PI * 2 * Math.random();

		store.x = Math.cos(randomDir) * Math.sin(randomAngle);
		store.y = Math.cos(randomAngle);
		store.z = Math.sin(randomDir) * Math.sin(randomAngle);

		if (particleEntity) {
			ParticleUtils.applyEntityTransformVector(store, particleEntity);
		}

		store.scale(scale);
		return store;
	};

	ParticleUtils.randomPointInCube = function (store, xRadius, yRadius, zRadius, center) {
		store.x = Math.random() * 2 * xRadius - xRadius + (center ? center.x : 0);
		store.y = Math.random() * 2 * yRadius - yRadius + (center ? center.y : 0);
		store.z = Math.random() * 2 * zRadius - zRadius + (center ? center.z : 0);
		return store;
	};

	ParticleUtils.createConstantForce = function (force) {
		var applyForce = new Vector3(force);
		return {
			enabled: true,
			/* Was: function (particleEntity, emitter) */
			prepare: function () {},
			/* Was: function (tpf, particle, particleIndex) */
			apply: function (tpf, particle) {
				particle.velocity.x += applyForce.x * tpf;
				particle.velocity.y += applyForce.y * tpf;
				particle.velocity.z += applyForce.z * tpf;
			}
		};
	};

	ParticleUtils.applyEntityTransformPoint = function (vec3, entity) {
		if (!entity.transformComponent || !entity.transformComponent.worldTransform) {
			return vec3;
		}

		return entity.transformComponent.sync().worldTransform.applyForward(vec3, vec3);
	};

	ParticleUtils.applyEntityTransformVector = function (vec3, entity) {
		if (!entity.transformComponent || !entity.transformComponent.worldTransform) {
			return vec3;
		}

		return entity.transformComponent.sync().worldTransform.applyForwardVector(vec3, vec3);
	};

	ParticleUtils.applyTimeline = function (particle, timeline) {
		var age = particle.age, lifeSpan = particle.lifeSpan;
		var prevCAge = 0, prevMAge = 0, prevSiAge = 0, prevSpAge = 0;
		var nextCAge = lifeSpan, nextMAge = lifeSpan, nextSiAge = lifeSpan, nextSpAge = lifeSpan;
		var trAge = 0, ratio;
		var prevCEntry = null, prevMEntry = null, prevSiEntry = null, prevSpEntry = null, prevUVEntry = null;
		var nextCEntry = null, nextMEntry = null, nextSiEntry = null, nextSpEntry = null;

		for (var i = 0, max = timeline.length; i < max; i++) {
			var entry = timeline[i];
			trAge += (entry.timeOffset ? entry.timeOffset : 0.0) * lifeSpan;
			// Color
			if (nextCEntry === null && entry.color !== undefined) {
				if (trAge > age) {
					nextCAge = trAge;
					nextCEntry = entry;
				} else {
					prevCAge = trAge;
					prevCEntry = entry;
				}
			}

			// mass
			if (nextMEntry === null && entry.mass !== undefined) {
				if (trAge > age) {
					nextMAge = trAge;
					nextMEntry = entry;
				} else {
					prevMAge = trAge;
					prevMEntry = entry;
				}
			}

			// uvIndex
			if (trAge <= age && entry.uvIndex !== undefined) {
				prevUVEntry = entry;
			}

			// size
			if (nextSiEntry === null && entry.size !== undefined) {
				if (trAge > age) {
					nextSiAge = trAge;
					nextSiEntry = entry;
				} else {
					prevSiAge = trAge;
					prevSiEntry = entry;
				}
			}

			// spin
			if (nextSpEntry === null && entry.spin !== undefined) {
				if (trAge > age) {
					nextSpAge = trAge;
					nextSpEntry = entry;
				} else {
					prevSpAge = trAge;
					prevSpEntry = entry;
				}
			}
		}

		// color
		ratio = (age - prevCAge) / (nextCAge - prevCAge);
		var start = prevCEntry !== null ? prevCEntry.color : [1, 1, 1, 1];
		var end = nextCEntry !== null ? nextCEntry.color : start;
		particle.color.x = (1.0 - ratio) * start[0] + ratio * end[0];
		particle.color.y = (1.0 - ratio) * start[1] + ratio * end[1];
		particle.color.z = (1.0 - ratio) * start[2] + ratio * end[2];
		particle.color.w = (1.0 - ratio) * start[3] + ratio * end[3];

		// mass
		ratio = (age - prevMAge) / (nextMAge - prevMAge);
		var start = prevMEntry !== null ? prevMEntry.mass : 1.0;
		var end = nextMEntry !== null ? nextMEntry.mass : start;
		particle.mass = (1 - ratio) * start + ratio * end;

		// uvIndex
		particle.uvIndex = prevUVEntry !== null ? prevUVEntry.uvIndex : 0;

		// Size
		ratio = (age - prevSiAge) / (nextSiAge - prevSiAge);
		var start = prevSiEntry !== null ? prevSiEntry.size : 1.0;
		var end = nextSiEntry !== null ? nextSiEntry.size : start;
		particle.size = (1 - ratio) * start + ratio * end;

		// Spin
		ratio = (age - prevSpAge) / (nextSpAge - prevSpAge);
		var start = prevSpEntry !== null ? prevSpEntry.spin : 0.0;
		var end = nextSpEntry !== null ? nextSpEntry.spin : start;
		particle.spin = (1 - ratio) * start + ratio * end;
	};

	module.exports = ParticleUtils;

/***/ },
/* 214 */
/***/ function(module, exports, __webpack_require__) {

	var ParticleUtils = __webpack_require__(213);
	var Renderer = __webpack_require__(123);
	var ObjectUtil = __webpack_require__(99);

	/**
	 * A Particle Emitter spawns particles - controlling spawn rate, lifetime, initial velocity vector and position of each particle.
	 * @param {Object} [options] Particle emitter options passed as an object
	 * @param {number} [options.totalParticlesToSpawn=-1] Specifies how many particles this emitter should spawn (-1 for an unlimited amount)
	 * @param {number} [options.maxLifetime=3.0] The maximum lifetime of a particle emitted by this emitter (in seconds)
	 * @param {number} [options.minLifetime=2.0] The minimum lifetime of a particle emitted by this emitter (in seconds)
	 * @param {Array<{ color, mass, uvIndex, color, size, spin }>} [options.timeline] A timeline object describing the transformations that a particle should go through while it 'ages'. This overrides the timeline set on the particle component
	 * @param {Array<ParticleInfluence>} [options.influences] An array of objects providing functions that alter the particle
	 * @param {function (particle, particleEntity) : Vector3} [options.emissionPoint] A function returning an emission point for a particle
	 * @param {function (particle, particleEntity) : Vector3} [options.getEmissionVelocity] A function returning an emission velocity for a particle
	 * @param {function (particle)} [options.getParticleBillboardVectors=ParticleEmitter.CAMERA_BILLBOARD_FUNC] A function that sets the orientation of the particle's billboard
	 * @param {number} [options.releaseRatePerSecond=10] Target number of particles per second to spawn
	 */
	function ParticleEmitter(options) {
		ObjectUtil.copyOptions(this, options, {
			totalParticlesToSpawn: -1,
			maxLifetime: 3.0,
			minLifetime: 2.0,
			timeline: undefined,
			influences: [],
			getEmissionPoint: function (particle, particleEntity) {
				var vec3 = particle.position;
				vec3.setDirect(0, 0, 0);
				return ParticleUtils.applyEntityTransformPoint(vec3, particleEntity);
			},
			getEmissionVelocity: function (particle, particleEntity) {
				var vec3 = particle.velocity;
				vec3.setDirect(0, 1, 0);
				return ParticleUtils.applyEntityTransformVector(vec3, particleEntity);
			},
			getParticleBillboardVectors: ParticleEmitter.CAMERA_BILLBOARD_FUNC,
			releaseRatePerSecond: 10,
			enabled: true
		});

		// used to track fractional parts of particles waiting to be released between frames.
		this.particlesWaitingToRelease = 0.0;
	}

	/**
	 * Sets the billboard coordinates of the particle to face the camera
	 * @param particle
	 */
	// Was: function (particle, particleEntity)
	ParticleEmitter.CAMERA_BILLBOARD_FUNC = function (particle) {
		var camera = Renderer.mainCamera;
		if (camera) {
			particle.bbX.set(camera._left);
			particle.bbY.set(camera._up);
		}
	};

	/**
	 * Returns a number between this.minLifeTime and this.maxLifeTime
	 * @private
	 * @returns {number}
	 */
	//! AT: is it just a glorified rand(min, max) function?
	ParticleEmitter.prototype.nextParticleLifeSpan = function () {
		return this.minLifetime + (this.maxLifetime - this.minLifetime) * Math.random();
	};

	module.exports = ParticleEmitter;

/***/ },
/* 215 */
/***/ function(module, exports, __webpack_require__) {

	var Component = __webpack_require__(20);
	var Material = __webpack_require__(30);

	/**
	 * Defines the appearance of a mesh, through materials. Using several materials results in multi-pass rendering.
	 * @example-link http://code.gooengine.com/latest/examples/goo/entities/components/MeshRendererComponent/MeshRendererComponent-example.html Working example
	 * @extends Component
	 */
	function MeshRendererComponent(materials) {
		Component.apply(this, arguments);

		this.type = 'MeshRendererComponent';

		//! schteppe: Don't chain or nest ternary operators as it hard to read and confusing
		/** Materials to use when rendering
		 * @type {Array<Material>}
		 */
		this.materials = Array.isArray(materials) ? materials : materials ? [materials] : [];
		/** Worldspace bounding considering entity transformations
		 * @type {BoundingVolume}
		 */
		this.worldBound = null;

		this._worldBoundDirty = true;
		this._transformUpdatedListener = null;

		/** Culling mode. Other valid values: 'Never'
		 * @type {string}
		 * @default
		 */
		this.cullMode = 'Dynamic'; //'Dynamic', 'Never'
		/**
		 * @type {boolean}
		 * @default
		 */
		this.castShadows = true;
		/**
		 * @type {boolean}
		 * @default
		 */
		this.receiveShadows = true;

		/**
		 * @type {boolean}
		 * @default
		 */
		this.isPickable = true;

		/**
		 * @type {boolean}
		 * @default
		 */
		this.isReflectable = true;

		/**
		 * @type {boolean}
		 * @default
		 */
		this.hidden = false;

		this._renderDistance = 0;

		// @ifdef DEBUG
		Object.seal(this);
		// @endif
	}

	MeshRendererComponent.type = 'MeshRendererComponent';

	MeshRendererComponent.prototype = Object.create(Component.prototype);
	MeshRendererComponent.prototype.constructor = MeshRendererComponent;

	MeshRendererComponent.prototype.api = {
		setDiffuse: function () {
			var material = this.meshRendererComponent.materials[0];
			if (!material.uniforms.materialDiffuse) {
				material.uniforms.materialDiffuse = [0, 0, 0, 1];
			}
			var diffuse = material.uniforms.materialDiffuse;

			//! AT: need to search for a pattern matching library; this is just ugly and unmaintainable
			if (arguments.length >= 3) {
				diffuse[0] = arguments[0];
				diffuse[1] = arguments[1];
				diffuse[2] = arguments[2];
				diffuse[3] = arguments.length === 3 ? 1 : arguments[3];
			} else {
				var arg = arguments[0];
				if (arg instanceof Array) {
					diffuse[0] = arg[0];
					diffuse[1] = arg[1];
					diffuse[2] = arg[2];
					diffuse[3] = arg.length === 3 ? 1 : arg[3];
				} else if (arg.r !== undefined && arg.g !== undefined && typeof arg.b !== undefined) {
					diffuse[0] = arg.r;
					diffuse[1] = arg.g;
					diffuse[2] = arg.b;
					diffuse[3] = arg.a === undefined ? 1 : arg.a;
				}
			}
		},
		getDiffuse: function () {
			return this.meshRendererComponent.materials[0].uniforms.materialDiffuse;
		}
	};

	MeshRendererComponent.entitySelectionAPI = {
		setDiffuse: MeshRendererComponent.prototype.api.setDiffuse
	};

	MeshRendererComponent.prototype.attached = function () {
		var that = this;
		this.entity.on('transformUpdated', this._transformUpdatedListener = function () {
			that._worldBoundDirty = true;
		});
	};

	MeshRendererComponent.prototype.detached = function () {
		this.entity.off('transformUpdated', this._transformUpdatedListener);
	};

	/**
	 * Update world bounding
	 *
	 * @param {BoundingVolume} bounding Bounding volume in local space
	 * @param {Transform} transform Transform to apply to local bounding -> world bounding
	 */
	MeshRendererComponent.prototype.updateBounds = function (bounding, transform) {
		this.worldBound = bounding.transform(transform, this.worldBound);
		this._worldBoundDirty = false;
	};

	/**
	 * Returns a clone of this mesh renderer component
	 * @param {Object} [options]
	 * @param {boolean} [options.shareMaterials=false] Cloning this component clones the materials by default
	 * @returns {MeshRendererComponent}
	 */
	MeshRendererComponent.prototype.clone = function (options) {
		options = options || {};

		var clonedMaterials;

		if (options.shareMaterials) {
			clonedMaterials = this.materials;
		} else {
			clonedMaterials = this.materials.map(function (material) { return material.clone(options); });
		}

		var clone = new MeshRendererComponent(clonedMaterials);

		clone.cullMode = this.cullMode;
		clone.castShadows = this.castShadows;
		clone.receiveShadows = this.receiveShadows;
		clone.isPickable = this.isPickable;
		clone.isReflectable = this.isReflectable;

		return clone;
	};

	MeshRendererComponent.applyOnEntity = function (obj, entity) {
		var meshRendererComponent = entity.meshRendererComponent;

		if (!meshRendererComponent) {
			meshRendererComponent = new MeshRendererComponent();
		}

		// or a texture
		// or a {r, g, b} object
		var matched = false;
		if (obj instanceof Material) {
			meshRendererComponent.materials.push(obj);
			matched = true;
		}

		if (matched) {
			entity.setComponent(meshRendererComponent);
			return true;
		}
	};

	module.exports = MeshRendererComponent;


/***/ },
/* 216 */
/***/ function(module, exports, __webpack_require__) {

	var BoundingBox = __webpack_require__(7);
	var Component = __webpack_require__(20);
	var MeshData = __webpack_require__(14);

	/**
	 * Holds the mesh data, like vertices, normals, indices etc. Also defines the local bounding volume.
	 * @example-link http://code.gooengine.com/latest/examples/goo/entities/components/MeshDataComponent/MeshDataComponent-example.html Working example
	 * @param {MeshData} meshData Target mesh data for this component.
	 * @extends Component
	 */
	function MeshDataComponent(meshData) {
		Component.apply(this, arguments);

		this.type = 'MeshDataComponent';

		/**
		 * @type {MeshData}
		 */
		this.meshData = meshData;

		/** Bounding volume in local space.
		 * @type {BoundingVolume}
		 */
		this.modelBound = new BoundingBox();

		/** Automatically compute bounding fit.
		 * @type {boolean}
		 * @default
		 */
		this.autoCompute = true;

		/**
		 * @type {SkeletonPose}
		 * @default
		 */
		this.currentPose = null; // SkeletonPose

		// @ifdef DEBUG
		Object.seal(this);
		// @endif
	}

	MeshDataComponent.type = 'MeshDataComponent';

	MeshDataComponent.prototype = Object.create(Component.prototype);
	MeshDataComponent.prototype.constructor = MeshDataComponent;

	/**
	 * Set the bounding volume type (sphere, box etc).
	 *
	 * @param {BoundingVolume} modelBound Bounding to apply to this meshdata component.
	 * @param {boolean} autoCompute If true, automatically compute bounding fit.
	 */
	MeshDataComponent.prototype.setModelBound = function (modelBound, autoCompute) {
		this.modelBound = modelBound;
		this.autoCompute = autoCompute;
	};

	/**
	 * Compute bounding center and bounds for this mesh.
	 */
	MeshDataComponent.prototype.computeBoundFromPoints = function () {
		if (this.autoCompute && this.modelBound !== null && this.meshData) {
			var verts = this.meshData.getAttributeBuffer('POSITION');
			if (verts !== undefined) {
				this.modelBound.computeFromPoints(verts);
				this.autoCompute = false;
			}
		}
	};

	/**
	 * Returns a clone of this mesh data component
	 * @param {Object} [options]
	 * @param {boolean} [options.shareMeshData=false] Cloning this component clones the mesh data by default
	 * @returns {MeshDataComponent}
	 */
	MeshDataComponent.prototype.clone = function (options) {
		options = options || {};

		var clone = new MeshDataComponent();

		if (options.shareMeshData) {
			clone.meshData = this.meshData;
			clone.modelBound = this.modelBound;
		} else {
			clone.meshData = this.meshData.clone();
			clone.modelBound = this.modelBound.clone();
		}

		clone.autoCompute = this.autoCompute;

		return clone;
	};

	MeshDataComponent.applyOnEntity = function (obj, entity) {
		if (obj instanceof MeshData) {
			var meshDataComponent = new MeshDataComponent(obj);
			entity.setComponent(meshDataComponent);
			return true;
		}
	};

	module.exports = MeshDataComponent;

/***/ },
/* 217 */,
/* 218 */,
/* 219 */,
/* 220 */,
/* 221 */
/***/ function(module, exports) {

	/**
	 * Shims for standard gaming features
	 * Only used to define the class. Should never be instantiated.
	 */
	function GameUtils() {}

	/** Supported features. All true by default.
	 * @type {Object}
	 * @property {boolean} fullscreen
	 * @property {boolean} pointerLock
	 */
	GameUtils.supported = {
		fullscreen: true,
		pointerLock: true
	};

	/**
	 * Attempts to request fullscreen.
	 */
	GameUtils.requestFullScreen = function () {
		if (!document.fullscreenElement && document.documentElement.requestFullScreen) {
			document.documentElement.requestFullScreen();
		}
	};

	/**
	 * Attempts to exit fullscreen.
	 */
	GameUtils.exitFullScreen = function () {
		if (document.fullscreenElement && document.cancelFullScreen) {
			document.cancelFullScreen();
		}
	};

	/**
	 * Attempts to toggle fullscreen.
	 */
	GameUtils.toggleFullScreen = function () {
		if (!document.fullscreenElement) {
			if (document.documentElement.requestFullScreen) {
				document.documentElement.requestFullScreen();
			}
		} else {
			if (document.cancelFullScreen) {
				document.cancelFullScreen();
			}
		}
	};

	/**
	 * Attempts to lock the mouse pointer in the window.
	 */
	GameUtils.requestPointerLock = function (optionalTarget) {
		var target = optionalTarget || document.documentElement;
		if (target.requestPointerLock) {
			target.requestPointerLock();
		}
	};

	/**
	 * Attempts to unlock the mouse pointer in the window.
	 */
	GameUtils.exitPointerLock = function () {
		if (document.exitPointerLock) {
			document.exitPointerLock();
		}
	};

	/**
	 * Attempts to toggle the lock on the mouse pointer in the window.
	 */
	GameUtils.togglePointerLock = function (optionalTarget) {
		if (!document.pointerLockElement) {
			GameUtils.requestPointerLock(optionalTarget);
		} else {
			GameUtils.exitPointerLock();
		}
	};

	var visibilityChangeListeners = [];

	/**
	 * Add a visibilitychange listener.
	 * @param {Function} callback function called with a boolean (true=hidden, false=visible)
	 */
	GameUtils.addVisibilityChangeListener = function (callback) {
		if (typeof callback !== 'function') {
			return;
		}

		var vendors = ['', 'ms', 'moz', 'webkit'];

		var hidden, visibilityChange;
		for (var x = 0; x < vendors.length; ++x) {
			var hiddenAttribute = vendors[x] + (vendors[x].length === 0 ? 'hidden' : 'Hidden');
			var visibilityAttribute = vendors[x] + 'visibilitychange';

			if (typeof document[hiddenAttribute] !== 'undefined') {
				hidden = hiddenAttribute;
				visibilityChange = visibilityAttribute;
				break;
			}
		}

		if (typeof document.addEventListener !== 'undefined' &&
			typeof hidden !== 'undefined') {
			var eventListener = function () {
				if (document[hidden]) {
					callback(true);
				} else {
					callback(false);
				}
			};
			visibilityChangeListeners.push({
				eventName: visibilityChange,
				eventListener: eventListener
			});
			document.addEventListener(visibilityChange, eventListener);
		}
	};

	GameUtils.clearVisibilityChangeListeners = function () {
		visibilityChangeListeners.forEach(function (listener) {
			document.removeEventListener(listener.eventName, listener.eventListener);
		});
		visibilityChangeListeners = [];
	};

	/**
	 * Attempts to initialize all shims (animation, fullscreen, pointer lock).
	 * @param {Element} [global=window] The global element (for compatibility checks and patching)
	 */
	GameUtils.initAllShims = function (global) {
		GameUtils.initWebGLShims();
		GameUtils.initAnimationShims();
		GameUtils.initFullscreenShims(global);
		GameUtils.initPointerLockShims(global);
	};

	/**
	 * Handle missing WebGL features like IE 11 Uint8ClampedArray
	 */
	GameUtils.initWebGLShims = function () {
		window.Uint8ClampedArray = window.Uint8ClampedArray || window.Uint8Array;
	};

	/**
	 * Attempts to initialize the animation shim, ie. defines requestAnimationFrame and cancelAnimationFrame
	 */
	GameUtils.initAnimationShims = function () {
		var lastTime = 0;
		var vendors = ['ms', 'moz', 'webkit', 'o'];

		for (var x = 0; x < vendors.length && !window.requestAnimationFrame; ++x) {
			window.requestAnimationFrame = window[vendors[x] + 'RequestAnimationFrame'];
			window.cancelAnimationFrame = window[vendors[x] + 'CancelAnimationFrame'] || window[vendors[x] + 'CancelRequestAnimationFrame'];
		}

		if (window.requestAnimationFrame === undefined) {
			window.requestAnimationFrame = function (callback) {
				var currTime = Date.now(), timeToCall = Math.max(0, 16 - (currTime - lastTime));
				var id = window.setTimeout(function () {
						callback(currTime + timeToCall);
					}, timeToCall);
				lastTime = currTime + timeToCall;
				return id;
			};
		}

		if (window.cancelAnimationFrame === undefined) {
			window.cancelAnimationFrame = function (id) {
				clearTimeout(id);
			};
		}
	};

	/**
	 * Attempts to initialize the fullscreen shim, ie. defines requestFullscreen and cancelFullscreen
	 * @param {Element} [global=window] The global element (for compatibility checks and patching)
	 */
	GameUtils.initFullscreenShims = function (global) {
		global = global || window;
		var elementPrototype = (global.HTMLElement || global.Element).prototype;

		if (!document.hasOwnProperty('fullscreenEnabled')) {
			var getter = (function () {
				if ('webkitIsFullScreen' in document) {
					return function () {
						return document.webkitFullscreenEnabled;
					};
				}
				if ('mozFullScreenEnabled' in document) {
					return function () {
						return document.mozFullScreenEnabled;
					};
				}

				GameUtils.supported.fullscreen = false;

				return function () {
					return false;
				};
			})();

			Object.defineProperty(document, 'fullscreenEnabled', {
				enumerable: true,
				configurable: false,
				writeable: false,
				get: getter
			});
		}

		if (!document.hasOwnProperty('fullscreenElement')) {
			var getter = (function () {
				var name = ['webkitCurrentFullScreenElement', 'webkitFullscreenElement', 'mozFullScreenElement'];

				var getNameInDocument = function (i) {
					return function () {
						return document[name[i]];
					};
				};

				for (var i = 0; i < name.length; i++) {
					if (name[i] in document) {
						return getNameInDocument(i);
					}
				}
				return function () {
					return null;
				};
			})();

			Object.defineProperty(document, 'fullscreenElement', {
				enumerable: true,
				configurable: false,
				writeable: false,
				get: getter
			});
		}

		function fullscreenchange() {
			var newEvent = document.createEvent('CustomEvent');
			newEvent.initCustomEvent('fullscreenchange', true, false, null);
			document.dispatchEvent(newEvent);
		}
		document.addEventListener('webkitfullscreenchange', fullscreenchange, false);
		document.addEventListener('mozfullscreenchange', fullscreenchange, false);

		function fullscreenerror() {
			var newEvent = document.createEvent('CustomEvent');
			newEvent.initCustomEvent('fullscreenerror', true, false, null);
			document.dispatchEvent(newEvent);
		}
		document.addEventListener('webkitfullscreenerror', fullscreenerror, false);
		document.addEventListener('mozfullscreenerror', fullscreenerror, false);

		if (!elementPrototype.requestFullScreen) {
			elementPrototype.requestFullScreen = (function () {
				if (elementPrototype.msRequestFullscreen) {
					return function () {
						this.msRequestFullscreen();
					};
				}

				if (elementPrototype.webkitRequestFullscreen) {
					return function () {
						this.webkitRequestFullscreen(global.Element.ALLOW_KEYBOARD_INPUT);
					};
				}

				if (elementPrototype.webkitRequestFullScreen) {
					return function () {
						this.webkitRequestFullScreen(global.Element.ALLOW_KEYBOARD_INPUT);
					};
				}

				if (elementPrototype.mozRequestFullScreen) {
					return function () {
						this.mozRequestFullScreen();
					};
				}

				return function () {};
			})();
		}

		if (!document.cancelFullScreen) {
			document.cancelFullScreen = (function () {
				return document.webkitCancelFullScreen || document.mozCancelFullScreen || function () {
				};
			})();
		}
	};

	/**
	 * Attempts to initialize the pointer lock shim, ie. define requestPointerLock and exitPointerLock
	 * @param {Element} [global=window] The global element (for compatibility checks and patching)
	 */
	GameUtils.initPointerLockShims = function (global) {
		global = global || window;
		var elementPrototype = (global.HTMLElement || global.Element).prototype;

		if (!global.MouseEvent) {
			return;
		}

		var mouseEventPrototype = global.MouseEvent.prototype;

		if (!('movementX' in mouseEventPrototype)) {
			Object.defineProperty(mouseEventPrototype, 'movementX', {
				enumerable: true,
				configurable: false,
				writeable: false,
				get: function () {
					return this.webkitMovementX || this.mozMovementX || 0;
				}
			});
		}

		if (!('movementY' in mouseEventPrototype)) {
			Object.defineProperty(mouseEventPrototype, 'movementY', {
				enumerable: true,
				configurable: false,
				writeable: false,
				get: function () {
					return this.webkitMovementY || this.mozMovementY || 0;
				}
			});
		}

		if (!navigator.pointer) {
			navigator.pointer = navigator.webkitPointer || navigator.mozPointer;
		}

		function pointerlockchange() {
			var newEvent = document.createEvent('CustomEvent');
			newEvent.initCustomEvent('pointerlockchange', true, false, null);
			document.dispatchEvent(newEvent);
		}
		document.addEventListener('webkitpointerlockchange', pointerlockchange, false);
		document.addEventListener('webkitpointerlocklost', pointerlockchange, false);
		document.addEventListener('mozpointerlockchange', pointerlockchange, false);
		document.addEventListener('mozpointerlocklost', pointerlockchange, false);

		function pointerlockerror() {
			var newEvent = document.createEvent('CustomEvent');
			newEvent.initCustomEvent('pointerlockerror', true, false, null);
			document.dispatchEvent(newEvent);
		}
		document.addEventListener('webkitpointerlockerror', pointerlockerror, false);
		document.addEventListener('mozpointerlockerror', pointerlockerror, false);

		if (!("pointerLockElement" in document)) {
			var getter = (function () {
				if ('webkitPointerLockElement' in document) {
					return function () {
						return document.webkitPointerLockElement;
					};
				}
				if ('mozPointerLockElement' in document) {
					return function () {
						return document.mozPointerLockElement;
					};
				}
				return function () {
					return null;
				};
			})();

			Object.defineProperty(document, 'pointerLockElement', {
				enumerable: true,
				configurable: false,
				writeable: false,
				get: getter
			});
		}

		if (!elementPrototype.requestPointerLock) {
			elementPrototype.requestPointerLock = (function () {
				if (elementPrototype.webkitRequestPointerLock) {
					return function () {
						this.webkitRequestPointerLock();
					};
				}

				if (elementPrototype.mozRequestPointerLock) {
					return function () {
						this.mozRequestPointerLock();
					};
				}

				if (navigator.pointer) {
					return function () {
						navigator.pointer.lock(this, pointerlockchange, pointerlockerror);
					};
				}

				GameUtils.supported.pointerLock = false;

				return function () {};
			})();
		}

		if (!document.exitPointerLock) {
			document.exitPointerLock = (function () {
				return document.webkitExitPointerLock || document.mozExitPointerLock || function () {
					if (navigator.pointer) {
						navigator.pointer.unlock();
					}
				};
			})();
		}
	};

	module.exports = GameUtils;

/***/ },
/* 222 */,
/* 223 */
/***/ function(module, exports, __webpack_require__) {

	var PromiseUtils = __webpack_require__(54);

	/**
	 * Promise-related utilities
	 * @target-class PromiseUtil PromiseUtil constructor
	 * @require-pathvar PromiseUtil = require('../util/PromiseUtil');
	 * @group util
	 * @deprecated Deprecated as of 0.14.x and scheduled for removal in 0.16.0; The class has been renamed to `goo/util/PromiseUtils`
	 */
	module.exports = PromiseUtils;

/***/ },
/* 224 */,
/* 225 */,
/* 226 */,
/* 227 */,
/* 228 */,
/* 229 */
/***/ function(module, exports, __webpack_require__) {

	var Component = __webpack_require__(20);
	var RenderTarget = __webpack_require__(133);

	/**
	 * Renders to the texture of the host object<br>
	 * @example-link http://code.gooengine.com/latest/visual-test/goo/entities/components/PortalComponent/PortalComponent-vtest.html Working example
	 * @param {Camera} camera The camera used for rendering
	 * @param {number} [height=200] Height of the texture to render to (the width is calculated automatically from the camera's aspect ratio)
	 * @param {Object} options
	 * @param {boolean} [options.autoUpdate=true] If set to true then updating is done every frame, otherwise updating is done only when solicited via the `requestUpdate` method
	 * @param {boolean} [options.preciseRecursion=false] By default the "portal depth" (the number of portals seen through a portal) is of 4. By enabling this option the limitation disappears, but at the cost of using more memory.
	 * @param {Material} [overrideMaterial=null] Optional override material to use when rendering to the host object
	 * @extends Component
	 */
	function PortalComponent(camera, height, options, overrideMaterial) {
		Component.apply(this, arguments);

		height = height || 200;

		this.options = options || {};
		this.options.preciseRecursion = !!this.options.preciseRecursion;
		this.options.autoUpdate = this.options.autoUpdate !== false;

		this.overrideMaterial = overrideMaterial;

		this.doUpdate = true;

		var aspect = camera.aspect;

		this.type = 'PortalComponent';

		/**
		 * @type {Camera}
		 */
		this.camera = camera;

		/**
		 * @type {RenderTarget}
		 */
		this.target = new RenderTarget(height, height / aspect);

		if (this.options.preciseRecursion) {
			this.secondaryTarget = new RenderTarget(height, height / aspect);
		}

		// @ifdef DEBUG
		Object.seal(this);
		// @endif
	}

	PortalComponent.type = 'PortalComponent';

	PortalComponent.prototype = Object.create(Component.prototype);
	PortalComponent.prototype.constructor = PortalComponent;

	/**
	 * Requests a rendering to be done to the material of the host object
	 */
	PortalComponent.prototype.requestUpdate = function () {
		this.doUpdate = true;
	};

	module.exports = PortalComponent;

/***/ },
/* 230 */
/***/ function(module, exports, __webpack_require__) {

	var System = __webpack_require__(42);

	/**
	 * Processes all entities with a portal component, a mesh renderer component and a mesh data component
	 * @extends System
	 * @example-link http://code.gooengine.com/latest/visual-test/goo/entities/components/PortalComponent/PortalComponent-vtest.html Working example
	 * @param {Renderer} renderer
	 * @param {RenderSystem} renderSystem
	 */
	function PortalSystem(renderer, renderSystem) {
		System.call(this, 'PortalSystem', ['MeshRendererComponent', 'MeshDataComponent', 'PortalComponent']);

		this.renderer = renderer;
		this.renderSystem = renderSystem;

		this.renderList = [];
	}

	PortalSystem.prototype = Object.create(System.prototype);
	PortalSystem.prototype.constructor = PortalSystem;

	PortalSystem.prototype.process = function (entities) {
		for (var i = 0; i < entities.length; i++) {
			var entity = entities[i];
			var portalComponent = entity.portalComponent;

			if (portalComponent.options.autoUpdate || portalComponent.doUpdate) {
				portalComponent.doUpdate = false;

				var camera = portalComponent.camera;
				var target = portalComponent.target;
				var secondaryTarget = portalComponent.secondaryTarget;
				var overrideMaterial = portalComponent.overrideMaterial;

				this.render(this.renderer, camera, target, overrideMaterial);

				var material = entity.meshRendererComponent.materials[0];
				material.setTexture('DIFFUSE_MAP', target);

				if (portalComponent.options.preciseRecursion) {
					var tmp = target;
					portalComponent.target = secondaryTarget;
					portalComponent.secondaryTarget = tmp;
				}
			}
		}
	};

	PortalSystem.prototype.render = function (renderer, camera, target, overrideMaterial) {
		renderer.updateShadows(this.renderSystem.partitioner, this.renderSystem.entities, this.renderSystem.lights);

		for (var i = 0; i < this.renderSystem.preRenderers.length; i++) {
			var preRenderer = this.renderSystem.preRenderers[i];
			preRenderer.process(renderer, this.renderSystem.entities, this.renderSystem.partitioner, camera, this.renderSystem.lights);
		}

		this.renderSystem.partitioner.process(camera, this.renderSystem.entities, this.renderList);

		renderer.render(this.renderList, camera, this.renderSystem.lights, target, true, overrideMaterial);
	};

	module.exports = PortalSystem;

/***/ },
/* 231 */,
/* 232 */,
/* 233 */,
/* 234 */,
/* 235 */,
/* 236 */,
/* 237 */,
/* 238 */,
/* 239 */,
/* 240 */,
/* 241 */,
/* 242 */,
/* 243 */,
/* 244 */,
/* 245 */,
/* 246 */,
/* 247 */,
/* 248 */,
/* 249 */,
/* 250 */,
/* 251 */,
/* 252 */,
/* 253 */,
/* 254 */,
/* 255 */,
/* 256 */,
/* 257 */,
/* 258 */,
/* 259 */,
/* 260 */,
/* 261 */,
/* 262 */,
/* 263 */,
/* 264 */,
/* 265 */,
/* 266 */,
/* 267 */,
/* 268 */,
/* 269 */,
/* 270 */,
/* 271 */,
/* 272 */,
/* 273 */,
/* 274 */,
/* 275 */,
/* 276 */,
/* 277 */,
/* 278 */,
/* 279 */,
/* 280 */,
/* 281 */,
/* 282 */,
/* 283 */,
/* 284 */,
/* 285 */,
/* 286 */,
/* 287 */,
/* 288 */,
/* 289 */,
/* 290 */,
/* 291 */,
/* 292 */,
/* 293 */,
/* 294 */
/***/ function(module, exports, __webpack_require__) {

	var MeshData = __webpack_require__(14);
	var ObjectUtils = __webpack_require__(6);

	/**
	 * A disk shape
	 * @extends MeshData
	 * @example-link http://code.gooengine.com/latest/visual-test/goo/shapes/Disk/Disk-vtest.html Working example
	 * @param {number} [nSegments=8] Number of slices
	 * @param {number} [radius=1] Radius of the disk
	 * @param {number} [pointiness=0] The center of the disk can be offset in both directions from its outer edge by setting a positive or negative pointiness.
	 */
	function Disk(nSegments, radius, pointiness) {
		if (arguments.length === 1 && arguments[0] instanceof Object) {
			var props = arguments[0];
			nSegments = props.nSegments;
			radius = props.radius;
			pointiness = props.pointiness;
		}
		//! AT: in cylinder and cone this is called radialSamples
		this.nSegments = nSegments || 8;
		this.radius = radius || 1;
		this.pointiness = pointiness || 0;

		var attributeMap = MeshData.defaultMap([MeshData.POSITION, MeshData.NORMAL, MeshData.TEXCOORD0]);
		MeshData.call(this, attributeMap, this.nSegments + 1, this.nSegments * 3);

		this.indexModes = ['Triangles'];

		this.rebuild();
	}

	Disk.prototype = Object.create(MeshData.prototype);
	Disk.prototype.constructor = Disk;

	/**
	 * Builds or rebuilds the mesh data.
	 * @returns {Disk} Self for chaining.
	 */
	Disk.prototype.rebuild = function () {
		var verts = [];
		var norms = [];
		var tex = [];
		var indices = [];

		var slope = Math.atan2(this.radius, this.pointiness);

		var angleIncrement = Math.PI * 2 / this.nSegments;
		for (var i = 0, angle = 0; i < this.nSegments; i++, angle += angleIncrement) {
			verts.push(
				Math.cos(angle) * this.radius,
				Math.sin(angle) * this.radius,
				0);

			norms.push(
				Math.cos(angle) * Math.cos(slope),
				Math.sin(angle) * Math.cos(slope),
				Math.sin(slope));

			tex.push(
				Math.cos(angle) * 0.5 + 0.5,
				Math.sin(angle) * 0.5 + 0.5);

			indices.push(this.nSegments, i, (i + 1) % this.nSegments);
		}

		verts.push(0, 0, this.pointiness);
		norms.push(0, 0, 1);
		tex.push(0.5, 0.5);

		this.getAttributeBuffer(MeshData.POSITION).set(verts);
		this.getAttributeBuffer(MeshData.NORMAL).set(norms);
		this.getAttributeBuffer(MeshData.TEXCOORD0).set(tex);
		this.getIndexBuffer().set(indices);

		return this;
	};

	/**
	 * Returns a clone of this disk
	 * @returns {Disk}
	 */
	Disk.prototype.clone = function () {
		var options = ObjectUtils.shallowSelectiveClone(this, ['nSegments', 'radius', 'pointiness']);

		return new Disk(options);
	};

	module.exports = Disk;

/***/ },
/* 295 */,
/* 296 */,
/* 297 */
/***/ function(module, exports, __webpack_require__) {

	var MeshData = __webpack_require__(14);
	var Vector3 = __webpack_require__(8);
	var MathUtils = __webpack_require__(9);
	var ObjectUtils = __webpack_require__(6);

	/**
	 * A donut-shaped model.
	 * @extends MeshData
	 * @param {number} [circleSamples=8] Number of segments.
	 * @param {number} [radialSamples=8] Number of slices.
	 * @param {number} [tubeRadius=1] Radius of tube.
	 * @param {number} [centerRadius=2] Radius from center.
	 */
	function Torus(circleSamples, radialSamples, tubeRadius, centerRadius) {
		if (arguments.length === 1 && arguments[0] instanceof Object) {
			var props = arguments[0];
			circleSamples = props.circleSamples;
			radialSamples = props.radialSamples;
			tubeRadius = props.tubeRadius;
			centerRadius = props.centerRadius;
		}
		this.circleSamples = circleSamples !== undefined ? circleSamples : 8;
		this.radialSamples = radialSamples !== undefined ? radialSamples : 8;
		this.tubeRadius = tubeRadius !== undefined ? tubeRadius : 1;
		this.centerRadius = centerRadius !== undefined ? centerRadius : 2;

		/** Inward-facing normals.
		 * @type {boolean}
		 * @default
		 */
		this.viewInside = false;

		var attributeMap = MeshData.defaultMap([MeshData.POSITION, MeshData.NORMAL, MeshData.TEXCOORD0]);
		var vertices = (this.circleSamples + 1) * (this.radialSamples + 1);
		var indices = 6 * this.circleSamples * this.radialSamples;
		MeshData.call(this, attributeMap, vertices, indices);

		this.rebuild();
	}

	Torus.prototype = Object.create(MeshData.prototype);
	Torus.prototype.constructor = Torus;

	/**
	 * Builds or rebuilds the mesh data.
	 * @returns {Torus} Self for chaining.
	 */
	Torus.prototype.rebuild = function () {
		var vbuf = this.getAttributeBuffer(MeshData.POSITION);
		var norms = this.getAttributeBuffer(MeshData.NORMAL);
		var texs = this.getAttributeBuffer(MeshData.TEXCOORD0);
		var indices = this.getIndexBuffer();

		// generate geometry
		var inverseCircleSamples = 1.0 / this.circleSamples;
		var inverseRadialSamples = 1.0 / this.radialSamples;
		var i = 0;
		// generate the cylinder itself
		var radialAxis = new Vector3(), torusMiddle = new Vector3(), tempNormal = new Vector3();
		for (var circleCount = 0; circleCount < this.circleSamples; circleCount++) {
			// compute center point on torus circle at specified angle
			var circleFraction = circleCount * inverseCircleSamples;
			var theta = MathUtils.TWO_PI * circleFraction;
			var cosTheta = Math.cos(theta);
			var sinTheta = Math.sin(theta);
			radialAxis.setDirect(cosTheta, sinTheta, 0);
			torusMiddle.copy(radialAxis).scale(this.centerRadius);

			// compute slice vertices with duplication at end point
			var iSave = i;
			for (var radialCount = 0; radialCount < this.radialSamples; radialCount++) {
				var radialFraction = radialCount * inverseRadialSamples;
				// in [0, 1)
				var phi = MathUtils.TWO_PI * radialFraction;
				var cosPhi = Math.cos(phi);
				var sinPhi = Math.sin(phi);

				tempNormal.copy(radialAxis).scale(cosPhi);
				tempNormal.z += sinPhi;
				tempNormal.normalize();

				if (!this.viewInside) {
					norms[i * 3 + 0] = tempNormal.x;
					norms[i * 3 + 1] = tempNormal.y;
					norms[i * 3 + 2] = tempNormal.z;
				} else {
					norms[i * 3 + 0] = -tempNormal.x;
					norms[i * 3 + 1] = -tempNormal.y;
					norms[i * 3 + 2] = -tempNormal.z;
				}

				tempNormal.scale(this.tubeRadius).add(torusMiddle);

				vbuf[i * 3 + 0] = tempNormal.x;
				vbuf[i * 3 + 1] = tempNormal.y;
				vbuf[i * 3 + 2] = tempNormal.z;

				texs[i * 2 + 0] = radialFraction;
				texs[i * 2 + 1] = circleFraction;

				i++;
			}

			copyInternal(vbuf, iSave, i);
			copyInternal(norms, iSave, i);

			texs[i * 2 + 0] = 1.0;
			texs[i * 2 + 1] = circleFraction;

			i++;
		}

		// duplicate the cylinder ends to form a torus
		for (var iR = 0; iR <= this.radialSamples; iR++, i++) {
			copyInternal(vbuf, iR, i);
			copyInternal(norms, iR, i);
			copyInternal2(texs, iR, i);
			texs[i * 2 + 1] = 1.0;
		}

		// generate connectivity
		var index = 0;
		var connectionStart = 0;
		for (var circleCount = 0; circleCount < this.circleSamples; circleCount++) {
			var i0 = connectionStart;
			var i1 = i0 + 1;
			connectionStart += this.radialSamples + 1;
			var i2 = connectionStart;
			var i3 = i2 + 1;
			for (i = 0; i < this.radialSamples; i++) {
				if (!this.viewInside) {
					indices[index++] = i0++;
					indices[index++] = i2;
					indices[index++] = i1;
					indices[index++] = i1++;
					indices[index++] = i2++;
					indices[index++] = i3++;
				} else {
					indices[index++] = i0++;
					indices[index++] = i1;
					indices[index++] = i2;
					indices[index++] = i1++;
					indices[index++] = i3++;
					indices[index++] = i2++;
				}
			}
		}

		return this;
	};

	//! AT: there's a method for doing this exact thing on typed arrays, copyWithin()
	function copyInternal(buf, from, to) {
		buf[to * 3 + 0] = buf[from * 3 + 0];
		buf[to * 3 + 1] = buf[from * 3 + 1];
		buf[to * 3 + 2] = buf[from * 3 + 2];
	}

	function copyInternal2(buf, from, to) {
		buf[to * 2 + 0] = buf[from * 2 + 0];
		buf[to * 2 + 1] = buf[from * 2 + 1];
	}

	/**
	 * Returns a clone of this texture torus
	 * @returns {Torus}
	 */
	Torus.prototype.clone = function () {
		var options = ObjectUtils.shallowSelectiveClone(this,
			['circleSamples', 'radialSamples', 'tubeRadius', 'centerRadius']);

		return new Torus(options);
	};

	module.exports = Torus;

/***/ },
/* 298 */,
/* 299 */,
/* 300 */
/***/ function(module, exports, __webpack_require__) {

	if (typeof window !== 'undefined') {
		__webpack_require__(301);
	}

	module.exports = {
		Ajax: __webpack_require__(132),
		ArrayUtil: __webpack_require__(302),
		ArrayUtils: __webpack_require__(86),
		AtlasNode: __webpack_require__(303),
		AudioContext: __webpack_require__(305),
		BoundingBox: __webpack_require__(7),
		BoundingPicker: __webpack_require__(165),
		BoundingSphere: __webpack_require__(13),
		BoundingTree: __webpack_require__(306),
		BoundingUpdateSystem: __webpack_require__(307),
		BoundingVolume: __webpack_require__(12),
		Box: __webpack_require__(27),
		BufferData: __webpack_require__(15),
		BufferUtils: __webpack_require__(16),
		Bus: __webpack_require__(45),
		Camera: __webpack_require__(120),
		CameraComponent: __webpack_require__(308),
		CameraComponentHandler: __webpack_require__(309),
		CameraSystem: __webpack_require__(310),
		CanvasUtils: __webpack_require__(131),
		Capabilities: __webpack_require__(17),
		Component: __webpack_require__(20),
		ComponentHandler: __webpack_require__(88),
		Composer: __webpack_require__(311),
		Cone: __webpack_require__(312),
		ConfigHandler: __webpack_require__(85),
		ContextLost: __webpack_require__(313),
		CrunchLoader: __webpack_require__(129),
		CssTransformComponent: __webpack_require__(314),
		CssTransformSystem: __webpack_require__(315),
		Cylinder: __webpack_require__(117),
		DdsLoader: __webpack_require__(127),
		DdsUtils: __webpack_require__(128),
		DirectionalLight: __webpack_require__(51),
		Disk: __webpack_require__(294),
		Dom3dComponent: __webpack_require__(316),
		Dom3dComponentHandler: __webpack_require__(317),
		Dom3dSystem: __webpack_require__(318),
		DynamicLoader: __webpack_require__(319),
		Easing: __webpack_require__(173),
		Entity: __webpack_require__(35),
		EntityCombiner: __webpack_require__(342),
		EntityHandler: __webpack_require__(321),
		EntityManager: __webpack_require__(38),
		EntitySelection: __webpack_require__(21),
		EntityUtils: __webpack_require__(3),
		EnvironmentHandler: __webpack_require__(336),
		EventTarget: __webpack_require__(37),
		FullscreenPass: __webpack_require__(135),
		FullscreenUtil: __webpack_require__(343),
		FullscreenUtils: __webpack_require__(136),
		GameUtils: __webpack_require__(221),
		GooRunner: __webpack_require__(344),
		Grid: __webpack_require__(355),
		GridRenderSystem: __webpack_require__(356),
		HtmlComponent: __webpack_require__(341),
		HtmlComponentHandler: __webpack_require__(340),
		HtmlSystem: __webpack_require__(357),
		JsonHandler: __webpack_require__(322),
		Light: __webpack_require__(50),
		LightComponent: __webpack_require__(194),
		LightComponentHandler: __webpack_require__(323),
		LightingSystem: __webpack_require__(349),
		Logo: __webpack_require__(354),
		Manager: __webpack_require__(39),
		Material: __webpack_require__(30),
		MaterialHandler: __webpack_require__(324),
		MathUtils: __webpack_require__(9),
		Matrix2: __webpack_require__(358),
		Matrix2x2: __webpack_require__(359),
		Matrix3: __webpack_require__(24),
		Matrix3x3: __webpack_require__(360),
		Matrix4: __webpack_require__(33),
		Matrix4x4: __webpack_require__(361),
		Matrix: __webpack_require__(25),
		MeshBuilder: __webpack_require__(112),
		MeshData: __webpack_require__(14),
		MeshDataComponent: __webpack_require__(216),
		MeshDataComponentHandler: __webpack_require__(325),
		MeshDataHandler: __webpack_require__(326),
		MeshRendererComponent: __webpack_require__(215),
		MeshRendererComponentHandler: __webpack_require__(327),
		MovementComponent: __webpack_require__(362),
		MovementSystem: __webpack_require__(363),
		Noise: __webpack_require__(364),
		ObjectUtil: __webpack_require__(99),
		ObjectUtils: __webpack_require__(6),
		OrbitCamControlScript: __webpack_require__(365),
		OscillatorSound: __webpack_require__(366),
		Particle: __webpack_require__(212),
		ParticleComponent: __webpack_require__(211),
		ParticleEmitter: __webpack_require__(214),
		ParticleInfluence: __webpack_require__(367),
		ParticleLib: __webpack_require__(209),
		ParticlesSystem: __webpack_require__(350),
		ParticleSystemUtils: __webpack_require__(210),
		ParticleUtils: __webpack_require__(213),
		Pass: __webpack_require__(137),
		PickingSystem: __webpack_require__(368),
		PipRenderSystem: __webpack_require__(369),
		Plane: __webpack_require__(121),
		PointLight: __webpack_require__(49),
		PortalComponent: __webpack_require__(229),
		PortalSystem: __webpack_require__(230),
		PrimitivePickLogic: __webpack_require__(370),
		ProjectHandler: __webpack_require__(331),
		PromiseUtil: __webpack_require__(223),
		PromiseUtils: __webpack_require__(54),
		Quad: __webpack_require__(28),
		Quaternion: __webpack_require__(23),
		Ray: __webpack_require__(122),
		Rc4Random: __webpack_require__(371),
		Rectangle: __webpack_require__(304),
		Renderer: __webpack_require__(123),
		RendererRecord: __webpack_require__(124),
		RendererUtils: __webpack_require__(18),
		RenderInfo: __webpack_require__(140),
		RenderPass: __webpack_require__(372),
		RenderQueue: __webpack_require__(43),
		RenderStats: __webpack_require__(138),
		RenderSystem: __webpack_require__(346),
		RenderTarget: __webpack_require__(133),
		rsvp: __webpack_require__(55),
		SceneHandler: __webpack_require__(328),
		ScriptComponent: __webpack_require__(353),
		Scripts: __webpack_require__(4),
		ScriptSystem: __webpack_require__(348),
		ScriptUtils: __webpack_require__(5),
		Selection: __webpack_require__(22),
		Shader: __webpack_require__(31),
		ShaderBuilder: __webpack_require__(48),
		ShaderCall: __webpack_require__(32),
		ShaderFragment: __webpack_require__(47),
		ShaderHandler: __webpack_require__(329),
		ShaderLib: __webpack_require__(46),
		ShadowHandler: __webpack_require__(134),
		ShapeCreatorMemoized: __webpack_require__(320),
		SimpleBox: __webpack_require__(373),
		SimplePartitioner: __webpack_require__(347),
		Skybox: __webpack_require__(339),
		SkyboxHandler: __webpack_require__(338),
		Snow: __webpack_require__(337),
		Sound: __webpack_require__(335),
		SoundComponent: __webpack_require__(333),
		SoundComponentHandler: __webpack_require__(332),
		SoundCreator: __webpack_require__(374),
		SoundHandler: __webpack_require__(334),
		SoundSystem: __webpack_require__(352),
		Sphere: __webpack_require__(29),
		Spline: __webpack_require__(375),
		SplineWalker: __webpack_require__(376),
		SpotLight: __webpack_require__(52),
		Stats: __webpack_require__(351),
		StringUtil: __webpack_require__(377),
		StringUtils: __webpack_require__(36),
		System: __webpack_require__(42),
		SystemBus: __webpack_require__(44),
		TangentGenerator: __webpack_require__(57),
		TaskScheduler: __webpack_require__(139),
		TextComponent: __webpack_require__(378),
		TextSystem: __webpack_require__(379),
		Texture: __webpack_require__(53),
		TextureCreator: __webpack_require__(125),
		TextureGrid: __webpack_require__(380),
		TextureHandler: __webpack_require__(126),
		TgaLoader: __webpack_require__(130),
		Torus: __webpack_require__(297),
		Transform: __webpack_require__(41),
		TransformComponent: __webpack_require__(40),
		TransformComponentHandler: __webpack_require__(330),
		TransformSystem: __webpack_require__(345),
		ValueNoise: __webpack_require__(381),
		Vector2: __webpack_require__(19),
		Vector3: __webpack_require__(8),
		Vector4: __webpack_require__(11),
		Vector: __webpack_require__(10),
		World: __webpack_require__(34)
	};

	if (typeof(window) !== 'undefined') {
		window.goo = module.exports;
	}

/***/ },
/* 301 */
/***/ function(module, exports) {

	// based on es6-collections by Andrea Giammarchi, @WebReflection
	// Object.is shim from the MDN
	(function (global) {
		'use strict';

		if (!Object.is) {
			Object.is = function(v1, v2) {
				if (v1 === 0 && v2 === 0) {
					return 1 / v1 === 1 / v2;
				}
				if (v1 !== v1) {
					return v2 !== v2;
				}
				return v1 === v2;
			};
		}

		//shared pointer
		var i;
		//shortcuts
		var defineProperty = Object.defineProperty, is = Object.is;

		if (!global.Set) {
			global.Map = createCollection({
				// WeakMap#delete(key:void*):boolean
				'delete': sharedDelete,
				//:was Map#get(key:void*[, d3fault:void*]):void*
				// Map#has(key:void*):boolean
				has: mapHas,
				// Map#get(key:void*):boolean
				get: sharedGet,
				// Map#set(key:void*, value:void*):void
				set: sharedSet,
				// Map#keys(void):Array === not in specs
				keys: sharedKeys,
				// Map#values(void):Array === not in specs
				values: sharedValues,
				// Map#forEach(callback:Function, context:void*):void ==> callback.call(context, key, value, mapObject) === not in specs`
				forEach: sharedForEach,
				// Map#clear():
				clear: sharedClear
			});

			global.Set = createCollection({
				// Set#has(value:void*):boolean
				has: setHas,
				// Set#add(value:void*):boolean
				add: sharedAdd,
				// Set#delete(key:void*):boolean
				'delete': sharedDelete,
				// Set#clear():
				clear: sharedClear,
				// Set#values(void):Array === not in specs
				values: sharedValues,
				// Set#forEach(callback:Function, context:void*):void ==> callback.call(context, value, index) === not in specs
				forEach: sharedSetIterate
			});
		}

		/**
		 * ES6 collection constructor
		 * @return {Function} a collection class
		 */
		function createCollection(proto, objectOnly){
			function Collection(a){
				if (!this || this.constructor !== Collection) return new Collection(a);
				this._keys = [];
				this._values = [];
				this.objectOnly = objectOnly;

				//parse initial iterable argument passed
				if (a) init.call(this, a);
			}

			//define size for non object-only collections
			if (!objectOnly) {
				defineProperty(proto, 'size', {
					get: sharedSize
				});
			}

			//set prototype
			proto.constructor = Collection;
			Collection.prototype = proto;

			return Collection;
		}


		/** parse initial iterable argument passed */
		function init(a){
			//init Set argument, like `[1,2,3,{}]`
			if (this.add)
				a.forEach(this.add, this);
			//init Map argument like `[[1,2], [{}, 4]]`
			else
				a.forEach(function(a){this.set(a[0],a[1])}, this);
		}


		/** delete */
		function sharedDelete(key) {
			if (this.has(key)) {
				this._keys.splice(i, 1);
				this._values.splice(i, 1);
			}
			// Aurora here does it while Canary doesn't
			return -1 < i;
		}

		function sharedGet(key) {
			return this.has(key) ? this._values[i] : undefined;
		}

		function has(list, key) {
			if (this.objectOnly && key !== Object(key))
				throw new TypeError("Invalid value used as weak collection key");
			//NaN or 0 passed
			if (key != key || key === 0) for (i = list.length; i-- && !is(list[i], key););
			else i = list.indexOf(key);
			return -1 < i;
		}

		function setHas(value) {
			return has.call(this, this._values, value);
		}

		function mapHas(value) {
			return has.call(this, this._keys, value);
		}

		/** @chainable */
		function sharedSet(key, value) {
			this.has(key) ?
				this._values[i] = value
				:
				this._values[this._keys.push(key) - 1] = value
			;
			return this;
		}

		/** @chainable */
		function sharedAdd(value) {
			if (!this.has(value)) this._values.push(value);
			return this;
		}

		function sharedClear() {
			this._values.length = 0;
		}

		/** keys, values, and iterate related methods */
		function sharedValues() {
			return this._values.slice();
		}

		function sharedKeys() {
			return this._keys.slice();
		}

		function sharedSize() {
			return this._values.length;
		}

		function sharedForEach(callback, context) {
			var self = this;
			var values = self._values.slice();
			self._keys.slice().forEach(function (key, n) {
				callback.call(context, values[n], key, self);
			});
		}

		function sharedSetIterate(callback, context) {
			var self = this;
			self._values.slice().forEach(function (value) {
				callback.call(context, value, value, self);
			});
		}
	})(typeof(window) !== 'undefined' && window || this);

/***/ },
/* 302 */
/***/ function(module, exports, __webpack_require__) {

	var ArrayUtils = __webpack_require__(86);


	/**
	 * Array-related utilities
	 * @target-class ArrayUtil ArrayUtil constructor
	 * @require-pathvar ArrayUtil = require('../util/ArrayUtil');
	 * @group util
	 * @deprecated Deprecated as of 0.14.x and scheduled for removal in 0.16.0; The class has been renamed to `goo/util/ArrayUtils`
	 */
	module.exports = ArrayUtils;


/***/ },
/* 303 */
/***/ function(module, exports, __webpack_require__) {

	var Rectangle = __webpack_require__(304);

	/**
	 * Atlas node
	 * @hidden
	 * @param w
	 * @param h
	 */
	function AtlasNode(w, h) {
		this.isLeaf = true;
		this.isSet = false;
		this.children = [];
		if (w !== undefined && h !== undefined) {
			this.localRectangle = new Rectangle(0, 0, w, h);
		} else {
			this.localRectangle = null;
		}
	}

	AtlasNode.prototype.getRectangles = function () {
		var rectangles = [];
		this._getRectangles(rectangles);
		return rectangles;
	};

	AtlasNode.prototype._getRectangles = function (list) {
		if (this.isSet) {
			list.push(this.localRectangle);
		}
		if (!this.isLeaf) {
			this.children[0]._getRectangles(list);
			this.children[1]._getRectangles(list);
		}
	};

	AtlasNode.prototype.insert = function (w, h) {
		return this._insert(new Rectangle(0, 0, w, h));
	};

	AtlasNode.prototype._insert = function (rectangle) {
		if (!this.isLeaf) {
			var newNode = this.children[0]._insert(rectangle);
			if (newNode !== null) {
				return newNode;
			}

			return this.children[1]._insert(rectangle);
		} else {
			if (this.isSet) {
				return null;
			}

			if (rectangle.w > this.localRectangle.w || rectangle.h > this.localRectangle.h) {
				return null;
			}

			if (rectangle.w === this.localRectangle.w && rectangle.h === this.localRectangle.h) {
				this.isSet = true;
				return this;
			}

			this.isLeaf = false;

			this.children[0] = new AtlasNode();
			this.children[1] = new AtlasNode();

			var dw = this.localRectangle.w - rectangle.w;
			var dh = this.localRectangle.h - rectangle.h;

			if (dw > dh) {
				this.children[0].localRectangle = new Rectangle(this.localRectangle.x, this.localRectangle.y, rectangle.w, this.localRectangle.h);
				this.children[1].localRectangle = new Rectangle(this.localRectangle.x + rectangle.w, this.localRectangle.y, dw, this.localRectangle.h);
			} else {
				this.children[0].localRectangle = new Rectangle(this.localRectangle.x, this.localRectangle.y, this.localRectangle.w, rectangle.h);
				this.children[1].localRectangle = new Rectangle(this.localRectangle.x, this.localRectangle.y + rectangle.h, this.localRectangle.w, dh);
			}

			return this.children[0]._insert(rectangle);
		}
	};

	module.exports = AtlasNode;

/***/ },
/* 304 */
/***/ function(module, exports) {

	/**
	 * Rectangle
	 * @hidden
	 * @param {number} x
	 * @param {number} y
	 * @param {number} w Width
	 * @param {number} h Height
	 */
	function Rectangle(x, y, w, h) {
		this.x = x;
		this.y = y;
		this.w = w;
		this.h = h;
	}

	module.exports = Rectangle;

/***/ },
/* 305 */
/***/ function(module, exports) {

	var supported = true;

	var AudioContext = typeof(window) !== 'undefined' && (window.AudioContext || window.webkitAudioContext);
	if (!AudioContext) {
		// warn once
		console.warn('WebAudio not supported');
		supported = false;
	}

	var context;

	/**
	 * AudioContext is a global to check for support and instantiate an audio context. Should not be used as a constructor.
	 * @target-class AudioContext AudioContext constructor
	 * @require-pathvar AudioContext = require('../../sound/AudioContext');
	 * @group sound
	 * @example
	 * if(AudioContext.isSupported()){
	 *     var context = AudioContext.getContext();
	 *     // ...operate on context...
	 * }
	 */
	module.exports = {
		getContext: function () {
			// try to get a context if it's supposedly supported or not cached
			if (!context && supported) {
				try {
					// even if window.AudioContext is available something might go wrong
					context = new AudioContext();
				} catch (e) {
					console.warn(e.message);
					supported = false;
				}
			}
			return context;
		},
		isSupported: function () {
			return supported;
		}
	};


/***/ },
/* 306 */
/***/ function(module, exports, __webpack_require__) {

	var BoundingBox = __webpack_require__(7);
	var BoundingSphere = __webpack_require__(13);
	var Vector3 = __webpack_require__(8);

	/**
	 * Bounding tree node
	 * @param boundType
	 */
	function BoundingTree(boundType) {
		this.leftTree = null;
		this.rightTree = null;
		this.localBound = null;
		this.worldBound = null;

		this.section = 0;
		this.start = 0;
		this.end = 0;

		this.boundType = boundType ? boundType : BoundingTree.BOUNDTYPE_BOX;
	}

	var vecStore = new Vector3();

	BoundingTree.BOUNDTYPE_SPHERE = 'sphere';
	BoundingTree.BOUNDTYPE_BOX = 'box';

	BoundingTree.MAX_PRIMITIVES_PER_LEAF = 16;

	BoundingTree.prototype.construct = function (entity) {
		// check entity has required components
		if (!entity.meshRendererComponent || !entity.meshDataComponent || !entity.transformComponent) {
			console.warn('Entity missing required components for boundingtree construction: ', entity);
			return;
		}

		var meshData = entity.meshDataComponent.meshData;
		// XXX: updatePrimitiveCounts could potentially be done as needed in MeshData instead.
		meshData.updatePrimitiveCounts();
		if (meshData.getSectionCount() === 1) {
			this.primitiveIndices = [];
			for ( var i = 0, max = meshData.getPrimitiveCount(0); i < max; i++) {
				this.primitiveIndices.push(i);
			}
			this.createTree(entity, 0, 0, this.primitiveIndices.length);
		} else {
			this.split(entity, 0, meshData.getSectionCount());
		}
	};

	BoundingTree.prototype.createTree = function (entity, section, start, end) {
		var meshData = entity.meshDataComponent.meshData;

		this.section = section;
		this.start = start;
		this.end = end;

		if (!this.primitiveIndices) {
			return;
		}

		this.createBounds();

		// the bounds at this level should contain all the primitives this level is responsible for.
		this.localBound.computeFromPrimitives(meshData, section, this.primitiveIndices, start, end);

		// check to see if we are a leaf, if the number of primitives we reference is less than or equal to the maximum
		// defined by the CollisionTreeManager we are done.
		if (end - start + 1 <= BoundingTree.MAX_PRIMITIVES_PER_LEAF) {
			return;
		}

		// create the left child
		if (!this.leftTree) {
			this.leftTree = new BoundingTree(this.boundType);
		}
		this.leftTree.primitiveIndices = this.primitiveIndices;
		this.leftTree.createTree(entity, section, start, Math.floor((start + end) / 2));

		// create the right child
		if (!this.rightTree) {
			this.rightTree = new BoundingTree(this.boundType);
		}
		this.rightTree.primitiveIndices = this.primitiveIndices;
		this.rightTree.createTree(entity, section, Math.floor((start + end) / 2), end);
	};

	BoundingTree.prototype.split = function (entity, sectionStart, sectionEnd) {
		// Split range in half
		var rangeSize = sectionEnd - sectionStart;
		var halfRange = Math.floor(rangeSize / 2); // odd number will give +1 to right.

		// left half:
		// if half size === 1, create as regular CollisionTree
		if (halfRange === 1) {
			// compute section
			var section = sectionStart;

			// create the left child
			this.leftTree = new BoundingTree(this.boundType);

			this.leftTree.primitiveIndices = [];
			for (var i = 0; i < this.leftTree.primitiveIndices.length; i++) {
				this.leftTree.primitiveIndices.push(i);
			}
			this.leftTree.createTree(entity, section, 0, this.leftTree.primitiveIndices.length);
		} else {
			// otherwise, make an empty collision tree and call split with new range
			this.leftTree = new BoundingTree(this.boundType);
			this.leftTree.split(entity, sectionStart, sectionStart + halfRange);
		}

		// right half:
		// if rangeSize - half size === 1, create as regular CollisionTree
		if (rangeSize - halfRange === 1) {
			// compute section
			var section = sectionStart + 1;

			// create the left child
			this.rightTree = new BoundingTree(this.boundType);

			this.rightTree._primitiveIndices = [];
			for (var i = 0; i < this.rightTree.primitiveIndices.length; i++) {
				this.rightTree.primitiveIndices.push(i);
			}
			this.rightTree.createTree(entity, section, 0, this.rightTree.primitiveIndices.length);
		} else {
			// otherwise, make an empty collision tree and call split with new range
			this.rightTree = new BoundingTree(this.boundType);
			this.rightTree.split(entity, sectionStart + halfRange, sectionEnd);
		}

		// Ok, now since we technically have no primitives, we need our bounds to be the merging of our children bounds
		// instead:
		this.localBound = this.leftTree.localBound.clone();
		this.localBound.merge(this.rightTree.localBound);
		this.worldBound = this.localBound.clone();
	};

	BoundingTree.prototype.createBounds = function () {
		switch (this.boundType) {
			case BoundingTree.BOUNDTYPE_BOX:
				this.localBound = new BoundingBox();
				this.worldBound = new BoundingBox();
				break;
			case BoundingTree.BOUNDTYPE_SPHERE:
				this.localBound = new BoundingSphere();
				this.worldBound = new BoundingSphere();
				break;
			default:
				break;
		}
	};

	BoundingTree.prototype.findPick = function (ray, entity, result) {
		if (!result) {
			result = [];
		}

		// if our ray doesn't hit the bounds, then it must not hit a primitive.
		if (!this.localBound.intersectsRay(ray)) {
			return result;
		}

		// This is not a leaf node, therefore, check each child (left/right) for intersection with the ray.
		if (this.leftTree) {
			this.leftTree.findPick(ray, entity, result);
		}

		if (this.rightTree) {
			this.rightTree.findPick(ray, entity, result);
		} else if (!this.leftTree) {
			// This is a leaf node. We can therefore check each primitive this node contains. If an intersection occurs, place it in the list.
			var data = entity.meshDataComponent.meshData;

			var vertices = null;
			for (var i = this.start, l = this.end; i < l; i++) {
				vertices = data.getPrimitiveVertices(this.primitiveIndices[i], this.section, vertices);
				if (ray.intersects(vertices, false, vecStore)) {
					var worldTransform = entity.transformComponent.sync().worldTransform;

					var point = new Vector3();
					point.set(vecStore);
					point.applyPostPoint(worldTransform.matrix);

					vecStore.sub(ray.origin);
					vecStore.applyPostPoint(worldTransform.matrix);
					var distance = vecStore.length();

					var verticesCopy = [];
					for (var copyIndex = vertices.length - 1; copyIndex >= 0; copyIndex--) {
						verticesCopy[copyIndex] = new Vector3().set(vertices[copyIndex]);
						verticesCopy[copyIndex].applyPostPoint(worldTransform.matrix);
					}

					result.push({
						distance: distance,
						point: point,
						vertices: verticesCopy
					});
				}
			}
		}

		return result;
	};

	module.exports = BoundingTree;

/***/ },
/* 307 */
/***/ function(module, exports, __webpack_require__) {

	var System = __webpack_require__(42);
	var BoundingBox = __webpack_require__(7);

	/**
	 * Calculates and updates all boundings on entities with both transform, meshrenderer and meshdata components
	 * @extends System
	 */
	function BoundingUpdateSystem() {
		System.call(this, 'BoundingUpdateSystem', ['TransformComponent', 'MeshRendererComponent', 'MeshDataComponent']);
		this._worldBound = new BoundingBox();
		this._computeWorldBound = null;
	}

	BoundingUpdateSystem.prototype = Object.create(System.prototype);
	BoundingUpdateSystem.prototype.constructor = BoundingUpdateSystem;

	BoundingUpdateSystem.prototype.process = function (entities) {
		var l = entities.length;
		if (l === 0) {
			this._computeWorldBound = null;
			return;
		}

		for (var i = 0; i < l; i++) {
			var entity = entities[i];
			var meshDataComponent = entity.meshDataComponent;
			var transformComponent = entity.transformComponent;
			var meshRendererComponent = entity.meshRendererComponent;

			transformComponent.sync();

			if (meshDataComponent.autoCompute) {
				meshDataComponent.computeBoundFromPoints();
				meshRendererComponent.updateBounds(meshDataComponent.modelBound, transformComponent.worldTransform);
			} else if (meshRendererComponent._worldBoundDirty) {
				meshRendererComponent.updateBounds(meshDataComponent.modelBound, transformComponent.worldTransform);
			}
		}
		if (this._computeWorldBound && this._computeWorldBound instanceof Function) {
			//this._worldBound = new BoundingSphere(new Vector3(0, 0, 0), 0); // optional for including the center of the scene into the world bound

			// generally we don't want particle systems to end up in our world bound computing since they have huge world bounds and can mess up stuff
			for (var i = 0; i < l; i++) {
				if (!entities[i].particleComponent) {
					this._worldBound = entities[i].meshRendererComponent.worldBound.clone();
					break;
				}
			}

			for (; i < l; i++) {
				if (!entities[i].particleComponent) {
					var mrc = entities[i].meshRendererComponent;
					this._worldBound = this._worldBound.merge(mrc.worldBound);
				}
			}

			this._computeWorldBound(this._worldBound);
			this._computeWorldBound = null;
		}
	};

	// function named get actually does a set
	BoundingUpdateSystem.prototype.getWorldBound = function (callback) {
		this._computeWorldBound = callback;
	};

	BoundingUpdateSystem.prototype.deleted = function (entity) {
		if (entity.meshRendererComponent) {
			entity.meshRendererComponent.worldBound = new BoundingBox();
		}
	};

	module.exports = BoundingUpdateSystem;

/***/ },
/* 308 */
/***/ function(module, exports, __webpack_require__) {

	var Component = __webpack_require__(20);
	var Vector3 = __webpack_require__(8);
	var Camera = __webpack_require__(120);
	var SystemBus = __webpack_require__(44);

	/**
	 * Holds a camera.
	 * @param {Camera} camera Camera to contain in this component.
	 * @extends Component
	 */
	function CameraComponent(camera) {
		Component.apply(this, arguments);

		this.type = 'CameraComponent';

		/**
		 * The camera contained by the component.
		 * @type {Camera}
		 */
		this.camera = camera;

		/**
		 * Left vector.
		 * @type {Vector3}
		 * @default (-1, 0, 0)
		 */
		this.leftVec = new Vector3(-1, 0, 0);

		/**
		 * Up vector.
		 * @type {Vector3}
		 * @default (0, 1, 0)
		 */
		this.upVec = new Vector3(0, 1, 0);

		/**
		 * Direction vector.
		 * @type {Vector3}
		 * @default (0, 0, -1)
		 */
		this.dirVec = new Vector3(0, 0, -1);

		this._transformUpdatedListener = null;
		this._transformDirty = true;

		// @ifdef DEBUG
		Object.seal(this);
		// @endif
	}

	CameraComponent.type = 'CameraComponent';

	CameraComponent.prototype = Object.create(Component.prototype);
	CameraComponent.prototype.constructor = CameraComponent;

	CameraComponent.prototype.api = {
		//! AT: the component holds no reference to its entity therefore this method could never stay on the component
		setAsMainCamera: function () {
			SystemBus.emit('goo.setCurrentCamera', {
				camera: this.cameraComponent.camera,
				entity: this
			});
			return this;
		}
	};

	/**
	 * @param {number} axisId Axis to use as up-vector (0=X, 1=Y, 2=Z).
	 */
	CameraComponent.prototype.setUpVector = function (axisId) {
		if (axisId === 0) {
			this.leftVec.setDirect(0, -1, 0);
			this.upVec.setDirect(1, 0, 0);
			this.dirVec.setDirect(0, 0, -1);
		} else if (axisId === 2) {
			this.leftVec.setDirect(-1, 0, 0);
			this.upVec.setDirect(0, 0, 1);
			this.dirVec.setDirect(0, -1, 0);
		} else {
			this.leftVec.setDirect(-1, 0, 0);
			this.upVec.setDirect(0, 1, 0);
			this.dirVec.setDirect(0, 0, -1);
		}
	};

	CameraComponent.prototype.attached = function () {
		var that = this;
		this.entity.on('transformUpdated', this._transformUpdatedListener = function () {
			that._transformDirty = true;
		});
	};

	CameraComponent.prototype.detached = function () {
		this.entity.off('transformUpdated', this._transformUpdatedListener);
		this._transformUpdatedListener = null;
	};

	/**
	 * Updates the contained camera according to a transform (coming from the TransformComponent).
	 * @param {Transform} transform
	 */
	CameraComponent.prototype.updateCamera = function (transform) {
		this.camera._left.set(this.leftVec);
		//! AT: let's prevent scaling or skewing from spilling in the view(projection) matrix
	//		transform.matrix.applyPostVector(this.camera._left);
		this.camera._left.applyPost(transform.rotation);

		this.camera._up.set(this.upVec);
	//		transform.matrix.applyPostVector(this.camera._up);
		this.camera._up.applyPost(transform.rotation);

		this.camera._direction.set(this.dirVec);
	//		transform.matrix.applyPostVector(this.camera._direction);
		this.camera._direction.applyPost(transform.rotation);

		transform.matrix.getTranslation(this.camera.translation);

		// RH: Don't update the frustum only the frame
		// this.camera.update();
		this.camera.onFrameChange();
	};

	CameraComponent.prototype.copy = function (source) {
		this.camera.copy(source.camera);
		this.leftVec.copy(source.leftVec);
		this.upVec.copy(source.upVec);
		this.dirVec.copy(source.dirVec);
		return this;
	};

	CameraComponent.prototype.clone = function () {
		var clone = new CameraComponent(this.camera.clone());

		clone.leftVec.copy(this.leftVec);
		clone.upVec.copy(this.upVec);
		clone.dirVec.copy(this.dirVec);

		return clone;
	};

	CameraComponent.applyOnEntity = function (obj, entity) {
		if (obj instanceof Camera) {
			var cameraComponent = new CameraComponent(obj);
			entity.setComponent(cameraComponent);
			return true;
		}
	};

	module.exports = CameraComponent;

/***/ },
/* 309 */
/***/ function(module, exports, __webpack_require__) {

	var ComponentHandler = __webpack_require__(88);
	var CameraComponent = __webpack_require__(308);
	var Camera = __webpack_require__(120);
	var ObjectUtils = __webpack_require__(6);

	/**
	 * For handling loading of camera components
	 * @param {World} world The goo world
	 * @param {Function} getConfig The config loader function. See {@see DynamicLoader._loadRef}.
	 * @param {Function} updateObject The handler function. See {@see DynamicLoader.update}.
	 * @extends ComponentHandler
	 * @hidden
	 */
	function CameraComponentHandler() {
		ComponentHandler.apply(this, arguments);
		this._type = 'CameraComponent';
	}

	CameraComponentHandler.prototype = Object.create(ComponentHandler.prototype);
	ComponentHandler._registerClass('camera', CameraComponentHandler);
	CameraComponentHandler.prototype.constructor = CameraComponentHandler;

	/**
	 * Prepare component. Set defaults on config here.
	 * @param {Object} config
	 * @returns {Object}
	 * @private
	 */
	CameraComponentHandler.prototype._prepare = function (config) {
		ObjectUtils.defaults(config, {
			near: 1,
			far: 10000,
			projectionMode: 'Perspective',
			aspect: 1,
			lockedRatio: false
		});
		if (config.projectionMode === 'Perspective' && config.fov === undefined) {
			config.fov = 45;
		}
		if (config.projectionMode === 'Parallel' && config.size === undefined) {
			config.size = 100;
		}
		if (config.projectionMode !== 'Perspective' && config.projectionMode !== 'Parallel') {
			config.projectionMode = 'Perspective';
		}
	};

	/**
	 * Create camera component object.
	 * @param {Entity} entity The entity on which this component should be added.
	 * @returns {CameraComponent} the created component object
	 * @private
	 */
	CameraComponentHandler.prototype._create = function () {
		var camera = new Camera(45, 1, 1, 1000);
		var component = new CameraComponent(camera);
		return component;
	};

	// TODO: Handle if cameracomponent is removed and camera is active

	/**
	 * Update engine cameracomponent object based on the config.
	 * @param {Entity} entity The entity on which this component should be added.
	 * @param {Object} config
	 * @param {Object} options
	 * @returns {RSVP.Promise} promise that resolves with the component when loading is done.
	 */
	CameraComponentHandler.prototype.update = function (entity, config, options) {
		return ComponentHandler.prototype.update.call(this, entity, config, options).then(function (component) {
			if (!component) { return; }
			component.camera.setProjectionMode(Camera[config.projectionMode]);
			component.camera.lockedRatio = false;
			if (config.projectionMode === 'Perspective') {
				component.camera.setFrustumPerspective(config.fov, null, config.near, config.far);
			} else {
				var size = config.size;
				component.camera.setFrustum(config.near, config.far, -size, size, size, -size, null);
				component.camera.size = size;
			}
			return component;
		});
	};

	module.exports = CameraComponentHandler;


/***/ },
/* 310 */
/***/ function(module, exports, __webpack_require__) {

	var System = __webpack_require__(42);
	var SystemBus = __webpack_require__(44);
	var Renderer = __webpack_require__(123);

	/**
	 * Updates cameras/cameracomponents with their transform component transforms
	 * @extends System
	 */
	function CameraSystem() {
		System.call(this, 'CameraSystem', ['TransformComponent', 'CameraComponent']);
		this.mainCamera = null; //! AT: what's up with this? is it unused?
	}

	CameraSystem.prototype = Object.create(System.prototype);
	CameraSystem.prototype.constructor = CameraSystem;

	/**
	 * Sets the Renderer's main camera to be the first camera of the CameraComponents
	 * in the currently active entities of this system.
	 */
	CameraSystem.prototype.findMainCamera = function () {
		if (this._activeEntities.length) {
			var firstEntity = this._activeEntities[0];
			SystemBus.emit('goo.setCurrentCamera', {
				camera: firstEntity.cameraComponent.camera,
				entity: firstEntity
			});
		}
	};

	CameraSystem.prototype.inserted = function (entity) {
		if (!Renderer.mainCamera) {
			SystemBus.emit('goo.setCurrentCamera', {
				camera: entity.cameraComponent.camera,
				entity: entity
			});
		}
	};

	CameraSystem.prototype.deleted = function () {
		//! AT: leaving it like this until a better solution is found
		// apparently it might conflict with the new loader scheme
		//this.findMainCamera();
	};

	CameraSystem.prototype.onPreRender = function () {
		for (var i = 0; i < this._activeEntities.length; i++) {
			var entity = this._activeEntities[i];
			var transformComponent = entity.transformComponent;
			var cameraComponent = entity.cameraComponent;
			transformComponent.sync();
			if (cameraComponent._transformDirty) {
				cameraComponent.updateCamera(transformComponent.worldTransform);
				cameraComponent._transformDirty = false;
			}
		}
	};

	module.exports = CameraSystem;

/***/ },
/* 311 */
/***/ function(module, exports, __webpack_require__) {

	var RenderTarget = __webpack_require__(133);
	var FullscreenPass = __webpack_require__(135);
	var ShaderLib = __webpack_require__(46);
	var SystemBus = __webpack_require__(44);

	/**
	 * Post processing handler
	 * @param {RenderTarget} renderTarget Data to wrap
	 * @property {RenderTarget} renderTarget Data to wrap
	 */
	function Composer(renderTarget) {
		this._passedWriteBuffer = !!renderTarget;
		this.writeBuffer = renderTarget;

		if (this.writeBuffer === undefined) {
			var width = window.innerWidth || 1;
			var height = window.innerHeight || 1;

			this.writeBuffer = new RenderTarget(width, height);
		}

		this.readBuffer = this.writeBuffer.clone();

		this.passes = [];
		this._clearColor = [0, 0, 0, 1];
		this.copyPass = new FullscreenPass(ShaderLib.copy);

		this.size = null;
		this.dirty = false;

		this._viewportResizeHandler = function (size) {
			this.dirty = true;
			this.size = size;
		}.bind(this);

		SystemBus.addListener('goo.viewportResize', this._viewportResizeHandler, true);
	}

	/**
	 * Deallocate all allocated WebGL buffers, listeners, and passes.
	 * @param  {Renderer} renderer
	 */
	Composer.prototype.destroy = function (renderer) {
		this.deallocateBuffers(renderer);
		for (var i = 0; i < this.passes.length; i++) {
			var pass = this.passes[i];
			pass.destroy(renderer);
		}
		SystemBus.removeListener('goo.viewportResize', this._viewportResizeHandler);
	};

	/**
	 * Deallocate the read and write buffers.
	 * @param {Renderer} renderer
	 */
	Composer.prototype.deallocateBuffers = function (renderer) {
		if (this.writeBuffer && !this._passedWriteBuffer) {
			this.writeBuffer.destroy(renderer.context);
		}
		if (this.readBuffer) {
			this.readBuffer.destroy(renderer.context);
		}
		this.copyPass.destroy(renderer);
	};

	Composer.prototype.swapBuffers = function () {
		var tmp = this.readBuffer;
		this.readBuffer = this.writeBuffer;
		this.writeBuffer = tmp;
	};

	Composer.prototype._checkPassResize = function (pass, size) {
		return !pass.viewportSize ||
			pass.viewportSize.x !== size.x ||
			pass.viewportSize.y !== size.y ||
			pass.viewportSize.width !== size.width ||
			pass.viewportSize.height !== size.height;
	};

	Composer.prototype.addPass = function (pass, renderer) {
		this.passes.push(pass);
		if (pass.updateSize && this.size && this._checkPassResize(pass, this.size)) {
			pass.updateSize(this.size, renderer);
			pass.viewportSize = this.size;
		}
	};

	Composer.prototype.setClearColor = function (color) {
		this._clearColor[0] = color[0];
		this._clearColor[1] = color[1];
		this._clearColor[2] = color[2];
		this._clearColor[3] = color[3];
	};

	Composer.prototype.updateSize = function (renderer) {
		var size = this.size;
		if (!size) {
			return;
		}
		var width = size.width;
		var height = size.height;

		this.deallocateBuffers(renderer);

		this.writeBuffer = new RenderTarget(width, height);
		this.readBuffer = this.writeBuffer.clone();

		for (var i = 0, il = this.passes.length; i < il; i++) {
			var pass = this.passes[i];
			if (pass.updateSize && this._checkPassResize(pass, size)) {
				pass.updateSize(size, renderer);
				pass.viewportSize = size;
			}
		}
	};

	Composer.prototype.render = function (renderer, delta, camera, lights) {
		if (this.dirty) {
			this.updateSize(renderer);
			this.dirty = false;
		}

		var maskActive = false;
		var pass, i, il = this.passes.length;

		for (i = 0; i < il; i++) {
			pass = this.passes[i];
			if (!pass.enabled) {
				continue;
			}

			pass.render(renderer, this.writeBuffer, this.readBuffer, delta, maskActive, camera, lights, this._clearColor);

			if (pass.needsSwap) {
				if (maskActive) {
					var context = this.renderer.context;
					context.stencilFunc(context.NOTEQUAL, 1, 0xffffffff);
					this.copyPass.render(renderer, this.writeBuffer, this.readBuffer, delta, camera, lights);
					context.stencilFunc(context.EQUAL, 1, 0xffffffff);
				}
				this.swapBuffers();
			}
		}
	};

	module.exports = Composer;

/***/ },
/* 312 */
/***/ function(module, exports, __webpack_require__) {

	var MeshData = __webpack_require__(14);
	var ObjectUtils = __webpack_require__(6);

	/**
	 * Cone mesh data
	 * @extends MeshData
	 * @example-link http://code.gooengine.com/latest/visual-test/goo/shapes/Cone/Cone-vtest.html Working example
	 * @param {number} [radialSamples=8] Number of slices
	 * @param {number} [radius=1] Radius of the cone
	 * @param {number} [height=2] The height of the cone
	 */
	function Cone(radialSamples, radius, height) {
		if (arguments.length === 1 && arguments[0] instanceof Object) {
			var props = arguments[0];
			radialSamples = props.radialSamples;
			radius = props.radius;
			height = props.height;
		}
		this.radialSamples = radialSamples || 8;
		this.radius = radius || 1;
		this.height = typeof height === 'undefined' ? 2 : height;

		var attributeMap = MeshData.defaultMap([MeshData.POSITION, MeshData.NORMAL, MeshData.TEXCOORD0]);
		MeshData.call(this, attributeMap, this.radialSamples * 3 + this.radialSamples + 1, this.radialSamples * 3 * 2);

		this.indexModes = ['Triangles'];

		this.rebuild();
	}

	Cone.prototype = Object.create(MeshData.prototype);
	Cone.prototype.constructor = Cone;

	/**
	 * Builds or rebuilds the mesh data.
	 * @returns {Cone} Self for chaining.
	 */
	Cone.prototype.rebuild = function () {
		var verts = [];
		var norms = [];
		var tex = [];
		var indices = [];

		// pointy part
		var slope = Math.atan2(this.radius, this.height);

		var ak = Math.PI * 2 / this.radialSamples;
		var at = 1 / this.radialSamples;
		for (var i = 0, k = 0, t = 0; i < this.radialSamples; i++, k += ak, t += at) {
			verts.push(
				0, 0, this.height,
				Math.cos(k) * this.radius, Math.sin(k) * this.radius, 0,
				Math.cos(k + ak) * this.radius, Math.sin(k + ak) * this.radius, 0
			);

			norms.push(
				0, 0, 1,
				Math.cos(k) * Math.cos(slope), Math.sin(k) * Math.cos(slope), Math.sin(slope),
				Math.cos(k + ak) * Math.cos(slope), Math.sin(k + ak) * Math.cos(slope), Math.sin(slope)
			);

			tex.push(
				t + at / 2, 1.0,
				t, 0.5,
				t + at, 0.5
			);

			indices.push(i * 3 + 0, i * 3 + 1, i * 3 + 2);
		}

		var baseCenterIndex = i * 3 + 0;

		verts.push(0, 0, 0);
		norms.push(0, 0, -1);
		tex.push(0.25, 0.25);

		// base
		for (var i = 1, k = 0; i <= this.radialSamples - 1; i++, k += ak) {
			verts.push(Math.cos(k) * this.radius, Math.sin(k) * this.radius, 0);
			norms.push(0, 0, -1);
			tex.push(Math.cos(k) * 0.25 + 0.25, Math.sin(k) * 0.25 + 0.25);

			indices.push(baseCenterIndex + i, baseCenterIndex, baseCenterIndex + i + 1);
		}

		verts.push(Math.cos(k) * this.radius, Math.sin(k) * this.radius, 0);
		norms.push(0, 0, -1);
		tex.push(Math.cos(k) * 0.25 + 0.25, Math.sin(k) * 0.25 + 0.25);

		indices.push(baseCenterIndex + this.radialSamples, baseCenterIndex, baseCenterIndex + 1);

		this.getAttributeBuffer(MeshData.POSITION).set(verts);
		this.getAttributeBuffer(MeshData.NORMAL).set(norms);
		this.getAttributeBuffer(MeshData.TEXCOORD0).set(tex);
		this.getIndexBuffer().set(indices);

		return this;
	};

	/**
	 * Returns a clone of this cone
	 * @returns {Cone}
	 */
	Cone.prototype.clone = function () {
		var options = ObjectUtils.shallowSelectiveClone(this, ['radialSamples', 'radius', 'height']);

		return new Cone(options);
	};

	module.exports = Cone;

/***/ },
/* 313 */
/***/ function(module, exports, __webpack_require__) {

	var Renderer = __webpack_require__(123);
	var RendererRecord = __webpack_require__(124);

	Renderer.prototype.invalidateBuffer = function (buffer) {
		buffer.glBuffer = null;
	};

	Renderer.prototype.invalidateMeshData = function (meshData) {
		this.invalidateBuffer(meshData.vertexData);
		if (meshData.indexData) {
			this.invalidateBuffer(meshData.indexData);
		}
		if (meshData.wireframeData) {
			this.invalidateMeshData(meshData.wireframeData);
		}
		if (meshData.flatMeshData) {
			this.invalidateMeshData(meshData.flatMeshData);
		}
	};

	Renderer.prototype.invalidateTexture = function (texture) {
		texture.glTexture = null;
		texture.textureRecord = {};
	};

	Renderer.prototype.invalidateShader = function (shader) {
		shader.shaderProgram = null;
		shader.vertexShader = null;
		shader.fragmentShader = null;
	};

	Renderer.prototype.invalidateMaterial = function (material) {
		var keys = Object.keys(material._textureMaps);
		for (var i = 0; i < keys.length; i++) {
			var key = keys[i];
			var texture = material._textureMaps[key];
			this.invalidateTexture(texture);
		}

		this.invalidateShader(material.shader);
	};

	Renderer.prototype.invalidateRenderTarget = function (renderTarget) {
		renderTarget.glTexture = null;
		renderTarget._glRenderBuffer = null;
		renderTarget._glFrameBuffer = null;
		delete renderTarget.textureRecord;
	};

	Renderer.prototype.invalidateComposer = function (composer) {
		if (composer.writeBuffer && !composer._passedWriteBuffer) {
			this.invalidateRenderTarget(composer.writeBuffer);
		}
		if (composer.readBuffer) {
			this.invalidateRenderTarget(composer.readBuffer);
		}

		composer.copyPass.invalidateHandles(this);

		for (var i = 0; i < composer.passes.length; i++) {
			var pass = composer.passes[i];
			// every pass has to do its own internal cleaning
			pass.invalidateHandles(this);
		}
	};

	Renderer.prototype.invalidatePicking = function () {
		if (this.hardwarePicking) {
			if (this.hardwarePicking.pickingTarget) {
				this.invalidateRenderTarget(this.hardwarePicking.pickingTarget);
			}
			this.invalidateMaterial(this.hardwarePicking.pickingMaterial);
		}
	};

	Renderer.prototype._restoreContext = function () {
		this.establishContext();

		this.rendererRecord = new RendererRecord();

		this.context.clearColor(
			this._clearColor.x,
			this._clearColor.y,
			this._clearColor.z,
			this._clearColor.w
		);
	};


/***/ },
/* 314 */
/***/ function(module, exports, __webpack_require__) {

	var Component = __webpack_require__(20);

	/**
	 * Connects a domElement to an entity and applies the transformComponent of the entity to the domElement with CSS3 3D transforms.
	 * @param {domElement} domElement
	 * @param {boolean} faceCamera
	 * @extends Component
	 */
	function CssTransformComponent(domElement, faceCamera) {
		Component.apply(this, arguments);

		this.type = 'CssTransformComponent';

		/**
		 * DOM element.
		 */
		this.domElement = domElement;

		/**
		 * @type {number}
		 * @default 1
		 */
		this.scale = 1;

		/**
		 * @type {boolean}
		 */
		this.faceCamera = (typeof faceCamera === 'undefined') ? false : faceCamera;

		// @ifdef DEBUG
		Object.seal(this);
		// @endif
	}

	CssTransformComponent.type = 'CssTransformComponent';

	CssTransformComponent.prototype = Object.create(Component.prototype);
	CssTransformComponent.prototype.constructor = CssTransformComponent;

	module.exports = CssTransformComponent;


/***/ },
/* 315 */
/***/ function(module, exports, __webpack_require__) {

	var System = __webpack_require__(42);
	var Renderer = __webpack_require__(123);
	var Matrix4 = __webpack_require__(33);
	var MathUtils = __webpack_require__(9);
	var Vector3 = __webpack_require__(8);

	/**
	 * @extends System
	 */
	function CssTransformSystem(renderer) {
		System.call(this, 'CssTransformSystem', ['TransformComponent', 'CssTransformComponent']);

		this.renderer = renderer;

		if (document.querySelector) {
			this.viewDom = document.querySelector('#view');
			this.containerDom = document.querySelector('#cam1');
			this.containerDom2 = document.querySelector('#cam2');
		}
	}

	var tmpMatrix = new Matrix4();
	var tmpMatrix2 = new Matrix4();
	var tmpVector = new Vector3();

	CssTransformSystem.prototype = Object.create(System.prototype);
	CssTransformSystem.prototype.constructor = CssTransformSystem;

	var epsilon = function (value) {
		return Math.abs(value) < 0.000001 ? 0 : value;
	};

	var prefixes = ['', '-webkit-', '-moz-', '-ms-', '-o-'];
	var setStyle = function (element, property, style) {
		for (var j = 0; j < prefixes.length; j++) {
			element.style[prefixes[j] + property] = style;
		}
	};

	var getCSSMatrix = function (matrix) {
		var elements = matrix.data;


		return 'matrix3d(' + epsilon(elements[0]) + ',' + epsilon(-elements[1]) + ',' + epsilon(elements[2]) + ',' + epsilon(elements[3]) + ','
			+ epsilon(elements[4]) + ',' + epsilon(-elements[5]) + ',' + epsilon(elements[6]) + ',' + epsilon(elements[7]) + ','
			+ epsilon(elements[8]) + ',' + epsilon(-elements[9]) + ',' + epsilon(elements[10]) + ',' + epsilon(elements[11]) + ','
			+ epsilon(elements[12]) + ',' + epsilon(-elements[13]) + ',' + epsilon(elements[14]) + ',' + epsilon(elements[15]) + ')';
	};

	CssTransformSystem.prototype.process = function (entities) {
		if (entities.length === 0) {
			return;
		}

		var camera = Renderer.mainCamera;

		if (!camera) {
			return;
		}

		var fov = 0.5 / Math.tan(MathUtils.DEG_TO_RAD * camera.fov * 0.5) * this.renderer.domElement.offsetHeight;
		setStyle(this.viewDom, 'perspective', fov + 'px');

		tmpMatrix.copy(camera.getViewInverseMatrix());
		tmpMatrix2.copy(tmpMatrix);
		tmpMatrix.invert();

		tmpMatrix.setTranslation(new Vector3(0, 0, fov));
		var style = getCSSMatrix(tmpMatrix);
		setStyle(this.containerDom, 'transform', style);

		tmpMatrix2.e03 = -tmpMatrix2.e03;
		// tmpMatrix2.e13 = -tmpMatrix2.e13;
		tmpMatrix2.e23 = -tmpMatrix2.e23;

		// Needed?
		tmpMatrix2.data[0] = 1;
		tmpMatrix2.data[1] = 0;
		tmpMatrix2.data[2] = 0;

		tmpMatrix2.data[4] = 0;
		tmpMatrix2.data[5] = 1;
		tmpMatrix2.data[6] = 0;

		tmpMatrix2.data[8] = 0;
		tmpMatrix2.data[9] = 0;
		tmpMatrix2.data[10] = 1;

		style = getCSSMatrix(tmpMatrix2);
		setStyle(this.containerDom2, 'transform', style);

		for (var i = 0; i < entities.length; i++) {
			var entity = entities[i];
			var component = entity.getComponent('CssTransformComponent');
			var domElement = component.domElement;
			var scale = component.scale;
			scale = [scale, -scale, scale].join(',');

			if (component.faceCamera) {
				entity.transformComponent.sync().worldTransform.matrix.getTranslation(tmpVector);
				tmpMatrix.copy(camera.getViewInverseMatrix());
				tmpMatrix.setTranslation(tmpVector);
			} else {
				tmpMatrix.copy(entity.transformComponent.sync().worldTransform.matrix);
			}

			style = 'translate3d(-50%,-50%,0) ' + getCSSMatrix(tmpMatrix) + 'scale3d(' + scale + ')';
			setStyle(domElement, 'transform', style);

			if (domElement.parentNode !== this.containerDom2) {
				this.containerDom2.appendChild(domElement);
			}
		}
	};

	module.exports = CssTransformSystem;


/***/ },
/* 316 */
/***/ function(module, exports, __webpack_require__) {

	var Component = __webpack_require__(20);
	var Quad = __webpack_require__(28);
	var MeshRendererComponent = __webpack_require__(215);
	var MeshDataComponent = __webpack_require__(216);

	/**
	 * Connects a domElement to an entity and applies the transforms of the entity to the domElement with CSS3 3D transforms.
	 * @param {domElement} domElement
	 * @param {Object} settings
	 * @extends Component
	 * @example-link http://code.gooengine.com/latest/visual-test/goo/entities/components/Dom3dComponent/Dom3dComponent-vtest.html Working example
	 */
	function Dom3dComponent(domElement, settings) {
		Component.apply(this, arguments);

		this.type = 'Dom3dComponent';

		settings = settings || {};

		/**
		 * @type {boolean}
		 */
		this.hidden = false;

		this.width = settings.width || 500;
		this.height = settings.height || 500;
		this.backfaceVisibility = settings.backfaceVisibility || 'hidden';

		this.updated = true;
		this.entity = null;
		this.initDom(domElement);

		this.meshData = new Quad(1, 1);
		this.meshDataComponent = new MeshDataComponent(this.meshData);
		this.meshRendererComponent = new MeshRendererComponent();

		this._transformDirty = true;
		this._transformUpdatedListener = null;

		// @ifdef DEBUG
		Object.seal(this);
		// @endif
	}

	Dom3dComponent.type = 'Dom3dComponent';

	Dom3dComponent.prototype = Object.create(Component.prototype);
	Dom3dComponent.prototype.constructor = Dom3dComponent;

	Dom3dComponent.prototype.attached = function (entity) {
		entity.setComponent(this.meshDataComponent);
		entity.setComponent(this.meshRendererComponent);
		var that = this;
		this.entity.on('transformUpdated', this._transformUpdatedListener = function () {
			that._transformDirty = true;
		});
	};

	Dom3dComponent.prototype.detached = function (entity) {
		if (this.domElement.parentNode !== null) {
			this.domElement.parentNode.removeChild(this.domElement);
		}
		entity.clearComponent('meshRendererComponent');
		entity.clearComponent('meshDataComponent');
		this.entity.off('transformUpdated', this._transformUpdatedListener);
		this._transformUpdatedListener = null;
	};

	Dom3dComponent.prototype.initDom = function (domElement) {
		if (this.domElement && this.domElement.parentNode !== null) {
			this.domElement.parentNode.removeChild(this.domElement);
		}
		this.domElement = document.createElement('div');
		if (domElement) {
			if (!domElement.style.width) {
				domElement.style.width = "100%";
			}
			if (!domElement.style.height) {
				domElement.style.height = "100%";
			}
			this.domElement.appendChild(domElement);
		}
		this.domElement.style.position = 'absolute';
		this.domElement.style.margin = '0px';
		this.domElement.style.padding = '0px';
		this.domElement.style.backgroundColor = 'white';
		// this.domElement.style.WebkitBackfaceVisibility = this.backfaceVisibility;
		this.domElement.style.backfaceVisibility = this.backfaceVisibility;
		this.domElement.style.overflow = 'hidden';
		this.setSize(this.width, this.height);
	};

	Dom3dComponent.prototype.setSize = function (width, height) {
		this.width = width || this.width;
		this.height = height || this.height;
		this.domElement.style.width = this.width + 'px';
		this.domElement.style.height = this.height + 'px';
	};

	Dom3dComponent.prototype.destroy = function (context) {
		this.meshData.destroy(context);
	};

	module.exports = Dom3dComponent;


/***/ },
/* 317 */
/***/ function(module, exports, __webpack_require__) {

	var ComponentHandler = __webpack_require__(88);
	var Dom3dComponent = __webpack_require__(316);
	var RSVP = __webpack_require__(55);
	var PromiseUtils = __webpack_require__(54);

	/**
	 * For handling loading of Dom3d components
	 * @param {World} world The goo world
	 * @param {Function} getConfig The config loader function. See {@see DynamicLoader._loadRef}.
	 * @param {Function} updateObject The handler function. See {@see DynamicLoader.update}.
	 * @extends ComponentHandler
	 * @hidden
	 */
	function Dom3dComponentHandler() {
		ComponentHandler.apply(this, arguments);
		this._type = 'Dom3dComponent';
	}

	Dom3dComponentHandler.prototype = Object.create(ComponentHandler.prototype);
	ComponentHandler._registerClass('dom3d', Dom3dComponentHandler);
	Dom3dComponentHandler.prototype.constructor = Dom3dComponentHandler;

	/**
	 * Prepare component. Set defaults on config here.
	 * @param {Object} config
	 * @returns {Object}
	 * @private
	 */
	Dom3dComponentHandler.prototype._prepare = function (/*config*/) {};

	/**
	 * Create camera component object.
	 * @param {Entity} entity The entity on which this component should be added.
	 * @returns {CameraComponent} the created component object
	 * @private
	 */
	Dom3dComponentHandler.prototype._create = function () {
		return new Dom3dComponent();
	};

	var regex = /\W/g;
	function getSafeEntityId(id) {
		// fancy chars (like '.') are allowed in ids in HTML but are not allowed in CSS
		return '__' + id.replace(regex, '-');
	}

	/**
	 * Update engine cameracomponent object based on the config.
	 * @param {Entity} entity The entity on which this component should be added.
	 * @param {Object} config
	 * @param {Object} options
	 * @returns {RSVP.Promise} promise that resolves with the component when loading is done.
	 */
	Dom3dComponentHandler.prototype.update = function (entity, config, options) {
		var that = this;
		return ComponentHandler.prototype.update.call(this, entity, config, options).then(function (component) {
			if (!component) { return; }

			// ids and classes can contain '.' or start with digits in html but not in css selectors
			// could have prefixed it with a simple '-' but that's sort of reserved for '-moz', '-webkit' and the like
			var safeEntityId = getSafeEntityId(entity.id);

			var domElement = component.domElement;
			if (!domElement) {
				domElement = document.createElement('div');
				domElement.id = safeEntityId;
				domElement.className = 'goo-entity';
				component.initDom(domElement);
			}
			component.setSize(config.width !== undefined ? config.width : 500, config.height !== undefined ? config.height : 500);

			var innerHtmlChanged = config.innerHtml !== domElement.prevInnerHtml;
			var styleChanged = config.style !== domElement.prevStyle;
			domElement.prevInnerHtml = config.innerHtml;
			domElement.prevStyle = config.style;

			if (entity.meshRendererComponent !== component.meshRendererComponent) {
				entity.setComponent(component.meshRendererComponent);
			}
			if (entity.meshDataComponent !== component.meshDataComponent) {
				entity.setComponent(component.meshDataComponent);
			}
			if (!innerHtmlChanged && !styleChanged) {
				return PromiseUtils.resolve();
			}

			var wrappedStyle = '';
			if (config.style) {
				var processedStyle = config.style.replace('__entity', '#' + safeEntityId);
				wrappedStyle = '<style>\n' + processedStyle + '\n</style>';
			}

			domElement.innerHTML = wrappedStyle + config.innerHtml;

			var children = domElement.childNodes;
			if (children.length === 1) {
				var child = children[0];
				if (!child.style.width) {
					child.style.width = "100%";
				}
				if (!child.style.height) {
					child.style.height = "100%";
				}
			}

			function loadImage(htmlImage, imageRef) {
				return that.loadObject(imageRef, options)
				.then(function (image) {
					htmlImage.src = image.src;
					return htmlImage;
				}, function (e) {
					console.error(e);
					delete htmlImage.src;
					return htmlImage;
				});
			}

			// Fix images.
			var images = domElement.getElementsByTagName('IMG');
			var imagePromises = [];
			for (var i = 0; i < images.length; i++) {
				var htmlImage = images[i];
				var imageRef = htmlImage.getAttribute('data-id');
				if (imageRef) {
					var promise = loadImage(htmlImage, imageRef);
					imagePromises.push(promise);
				}
			}

			return RSVP.all(imagePromises);
		});
	};

	Dom3dComponentHandler.prototype._remove = function (entity) {
		var component = entity.dom3dComponent;
		ComponentHandler.prototype._remove.call(this, entity);
		if (component.domElement && component.domElement.parentNode) {
			component.domElement.parentNode.removeChild(component.domElement);
		}

		if (entity.meshRendererComponent || entity.meshDataComponent) {
			entity.clearComponent('meshDataComponent');
			entity.clearComponent('meshRendererComponent');
		}
		component.destroy(this.world.gooRunner.renderer.context);
	};

	module.exports = Dom3dComponentHandler;


/***/ },
/* 318 */
/***/ function(module, exports, __webpack_require__) {

	var System = __webpack_require__(42);
	var SystemBus = __webpack_require__(44);
	var Material = __webpack_require__(30);
	var ShaderLib = __webpack_require__(46);
	var Vector3 = __webpack_require__(8);
	var Ray = __webpack_require__(122);
	var MathUtils = __webpack_require__(9);

	/**
	 * @extends System
	 * @example-link http://code.gooengine.com/latest/visual-test/goo/entities/components/Dom3dComponent/Dom3dComponent-vtest.html Working example
	 */
	function Dom3dSystem(renderer) {
		System.call(this, 'Dom3dSystem', ['TransformComponent', 'Dom3dComponent']);

		this.renderer = renderer;
		this.camera = null;

		SystemBus.addListener('goo.setCurrentCamera', function (newCam) {
			this.camera = newCam.camera;
		}.bind(this), true);

		this.playing = true;

		var frontMaterial = new Material(ShaderLib.simple);
		frontMaterial.blendState.blending = 'CustomBlending';
		frontMaterial.blendState.blendSrc = 'ZeroFactor';
		frontMaterial.blendState.blendDst = 'ZeroFactor';

		var backMaterial = new Material(ShaderLib.uber);
		backMaterial.uniforms.materialDiffuse = [0.5, 0.5, 0.5, 1];
		backMaterial.cullState.cullFace = 'Front';

		this.materials = [frontMaterial, backMaterial];

		// this.prefixes = ['', '-webkit-', '-moz-'];
		this.prefixes = ['', '-webkit-'];
		this.styleCache = new Map();

		this.precisionScale = 1000; // Thanks browsers
	}

	Dom3dSystem.prototype = Object.create(System.prototype);
	Dom3dSystem.prototype.constructor = Dom3dSystem;

	Dom3dSystem.prototype.init = function () {
		var ray = new Ray();
		var polygonVertices = [new Vector3(), new Vector3(), new Vector3(), new Vector3()];
		var offsets = [new Vector3(-0.5, -0.5, 0), new Vector3(-0.5, 0.5, 0), new Vector3(0.5, 0.5, 0), new Vector3(0.5, -0.5, 0)];
		var doPlanar = false;

		var doesIntersect = false;

		var that = this;
		var doPick = function (event) {
			var x, y;
			var domTarget = that.renderer.domElement;
			if (event.type === 'touchstart' || event.type === 'touchend' || event.type === 'touchmove') {
				x = event.changedTouches[0].pageX - domTarget.getBoundingClientRect().left;
				y = event.changedTouches[0].pageY - domTarget.getBoundingClientRect().top;
			} else {
				var rect = domTarget.getBoundingClientRect();
				x = event.clientX - rect.left;
				y = event.clientY - rect.top;
			}

			that.camera.getPickRay(x, y, that.renderer.domElement.offsetWidth, that.renderer.domElement.offsetHeight, ray);

			for (var i = 0; i < that._activeEntities.length; i++) {
				var entity = that._activeEntities[i];

				for (var j = 0; j < polygonVertices.length; j++) {
					var vec = polygonVertices[j];
					vec.set(offsets[j]);
					vec.applyPostPoint(entity.transformComponent.sync().worldTransform.matrix);
				}

				if (ray.intersects(polygonVertices, doPlanar, null, true)) {
					return true;
				}
			}

			return false;
		};

		var handlePick = function (event) {
			if (!that.camera || that._activeEntities.length === 0) {
				return false;
			}

			var intersects = doPick(event);

			if (intersects && !doesIntersect) {
				SystemBus.emit('goo.dom3d.enabled', true);
				that.renderer.domElement.style.pointerEvents = 'none';
				doesIntersect = true;
			} else if (!intersects && doesIntersect) {
				SystemBus.emit('goo.dom3d.enabled', false);
				that.renderer.domElement.style.pointerEvents = '';
				doesIntersect = false;
			}
		};

		var drag = false;
		document.addEventListener('mousedown', function (event) {
			if (!that.camera || that._activeEntities.length === 0) {
				return;
			}

			drag = !doPick(event);
		}, false);
		document.addEventListener('mouseup', function (event) {
			if (!that.camera || that._activeEntities.length === 0) {
				return;
			}

			drag = false;

			if (that.playing) {
				handlePick(event);
			}
		}, false);
		document.addEventListener('mousemove', function (event) {
			if (drag || !that.camera || that._activeEntities.length === 0) {
				return;
			}

			if (that.playing) {
				handlePick(event);
			}
		}, false);

		var rootDom = this.rootDom = document.createElement('div');
		this.renderer.domElement.parentNode.insertBefore(rootDom, this.renderer.domElement);

		rootDom.style.position = 'absolute';
		rootDom.style.overflow = 'hidden';
		rootDom.style.webkitUserSelect = 'none';
		rootDom.style.mozUserSelect = 'none';
		rootDom.style.msUserSelect = 'none';
		// rootDom.style.webkitTransformStyle = 'preserve-3d';
		// rootDom.style.mozTransformStyle = 'preserve-3d';
		rootDom.style.transformStyle = 'preserve-3d';
		rootDom.style.width = '100%';
		rootDom.style.height = '100%';
		rootDom.style.top = '0px';
		rootDom.style.bottom = '0px';
		rootDom.style.left = '0px';
		rootDom.style.right = '0px';

		var cameraDom = this.cameraDom = document.createElement('div');
		cameraDom.style.webkitUserSelect = 'none';
		cameraDom.style.mozUserSelect = 'none';
		cameraDom.style.msUserSelect = 'none';
		// cameraDom.style.webkitTransformStyle = 'preserve-3d';
		// cameraDom.style.mozTransformStyle = 'preserve-3d';
		cameraDom.style.transformStyle = 'preserve-3d';
		cameraDom.style.width = '100%';
		cameraDom.style.height = '100%';

		rootDom.appendChild(cameraDom);
	};

	Dom3dSystem.prototype.play = function () {
		this.playing = true;
	};

	Dom3dSystem.prototype.pause = function () {
	};

	Dom3dSystem.prototype.resume = Dom3dSystem.prototype.play;

	Dom3dSystem.prototype.stop = function () {
		this.playing = false;

		SystemBus.emit('goo.dom3d.enabled', false);
		if (this.renderer.domElement) {
			this.renderer.domElement.style.pointerEvents = '';
		}
	};

	Dom3dSystem.prototype.getCameraCSSMatrix = function (matrix) {
		var elements = matrix.data;

		return 'matrix3d('
			+ elements[0] + ',' + (-elements[1]) + ',' + elements[2] + ',' + elements[3] + ','
			+ elements[4] + ',' + (-elements[5]) + ',' + elements[6] + ',' + elements[7] + ','
			+ elements[8] + ',' + (-elements[9]) + ',' + elements[10] + ',' + elements[11] + ','
			+ elements[12] * this.precisionScale + ',' + (-elements[13]) * this.precisionScale + ',' + elements[14] * this.precisionScale + ',' + elements[15] + ')';
	};

	Dom3dSystem.prototype.getEntityCSSMatrix = function (matrix) {
		var elements = matrix.data;

		return 'translate3d(-50%,-50%,0) matrix3d('
			+ elements[0] + ',' + elements[1] + ',' + elements[2] + ',' + elements[3] + ','
			+ (-elements[4]) + ',' + (-elements[5]) + ',' + (-elements[6]) + ',' + (-elements[7]) + ','
			+ elements[8] + ',' + elements[9] + ',' + elements[10] + ',' + elements[11] + ','
			+ elements[12] * this.precisionScale + ',' + elements[13] * this.precisionScale + ',' + elements[14] * this.precisionScale + ',' + elements[15] + ')';
	};

	Dom3dSystem.prototype.setStyle = function (element, property, style) {
		var cachedStyle = this.styleCache.get(element);

		if (style !== cachedStyle) {
			for (var j = 0; j < this.prefixes.length; j++) {
				element.style[this.prefixes[j] + property] = style;
			}
			this.styleCache.set(element, style);
		}
	};

	Dom3dSystem.prototype.inserted = function (entity) {
		var component = entity.dom3dComponent;
		component.meshRendererComponent.materials = this.materials;
	};

	Dom3dSystem.prototype.onPreRender = function () {
		var entities = this._activeEntities;
		var camera = this.camera;
		if (!camera || entities.length === 0) {
			return;
		}

		// lazy init
		if (this.renderer.domElement.parentNode && !this.rootDom) {
			this.init();
		}

		var width = this.renderer.viewportWidth / this.renderer.devicePixelRatio;
		var height = this.renderer.viewportHeight / this.renderer.devicePixelRatio;
		var fov = 0.5 / Math.tan(MathUtils.DEG_TO_RAD * camera.fov * 0.5) * height;

		this.setStyle(this.rootDom, 'perspective', fov + 'px');

		var viewMatrix = camera.getViewMatrix();
		var style = 'translate3d(0,0,' + fov + 'px) ' +
				this.getCameraCSSMatrix(viewMatrix) +
				' translate3d(' + (width / 2) + 'px,' + (height / 2) + 'px, 0)';
		this.setStyle(this.cameraDom, 'transform', style);

		for (var i = 0, l = entities.length; i < l; i++) {
			var entity = entities[i];
			var component = entity.dom3dComponent;
			var domElement = component.domElement;

			if (domElement.parentNode !== this.cameraDom) {
				this.cameraDom.appendChild(domElement);
			}

			// Do we really have to set this every time?
			if (component.hidden) {
				component.domElement.style.display = 'none';
				continue;
			} else {
				component.domElement.style.display = '';
			}

			if (!component.updated && !component._transformDirty) {
				continue;
			}
			component.updated = false;
			component._transformDirty = false;

			var worldTransform = entity.transformComponent.sync().worldTransform;
			style = this.getEntityCSSMatrix(worldTransform.matrix) +
					' scale(' + this.precisionScale / component.width +
					', ' + this.precisionScale / component.height + ')';
			this.setStyle(domElement, 'transform', style);
		}
	};

	Dom3dSystem.prototype.cleanup = function () {
		System.prototype.cleanup.apply(this, arguments);

		if (this.rootDom.parentNode !== null) {
			this.rootDom.parentNode.removeChild(this.rootDom);
		}
	};

	module.exports = Dom3dSystem;


/***/ },
/* 319 */
/***/ function(module, exports, __webpack_require__) {

	var ConfigHandler = __webpack_require__(85);
	var Ajax = __webpack_require__(132);
	var RSVP = __webpack_require__(55);
	var StringUtils = __webpack_require__(36);
	var PromiseUtils = __webpack_require__(54);
	var ArrayUtils = __webpack_require__(86);
	var ShapeCreatorMemoized = __webpack_require__(320);

	// Todo: should these really be included here?
	__webpack_require__(88);
	__webpack_require__(309);
	__webpack_require__(321);
	__webpack_require__(322);
	__webpack_require__(323);
	__webpack_require__(324);
	__webpack_require__(325);
	__webpack_require__(326);
	__webpack_require__(327);
	__webpack_require__(328);
	__webpack_require__(329);
	__webpack_require__(126);
	__webpack_require__(330);
	__webpack_require__(331);
	__webpack_require__(332);
	__webpack_require__(334);
	__webpack_require__(336);
	__webpack_require__(338);
	__webpack_require__(340);

	/**
	 * Class to load objects into the engine, or to update objects based on the data model.
	 * @param {Object} options
	 * @param {World} options.world The target World object.
	 * @param {string} options.rootPath The root path from where to get resources.
	 * @param {Ajax} [options.ajax=new Ajax(options.rootPath)]
	 * Can be used to overwrite how the loader fetches refs. Good for testing.
	 */
	function DynamicLoader(options) {
		if (options.world) {
			this._world = options.world;
		} else {
			throw new Error('World argument cannot be null');
		}

		if (options.ajax) {
			this._ajax = options.ajax;
		} else if (options.rootPath) {
			this._ajax = new Ajax(options.rootPath);
		} else {
			throw new Error('ajax or rootPath must be defined');
		}

		// Will hold the engine objects
		this._objects = new Map();
		// Will hold instances of handler classes by type
		this._handlers = {};
	}

	/**
	 * Load configs into the loader cache without loading anything into the engine.
	 * Subsequent calls to load and update will draw configs from the prefilled cache.
	 *
	 * @param {Object} configs Configs object. Keys should be refs, and values are the config objects. If a config is null,
	 * the loader will search for the appropriate config in the loader's internal cache.
	 * @param {boolean} [clear=false] If true, possible previous cache will be cleared. Otherwise the existing cache is extended.
	 *
	 **/
	DynamicLoader.prototype.preload = function (bundle, clear) {
		this._ajax.prefill(bundle, clear);
	};

	/**
	 * Clears the cache of all the handlers. Also clears the engine.
	 * @returns {RSVP.Promise} Promise resolves when handlers are cleared.
	 */
	DynamicLoader.prototype.clear = function () {
		var promises = [];
		for (var type in this._handlers) {
			promises.push(this._handlers[type].clear());
		}
		if (this._ajax.clear instanceof Function) {
			this._ajax.clear();
		}
		if (this._world && this._world.gooRunner) {
			ShapeCreatorMemoized.clearCache(this._world.gooRunner.renderer.context);
			for (var i = 0; i < this._world.gooRunner.renderSystems.length; i++) {
				var lights = this._world.gooRunner.renderSystems[i].lights;
				if (lights) {
					for (var j = 0; j < lights.length; j++) {
						lights[j].destroy(this._world.gooRunner.renderer);
					}
				}
			}

			this._world.gooRunner.renderer.clearShaderCache();
		}
		return RSVP.all(promises);
	};

	/**
	 * Load an object with the specified path into the engine. The object can be of any
	 * type, what loading does is determined by the ref type and the
	 * registered {@link ConfigHandler}.
	 *
	 * @param {string} ref Ref of object to load.
	 * @param {Object} options
	 * @param {function (handled, total)} [options.progressCallback] Function called while loading the world.
	 * Arguments handled and total are both integer numbers and represent the loaded elements so far as well as the total elements.
	 * @param {boolean} [options.preloadBinaries=false] Load the binary data as soon as the reference is loaded.
	 * @param {boolean} [options.noCache=false] Ignore cache, i.e. always load files fresh from the server.
	 * @returns {RSVP.Promise} The promise is resolved when the object is loaded into the world. The parameter is an object
	 * mapping all loaded refs to their configuration, like so: <code>{sceneRef: sceneConfig, entity1Ref: entityConfig...}</code>.
	 */
	DynamicLoader.prototype.load = function (ref, options) {
		options = options || {};
		var load = this._loadObject.bind(this, ref, options);
		if (options.preloadBinaries === true) {
			return this._loadBinariesFromRefs(ref, options).then(load);
		} else {
			return load();
		}
	};

	/**
	 * Update an object in the world with an updated config. The object can be of any
	 * type, updating behavior is determined by the registered {ConfigHandler}.
	 *
	 * @param {string} ref Ref of object to update.
	 * @param {Object} [config] New configuration (formatted according to data model).
	 * If omitted, works the same as {DynamicLoader.load}.
	 * @param {Object} options
	 * @param {boolean} [options.noCache=false] Ignore cache, i.e. always load files fresh from the server.
	 * @returns {RSVP.Promise} The promise is resolved when the object is updated, with the config data as argument.
	 */
	DynamicLoader.prototype.update = function (ref, config, options) {
		var that = this;
		options = options || {};

		return this._ajax.update(ref, config).then(function (config) {
			return that._updateObject(ref, config, options);
		})
		.then(null, function (err) {
			console.error('Error updating ' + ref + ' ' + err);
			throw err;
		});
	};

	/*
	 **** Loader functions ****
	 */

	/**
	 * Loads the object specified by the ref. If an object is already loaded,
	 * it will return that object without updating it.
	 * @param {string} ref
	 * @param {Object} options
	 * @returns {Object} Depending on what type of ref was loaded.
	 * @private
	 */
	DynamicLoader.prototype._loadObject = function (ref, options) {
		var type = DynamicLoader.getTypeForRef(ref);
		var handler = this._getHandler(type);
		if (handler) {
			return handler.load(ref, options);
		} else {
			return this._loadRef(ref, options);
		}
	};

	DynamicLoader.prototype.remove = function (ref) {
		this._objects.delete(ref);
		return this.update(ref, null);
	};

	/**
	 * Updates object identified by ref according to config
	 * @param {string} ref
	 * @param {Object} config
	 * @param {Object} options
	 * @returns {Object} Depending on what's being updated
	 * @private
	 */
	DynamicLoader.prototype._updateObject = function (ref, config, options) {
		var type = DynamicLoader.getTypeForRef(ref);
		var handler = this._getHandler(type);
		if (handler) {
			return handler.update(ref, config, options);
		} else if (DynamicLoader._isRefTypeInGroup(ref, 'binary') || type !== 'bundle') {
			return PromiseUtils.resolve(config);
		} else {
			console.warn('No handler for type ' + type);
			return PromiseUtils.resolve(config);
		}
	};

	/**
	 * Fetch a file from the server, and parse JSON if needed.
	 *
	 * @param {string} ref Ref of the config to load
	 * @param {boolean} [noCache] If true, ignore cached config and fetch everything from the server
	 * @returns {RSVP.Promise} Promise that resolves with the loaded config
	 * @private
	 */
	DynamicLoader.prototype._loadRef = function (ref, options) {
		return this._ajax.load(ref, (options == null) ? false : options.noCache);
	};

	/**
	 * Recursively traverses all configs and preloads the binary files referenced.
	 * @param {Object} references one-level object of references, like in datamodel
	 * @param {Object} options See {DynamicLoader.load}
	 * @returns {RSVP.Promise} Promise resolving when the binary files are loaded.
	 * @private
	 */
	DynamicLoader.prototype._loadBinariesFromRefs = function (references, options) {
		if (typeof references === 'string') {
			var reference = references;
			references = {};
			references[reference] = reference;
		}

		var that = this;
		function loadBinaryRefs(refs) {
			var handled = 0;

			// Load the binary and increase progress tick on finished loading
			function load(ref) {
				return that._loadRef(ref, options).then(function () {
					handled++;
					if (options.progressCallback instanceof Function) {
						options.progressCallback(handled, refs.length);
					}
				});
			}
			// When all binary refs are loaded, we're done
			return RSVP.all(refs.map(load));
		}

		function traverse(refs) {
			var binaryRefs = new Set();
			var jsonRefs = new Set();

			// Loads config for traversal
			function loadFn(ref) {
				return that._loadRef(ref, options).then(traverseFn);
			}

			// Looks through config for binaries
			function traverseFn(config) {
				var promises = [];
				if (config.lazy === true) {
					return PromiseUtils.resolve();
				}

				var refs = DynamicLoader._getRefsFromConfig(config);

				for (var i = 0, len = refs.length; i < len; i++) {
					var ref = refs[i];
					if (DynamicLoader._isRefTypeInGroup(ref, 'asset') && !binaryRefs.has(ref)) {
						// If it's a binary ref, store it in the list
						binaryRefs.add(ref);
					} else if (DynamicLoader._isRefTypeInGroup(ref, 'json') && !jsonRefs.has(ref)) {
						// If it's a json-config, look deeper
						jsonRefs.add(ref);
						promises.push(loadFn(ref));
					}
				}
				return RSVP.all(promises);
			}

			// Resolved when everything is loaded and traversed
			return traverseFn({ collectionRefs: refs }).then(function () {
				return ArrayUtils.fromValues(binaryRefs);
			});
		}

		return traverse(references).then(loadBinaryRefs);
	};

	/**
	 * Gets cached handler for type or creates a new one.
	 * @param {string} type Type.
	 * @returns {ConfigHandler} Config handler.
	 * @private
	 */
	DynamicLoader.prototype._getHandler = function (type) {
		var handler = this._handlers[type];
		if (handler) { return handler; }
		var Handler = ConfigHandler.getHandler(type);
		if (Handler) {
			this._handlers[type] = new Handler(
				this._world,
				this._loadRef.bind(this),
				this._updateObject.bind(this),
				this._loadObject.bind(this)
			);
			return this._handlers[type];
		}
		return null;
	};


	var BINARY_HASH_LENGTH = 40;
	var JSON_HASH_LENGTH = 32;

	/**
	 * Determine if a string is a valid goo data model id
	 *
	 * @param {string} id
	 * @returns {boolean}
	 * @private
	 */
	var isValidId = function (id) {
		if (typeof id !== 'string') {
			return false;
		}
		var tokens = id.split('.');
		return tokens[0] &&
			(tokens[0].length === BINARY_HASH_LENGTH || tokens[0].length === JSON_HASH_LENGTH) &&
			tokens[1];
	};

	/**
	 * Traverses a json-like structure and collects refs in an array
	 * @param config
	 * @returns {Array}
	 * @hidden
	 */
	DynamicLoader._getRefsFromConfig = function (config) {
		var refs = [];

		function traverse(key, value) {
			// Multiple refs
			if (StringUtils.endsWith(key.toLowerCase(), 'refs') && value instanceof Object) {
				var foundRefs = 0;
				for (var i = 0, keys = Object.keys(value), len = keys.length; i < len; i++) {
					if (isValidId(value[keys[i]])) {
						refs.push(value[keys[i]]);
						foundRefs++;
					}
				}
				if (foundRefs > 0) {
					return;
				}
			}

			// Single ref
			if (
				StringUtils.endsWith(key.toLowerCase(), 'ref') &&
				key !== 'thumbnailRef' &&
				isValidId(value)
			) {
				refs.push(value);
				return;
			}

			// Regular object (step into)
			if (
				value instanceof Object &&
				key !== 'assets' &&
				!(value instanceof Array)
			) {
				// Go down a level
				for (var i = 0, keys = Object.keys(value), len = keys.length; i < len; i++) {
					traverse(keys[i], value[keys[i]]);
				}
			}
		}

		traverse('', config);
		return refs;
	};

	/**
	 * Gets the type of a reference.
	 *
	 * @param {string} ref Reference.
	 * @returns {string} Type of reference.
	 */
	DynamicLoader.getTypeForRef = function (ref) {
		return ref.substr(ref.lastIndexOf('.') + 1).toLowerCase();
	};

	/**
	 * Checks if ref has a type included in the group
	 * Different groups are found in the top of the file
	 * @private
	 * @param {string} ref
	 * @param {string} group
	 * @returns {boolean}
	 */
	DynamicLoader._isRefTypeInGroup = function (ref, group) {
		var type = DynamicLoader.getTypeForRef(ref);
		return type && Ajax.types[group] && Ajax.types[group][type];
	};

	module.exports = DynamicLoader;


/***/ },
/* 320 */
/***/ function(module, exports, __webpack_require__) {

	var Box = __webpack_require__(27);
	var Quad = __webpack_require__(28);
	var Sphere = __webpack_require__(29);
	var Cylinder = __webpack_require__(117);
	var Torus = __webpack_require__(297);
	var Disk = __webpack_require__(294);
	var Cone = __webpack_require__(312);
	var ObjectUtil = __webpack_require__(99);

	/**
	 * Factory for shape creation.
	 * Only used to define the class. Should never be instantiated.
	 */
	function ShapeCreatorMemoized() {}

	var _cacheQueue = [];
	var _cacheMap = new Map();
	var cacheLimit = 100;

	function computeHash(name, options) {
		var keys = Object.keys(options);
		var optionsStr = keys.map(function (key) {
			return key + '' + options[key];
		}).join('');
		return name + optionsStr;
	}

	function cacheOrCreate(name, options, createShape) {
		var hash = computeHash(name, options);

		var shape = _cacheMap.get(hash);
		if (shape) {
			return shape;
		} else {
			shape = createShape();
			_cacheQueue.push(hash);
			_cacheMap.set(hash, shape);
			if (_cacheQueue.length > cacheLimit) {
				var hash = _cacheQueue.shift();
				_cacheMap.delete(hash);
			}
			return shape;
		}
	}

	ShapeCreatorMemoized.createQuad = function (options, oldMeshData) {
		var width = 1, height = 1, tileX = 1, tileY = 1;
		if (!oldMeshData ||
			width !== oldMeshData.xExtent ||
			height !== oldMeshData.yExtent ||
			tileX !== oldMeshData.tileX ||
			tileY !== oldMeshData.tileY) {
			return cacheOrCreate('quad', {}, function () {
				return new Quad(width, height, tileX, tileY);
			});
		} else {
			return oldMeshData;
		}
	};

	ShapeCreatorMemoized.createBox = function (options, oldMeshData) {
		options = options || {};
		ObjectUtil.defaults(options, {
			textureMode: 'Uniform'
		});

		var width = 1, height = 1, length = 1, tileX = 1, tileY = 1;
		if (!oldMeshData ||
			width !== oldMeshData.xExtent ||
			height !== oldMeshData.yExtent ||
			length !== oldMeshData.zExtent ||
			tileX !== oldMeshData.tileX ||
			tileY !== oldMeshData.tileY ||
			options.textureMode !== oldMeshData.textureMode.name) {
			return cacheOrCreate('box', options, function () {
				return new Box(width, height, length, tileX, tileY, options.textureMode);
			});
		} else {
			return oldMeshData;
		}
	};

	ShapeCreatorMemoized.createSphere = function (options, oldMeshData) {
		options = options || {};
		ObjectUtil.defaults(options, {
			zSamples: 8,
			radialSamples: 8,
			textureMode: 'Projected',
			radius: 1
		});

		if (!oldMeshData ||
			options.zSamples !== oldMeshData.zSamples - 1 ||
			options.radialSamples !== oldMeshData.radialSamples ||
			options.textureMode !== oldMeshData.textureMode.name ||
			options.radius !== oldMeshData.radius) {
			return cacheOrCreate('sphere', options, function () {
				return new Sphere(options.zSamples, options.radialSamples, options.radius, options.textureMode);
			});
		} else {
			return oldMeshData;
		}
	};

	ShapeCreatorMemoized.createCylinder = function (options, oldMeshData) {
		options = options || {};
		ObjectUtil.defaults(options, {
			radialSamples: 8,
			radius: 1
		});

		if (!oldMeshData ||
			options.radialSamples !== oldMeshData.radialSamples ||
			options.radius !== oldMeshData.radius) {
			return cacheOrCreate('cylinder', options, function () {
				return new Cylinder(options.radialSamples, options.radius);
			});
		} else {
			return oldMeshData;
		}
	};

	ShapeCreatorMemoized.createTorus = function (options, oldMeshData) {
		options = options || {};
		ObjectUtil.defaults(options, {
			radialSamples: 8,
			circleSamples: 12,
			tubeRadius: 0.2,
			centerRadius: 1
		});

		if (!oldMeshData ||
			options.radialSamples !== oldMeshData._radialSamples ||
			options.circleSamples !== oldMeshData._circleSamples ||
			options.tubeRadius !== oldMeshData._tubeRadius ||
			options.centerRadius !== oldMeshData._centerRadius) {
			return cacheOrCreate('torus', options, function () { // cannot cache torus because of real typed tubeRadius
				return new Torus(options.circleSamples, options.radialSamples, options.tubeRadius, options.centerRadius);
			});
		} else {
			return oldMeshData;
		}
	};

	ShapeCreatorMemoized.createDisk = function (options, oldMeshData) {
		options = options || {};
		ObjectUtil.defaults(options, {
			radialSamples: 8,
			pointiness: 0,
			radius: 1
		});

		if (!oldMeshData ||
			options.radialSamples !== oldMeshData.nSegments ||
			options.pointiness !== oldMeshData.pointiness ||
			options.radius !== oldMeshData.radius) {
			if (options.pointiness === Math.floor(options.pointiness)) {
				return cacheOrCreate('disk', options, function () {
					return new Disk(options.radialSamples, options.radius, options.pointiness);
				});
			} else {
				return new Disk(options.radialSamples, options.radius, options.pointiness);
			}
		} else {
			return oldMeshData;
		}
	};

	ShapeCreatorMemoized.createCone = function (options, oldMeshData) {
		options = options || {};
		ObjectUtil.defaults(options, {
			radialSamples: 8,
			height: 0,
			radius: 1
		});

		if (!oldMeshData ||
			options.radialSamples !== oldMeshData.radialSamples ||
			options.height !== oldMeshData.height ||
			options.radius !== oldMeshData.radius) {
			if (options.height === Math.floor(options.height)) {
				return cacheOrCreate('cone', options, function () {
					return new Cone(options.radialSamples, options.radius, options.height);
				});
			} else {
				return new Cone(options.radialSamples, options.radius, options.height);
			}
		} else {
			return oldMeshData;
		}
	};

	ShapeCreatorMemoized.clearCache = function (context) {
		if (context) {
			_cacheMap.forEach(function (value) {
				value.destroy(context);
			});
		}
		_cacheQueue.length = 0;
		_cacheMap.clear();
	};

	module.exports = ShapeCreatorMemoized;

/***/ },
/* 321 */
/***/ function(module, exports, __webpack_require__) {

	var ConfigHandler = __webpack_require__(85);
	var ComponentHandler = __webpack_require__(88);
	var RSVP = __webpack_require__(55);
	var StringUtils = __webpack_require__(36);
	var PromiseUtils = __webpack_require__(54);

	/**
	 * Handler for loading entities into engine
	 * @extends ConfigHandler
	 * @param {World} world
	 * @param {Function} getConfig
	 * @param {Function} updateObject
	 * @private
	 */
	function EntityHandler() {
		ConfigHandler.apply(this, arguments);
		this._componentHandlers = {};
	}

	EntityHandler.prototype = Object.create(ConfigHandler.prototype);
	EntityHandler.prototype.constructor = EntityHandler;
	ConfigHandler._registerClass('entity', EntityHandler);

	/**
	 * Creates an empty entity
	 * @param {string} ref will be the entity's id
	 * @returns {Entity}
	 * @private
	 */
	EntityHandler.prototype._create = function () {
		return this.world.createEntity();
	};

	/**
	 * Removes an entity
	 * @param {ref}
	 * @private
	 */
	EntityHandler.prototype._remove = function (ref) {
		var entity = this._objects.get(ref);
		var that = this;
		if (entity) {
			// Remove components
			var promises = [];
			var components = entity._components.slice(0);
			for (var i = 0; i < components.length; i++) {
				var type = this._getComponentType(components[i]);
				var p = this._updateComponent(entity, type, null);
				if (p instanceof RSVP.Promise) {
					promises.push(p);
				}
			}
			return RSVP.all(promises)
			.then(function () {
				entity.removeFromWorld();
				that._objects.delete(ref);
			});
		}
	};

	function updateTags(entity, tags) {
		entity._tags.clear();
		if (!tags) { return; }

		for (var tag in tags) {
			entity.setTag(tag);
		}
	}

	function updateAttributes(entity, attributes) {
		entity._attributes.clear();
		if (!attributes) { return; }

		for (var attribute in attributes) {
			entity.setAttribute(attribute, attributes[attribute]);
		}
	}

	/**
	 * Adds/updates/removes an entity
	 * @param {string} ref
	 * @param {Object} config
	 * @param {Object} options
	 * @returns {RSVP.Promise} Resolves with the updated entity or null if removed
	 */
	EntityHandler.prototype._update = function (ref, config, options) {
		var that = this;
		return ConfigHandler.prototype._update.call(this, ref, config, options).then(function (entity) {
			if (!entity) { return; }
			entity.id = ref;
			entity.name = config.name;
			entity.static = !!config.static;

			updateTags(entity, config.tags);
			updateAttributes(entity, config.customAttributes);

			var promises = [];

			// Adding/updating components
			for (var type in config.components) {
				if (config.components[type]) {
					var p = that._updateComponent(entity, type, config.components[type], options);
					if (p) { promises.push(p); }
					else {
						console.error('Error handling component ' + type);
					}
				}
			}

			// Removing components
			var components = entity._components;
			for (var i = 0; i < components.length; i++) {
				var type = that._getComponentType(components[i]);
				if (!config.components[type]) {
					that._updateComponent(entity, type, null, options);
				}
			}
			// When all is done, hide or show and return
			return PromiseUtils.optimisticAll(promises).then(function (/*components*/) {
				if (config.hidden) {
					entity.hide();
				} else {
					entity.show();
				}
				return entity;
			});
		});
	};

	/**
	 * Adds/updates/removes a component on an entity
	 * @param {Entity} entity
	 * @param {string} type
	 * @param {Object} config
	 * @param {Object} options
	 * @returns {RSVP.Promise} Resolves with updated entity
	 * @private
	 */
	EntityHandler.prototype._updateComponent = function (entity, type, config, options) {
		var handler = this._getHandler(type);
		if (!handler) { return null; }

		var p = handler.update(entity, config, options);
		if (!p || !p.then) { return null; }

		return p;
	};

	/**
	 * Get the type for the component. Needed to match engine components against data model
	 * component types.
	 * @param {Component} component
	 * @returns {string}
	 * @private
	 */
	EntityHandler.prototype._getComponentType = function (component) {
		var type = component.type;
		type = type.slice(0, type.lastIndexOf('Component'));
		type = StringUtils.uncapitalize(type);
		if (type === 'howler') { type = 'sound'; } // HowlerComponent should be renamed
		return type;
	};

	/**
	 * Gets the handler for a component type or creates a new one if necessary
	 * @param {string} type
	 * @returns {ComponentHandler}
	 */
	EntityHandler.prototype._getHandler = function (type) {
		if (!this._componentHandlers[type]) {
			var Handler = ComponentHandler.getHandler(type);
			if (Handler) {
				this._componentHandlers[type] = new Handler(
					this.world,
					this.getConfig,
					this.updateObject,
					this.loadObject
				);
			}
		}
		return this._componentHandlers[type];
	};

	module.exports = EntityHandler;


/***/ },
/* 322 */
/***/ function(module, exports, __webpack_require__) {

	var ConfigHandler = __webpack_require__(85);
	var PromiseUtils = __webpack_require__(54);

	/**
	 * Handler for loading json objects.
	 *
	 * @param {World} world
	 * @param {Function} getConfig
	 * @param {Function} updateObject
	 *
	 * @extends ConfigHandler
	 * @private
	 */
	function JsonHandler() {
		ConfigHandler.apply(this, arguments);
	}

	JsonHandler.prototype = Object.create(ConfigHandler.prototype);
	JsonHandler.prototype.constructor = JsonHandler;
	ConfigHandler._registerClass('json', JsonHandler);

	/**
	 * Adds/updates/removes a json data object.
	 *
	 * @param {string} ref
	 * @param {Object} config
	 * @returns {RSVP.Promise} Resolves with the updated shader or null if removed
	 */
	JsonHandler.prototype._update = function (ref, config) {
		if (!config) {
			this._remove(ref);
			return PromiseUtils.resolve();
		}

		var data;
		try {
			data = JSON.parse(config.body);
		} catch (error) {
			data = {};
		}

		return PromiseUtils.resolve(data)
	};

	module.exports = JsonHandler;


/***/ },
/* 323 */
/***/ function(module, exports, __webpack_require__) {

	var ComponentHandler = __webpack_require__(88);
	var LightComponent = __webpack_require__(194);
	var PointLight = __webpack_require__(49);
	var SpotLight = __webpack_require__(52);
	var DirectionalLight = __webpack_require__(51);
	var Vector3 = __webpack_require__(8);
	var ObjectUtils = __webpack_require__(6);

	/**
	 * For handling loading of light components
	 * @param {World} world The goo world
	 * @param {Function} getConfig The config loader function. See {@see DynamicLoader._loadRef}.
	 * @param {Function} updateObject The handler function. See {@see DynamicLoader.update}.
	 * @extends ComponentHandler
	 * @hidden
	 */
	function LightComponentHandler() {
		ComponentHandler.apply(this, arguments);
		this._type = 'LightComponent';
	}

	LightComponentHandler.prototype = Object.create(ComponentHandler.prototype);
	LightComponentHandler.prototype.constructor = LightComponentHandler;
	ComponentHandler._registerClass('light', LightComponentHandler);

	/**
	 * Prepare component. Set defaults on config here.
	 * @param {Object} config
	 * @private
	 */
	LightComponentHandler.prototype._prepare = function (config) {
		ObjectUtils.defaults(config, {
			direction: [0, 0, 0],
			color: [1, 1, 1],
			shadowCaster: false,
			lightCookie: null
		});

		if (config.type !== 'DirectionalLight') {
			config.range = (config.range !== undefined) ? config.range : 1000;
		}

		if (config.shadowCaster) {
			config.shadowSettings = config.shadowSettings || {};
			ObjectUtils.defaults(config.shadowSettings, {
				shadowType: 'Basic',
				near: 1,
				far: 1000,
				resolution: [512, 512],
				darkness: 0.5,
				shadowOffset: -0.001
			});

			var settings = config.shadowSettings;

			if (settings.projection === 'Parallel') {
				settings.size = (settings.size !== undefined) ? settings.size : 400;
			} else {
				settings.fov = (settings.fov !== undefined) ? settings.fov : 55;
			}
		}
	};

	/**
	 * Create light component object based on the config.
	 * @returns {LightComponent} the created component object
	 * @private
	 */
	LightComponentHandler.prototype._create = function () {
		return new LightComponent();
	};

	/**
	 * Update engine cameracomponent object based on the config.
	 * @param {Entity} entity The entity on which this component should be added.
	 * @param {Object} config
	 * @param {Object} options
	 * @returns {RSVP.Promise} promise that resolves with the component when loading is done.
	 */
	LightComponentHandler.prototype.update = function (entity, config, options) {
		var that = this;
		var Light = {
			SpotLight: SpotLight,
			DirectionalLight: DirectionalLight,
			PointLight: PointLight
		};

		return ComponentHandler.prototype.update.call(this, entity, config, options).then(function (component) {
			if (!component) { return; }
			var light = component.light;
			if (!light || Light[config.type] !== light.constructor) {
				light = new Light[config.type]();
				component.light = light;
			}

			for (var key in config) {
				var value = config[key];
				if (light.hasOwnProperty(key)) {
					if (key === 'shadowSettings') {
						for (var key in value) {
							var shadowVal = value[key];
							if (light.shadowSettings[key] instanceof Vector3) {
								light.shadowSettings[key].setDirect(shadowVal[0], shadowVal[1], shadowVal[2]);
							} else {
								light.shadowSettings[key] = ObjectUtils.clone(shadowVal);
							}
						}
					} else if (light[key] instanceof Vector3) {
						light[key].setDirect(value[0], value[1], value[2]);
					} else {
						light[key] = ObjectUtils.clone(value);
					}
				}
			}

			if (config.type === 'PointLight') {
				light.shadowCaster = false;
			}

			if (config.lightCookie && config.type !== 'PointLight') {
				var textureObj = config.lightCookie;

				if (!textureObj || !textureObj.textureRef || textureObj.enabled === false) {
					light.lightCookie = null;
					return component;
				} else {
					return that._load(textureObj.textureRef, options).then(function (texture) {
						light.lightCookie = texture;
						return component;
					});
				}
			} else {
				light.lightCookie = null;
				return component;
			}
		});
	};

	module.exports = LightComponentHandler;


/***/ },
/* 324 */
/***/ function(module, exports, __webpack_require__) {

	var ConfigHandler = __webpack_require__(85);
	var Material = __webpack_require__(30);
	var ShaderLib = __webpack_require__(46);
	var RenderQueue = __webpack_require__(43);
	var RSVP = __webpack_require__(55);
	var ObjectUtils = __webpack_require__(6);

	/**
	 * Handler for loading materials into engine
	 * @extends ConfigHandler
	 * @param {World} world
	 * @param {Function} getConfig
	 * @param {Function} updateObject
	 * @private
	 */
	function MaterialHandler() {
		ConfigHandler.apply(this, arguments);
	}

	MaterialHandler.prototype = Object.create(ConfigHandler.prototype);
	MaterialHandler.prototype.constructor = MaterialHandler;
	ConfigHandler._registerClass('material', MaterialHandler);

	MaterialHandler.ENGINE_SHADER_PREFIX = 'GOO_ENGINE_SHADERS/';

	/**
	 * Preparing material config by populating it with defaults.
	 * @param {Object} config
	 * @private
	 */
	MaterialHandler.prototype._prepare = function (config) {
		ObjectUtils.defaults(config, {
			blendState: {},
			cullState: {},
			depthState: {},
			renderQueue: -1,
			dualTransparency: false,
			wireframe: false,
			flat: false
		});

		ObjectUtils.defaults(config.blendState, {
			blending: 'NoBlending',
			blendEquation: 'AddEquation',
			blendSrc: 'SrcAlphaFactor',
			blendDst: 'OneMinusSrcAlphaFactor'
		});

		ObjectUtils.defaults(config.cullState, {
			enabled: true,
			cullFace: 'Back',
			frontFace: 'CCW'
		});

		ObjectUtils.defaults(config.depthState, {
			enabled: true,
			write: true
		});
	};

	/**
	 * Creates a (somewhat) empty material.
	 * @returns {Material}
	 * @private
	 */
	MaterialHandler.prototype._create = function () {
		return new Material();
	};

	MaterialHandler.prototype._remove = function (ref) {
		var material = this._objects.get(ref);
		if (!material) {
			return;
		}
		// material.shader.destroy(); // don't destroy the shader; it may be used by some other material
		material.empty();
		this._objects.delete(ref);
	};

	/**
	 * Adds/updates/removes a a material
	 * @param {string} ref
	 * @param {Object} config
	 * @param {Object} options
	 * @returns {RSVP.Promise} Resolves with the updated material or null if removed
	 */
	MaterialHandler.prototype._update = function (ref, config, options) {
		var that = this;
		return ConfigHandler.prototype._update.call(this, ref, config, options).then(function (material) {
			if (!material) { return; }

			var promises = [];

			// Material settings
			ObjectUtils.extend(material.blendState, config.blendState);
			ObjectUtils.extend(material.cullState, config.cullState);
			ObjectUtils.extend(material.depthState, config.depthState);

			material.id = config.id;
			material.name = config.name;
			material.wireframe = config.wireframe;
			material.flat = config.flat;
			material.dualTransparency = config.dualTransparency;

			if (config.renderQueue === -1) {
				if (config.blendState.blending !== 'NoBlending') {
					material.renderQueue = RenderQueue.TRANSPARENT;
				} else {
					material.renderQueue = null;
				}
			} else {
				material.renderQueue = config.renderQueue;
			}

			material.uniforms = {};
			for (var name in config.uniforms) {
				if (config.uniforms[name].enabled === undefined) {
					material.uniforms[name] = ObjectUtils.clone(config.uniforms[name]);
				} else if (config.uniforms[name].enabled) {
					material.uniforms[name] = ObjectUtils.clone(config.uniforms[name].value);
				}
			}

			// Patch color uniforms
			if (material.uniforms.materialDiffuse !== undefined) {
				material.uniforms.materialDiffuse[3] = 1;
			}
			if (material.uniforms.materialAmbient !== undefined) {
				material.uniforms.materialAmbient[3] = 1;
			}
			if (material.uniforms.materialEmissive !== undefined) {
				material.uniforms.materialEmissive[3] = 1;
			}

			// TODO: This is a temporary hack until we fully moved shininess into the last entry of specular [r, g, b, spec_power]
			if (material.uniforms.materialSpecular !== undefined && material.uniforms.materialSpecularPower !== undefined) {
				material.uniforms.materialSpecular[3] = material.uniforms.materialSpecularPower;
			}

			// Shader
			var shaderRef = config.shaderRef;
			if (!shaderRef) {
				material.shader = Material.createShader(ShaderLib.texturedLit, 'DefaultShader');
			}
			else if (shaderRef.indexOf(MaterialHandler.ENGINE_SHADER_PREFIX) === 0) {
				var shaderName = shaderRef.slice(MaterialHandler.ENGINE_SHADER_PREFIX.length);
				material.shader = Material.createShader(ShaderLib[shaderName]);
			} else {
				var p = that._load(shaderRef, options).then(function (shader) {
					material.shader = shader;
				}).then(null, function (err) {
					throw new Error('Error loading shader: ' + err);
				});
				promises.push(p);
			}

			// Textures
			function addTexture(type, ref, options) {
				return that._load(ref, options).then(function (texture) {
					material.setTexture(type, texture);
				}).then(null, function (err) {
					throw new Error('Error loading texture: ' + ref + ' - ' + err);
				});
			}
			var textureRef;
			for (var type in config.texturesMapping) {
				textureRef = config.texturesMapping[type];
				if (!textureRef || !textureRef.textureRef || textureRef.enabled === false) {
					material.removeTexture(type);
				} else {
					promises.push(addTexture(type, textureRef.textureRef, options));
				}
			}
			for (var type in material._textureMaps) {
				if (!config.texturesMapping[type]) {
					material.removeTexture(type);
				}
			}
			return RSVP.all(promises).then(function () {
				return material;
			});
		});
	};

	module.exports = MaterialHandler;


/***/ },
/* 325 */
/***/ function(module, exports, __webpack_require__) {

	var ComponentHandler = __webpack_require__(88);
	var MeshDataComponent = __webpack_require__(216);
	var BoundingBox = __webpack_require__(7);
	var ShapeCreatorMemoized = __webpack_require__(320);
	var RSVP = __webpack_require__(55);
	var ObjectUtils = __webpack_require__(6);
	var StringUtils = __webpack_require__(36);

	/**
	 * For handling loading of meshdatacomponents
	 * @param {World} world The goo world
	 * @param {Function} getConfig The config loader function. See {@see DynamicLoader._loadRef}.
	 * @param {Function} updateObject The handler function. See {@see DynamicLoader.update}.
	 * @extends ComponentHandler
	 * @hidden
	 */
	function MeshDataComponentHandler() {
		ComponentHandler.apply(this, arguments);
		this._type = 'MeshDataComponent';
	}

	MeshDataComponentHandler.prototype = Object.create(ComponentHandler.prototype);
	MeshDataComponentHandler.prototype.constructor = MeshDataComponentHandler;
	ComponentHandler._registerClass('meshData', MeshDataComponentHandler);

	/**
	 * Prepare component. Set defaults on config here.
	 * @param {Object} config
	 * @returns {Object}
	 * @private
	 */
	MeshDataComponentHandler.prototype._prepare = function (config) {
		return ObjectUtils.defaults(config, {
		});
	};

	/**
	 * Create meshdata component.
	 * @returns {MeshDataComponent} the created component object
	 * @private
	 */
	MeshDataComponentHandler.prototype._create = function () {
		return new MeshDataComponent();
	};

	/**
	 * Removes the meshdata component
	 * @param {string} ref
	 */
	MeshDataComponentHandler.prototype._remove = function (entity) {
		//! AT: why is this check needed?
		if (entity.meshDataComponent && entity.meshDataComponent.meshData && this.world.gooRunner) {
			entity.meshDataComponent.meshData.destroy(this.world.gooRunner.renderer.context);
		}
		entity.clearComponent('MeshDataComponent');
	};

	/**
	 * Update engine meshdatacomponent object based on the config.
	 * @param {Entity} entity The entity on which this component should be added.
	 * @param {Object} config
	 * @param {Object} options
	 * @returns {RSVP.Promise} promise that resolves with the component when loading is done.
	 */
	MeshDataComponentHandler.prototype.update = function (entity, config, options) {
		var that = this;
		return ComponentHandler.prototype.update.call(this, entity, config, options).then(function (component) {
			if (!component) { return; }
			if (config.shape) {
				var shapeCreator = ShapeCreatorMemoized['create' + StringUtils.capitalize(config.shape)];
				if (shapeCreator) {
					component.meshData = shapeCreator(config.shapeOptions, component.meshData);
					component.autoCompute = true;
					return component;
				}
			} else if (config.meshRef) {
				var promises = [];
				// MeshData
				promises.push(that._load(config.meshRef, options).then(function (meshData) {
					component.meshData = meshData;
					if (meshData.boundingBox) {
						var min = meshData.boundingBox.min;
						var max = meshData.boundingBox.max;
						var size = [max[0] - min[0], max[1] - min[1], max[2] - min[2]];
						var center = [(max[0] + min[0]) * 0.5, (max[1] + min[1]) * 0.5, (max[2] + min[2]) * 0.5];
						var bounding = new BoundingBox();
						bounding.xExtent = size[0] / 2;
						bounding.yExtent = size[1] / 2;
						bounding.zExtent = size[2] / 2;
						bounding.center.setDirect(center[0], center[1], center[2]);
						component.modelBound = bounding;
						component.autoCompute = false;
					}
				}));
				// Skeleton pose
				if (config.poseRef) {
					promises.push(that._load(config.poseRef, options).then(function (pose) {
						component.currentPose = pose;
					}));
				} else {
					component.currentPose = null;
				}
				return RSVP.all(promises).then(function () {
					return component;
				});
			} else {
				console.warn('MeshDataComponent config does not contain a primitive spec or a reference to a mesh');
			}
		});
	};

	module.exports = MeshDataComponentHandler;


/***/ },
/* 326 */
/***/ function(module, exports, __webpack_require__) {

	var ConfigHandler = __webpack_require__(85);
	var MeshData = __webpack_require__(14);
	var BufferUtils = __webpack_require__(16);
	var Capabilities = __webpack_require__(17);
	var PromiseUtils = __webpack_require__(54);
	var ArrayUtils = __webpack_require__(86);

	var WEIGHTS_PER_VERT = 4;

	/**
	 * Handler for meshdata. Will not update, only create once
	 * @param {World} world
	 * @param {Function} getConfig
	 * @param {Function} updateObject
	 * @private
	 */
	function MeshDataHandler() {
		ConfigHandler.apply(this, arguments);
	}

	MeshDataHandler.prototype = Object.create(ConfigHandler.prototype);
	MeshDataHandler.prototype.constructor = MeshDataHandler;
	ConfigHandler._registerClass('mesh', MeshDataHandler);

	/**
	 * Removes the meshdata from the objects config
	 * @param {string} ref
	 */
	MeshDataHandler.prototype._remove = function (ref) {
		var meshData = this._objects.get(ref);
		if (meshData && this.world.gooRunner) {
			meshData.destroy(this.world.gooRunner.renderer.context);
		}
		this._objects.delete(ref);
	};

	/**
	 * Creates a MeshData once, then reuses that one without updating
	 * @param {string} ref
	 * @param {Object} config
	 * @param {Object} options
	 * @returns {RSVP.Promise} Resolves with the Meshdata or null if removed
	 */
	MeshDataHandler.prototype._update = function (ref, config, options) {
		// Don't call ConfigHandler.prototype.update, since we don't want to do ._create in the normal way
		if (!config) {
			this._remove(ref);
			return PromiseUtils.resolve();
		}

		var meshData = this._objects.get(ref);
		if (meshData) {
			return PromiseUtils.resolve(meshData);
		}

		return this.loadObject(config.binaryRef, options).then(function (bindata) {
			if (!bindata) {
				throw new Error('Binary mesh data was empty');
			}
			var meshData = this._createMeshData(config, bindata);
			this._fillMeshData(meshData, config, bindata);

			this._objects.set(ref, meshData);
			return meshData;
		}.bind(this));
	};

	/**
	 * Creates a MeshData object with attributeMap according to config
	 * @param {Object} config
	 * @returns {MeshData}
	 * @private
	 */
	MeshDataHandler.prototype._createMeshData = function (config) {
		var skinned = config.type === 'SkinnedMesh';
		var vertexCount = config.vertexCount;
		if (vertexCount === 0) {
			return null;
		}

		var indexCount = 0;
		if (config.indexLengths) {
			indexCount = config.indexLengths.reduce(function (store, val) { return store + val; });
		} else if (config.indices) {
			indexCount = config.indices.wordLength;
		}

		var typeMatch = {
			'float32': 'Float',
			'uint8': 'UnsignedByte',
			'uint16': 'UnsignedShort',
			// Not yet supported
			'uint32': 'UnsignedInt'
		};

		if (BufferUtils.browserType === 'Trident') {
			typeMatch.uint8 = 'UnsignedShort';
		}

		var attributeMap = {};
		for (var key in config.attributes) {
			var map = config.attributes[key];
			var type = map.value[2];
			attributeMap[key] = MeshData.createAttribute(map.dimensions, typeMatch[type]);
		}

		var meshData = new MeshData(attributeMap, vertexCount, indexCount);
		meshData.type = skinned ? MeshData.SKINMESH : MeshData.MESH;
		return meshData;
	};

	/**
	 * Fills MeshData object from config
	 * @param {MeshData} meshData
	 * @param {Object} config
	 * @param {ArrayBuffer} bindata
	 * @returns {MeshData}
	 * @private
	 */
	MeshDataHandler.prototype._fillMeshData = function (meshData, config, bindata) {
		var skinned = meshData.type === MeshData.SKINMESH;

		for (var key in config.attributes) {
			if (key === 'JOINTIDS') {
				//Special handling later
				continue;
			}
			var data = config.attributes[key].value;
			meshData.getAttributeBuffer(key).set(ArrayUtils.getTypedArray(bindata, data));
		}

		/**Remapping the joints. This will enable us to have skeleton with hundreds of joints even
		 * though meshes can only have ~70
		 */
		if (skinned && config.attributes.JOINTIDS) {
			var buffer = meshData.getAttributeBuffer(MeshData.JOINTIDS);
			var jointData = ArrayUtils.getTypedArray(bindata, config.attributes.JOINTIDS.value);

			// Map skeleton joint index local joint index
			var localJointMap = [];

			var localIndex = 0;
			for (var idx = 0; idx < jointData.length; idx++) {
				var jointIndex = jointData[idx];
				if (localJointMap[jointIndex] === undefined) {
					// If vertex has joint index, add to localmap
					localJointMap[jointIndex] = localIndex++;
				}
				// Set vertex joint index to local index
				buffer.set([localJointMap[jointIndex]], idx);
			}
			// Make a reverse map from local joint to skeleton joint
			// We will use this later in animation shader code
			var localMap = [];
			for (var jointIndex = 0; jointIndex < localJointMap.length; jointIndex++) {
				var localIndex = localJointMap[jointIndex];
				if (localIndex !== null) {
					localMap[localIndex] = jointIndex;
				}
			}
			meshData.paletteMap = localMap;
			meshData.weightsPerVertex = WEIGHTS_PER_VERT;
		}

		meshData.getIndexBuffer().set(ArrayUtils.getTypedArray(bindata, config.indices));
		meshData.indexModes = config.indexModes.slice();
		meshData.indexLengths = config.indexLengths.slice();

		// TODO Put somewhere else
		if (config.boundingVolume) {
			if (config.boundingVolume.type === 'BoundingBox') {
				meshData.boundingBox = { min: config.boundingVolume.min, max: config.boundingVolume.max };
			} else {
				throw new Error('Bounding volume was not BoundingBox');
			}
		}

		if (!Capabilities.ElementIndexUInt && meshData.vertexCount > 65536) {
			meshData.deIndex();
		}

		return meshData;
	};

	module.exports = MeshDataHandler;


/***/ },
/* 327 */
/***/ function(module, exports, __webpack_require__) {

	var ComponentHandler = __webpack_require__(88);
	var MeshRendererComponent = __webpack_require__(215);
	var Material = __webpack_require__(30);
	var ShaderLib = __webpack_require__(46);
	var RSVP = __webpack_require__(55);
	var ObjectUtils = __webpack_require__(6);

	/**
	 * For handling loading of meshrenderercomponents
	 * @param {World} world The goo world
	 * @param {Function} getConfig The config loader function. See {@see DynamicLoader._loadRef}.
	 * @param {Function} updateObject The handler function. See {@see DynamicLoader.update}.
	 * @extends ComponentHandler
	 * @hidden
	 */
	function MeshRendererComponentHandler() {
		ComponentHandler.apply(this, arguments);
		this._type = 'MeshRendererComponent';
	}

	MeshRendererComponentHandler.prototype = Object.create(ComponentHandler.prototype);
	MeshRendererComponentHandler.prototype.constructor = MeshRendererComponentHandler;
	ComponentHandler._registerClass('meshRenderer', MeshRendererComponentHandler);

	MeshRendererComponentHandler.DEFAULT_MATERIAL = new Material(ShaderLib.uber, 'Default material');

	/**
	 * Prepare component. Set defaults on config here.
	 * @param {Object} config
	 * @returns {Object}
	 * @private
	 */
	MeshRendererComponentHandler.prototype._prepare = function (config) {
		return ObjectUtils.defaults(config, {
			cullMode: 'Dynamic',
			castShadows: true,
			receiveShadows: true,
			reflectable: true
		});
	};

	/**
	 * Create meshrenderer component.
	 * @returns {MeshRendererComponent} the created component object
	 * @private
	 */
	MeshRendererComponentHandler.prototype._create = function () {
		return new MeshRendererComponent();
	};

	/**
	 * Update engine meshrenderercomponent object based on the config.
	 * @param {Entity} entity The entity on which this component should be added.
	 * @param {Object} config
	 * @param {Object} options
	 * @returns {RSVP.Promise} promise that resolves with the component when loading is done.
	 */
	 MeshRendererComponentHandler.prototype.update = function (entity, config, options) {
		var that = this;

		return ComponentHandler.prototype.update.call(this, entity, config, options).then(function (component) {
			if (!component) { return; }
			// Component settings
			component.cullMode = config.cullMode;
			component.castShadows = config.castShadows;
			component.receiveShadows = config.receiveShadows;
			component.isReflectable = config.reflectable;
			//component.isPickable = config.pickable;

			// Materials
			var materials = config.materials;
			if (!materials || !Object.keys(materials).length) {
				var selectionMaterial = component.materials.filter(function (material) {
					return material.name === 'gooSelectionIndicator';
				});
				component.materials = [MeshRendererComponentHandler.DEFAULT_MATERIAL].concat(selectionMaterial);
				return component;
			}

			var promises = [];
			ObjectUtils.forEach(materials, function (item) {
				promises.push(that._load(item.materialRef, options));
			}, null, 'sortValue');
			return RSVP.all(promises).then(function (materials) {
				var selectionMaterial = component.materials.filter(function (material) {
					return material.name === 'gooSelectionIndicator';
				});
				component.materials = materials.concat(selectionMaterial);
				return component;
			});
		});
	};

	module.exports = MeshRendererComponentHandler;


/***/ },
/* 328 */
/***/ function(module, exports, __webpack_require__) {

	var ConfigHandler = __webpack_require__(85);
	var SystemBus = __webpack_require__(44);
	var ObjectUtils = __webpack_require__(6);
	var RSVP = __webpack_require__(55);

	/**
	 * Handler for loading scene into engine
	 * @extends ConfigHandler
	 * @param {World} world
	 * @param {Function} getConfig
	 * @param {Function} updateObject
	 * @private
	 */
	function SceneHandler() {
		ConfigHandler.apply(this, arguments);
	}

	SceneHandler.prototype = Object.create(ConfigHandler.prototype);
	SceneHandler.prototype.constructor = SceneHandler;
	ConfigHandler._registerClass('scene', SceneHandler);

	/**
	 * Removes the scene, i e removes all entities in scene from engine world
	 * @param {ref}
	 */
	SceneHandler.prototype._remove = function (ref) {
		//Todo Clear engine
		var scene = this._objects.get(ref);
		if (scene) {
			for (var i = 0; i < scene.entities.length; i++) {
				scene.entities[i].removeFromWorld();
			}
		}
		// Remove posteffects
		// Remove environment

		this._objects.delete(ref);
	};

	/**
	 * Creates an empty scene which will hold some scene data
	 * @returns {Entity}
	 * @private
	 */
	SceneHandler.prototype._create = function () {
		return {
			id: null,
			entities: {},
			posteffects: [],
			environment: null,
			initialCameraRef: null
		};
	};

	/**
	 * Creates/updates/removes a scene
	 * @param {string} ref
	 * @param {Object} config
	 * @param {Object} options
	 * @returns {RSVP.Promise} Resolves with the updated scene or null if removed
	 */
	SceneHandler.prototype._update = function (ref, config, options) {
		var that = this;
		return ConfigHandler.prototype._update.call(this, ref, config, options).then(function (scene) {
			if (!scene) { return; }
			scene.id = ref;
			var promises = [];
			promises.push(that._handleEntities(config, scene, options));
			if (config.posteffectsRef) {
				promises.push(that._load(config.posteffectsRef, options));
			}
			if (config.environmentRef) {
				promises.push(that._load(config.environmentRef, options));
			}
			if (!options.scene || !options.scene.dontSetCamera) {
				if (config.initialCameraRef && config.initialCameraRef !== scene.initialCameraRef) {
					promises.push(that._load(config.initialCameraRef, options).then(function (cameraEntity) {
						if (cameraEntity && cameraEntity.cameraComponent) {
							SystemBus.emit('goo.setCurrentCamera', {
								camera: cameraEntity.cameraComponent.camera,
								entity: cameraEntity
							});
						}
						scene.initialCameraRef = config.initialCameraRef;
					}));
				}
			}
			return RSVP.all(promises).then(function () {
				return scene;
			});
		});
	};

	/**
	 * Adding and removing entities to the engine and thereby the scene
	 * @param {Object} config
	 * @param {Object} scene
	 * @param {Object} options
	 */
	SceneHandler.prototype._handleEntities = function (config, scene, options) {
		var that = this;
		var promises = [];

		var addedEntityIds = ObjectUtils.clone(config.entities);
		var removedEntityIds = [];

		for (var id in scene.entities) {
			//var engineEntity = scene.entities[id];
			if (addedEntityIds[id]) {
				delete addedEntityIds[id];
			}
			else {
				removedEntityIds[id] = id;
			}
		}

		ObjectUtils.forEach(config.entities, function (entityConfig) {
			promises.push(that._load(entityConfig.entityRef, options));
		}, null, 'sortValue');

		return RSVP.all(promises).then(function (entities) {
			// Adding new entities
			for (var i = 0; i < entities.length; i++) {
				var entity = entities[i];
				if (addedEntityIds[entity.id]) {
					entity.addToWorld();
				}

				// readding back entities removed by the scripts/fsm
				if (!addedEntityIds[entity.id] &&
					!removedEntityIds[entity.id] &&
					!entity._world.entityManager.containsEntity(entity)) {
					entity.addToWorld();
				}

				scene.entities[entity.id] = entity;
			}

			// Removing old entities from the handler cache
			// Removing them from the world is handled by the EntityHandler
			for (var id in removedEntityIds) {
				delete scene.entities[id];
			}
		});
	};

	/**
	 * Handling posteffects
	 * @param {Object} config
	 * @param {Object} scene
	 * @param {Object} options
	 */
	SceneHandler.prototype._handlePosteffects = function (config, scene, options) {
		return this._load(config.posteffectsRef, options);
	};

	/**
	 * Handling environment, to be implemented
	 * @param {Object} config
	 * @param {Object} scene
	 * @param {Object} options
	 */
	SceneHandler.prototype._handleEnvironment = function (config, scene, options) {
		return this._load(config.environmentRef, options);
	};

	module.exports = SceneHandler;

/***/ },
/* 329 */
/***/ function(module, exports, __webpack_require__) {

	var ConfigHandler = __webpack_require__(85);
	var Material = __webpack_require__(30);
	var ShaderBuilder = __webpack_require__(48);
	var RSVP = __webpack_require__(55);
	var PromiseUtils = __webpack_require__(54);

	/**
	 * Handler for loading shaders into engine
	 * @extends ConfigHandler
	 * @param {World} world
	 * @param {Function} getConfig
	 * @param {Function} updateObject
	 * @private
	 */
	function ShaderHandler() {
		ConfigHandler.apply(this, arguments);
	}

	ShaderHandler.prototype = Object.create(ConfigHandler.prototype);
	ShaderHandler.prototype.constructor = ShaderHandler;
	ConfigHandler._registerClass('shader', ShaderHandler);

	/**
	 * Removes a shader
	 * @param {ref}
	 * @private
	 */
	ShaderHandler.prototype._remove = function (ref) {
		var shader = this._objects.get(ref);
		if (shader && this.world.gooRunner) {
			shader.destroy(this.world.gooRunner.renderer.context);
			this._objects.delete(ref);
		}
	};

	/**
	 * Adds/updates/removes a shader
	 * Currently it is not possible to update a shader, so we create a new one every time
	 * @param {string} ref
	 * @param {Object} config
	 * @param {Object} options
	 * @returns {RSVP.Promise} Resolves with the updated shader or null if removed
	 */
	ShaderHandler.prototype._update = function (ref, config, options) {
		if (!config) {
			this._remove(ref);
			return PromiseUtils.resolve();
		}
		if (!config.vshaderRef) {
			return PromiseUtils.reject('Shader error, missing vertex shader ref');
		}
		if (!config.fshaderRef) {
			return PromiseUtils.reject('Shader error, missing fragment shader ref');
		}

		var promises = [
			this.loadObject(config.vshaderRef, options),
			this.loadObject(config.fshaderRef, options)
		];

		return RSVP.all(promises).then(function (shaders) {
			var vshader = shaders[0];
			var fshader = shaders[1];

			if (!vshader) {
				return PromiseUtils.reject('Vertex shader' + config.vshaderRef + 'in shader' + ref + 'not found');
			}
			if (!fshader) {
				return PromiseUtils.reject('Fragment shader' + config.fshaderRef + 'in shader' + ref + 'not found');
			}

			var shaderDefinition = {
				defines: config.defines || {},
				attributes: config.attributes || {},
				uniforms: config.uniforms || {},
				vshader: vshader,
				fshader: fshader
			};

			if (config.processors) {
				shaderDefinition.processors = [];
				for (var i = 0; i < config.processors.length; i++) {
					var processor = config.processors[i];
					if (ShaderBuilder[processor]) {
						shaderDefinition.processors.push(ShaderBuilder[processor].processor);
					} else {
						console.error('Unknown processor ' + processor);
					}
				}
			}

			var shader = Material.createShader(shaderDefinition, ref);

			this._objects.set(ref, shader);

			return shader;
		}.bind(this));
	};

	module.exports = ShaderHandler;


/***/ },
/* 330 */
/***/ function(module, exports, __webpack_require__) {

	var ComponentHandler = __webpack_require__(88);
	var TransformComponent = __webpack_require__(40);
	var MathUtils = __webpack_require__(9);
	var ObjectUtils = __webpack_require__(6);
	var RSVP = __webpack_require__(55);

	/**
	 * For handling loading of transform component
	 * @extends ComponentHandler
	 * @param {World} world The goo world
	 * @param {Function} getConfig The config loader function. See {@see DynamicLoader._loadRef}.
	 * @param {Function} updateObject The handler function. See {@see DynamicLoader.update}.
	 * @hidden
	 */
	function TransformComponentHandler() {
		ComponentHandler.apply(this, arguments);
		this._type = 'TransformComponent';
	}

	TransformComponentHandler.prototype = Object.create(ComponentHandler.prototype);
	TransformComponentHandler.prototype.constructor = TransformComponentHandler;
	ComponentHandler._registerClass('transform', TransformComponentHandler);

	/**
	 * Prepare component. Set defaults on config here.
	 * @param {Object} config
	 * @private
	 */
	TransformComponentHandler.prototype._prepare = function (config) {
		return ObjectUtils.defaults(config, {
			translation: [0, 0, 0],
			rotation: [0, 0, 0],
			scale: [1, 1, 1]
		});
	};

	/**
	 * Create transform component object based on the config.
	 * @param {Entity} entity The entity on which this component should be added.
	 * @returns {TransformComponent} the created component object
	 * @private
	 */
	TransformComponentHandler.prototype._create = function () {
		return new TransformComponent();
	};

	/**
	 * Remove engine component object. TransformComponents can't be removed, so we reset.
	 * @param {Entity} entity The entity from which this component should be removed.
	 * @private
	 */
	TransformComponentHandler.prototype._remove = function (entity) {
		var component = entity.transformComponent;
		// Reset
		component.transform.translation.setDirect(0, 0, 0);
		component.transform.setRotationXYZ(0, 0, 0);
		component.transform.scale.setDirect(1, 1, 1);

		// Detach all children
		for (var i = 0; i < component.children.length; i++) {
			var child = component.children[i];
			component.detachChild(child);
		}
		component.setUpdated();
	};

	/**
	 * Update engine transform component object based on the config.
	 * @param {Entity} entity The entity on which this component should be added.
	 * @param {Object} config
	 * @param {Object} options
	 * @returns {RSVP.Promise} promise that resolves with the component when loading is done.
	 */
	TransformComponentHandler.prototype.update = function (entity, config, options) {
		var that = this;

		function attachChild(component, ref) {
			return that.loadObject(ref, options).then(function (entity) {
				if (entity && entity.transformComponent) {
					component.attachChild(entity.transformComponent);
					var entityInWorld = that.world.entityManager.containsEntity(entity) ||
						that.world._addedEntities.indexOf(entity) !== -1; //! AT: most probably not needed anymore
						// entities are added synchronously to the managers
					var parentInWorld = that.world.entityManager.containsEntity(component.entity) ||
						that.world._addedEntities.indexOf(component.entity) > -1; //! AT: most probably not needed anymore
					// also, why the inconsistency: "!== -1" vs "> -1" ?

					if (!entityInWorld && parentInWorld) {
						entity.addToWorld();
					}
				} else {
					console.error('Failed to add child to transform component');
				}
				return component;
			});
		}

		return ComponentHandler.prototype.update.call(this, entity, config, options).then(function (component) {
			if (!component) {
				// Component was removed
				return;
			}

			// Translation
			component.transform.translation.setDirect(config.translation[0], config.translation[1], config.translation[2]);
			// Rotation
			component.transform.setRotationXYZ(
				MathUtils.DEG_TO_RAD * config.rotation[0],
				MathUtils.DEG_TO_RAD * config.rotation[1],
				MathUtils.DEG_TO_RAD * config.rotation[2]
			);
			// Scale
			component.transform.scale.setDirect(config.scale[0], config.scale[1], config.scale[2]);

			var promises = [];
			if (config.children) {
				// Attach children
				// TODO: Watch out for circular dependencies
				// TODO: Use sort values
				var keys = Object.keys(config.children);
				for (var i = 0; i < keys.length; i++) {
					var childRef = config.children[keys[i]].entityRef;
					promises.push(attachChild(component, childRef));
				}
				for (var i = 0; i < component.children.length; i++) {
					var child = component.children[i];
					var id = child.entity.id;
					if (!config.children[id]) {
						component.detachChild(child);
					}
				}
			} else {
				// Detach all children
				for (var i = 0; i < component.children.length; i++) {
					var child = component.children[i];
					component.detachChild(child);
				}
			}

			// When all children are attached, return component
			return RSVP.all(promises).then(function () {
				component.setUpdated();
				return component;
			});
		});
	};

	module.exports = TransformComponentHandler;


/***/ },
/* 331 */
/***/ function(module, exports, __webpack_require__) {

	var ConfigHandler = __webpack_require__(85);

	/**
	 * Handler for loading project into engine (actually loading mainScene)
	 * @private
	 * @extends ConfigHandler
	 * @param {World} world
	 * @param {Function} getConfig
	 * @param {Function} updateObject
	 */
	function ProjectHandler() {
		ConfigHandler.apply(this, arguments);
		/**
		this._skybox = null;
		this._skyboxTexture = null;
		this._skyboxGeographic = false;

		this._composer = null;
		this._passes = [];
		this.weatherState = {};
		*/
	}

	ProjectHandler.prototype = Object.create(ConfigHandler.prototype);
	ProjectHandler.prototype.constructor = ProjectHandler;
	ConfigHandler._registerClass('project', ProjectHandler);

	/**
	 * Removes project from engine, i e removes mainScene, i e removes scene entities from world
	 * @param {string} ref}
	 * @param {Object} options
	 */
	ProjectHandler.prototype._remove = function (ref, options) {
		var project = this._objects.get(ref);
		if (project) {
			this.updateObject(project.mainScene.id, null, options);
		}
	};

	/**
	 * Creates an empty project object
	 * @returns {Object}
	 * @private
	 */
	ProjectHandler.prototype._create = function () {
		return {
			mainScene: null
		};
	};

	/**
	 * Creates/updates/removes a project
	 * @param {string} ref
	 * @param {Object} config
	 * @param {Object} options
	 * @returns {RSVP.Promise} Resolves with the updated scene or null if removed
	 */
	ProjectHandler.prototype._update = function (ref, config, options) {
		var that = this;
		return ConfigHandler.prototype._update.call(this, ref, config, options).then(function (project) {
			if (!project) { return; }
			function loadPromise() {
				return that._load(config.mainSceneRef, options).then(function (scene) {
					project.mainScene = scene;
					return project;
				});
			}

			if (project.mainScene && config.mainSceneRef !== project.mainScene.id) {
				return that.updateObject(project.mainScene.id, null, options).then(loadPromise);
			} else {
				return loadPromise();
			}
		});
	};

	module.exports = ProjectHandler;


/***/ },
/* 332 */
/***/ function(module, exports, __webpack_require__) {

	var ComponentHandler = __webpack_require__(88);
	var SoundComponent = __webpack_require__(333);
	var AudioContext = __webpack_require__(305);
	var RSVP = __webpack_require__(55);
	var PromiseUtils = __webpack_require__(54);
	var ObjectUtils = __webpack_require__(6);

	/**
	 * For handling loading of sound components
	 * @param {World} world The goo world
	 * @param {Function} getConfig The config loader function. See {@see DynamicLoader._loadRef}.
	 * @param {Function} updateObject The handler function. See {@see DynamicLoader.update}.
	 * @extends ComponentHandler
	 * @hidden
	 */
	function SoundComponentHandler() {
		ComponentHandler.apply(this, arguments);
		this._type = 'SoundComponent';
	}

	SoundComponentHandler.prototype = Object.create(ComponentHandler.prototype);
	SoundComponentHandler.prototype.constructor = SoundComponentHandler;
	ComponentHandler._registerClass('sound', SoundComponentHandler);

	/**
	 * Removes the souncomponent and stops all connected sounds
	 * @param {Entity} entity
	 * @private
	 */
	SoundComponentHandler.prototype._remove = function (entity) {
		var component = entity.soundComponent;
		if (component && component.sounds) {
			var sounds = component.sounds;
			for (var i = 0; i < sounds.length; i++) {
				sounds[i].stop();
			}
		}
	};

	/**
	 * Prepares the config
	 * @param {Object} config
	 */
	SoundComponentHandler.prototype._prepare = function (config) {
		ObjectUtils.defaults(config, {
			volume: 1.0,
			reverb: 0.0
		});
	};

	/**
	 * Creates sound component
	 * @returns {SoundComponent} Should be soundcomponent
	 * @private
	 */
	SoundComponentHandler.prototype._create = function () {
		return new SoundComponent();
	};

	/**
	 * Update engine sound component object based on the config.
	 * @param {Entity} entity The entity on which this component should be added.
	 * @param {Object} config
	 * @param {Object} options
	 * @returns {RSVP.Promise} promise that resolves with the component when loading is done.
	 */
	SoundComponentHandler.prototype.update = function (entity, config, options) {
		if (!AudioContext.isSupported()) {
			return PromiseUtils.resolve(); //! AT: we're not really using reject
		}

		var that = this;
		return ComponentHandler.prototype.update.call(this, entity, config, options).then(function (component) {
			if (!component) { return; }
			component.updateConfig(config);

			// Remove old sounds
			for (var i = 0; i < component.sounds.length; i++) {
				var sound = component.sounds[i];
				if (!config.sounds[sound.id]) {
					component.removeSound(sound);
				}
			}

			var promises = [];
			// Load all sounds
			ObjectUtils.forEach(config.sounds, function (soundCfg) {
				promises.push(that._load(soundCfg.soundRef, options));
			}, null, 'sortValue');

			return RSVP.all(promises).then(function (sounds) {
				// Add new sounds
				for (var i = 0; i < sounds.length; i++) {
					if (component.sounds.indexOf(sounds[i]) === -1) {
						component.addSound(sounds[i]);
					}
				}
				return component;
			});
		});
	};

	module.exports = SoundComponentHandler;

/***/ },
/* 333 */
/***/ function(module, exports, __webpack_require__) {

	var Component = __webpack_require__(20);
	var AudioContext = __webpack_require__(305);
	var Vector3 = __webpack_require__(8);
	var MathUtils = __webpack_require__(9);

	//! AT: every method here is prefixed with a check for AudioContext. Is it really needed? can it just be refactored away?
	//Or, isn't just one (the first) warning enough - it might ruing everything if flooding the console

	/**
	 * Component that adds sound to an entity.
	 * @example-link http://code.gooengine.com/latest/visual-test/goo/addons/Sound/Sound-vtest.html Working example
	 * @extends {Component}
	 */
	function SoundComponent() {
		Component.apply(this, arguments);

		this.type = 'SoundComponent';

		this._system = null;

		/**
		 * Current sounds in the entity. Add a sound using {@link SoundComponent#addSound}.
		 * @type {Array<Sound>}
		 */
		this.sounds = [];

		this._isPanned = true;
		this._outDryNode = AudioContext.getContext().createGain();
		this._outWetNode = AudioContext.getContext().createGain();
		this.connectTo();
		this._pannerNode = AudioContext.getContext().createPanner();
		this._pannerNode.connect(this._outDryNode);
		this._inNode = AudioContext.getContext().createGain();
		this._inNode.connect(this._pannerNode);

		// The 2D sounds are always in camera space
		// Do we need another outDryNode for 2D?
		this._inNode2d = AudioContext.getContext().createGain();
		this._inNode2d.connect(this._outDryNode);

		this._oldPosition = new Vector3();
		this._position = new Vector3();
		this._orientation = new Vector3();
		this._attachedToCamera = false;

		this._autoPlayDirty = false;

		// @ifdef DEBUG
		Object.seal(this);
		// @endif
	}

	SoundComponent.type = 'SoundComponent';

	SoundComponent.prototype = Object.create(Component.prototype);
	SoundComponent.prototype.constructor = SoundComponent;

	/**
	 * Add a sound to the component
	 * @param {Sound} sound
	 */
	SoundComponent.prototype.addSound = function (sound) {
		if (this.sounds.indexOf(sound) === -1) {
			if (sound.spatialize) {
				sound.connectTo([this._inNode, this._outWetNode]);
			} else {
				sound.connectTo([this._inNode2d]);
			}
			this.sounds.push(sound);
			this._autoPlayDirty = true;
		}
	};

	/**
	 * Remove sound from component
	 * @param {Sound} sound
	 */
	SoundComponent.prototype.removeSound = function (sound) {
		var idx = this.sounds.indexOf(sound);
		if (idx > -1) {
			sound.stop();
			this.sounds.splice(idx, 1);

			if (sound.spatialize) {
				sound.disconnectFrom([this._inNode, this._outWetNode]);
			} else {
				sound.disconnectFrom([this._inNode2d]);
			}
		}
	};

	/**
	 * Get a component's sound by id
	 * @param {string} id
	 * @returns {Sound}
	 */
	SoundComponent.prototype.getSoundById = function (id) {
		for (var i = 0; i < this.sounds.length; i++) {
			if (this.sounds[i].id === id) {
				return this.sounds[i];
			}
		}
	};

	/**
	 * Connect output of component to audionodes
	 * @param {Object} [nodes]
	 * @param {AudioNode} [nodes.dry]
	 * @param {AudioNode} [nodes.wet]
	 */
	SoundComponent.prototype.connectTo = function (nodes) {
		this._outDryNode.disconnect();
		this._outWetNode.disconnect();
		if (nodes && nodes.dry) {
			this._outDryNode.connect(nodes.dry);
		}
		if (nodes && nodes.wet) {
			this._outWetNode.connect(nodes.wet);
		}
	};

	/**
	 * Updates the component valueas according to config
	 * @param {Object} [config]
	 * @param {number} [config.volume] A number between 0 and 1.
	 * @param {number} [config.reverb] A number between 0 and 1.
	 */
	SoundComponent.prototype.updateConfig = function (config) {
		if (config.volume !== undefined) {
			this._outDryNode.gain.value = MathUtils.clamp(config.volume, 0, 1);
		}
		if (config.reverb !== undefined) {
			this._outWetNode.gain.value = MathUtils.clamp(config.reverb, 0, 1);
		}
	};

	SoundComponent.prototype._autoPlaySounds = function () {
		var sounds = this.sounds;
		for (var i = 0; i < sounds.length; i++) {
			var sound = sounds[i];
			if (sound.autoPlay) {
				sound.play();
			}
		}
	};

	/**
	 * Updates position and orientation of component and thereby all connected sounds.
	 * Since all sounds in the engine are relative to the current camera, the model view matrix needs to be passed to this method.
	 * @param {Object} settings See {@link SoundSystem}
	 * @param {Matrix4} mvMat The model view matrix from the current camera, or falsy if the component is attached to the camera.
	 * @param {number} tpf
	 * @hidden
	 */
	SoundComponent.prototype.process = function (settings, mvMat/*, tpf*/) {
		this._pannerNode.rolloffFactor = settings.rolloffFactor;
		this._pannerNode.maxDistance = settings.maxDistance;

		if (this._autoPlayDirty && this._system && !this._system.passive) {
			this._autoPlaySounds();
			this._autoPlayDirty = false;
		}

		if (this._attachedToCamera || !mvMat) {
			// The component is attached to the current camera.
			if (this._isPanned) {
				this._inNode.disconnect();
				this._inNode.connect(this._outDryNode);
				this._isPanned = false;
			}
			this._pannerNode.setPosition(0, 0, 0);
			this._pannerNode.setOrientation(0, 0, 0);
			return;
		} else if (!this._isPanned) {
			this._inNode.disconnect();
			this._inNode.connect(this._pannerNode);
			this._isPanned = true;
		}

		mvMat.getTranslation(this._position);
		this._oldPosition.set(this._position);
		this._orientation.setDirect(0, 0, -1);
		this._orientation.applyPostVector(mvMat);

		this._pannerNode.setPosition(this._position.x, this._position.y, this._position.z);
		this._pannerNode.setOrientation(this._orientation.x, this._orientation.y, this._orientation.z);
	};

	module.exports = SoundComponent;


/***/ },
/* 334 */
/***/ function(module, exports, __webpack_require__) {

	var ConfigHandler = __webpack_require__(85);
	var AudioContext = __webpack_require__(305);
	var Sound = __webpack_require__(335);
	var PromiseUtils = __webpack_require__(54);
	var ObjectUtils = __webpack_require__(6);

	/**
	 * Handler for loading sounds into engine
	 * @extends ConfigHandler
	 * @param {World} world
	 * @param {Function} getConfig
	 * @param {Function} updateObject
	 * @private
	 */
	function SoundHandler() {
		ConfigHandler.apply(this, arguments);
		this._audioCache = {};

		if (window.Audio !== undefined) {
			var audioTest = new Audio();

			this._codecs = [
				{
					type: 'mp3',
					enabled: !!audioTest.canPlayType('audio/mpeg;')
				}, {
					type: 'ogg',
					enabled: !!audioTest.canPlayType('audio/ogg; codecs="vorbis"')
				}, {
					type: 'wav',
					enabled: !!audioTest.canPlayType('audio/wav; codecs="1"')
				}
			];
		} else {
			this._codecs = [];
		}
	}

	SoundHandler.prototype = Object.create(ConfigHandler.prototype);
	SoundHandler.prototype.constructor = SoundHandler;
	ConfigHandler._registerClass('sound', SoundHandler);

	/**
	 * Removes a sound
	 * @param {ref}
	 * @private
	 */
	SoundHandler.prototype._remove = function (ref) {
		var sound = this._objects.get(ref);
		if (!sound) { return; }

		sound.stop();
		this._objects.delete(ref);
	};

	/**
	 * Preparing sound config by populating it with defaults.
	 * @param {Object} config
	 * @private
	 */
	SoundHandler.prototype._prepare = function (config) {
		ObjectUtils.defaults(config, {
			loop: false,
			audioRefs: {},
			volume: 1.0,
			spatialize: false,
			autoPlay: false,
			name: 'A Sound'
		});
	};

	/**
	 * Creates an empty sound.
	 * @returns {Howl}
	 * @private
	 */
	SoundHandler.prototype._create = function () {
		return new Sound();
	};

	/**
	 * Adds/updates/removes a sound
	 * @param {string} ref
	 * @param {Object} config
	 * @param {Object} options
	 * @returns {RSVP.Promise} Resolves with the updated sound or null if removed
	 */
	SoundHandler.prototype._update = function (ref, config, options) {
		if (!AudioContext.isSupported()) {
			return PromiseUtils.resolve();
		}
		var that = this;
		return ConfigHandler.prototype._update.call(this, ref, config, options).then(function (sound) {
			if (!sound) { return; }
			sound.update(config);
			for (var i = 0; i < that._codecs.length; i++) {
				var codec = that._codecs[i];
				var ref = config.audioRefs[codec.type];

				if (ref && codec.enabled) {
					if (that._audioCache[ref]) {
						sound.setAudioBuffer(that._audioCache[ref]);
						return sound;
					} else {
						return that.loadObject(ref).then(function (buffer) {
							return PromiseUtils.createPromise(function (resolve) {
								AudioContext.getContext().decodeAudioData(buffer, function (audioBuffer) {
									resolve(audioBuffer);
								}, function (/*err*/) {
									console.error('Could not decode audio ' + ref);
									// shouldn't this just reject?
									resolve(null);
								});
							});
						}).then(function (audioBuffer) {
							if (audioBuffer) {
								that._audioCache[ref] = audioBuffer;
								sound.setAudioBuffer(audioBuffer);
							}
							return sound;
						});
					}
				}
			}
			console.warn('No supported audioformat was found');
			return sound;
		});
	};

	module.exports = SoundHandler;

/***/ },
/* 335 */
/***/ function(module, exports, __webpack_require__) {

	var AudioContext = __webpack_require__(305);
	var MathUtils = __webpack_require__(9);
	var PromiseUtil = __webpack_require__(223);
	var RSVP = __webpack_require__(55);

	/**
	 * A representation of a sound in the engine
	 */
	function Sound() {
		/** @type {string}
		 */
		this.id = null;
		/** @type {string}
		 */
		this.name = null;
		this._loop = false;
		this._rate = 1.0;
		this._offset = 0;
		this._duration = null;
		this._volume = 1.0;

		// Nodes
		this._buffer = null;
		this._stream = null;
		this._streamSource = null;
		this._currentSource = null;
		this._outNode = AudioContext.getContext().createGain();
		this.connectTo();

				// Playback memory
		this._playStart = 0;
		this._pausePos = 0;
		//this._endTimer = null;
		this._endPromise = null;

		this._paused = false;

		/**
		 * @type {boolean}
		 * @readonly
		 */
		this.spatialize = true;

		/**
		 * If true, it will start playing when the SoundSystem runs play().
		 * @type {boolean}
		 * @readonly
		 */
		this.autoPlay = false;

		// @ifdef DEBUG
		Object.seal(this);
		// @endif
	}

	/**
	 * Plays the sound if it's not playing
	 * @param {number} when Time in seconds according to [AudioContext.currentTime]{@link https://developer.mozilla.org/en-US/docs/Web/API/AudioContext/currentTime} when sound should start to play.
	 * @returns {RSVP.Promise} Resolves when sound has played through or when it's stopped.
	 * Looping sounds will never resolve
	 */
	Sound.prototype.play = function (when) {
		when = when || 0;
		if (this._currentSource) {
			return this._endPromise;
		}
		this._endPromise = new RSVP.Promise(); //! AT: this needs refactoring
		if (!this._buffer || this._stream) {
			return this._endPromise;
		}

		var currentSource = this._currentSource = AudioContext.getContext().createBufferSource();

		this._paused = false;
		this._currentSource.onended = function () {
			if (this._currentSource === currentSource && !this._paused) {
				this.stop();
			}
		}.bind(this);

		this._currentSource.playbackRate.value = this._rate;
		this._currentSource.connect(this._outNode);
		this._currentSource.buffer = this._buffer;
		this._currentSource.loop = this._loop;
		if (this._loop) {
			this._currentSource.loopStart = this._offset;
			this._currentSource.loopEnd = this._duration + this._offset;
		}

		this._playStart = AudioContext.getContext().currentTime - this._pausePos;
		var duration = this._duration - this._pausePos;

		if (this._loop) {
			this._currentSource.start(when, this._pausePos + this._offset);
		} else {
			this._currentSource.start(when, this._pausePos + this._offset, duration);
		}

		return this._endPromise;
	};

	/**
	 * Pauses the sound if it's playing
	 */
	Sound.prototype.pause = function () {
		if (!this._currentSource) {
			return;
		}

		this._paused = true;

		this._pausePos = (AudioContext.getContext().currentTime - this._playStart) % this._duration;
		this._pausePos /= this._rate;
		this._stop();
	};

	/**
	 * Stops the sound if it's playing
	 * @param {number} when Time in seconds according to [AudioContext.currentTime]{@link https://developer.mozilla.org/en-US/docs/Web/API/AudioContext/currentTime} when sound should stop.
	 */
	Sound.prototype.stop = function (when) {
		this._paused = false;
		this._pausePos = 0;
		if (this._endPromise) {
			this._endPromise.resolve();
		}
		if (this._currentSource) {
			this._stop(when);
		}
	};

	Sound.prototype.fadeIn = function (time) {
		this.stop();
		var volume = this._volume;
		this._outNode.gain.value = 0;
		var p = this.fade(volume, time);
		this.play();
		return p;
	};

	Sound.prototype.fadeOut = function (time) {
		this._outNode.gain.value = this._volume;
		return this.fade(0, time);
	};

	Sound.prototype.fade = function (volume, time) {
		this._outNode.gain.cancelScheduledValues(AudioContext.getContext().currentTime);
		this._outNode.gain.setValueAtTime(this._outNode.gain.value, AudioContext.getContext().currentTime);
		this._outNode.gain.linearRampToValueAtTime(volume, AudioContext.getContext().currentTime + time);
		return PromiseUtil.delay(volume, time * 1000);
	};

	Sound.prototype.isPlaying = function () {
		return !!this._currentSource;
	};

	/**
	 * Does the actual stopping of the sound
	 * @param {number} when Time in seconds according to [AudioContext.currentTime]{@link https://developer.mozilla.org/en-US/docs/Web/API/AudioContext/currentTime} when sound should stop.
	 * @private
	 */
	Sound.prototype._stop = function (when) {
		when = when || 0;
		this._currentSource.stop(when);
		this._currentSource = null;
	};

	/**
	 * Updates the sound according to config
	 * @param {Object} [config]
	 * @param {boolean} [config.loop]
	 * @param {number} [config.volume]
	 * @param {number} [config.name] The sound name
	 * @param {number} [config.start] Start offset in seconds.
	 * Will be clamped to be in actual soundclip duration
	 * @param {number} [config.duration] Duration of the sound.
	 * Will be clamped to be in actual soundclip duration
	 * @param {number} [config.timeScale] Playback rate of the sound
	 */
	Sound.prototype.update = function (config) {
		config = config || {};
		if (config.id !== undefined) {
			this.id = config.id;
		}
		if (config.name !== undefined) {
			this.name = config.name;
		}
		if (config.loop !== undefined) {
			this._loop = !!config.loop;
			if (this._currentSource) {
				this._currentSource.loop = this._loop;
			}
		}
		if (config.volume !== undefined) {
			this._volume = MathUtils.clamp(config.volume, 0, 1);
			this._outNode.gain.value = this._volume;
		}
		if (config.offset !== undefined) {
			this._offset = config.offset;
		}
		if (config.duration !== undefined) {
			this._duration = config.duration;
		}
		if (config.timeScale !== undefined) {
			this._rate = config.timeScale;
			//! AT: should have the same name if they are the same thing
			// problem is that there are plenty of projects out there that have timeScale instead of rate
			// timeScale was considered because it's the same as for animations
			// rate would have been preferred to timeScale as it's the term used by WebAudio
			if (this._currentSource) {
				this._currentSource.playbackRate.value = config.timeScale;
			}
		}
		if (config.spatialize !== undefined) {
			this.spatialize = config.spatialize;
		}
		if (config.autoPlay !== undefined) {
			this.autoPlay = config.autoPlay;
		}
		if (this._buffer) {
			this._clampInterval();
		}
	};

	/**
	 * Clamps the start offset and duration to be in sound range
	 * @private
	 */
	Sound.prototype._clampInterval = function () {
		this._offset = Math.min(this._offset, this._buffer.duration);
		if (this._duration !== null) {
			this._duration = Math.min(this._buffer.duration - this._offset, this._duration);
		} else {
			this._duration = this._buffer.duration - this._offset;
		}
		this._pausePos = MathUtils.clamp(this._pausePos, 0, this._duration);
	};

	/**
	 * Connect output of sound to audionodes
	 * @param {(Array<AudioNode> | AudioNode)} nodes
	 */
	Sound.prototype.connectTo = function (nodes) {
		if (!nodes) {
			return;
		}
		if (!(nodes instanceof Array)) {
			nodes = [nodes];
		}
		for (var i = 0; i < nodes.length; i++) {
			this._outNode.connect(nodes[i]);
		}
	};

	/**
	 * Disconnect output of sound from audionodes
	 * @param {(Array<AudioNode>|AudioNode)} nodes
	 */
	Sound.prototype.disconnectFrom = function (nodes) {
		if (!nodes) {
			return;
		}
		if (!(nodes instanceof Array)) {
			nodes = [nodes];
		}
		for (var i = 0; i < nodes.length; i++) {
			this._outNode.disconnect(nodes[i]);
		}
	};

	/**
	 * Sets the audio buffer which will be the sound source
	 * @param {AudioBuffer} buffer
	 */
	Sound.prototype.setAudioBuffer = function (buffer) {
		this.setAudioStream(null);
		this._buffer = buffer;
		this._clampInterval();
	};

	Sound.prototype.setAudioStream = function (stream) {
		if (!stream) {
			if (this._streamSource) {
				this._streamSource.disconnect();
				this._streamSource = null;
			}
			return;
		}
		this.stop();
		this._stream = stream;
		this._streamSource = AudioContext.getContext().createMediaStreamSource(stream);
		this._streamSource.connect(this._outNode);
	};

	module.exports = Sound;

/***/ },
/* 336 */
/***/ function(module, exports, __webpack_require__) {

	var ConfigHandler = __webpack_require__(85);
	var ObjectUtils = __webpack_require__(6);
	var SystemBus = __webpack_require__(44);
	var ShaderBuilder = __webpack_require__(48);
	var Snow = __webpack_require__(337); // TODO Should move!
	var RSVP = __webpack_require__(55);

	var defaults = {
		backgroundColor: [0.3, 0.3, 0.3, 1],
		globalAmbient: [0, 0, 0],
		fog: {
			enabled: false,
			color: [1, 1, 1],
			near: 10,
			far: 1000
		}
	};
	var soundDefaults = {
		volume: 1,
		reverb: 0,
		rolloffFactor: 0.4,
		maxDistance: 100
	};

	/**
	 * Handling environments
	 * @param {World} world
	 * @param {Function} getConfig
	 * @param {Function} updateObject
	 * @private
	 */
	function EnvironmentHandler() {
		ConfigHandler.apply(this, arguments);
	}

	EnvironmentHandler.prototype = Object.create(ConfigHandler.prototype);
	EnvironmentHandler.prototype.constructor = EnvironmentHandler;
	ConfigHandler._registerClass('environment', EnvironmentHandler);

	EnvironmentHandler.prototype._prepare = function (config) {
		ObjectUtils.defaults(config, defaults);
	};

	EnvironmentHandler.prototype._create = function () {
		return {
			weatherState: {}
		};
	};

	EnvironmentHandler.prototype._remove = function (ref) {
		var object = this._objects.get(ref);
		this._objects.delete(ref);
		if (!object) {
			return;
		}

		// Remove weather
		for (var key in object.weatherState) {
			EnvironmentHandler.weatherHandlers[key].remove(object.weatherState);
		}

		// Reset environment
		SystemBus.emit('goo.setClearColor', defaults.backgroundColor);
		ShaderBuilder.CLEAR_COLOR = defaults.backgroundColor;
		ShaderBuilder.GLOBAL_AMBIENT = defaults.globalAmbient.slice(0, 3);
		ShaderBuilder.USE_FOG = defaults.fog.enabled;
		ShaderBuilder.FOG_COLOR = defaults.fog.color.slice(0, 3);
		ShaderBuilder.FOG_SETTINGS = [defaults.fog.near, defaults.fog.far];

		// Reset Sound
		var soundSystem = this.world.getSystem('SoundSystem');
		if (soundSystem) {
			soundSystem.updateConfig(soundDefaults);
			soundSystem.setReverb(null);
		}
	};

	/**
	 * Adds/updates/removes an environment
	 * @param {string} ref
	 * @param {Object} config
	 * @param {Object} options
	 * @returns {RSVP.Promise} Resolves with the updated environment or null if removed
	 */
	EnvironmentHandler.prototype._update = function (ref, config, options) {
		var that = this;
		return ConfigHandler.prototype._update.call(this, ref, config, options).then(function (object) {
			if (!object) { return; }

			var backgroundColor = config.backgroundColor;
			var alpha = backgroundColor[3];
			object.backgroundColor = [
				backgroundColor[0] * alpha,
				backgroundColor[1] * alpha,
				backgroundColor[2] * alpha,
				backgroundColor[3]
			];
			object.globalAmbient = config.globalAmbient.slice(0, 3);

			object.fog = ObjectUtils.deepClone(config.fog);

			// Background color
			SystemBus.emit('goo.setClearColor', object.backgroundColor);

			// Fog and ambient
			ShaderBuilder.CLEAR_COLOR = object.backgroundColor;
			ShaderBuilder.GLOBAL_AMBIENT = object.globalAmbient;
			ShaderBuilder.USE_FOG = object.fog.enabled;
			ShaderBuilder.FOG_COLOR = object.fog.color.slice(0, 3);
			ShaderBuilder.FOG_SETTINGS = [object.fog.near, config.fog.far];

			// Weather
			for (var key in config.weather) {
				var handler = EnvironmentHandler.weatherHandlers[key];
				if (handler) {
					handler.update.call(that, config.weather[key], object.weatherState);
				}
			}

			var promises = [];

			// Skybox
			if (config.skyboxRef) {
				EnvironmentHandler.currentSkyboxRef = config.skyboxRef;
				promises.push(that._load(config.skyboxRef, { reload: true }));
			} else if (EnvironmentHandler.currentSkyboxRef) {
				var p = that.updateObject(EnvironmentHandler.currentSkyboxRef, null)
				.then(function () {
					delete EnvironmentHandler.currentSkyboxRef;
				});
				promises.push(p);
			}

			// Sound
			var soundSystem = that.world.getSystem('SoundSystem');
			if (config.sound && soundSystem) {
				soundSystem.updateConfig(config.sound);
				if (config.sound.reverbRef) {
					var p = that._load(config.sound.reverbRef, options).then(function (sound) {
						soundSystem.setReverb(sound._buffer);
					});
					promises.push(p);
				} else {
					soundSystem.setReverb(null);
				}
			}
			return RSVP.all(promises).then(function () { return object; });
		});
	};


	EnvironmentHandler.weatherHandlers = {
		snow: {
			update: function (config, weatherState) {
				if (config.enabled) {
					if (!weatherState.snow || !weatherState.snow.enabled) {
						// add snow
						weatherState.snow = weatherState.snow || {};
						weatherState.snow.enabled = true;
						weatherState.snow.snow = new Snow(this.world.gooRunner);
					}

					weatherState.snow.snow.setEmissionVelocity(config.velocity);
					weatherState.snow.snow.setReleaseRatePerSecond(config.rate);
					weatherState.snow.snow.setEmissionHeight(config.height);
				} else if (weatherState.snow && weatherState.snow.enabled) {
					// remove snow
					weatherState.snow.snow.remove();
					weatherState.snow.enabled = false;
					delete weatherState.snow.snow;
				}
			},
			remove: function (weatherState) {
				if (weatherState.snow && weatherState.snow.snow) {
					weatherState.snow.snow.remove();
					weatherState.snow.enabled = false;
					delete weatherState.snow.snow;
				}
			}
		}
	};

	module.exports = EnvironmentHandler;

/***/ },
/* 337 */
/***/ function(module, exports, __webpack_require__) {

	var Material = __webpack_require__(30);
	var ShaderLib = __webpack_require__(46);
	var ParticleLib = __webpack_require__(209);
	var ParticleSystemUtils = __webpack_require__(210);
	var Renderer = __webpack_require__(123);
	var Vector3 = __webpack_require__(8);

	/**
	 * Snow
	 * @param {GooRunner} gooRunner
	 */
	function Snow(gooRunner) {
		this.velocity = 10;
		this.height = 25;

		// put this in some subroutine
		this.material = new Material(ShaderLib.particles);
		var texture = ParticleSystemUtils.createFlareTexture(64); //Snowflake
		texture.generateMipmaps = true;
		this.material.setTexture('DIFFUSE_MAP', texture);
		this.material.blendState.blending = 'AdditiveBlending';
		this.material.cullState.enabled = false;
		this.material.depthState.write = false;
		this.material.renderQueue = 2002;

		// actually needed
		var that = this;

		// and this too
		this.particleCloudEntity = ParticleSystemUtils.createParticleSystemEntity(
			gooRunner.world,
			ParticleLib.getSnow({
				getEmissionPoint: function (vec3) {
					// either camera or some predefined area

					// camera
					vec3.copy(Renderer.mainCamera ? Renderer.mainCamera.translation : new Vector3());
					vec3.x += Math.random() * 1000 - 500;
					vec3.y += that.height; // put higher than camera
					vec3.z += Math.random() * 1000 - 500;
				},
				getEmissionVelocity: function (vec3) {
					vec3.x = (Math.random() - 0.5) * 2;
					vec3.y = -(Math.random() + 1) * that.velocity;
					vec3.z = (Math.random() - 0.5) * 2;
				}
			}),
			this.material
		);
		this.particleCloudEntity.name = '_ParticleSystemSnow';

		this.onCameraChange = function (newCam) {
			newCam.entity.attachChild(this.particleCloudEntity);
		}.bind(this);

		this.particleCloudEntity.transformComponent.transform.translation.copy(Renderer.mainCamera ? Renderer.mainCamera.translation : new Vector3());

		this.particleCloudEntity.addToWorld();
		//SystemBus.addListener('goo.setCurrentCamera', this.onCameraChange);
	}

	Snow.prototype.setEmissionVelocity = function (velocity) {
		if (velocity) {
			this.velocity = velocity;

			// change velocity of all particles in the particle system
			// hack, but necessary for this particular situation
			var particleComponent = this.particleCloudEntity.particleComponent;
			var particles = particleComponent.particles;

			for (var i = 0; i < particles.length; i++) {
				particles[i].velocity.y = -(Math.random() + 1) * this.velocity; //this.velocity;
			}
		}
	};

	Snow.prototype.setEmissionHeight = function (height) {
		if (height) {
			this.height = height;
		}
	};

	Snow.prototype.setReleaseRatePerSecond = function (releaseRatePerSecond) {
		if (releaseRatePerSecond) {
			var particleComponent = this.particleCloudEntity.particleComponent;
			var emitter = particleComponent.emitters[0];
			emitter.releaseRatePerSecond = releaseRatePerSecond;
		}
	};

	Snow.prototype.remove = function () {
		//SystemBus.removeListener('goo.setCurrentCamera', this.onCameraChange);
		this.particleCloudEntity.removeFromWorld();
	};

	module.exports = Snow;


/***/ },
/* 338 */
/***/ function(module, exports, __webpack_require__) {

	var ConfigHandler = __webpack_require__(85);
	var EnvironmentHandler = __webpack_require__(336);
	var Texture = __webpack_require__(53);
	var ShaderBuilder = __webpack_require__(48);
	var Skybox = __webpack_require__(339);
	var RSVP = __webpack_require__(55);
	var PromiseUtils = __webpack_require__(54);
	var SystemBus = __webpack_require__(44);

	function SkyboxHandler() {
		ConfigHandler.apply(this, arguments);

		this._activeSkyboxRef = null;

		// Skybox entity
		var skybox = new Skybox('box', [], null, 0);
		this._skybox = this.world.createEntity(skybox.meshData, skybox.materials[0], skybox.transform);
		this._skybox.transformComponent.sync();
		this._skybox.isSkybox = true;
		this._skybox.name = 'Skybox_box';

		// Skybox texture
		this._skyboxTexture = new Texture(null, { flipY: false });
		this._skyboxTexture.variant = 'CUBE';
		this._skyboxTexture.wrapS = 'EdgeClamp';
		this._skyboxTexture.wrapT = 'EdgeClamp';
		this._skybox.meshRendererComponent.materials[0].setTexture('DIFFUSE_MAP', this._skyboxTexture);

		// Skysphere entity
		var skysphere = new Skybox('sphere', [], null, 0);
		this._skysphere = this.world.createEntity(skysphere.meshData, skysphere.materials[0], skysphere.transform);
		this._skysphere.transformComponent.sync();
		this._skysphere.isSkybox = true;
		this._skysphere.name = 'Skybox_sphere';

		// Skysphere texture
		this._skysphereTexture = new Texture(null, { flipY: false, wrapS: 'EdgeClamp', wrapT: 'EdgeClamp' });
		this._skysphere.meshRendererComponent.materials[0].setTexture('DIFFUSE_MAP', this._skysphereTexture);

		this._activeSkyshape = null;
	}

	SkyboxHandler.prototype = Object.create(ConfigHandler.prototype);
	SkyboxHandler.prototype.constructor = SkyboxHandler;
	ConfigHandler._registerClass('skybox', SkyboxHandler);

	SkyboxHandler.prototype._remove = function (ref) {
		this._objects.delete(ref);

		// We can only remove the skybox if it is the one that is currently
		// active. Otherwise the scene will be left with no skybox in cases
		// where it shouldn't be.
		if (this._activeSkyboxRef === ref) {
			this._hide(this._skybox);
			this._hide(this._skysphere);
			this._skyboxTexture.setImage(null);
			this._activeSkyshape = null;
			ShaderBuilder.SKYBOX = null;
			ShaderBuilder.SKYSPHERE = null;
			this._activeSkyboxRef = null;
		}
	};

	SkyboxHandler.prototype._create = function () {
		return {
			textures: [],
			enabled: false
		};
	};

	SkyboxHandler.prototype._update = function (ref, config, options) {
		var that = this;
		return ConfigHandler.prototype._update.call(this, ref, config, options).then(function (skybox) {
			if (!skybox) {
				return PromiseUtils.resolve([]);
			}

			var promises = [];
			if (config.box) {
				promises.push(that._updateBox(ref, config.box, options, skybox));
			}
			if (config.sphere) {
				promises.push(that._updateSphere(ref, config.sphere, options, skybox));
			}

			return RSVP.all(promises).then(function (skyboxes) {
				if (config.box || config.sphere) {
					that._activeSkyboxRef = ref;
				}

				return skyboxes;
			});
		});
	};

	SkyboxHandler.prototype._updateSphere = function (ref, config, options, skybox) {
		var that = this;

		if (config.sphereRef) {
			return this._load(config.sphereRef, options).then(function (texture) {
				if (!texture || !texture.image) {
					SystemBus.emit('goo.error.skybox', {
						type: 'Sphere',
						message: 'The skysphere needs an image to display.'
					});
					that._hide(that._skysphere);
					return;
				}

				// Check if skybox is the same
				if (texture === skybox.textures[0] && that._activeSkyshape === that._skysphere) {
					return that._skysphere;
				}

				if (ref === EnvironmentHandler.currentSkyboxRef && config.enabled) {
					var skyTex = that._skysphereTexture;
					skybox.textures = [texture];
					skyTex.setImage(texture.image);

					that._show(that._skysphere);
				} else if (!config.enabled) {
					that._hide(that._skysphere);
				}
				return that._skysphere;
			});
		} else {
			that._skysphereTexture.setImage(null);
			that._hide(that._skysphere);
		}
		return PromiseUtils.resolve(that._skysphere);
	};

	var sides = ['rightRef', 'leftRef', 'topRef', 'bottomRef', 'frontRef', 'backRef'];

	//! AT: this can definitely be moved elsewhere
	function isEqual(a, b) {
		var len = a.length;
		if (len !== b.length) {
			return false;
		}
		while (len--) {
			if (a[len] !== b[len]) {
				return false;
			}
		}
		return true;
	}


	SkyboxHandler.prototype._updateBox = function (ref, config, options, skybox) {
		var that = this;

		var promises = sides.map(function (side) {
			return config[side] ? that._load(config[side], options) : PromiseUtils.resolve();
		});

		// Load all textures
		return RSVP.all(promises).then(function (textures) {
			// Check if skybox is the same
			if (isEqual(textures, skybox.textures) && that._activeSkyshape === that._skybox) {
				return that._skybox;
			}

			var images = textures.map(function (texture) { return texture ? texture.image : null; });

			// If no textures were found, clear skybox and return
			if (images.filter(Boolean).length === 0) {
				that._skyboxTexture.setImage(null);
				that._hide(that._skybox);
				return that._skybox;
			}


			var w = 1;
			var h = 1;
			for (var i = 0; i < images.length; i++) {
				if (images[i]) {
					w = Math.max(w, images[i].width);
					h = Math.max(h, images[i].width);
				}
			}

			if (ref === EnvironmentHandler.currentSkyboxRef && config.enabled) {
				skybox.textures = textures;
				var skyTex = that._skyboxTexture;
				skyTex.setImage(images);
				skyTex.image.width = w;
				skyTex.image.height = h;
				skyTex.image.dataReady = true;
				skyTex.setNeedsUpdate();

				that._show(that._skybox);
			} else if (!config.enabled) {
				that._hide(that._skybox);
			}

			return that._skybox;
		});
	};

	SkyboxHandler.prototype._hide = function (skyshape) {
		var renderSystem = this.world.getSystem('RenderSystem');
		renderSystem.removed(skyshape);
		if (skyshape === this._skybox) {
			ShaderBuilder.SKYBOX = null;
		} else if (skyshape === this._skysphere) {
			ShaderBuilder.SKYSPHERE = null;
		}
	};

	SkyboxHandler.prototype._show = function (skyshape) {
		var renderSystem = this.world.getSystem('RenderSystem');
		if (this._activeSkyshape) {
			renderSystem.removed(this._activeSkyshape);
		}
		renderSystem.added(skyshape);
		this._activeSkyshape = skyshape;
		ShaderBuilder.SKYBOX = skyshape === this._skybox ? this._skyboxTexture : null;
		ShaderBuilder.SKYSPHERE = skyshape === this._skysphere ? this._skysphereTexture : null;
	};

	module.exports = SkyboxHandler;

/***/ },
/* 339 */
/***/ function(module, exports, __webpack_require__) {

	var Box = __webpack_require__(27);
	var Sphere = __webpack_require__(29);
	var MeshData = __webpack_require__(14);
	var Material = __webpack_require__(30);
	var Shader = __webpack_require__(31);
	var TextureCreator = __webpack_require__(125);
	var Transform = __webpack_require__(41);

	/**
	 * Skybox
	 * @param type
	 * @param images
	 * @param textureMode
	 * @param yRotation
	 */
	function Skybox(type, images, textureMode, yRotation) {
		var promise;
		if (type === Skybox.SPHERE) {
			this.meshData = new Sphere(16, 32, 1, textureMode || Sphere.TextureModes.Projected);
			if (images instanceof Array) {
				images = images[0];
			}
			if (images) {
				promise = new TextureCreator().loadTexture2D(images);
			}
		} else if (type === Skybox.BOX) {
			this.meshData = new Box(1, 1, 1);
			if (images.length) {
				promise = new TextureCreator().loadTextureCube(images, {
					flipY: false,
					wrapS: 'EdgeClamp',
					wrapT: 'EdgeClamp'
				});
			}
		} else {
			throw new Error('Unknown geometry type');
		}

		var material = new Material(shaders[type], 'Skybox material');
		material.cullState.cullFace = 'Front';
		material.depthState.enabled = false;
		material.renderQueue = 1;
		if (promise) {
			promise.then(function (texture) {
				material.setTexture(Shader.DIFFUSE_MAP, texture);
			});
		}

		this.materials = [material];

		this.transform = new Transform();
		var xAngle = (type === Skybox.SPHERE) ? Math.PI / 2 : 0;
		this.transform.rotation.fromAngles(xAngle, yRotation, 0);
		this.transform.update();

		this.active = true;
	}

	Skybox.SPHERE = 'sphere';
	Skybox.BOX = 'box';

	var shaders = {};
	shaders.box = {
		attributes: {
			vertexPosition: MeshData.POSITION
		},
		uniforms: {
			normalMatrix: Shader.NORMAL_MATRIX,
			viewMatrix: Shader.VIEW_MATRIX,
			projectionMatrix: Shader.PROJECTION_MATRIX,
			near: Shader.NEAR_PLANE,
			diffuseMap: Shader.DIFFUSE_MAP
		},
		vshader: [
			'attribute vec3 vertexPosition;',

			'uniform mat3 normalMatrix;',
			'uniform mat4 viewMatrix;',
			'uniform mat4 projectionMatrix;',
			'uniform float near;',

			'varying vec3 eyeVec;',

			'void main(void) {',
			'	eyeVec = vertexPosition * normalMatrix * near * 10.0;',
			'	vec3 worldPos = mat3(viewMatrix) * eyeVec;',
			'	gl_Position = projectionMatrix * vec4(worldPos, 1.0);',
			'}'
		].join('\n'),
		fshader: [
			'uniform samplerCube diffuseMap;',

			'varying vec3 eyeVec;',

			'void main(void) {',
			'	vec4 cube = textureCube(diffuseMap, eyeVec);',
			'	if (cube.a < 0.05) discard;',
			'	gl_FragColor = cube;',
			'}'
		].join('\n')
	};
	shaders.sphere = {
		attributes: {
			vertexPosition: MeshData.POSITION,
			vertexUV0: MeshData.TEXCOORD0
		},
		uniforms: {
			normalMatrix: Shader.NORMAL_MATRIX,
			viewMatrix: Shader.VIEW_MATRIX,
			projectionMatrix: Shader.PROJECTION_MATRIX,
			near: Shader.NEAR_PLANE,
			diffuseMap: Shader.DIFFUSE_MAP
		},
		vshader: [
			'attribute vec3 vertexPosition;',
			'attribute vec2 vertexUV0;',

			'uniform mat3 normalMatrix;',
			'uniform mat4 viewMatrix;',
			'uniform mat4 projectionMatrix;',
			'uniform float near;',

			'varying vec2 texCoord0;',

			'void main(void) {',
			'	texCoord0 = vertexUV0;',

			'	vec3 worldPos = mat3(viewMatrix) * normalMatrix * vertexPosition * near * 10.0;',
			'	gl_Position = projectionMatrix * vec4(worldPos, 1.0);',
			'}'
		].join('\n'),
		fshader: [
			'precision mediump float;',

			'uniform sampler2D diffuseMap;',

			'varying vec2 texCoord0;',

			'void main(void)',
			'{',
			'	vec4 sphere = texture2D(diffuseMap, texCoord0);',
			'	if (sphere.a < 0.05) discard;',
			'	gl_FragColor = sphere;',
			'}'
		].join('\n')
	};

	module.exports = Skybox;

/***/ },
/* 340 */
/***/ function(module, exports, __webpack_require__) {

	var ComponentHandler = __webpack_require__(88);
	var HtmlComponent = __webpack_require__(341);
	var RSVP = __webpack_require__(55);
	var PromiseUtils = __webpack_require__(54);

	'use strict';

	/**
	 * For handling loading of HTML components
	 * @param {World} world The goo world
	 * @param {Function} getConfig The config loader function. See {@see DynamicLoader._loadRef}.
	 * @param {Function} updateObject The handler function. See {@see DynamicLoader.update}.
	 * @extends ComponentHandler
	 * @hidden
	 */
	function HtmlComponentHandler() {
		ComponentHandler.apply(this, arguments);
		this._type = 'HtmlComponent';
	}

	HtmlComponentHandler.prototype = Object.create(ComponentHandler.prototype);
	ComponentHandler._registerClass('html', HtmlComponentHandler);
	HtmlComponentHandler.prototype.constructor = HtmlComponentHandler;

	/**
	 * Prepare component. Set defaults on config here.
	 * @param {Object} config
	 * @returns {Object}
	 * @private
	 */
	HtmlComponentHandler.prototype._prepare = function (/*config*/) {};

	/**
	 * Create camera component object.
	 * @param {Entity} entity The entity on which this component should be added.
	 * @returns {CameraComponent} the created component object
	 * @private
	 */
	HtmlComponentHandler.prototype._create = function () {
		return new HtmlComponent();
	};

	var regex = /\W/g;
	function getSafeEntityId(id) {
		// fancy chars (like '.') are allowed in ids in HTML but are not allowed in CSS
		return '__' + id.replace(regex, '-');
	}

	/**
	 * Update engine cameracomponent object based on the config.
	 * @param {Entity} entity The entity on which this component should be added.
	 * @param {Object} config
	 * @param {Object} options
	 * @returns {RSVP.Promise} promise that resolves with the component when loading is done.
	 */
	HtmlComponentHandler.prototype.update = function (entity, config, options) {
		var that = this;
		return ComponentHandler.prototype.update.call(this, entity, config, options).then(function (component) {
			if (!component) { return; }

			var domElement = component.domElement;
			if (!domElement) {
				domElement = component.domElement = that._createDomElement(entity, component);
				that._attachDomElement(domElement, entity);
			}

			component.useTransformComponent = config.useTransformComponent !== false;
			component.pixelPerfect = config.pixelPerfect !== undefined ? config.pixelPerfect : true;

			return that._updateHtml(domElement, entity, config, options)
			.then(function () {
				that._updateAttributes(domElement, entity, config);
				return component;
			});
		});
	};

	/**
	 * Creates a new dom element for the specified component.
	 *
	 * @param {Entity} entity
	 *        The entity to which the component belongs.
	 * @param {HtmlComponent} component
	 *        The HTML component whose DOM element is to be created.
	 *
	 * @return {Element}
	 *         The new dom element.
	 */
	HtmlComponentHandler.prototype._createDomElement = function (entity) {
		var domElement = document.createElement('div');

		// ids and classes can contain '.' or start with digits in html but not in css selectors
		// could have prefixed it with a simple '-' but that's sort of reserved for '-moz', '-webkit' and the like
		domElement.id = getSafeEntityId(entity.id);

		domElement.className = 'goo-entity';

		this._addMouseListeners(domElement, entity);
		this._addTouchListeners(domElement, entity);

		return domElement;
	};

	HtmlComponentHandler.prototype._addMouseListeners = function (domElement, entity) {
		var mouseListener = function (domEvent) {
			var gooRunner = entity._world.gooRunner;
			var evt = {
				entity: entity,
				depth: 0,
				x: domEvent.pageX,
				y: domEvent.pageY,
				domEvent: domEvent,
				id: entity.id,
				type: domEvent.type
			};
			gooRunner.triggerEvent(domEvent.type, evt);
		};
		domElement.addEventListener('mousedown', mouseListener);
		domElement.addEventListener('mouseup', mouseListener);
		domElement.addEventListener('click', mouseListener);
	};

	HtmlComponentHandler.prototype._addTouchListeners = function (domElement, entity) {
		var touchListener = function (domEvent) {
			var gooRunner = entity._world.gooRunner;
			var domTarget = gooRunner.renderer.domElement;

			var x = domEvent.changedTouches[0].pageX - domTarget.getBoundingClientRect().left;
			var y = domEvent.changedTouches[0].pageY - domTarget.getBoundingClientRect().top;

			var evt = {
				entity: entity,
				depth: 0,
				x: x,
				y: y,
				domEvent: domEvent,
				id: entity.id,
				type: domEvent.type
			};
			gooRunner.triggerEvent(domEvent.type, evt);
		};
		domElement.addEventListener('touchstart', touchListener);
		domElement.addEventListener('touchmove', touchListener);
		domElement.addEventListener('touchend', touchListener);
	};

	/**
	 * Attaches the specified element to the parent of the renderer's canvas.
	 *
	 * @param {Element} domElement
	 *        The dom element which is to be attached.
	 * @param {Entity} entity
	 *        The entity to which the HTML component belongs.
	 *
	 * @private
	 */
	HtmlComponentHandler.prototype._attachDomElement = function (domElement, entity) {
		var parentEl = entity._world.gooRunner.renderer.domElement.parentElement || document.body;
		parentEl.appendChild(domElement);
	};

	/**
	 * Updates the HTML content of the specified dom element based on the config.
	 *
	 * @param {Element} domElement
	 *        The html element which is to be updated.
	 * @param {Entity} entity
	 *        The entity to which the HTML component belongs.
	 * @param {object} config
	 *        The configuration of the component.
	 * @param {object} options
	 *        The options passed to the handler by the DynamicLoader.
	 *
	 * @return {Promise}
	 * @private
	 */
	HtmlComponentHandler.prototype._updateHtml = function (domElement, entity, config, options) {
		if (config.innerHtml === domElement.prevInnerHtml) {
			return PromiseUtils.resolve();
		}

		domElement.prevInnerHtml = config.innerHtml;
		domElement.innerHTML = config.innerHtml;

		return this._loadImages(domElement, options);
	};

	/**
	 * Loads all the images referenced in the HTML of the specified DOM element.
	 *
	 * @param {Element} domElement
	 *        The element whose images are to be loaded.
	 * @param {objects} options
	 *        Options passed to the handler by the DynamicLoader.
	 *
	 * @return {Promise}
	 * @private
	 */
	HtmlComponentHandler.prototype._loadImages = function (domElement, options) {
		var that = this;

		function loadImage(htmlImage) {
			var imageRef = htmlImage.getAttribute('data-id');
			if (!imageRef) { return PromiseUtils.resolve(); }

			return that.loadObject(imageRef, options)
			.then(function (image) {
				htmlImage.src = image.src;
				return htmlImage;
			}, function (e) {
				console.error(e);
				delete htmlImage.src;
				return htmlImage;
			});
		}

		var images = [].slice.apply(domElement.getElementsByTagName('IMG'));
		return RSVP.all(images.map(loadImage));
	};

	/**
	 * Sets all the attributes that are in the configuration (if any) on the
	 * specified dom element.
	 *
	 * @param {Element} domElement
	 *        The dom element on which the attributes are to be set.
	 * @param {object} config
	 *        The configuration object.
	 *
	 * @return {Promise}
	 * @private
	 */
	HtmlComponentHandler.prototype._updateAttributes = function (domElement, entity, config) {
		var i, attribute, attributeValue;
		var prevAttributes = domElement.prevAttributes || {};
		var prevAttributeNames = Object.keys(prevAttributes);

		var newAttributes = config.attributes || {};
		var newAttributeNames = Object.keys(newAttributes);

		// Remove old attributes that are not used anymore.
		for (i = 0; i < prevAttributeNames.length; ++i) {
			attribute = prevAttributeNames[i];
			if (newAttributes[attribute] === undefined) {
				domElement.removeAttribute(prevAttributeNames[i]);
			}
		}

		// Add new attributes that have changed.
		for (i = 0; i < newAttributeNames.length; ++i) {
			attribute = newAttributeNames[i];
			attributeValue = newAttributes[attribute];
			if (attributeValue !== prevAttributes[attribute]) {
				domElement.setAttribute(attribute, attributeValue);
			}
		}

		domElement.prevAttributes = config.attributes;

		// Set default styles if no style was set by the user.
		if (!newAttributes.style) {
			domElement.setAttribute('style', 'position: absolute; top: 0; left: 0; z-index: 1; display: none');
		}

		// Force the HTML system to update again.
		entity._world.getSystem('HtmlSystem').clearStyleCache(domElement);
	};

	HtmlComponentHandler.prototype._remove = function (entity) {
		var component = entity.htmlComponent;
		ComponentHandler.prototype._remove.call(this, entity);
		if (component.domElement) {
			component.domElement.parentNode.removeChild(component.domElement);
		}
	};

	module.exports = HtmlComponentHandler;


/***/ },
/* 341 */
/***/ function(module, exports, __webpack_require__) {

	var Component = __webpack_require__(20);

	/**
	 * Adds a 2D DOM element to the entity, that can move with its transform.
	 * @extends Component
	 * @param {DOMElement} domElement
	 * @param {object} [options]
	 * @param {boolean} [options.hidden=false]
	 * @param {boolean} [options.useTransformComponent=true]
	 * @param {boolean} [options.pixelPerfect=true]
	 * @example-link http://code.gooengine.com/latest/visual-test/goo/entities/components/HTMLComponent/HTMLComponent-vtest.html Working example
	 */
	function HtmlComponent(domElement, options) {
		options = options || {};
		Component.apply(this, arguments);

		this.type = 'HtmlComponent';

		/**
		 * DOM element.
		 */
		this.domElement = domElement;

		/**
		 * @type {boolean}
		 */
		this.hidden = options.hidden !== undefined ? options.hidden : false;

		/**
		 * Move with the screen position of the entity.
		 * @type {boolean}
		 */
		this.useTransformComponent = options.useTransformComponent !== undefined ? options.useTransformComponent : true;

		/**
		 * Snap to integer pixel positions.
		 * @type {boolean}
		 */
		this.pixelPerfect = options.pixelPerfect !== undefined ? options.pixelPerfect : true;

		// @ifdef DEBUG
		Object.seal(this);
		// @endif
	}

	HtmlComponent.type = 'HtmlComponent';

	HtmlComponent.prototype = Object.create(Component.prototype);
	HtmlComponent.prototype.constructor = HtmlComponent;

	module.exports = HtmlComponent;


/***/ },
/* 342 */
/***/ function(module, exports, __webpack_require__) {

	var Entity = __webpack_require__(35);
	var MeshBuilder = __webpack_require__(112);
	var Transform = __webpack_require__(41);
	var Vector3 = __webpack_require__(8);
	var BoundingBox = __webpack_require__(7);
	var BoundingSphere = __webpack_require__(13);

	/**
	 * Runs a mesh combine optimization on the whole scene, based on
	 * material, components etc
	 * @param {World} gooWorld An instance of a goo.world object
	 * @param {number} [gridCount=1] Number of grid segments to split the world in during combine
	 * @param {boolean} [removeOldData=true] Remove old data which is now unused after combining
	 * @param {boolean} [keepEntities=false] Keep all entities even if they are unused after combine
	 */
	function EntityCombiner(gooWorld, gridCount, removeOldData, keepEntities) {
		this.world = gooWorld;
		this.gridCount = gridCount || 1;
		this.gridSize = 1;
		this.removeOldData = removeOldData !== undefined ? removeOldData : true;
		this.keepEntities = keepEntities !== undefined ? keepEntities : false;
		this.createdEntities = [];
	}

	/**
	 * Runs the combiner
	 */
	EntityCombiner.prototype.combine = function () {
		this.world.processEntityChanges();
		this.world.getSystem('TransformSystem')._process();
		this.world.getSystem('BoundingUpdateSystem')._process();

		var topEntities = this.world.entityManager.getTopEntities();
		if (this.gridSize > 1) {
			this.gridSize = this._calculateBounds(topEntities) / this.gridCount;
		}
		this._combineList(topEntities);
	};

	EntityCombiner.prototype._combineList = function (entities) {
		var root = entities;
		this.createdEntities = [];
		if (entities instanceof Entity === true) {
			root = [entities];
		}

		var baseSubs = new Map();
		var subs = [];
		for (var i = 0; i < root.length; i++) {
			this._buildSubs(root[i], baseSubs, subs);
		}
		if (subs.length > 1) {
			root = this.world.createEntity('RootCombined').addToWorld();
			baseSubs.set(root, subs);
		}

		var that = this;
		baseSubs.forEach(function (combineList, entity) {
			if (combineList.length > 0) {
				that._combine(entity, combineList);
			}
		});
	};

	EntityCombiner.prototype._buildSubs = function (entity, baseSubs, subs) {
		if (entity._hidden || entity.skip || entity.animationComponent || entity.particleComponent) {
			return;
		}

		// Non static entities become roots in the tree of combined ones so one can have statics under a moving node that combines but you can still move the parent node.
		if (!subs || entity.static === false) {
			subs = [];
			baseSubs.set(entity, subs);
		}

		if (entity.static && entity.meshDataComponent && entity.meshRendererComponent &&
			entity.meshRendererComponent.worldBound) {
			subs.push(entity);
		}

		for (var i = 0; i < entity.transformComponent.children.length; i++) {
			var child = entity.transformComponent.children[i];
			this._buildSubs(child.entity, baseSubs, subs);
		}
	};

	EntityCombiner.prototype._combine = function (root, combineList) {
		var rootTransform = root.transformComponent.sync().worldTransform;
		var invertTransform = new Transform();
		var calcTransform = new Transform();
		rootTransform.invert(invertTransform);

		var entities = new Map();
		for (var i = 0; i < combineList.length; i++) {
			var entity = combineList[i];

			var key = entity.meshRendererComponent.materials[0];

			var attributeMap = entity.meshDataComponent.meshData.attributeMap;
			var key2 = Object.keys(attributeMap);
			key2.sort();
			key2 = key2.join('_');

			if (this.gridSize > 1) {
				var xBucket = entity.meshRendererComponent.worldBound.center.x / this.gridSize;
				var zBucket = entity.meshRendererComponent.worldBound.center.z / this.gridSize;
				key2 = key2 + '_' + Math.round(xBucket) + '_' + Math.round(zBucket);
			}

			var set = entities.get(key);
			if (!set) {
				set = new Map();
				entities.set(key, set);
			}
			var set2 = set.get(key2);
			if (!set2) {
				set2 = [];
				set.set(key2, set2);
			}

			set2.push(entity);
		}

		var that = this;
		entities.forEach(function (entities2, material) {
			entities2.forEach(function (toCombine) {
				if (toCombine.length === 1) {
					return;
				}

				var meshBuilder = new MeshBuilder();
				for (var k = 0; k < toCombine.length; k++) {
					var entity = toCombine[k];

					if (root !== entity) {
						calcTransform.multiply(invertTransform, entity.transformComponent.sync().worldTransform);
					} else {
						calcTransform.setIdentity();
					}

					meshBuilder.addMeshData(entity.meshDataComponent.meshData, calcTransform);

					if (that.removeOldData) {
						entity.clearComponent('meshDataComponent');
						entity.clearComponent('meshRendererComponent');

						// Remove empty leaf children
						if (!that.keepEntities && entity._components.length === 1 && entity.transformComponent.children.length === 0) {
							entity.removeFromWorld();
						}
					} else {
						entity.skip = true;
						entity._hidden = true;
					}
				}
				var meshDatas = meshBuilder.build();

				for (var key in meshDatas) {
					var entity = that.world.createEntity(meshDatas[key], material);
					entity.addToWorld();
					root.attachChild(entity);
					that.createdEntities.push(entity);
				}
			});
		});
	};

	EntityCombiner.prototype._calculateBounds = function (entities) {
		var first = true;
		var wb = new BoundingBox();
		for (var i = 0; i < entities.length; i++) {
			var rootEntity = entities[i];
			rootEntity.traverse(function (entity) {
				if (entity.meshRendererComponent && !entity.particleComponent) {
					if (first) {
						var bound = entity.meshRendererComponent.worldBound;
						if (bound instanceof BoundingBox) {
							wb.copy(bound);
						} else if (bound instanceof BoundingSphere) {
							wb.center.set(bound.center);
							wb.xExtent = wb.yExtent = wb.zExtent = bound.radius;
						} else {
							wb.center.set(Vector3.ZERO);
							wb.xExtent = wb.yExtent = wb.zExtent = 10;
						}

						first = false;
					} else {
						wb.merge(entity.meshRendererComponent.worldBound);
					}
				}
			});
		}
		return Math.max(wb.xExtent, wb.zExtent) * 2.0;
	};

	EntityCombiner.prototype.cleanup = function () {
		for (var i = 0; i < this.createdEntities.length; i++) {
			var entity = this.createdEntities[i];

			entity.removeFromWorld();

			entity.parent().each(function (parent) {
				parent.detachChild(entity);
			});
		}
	};

	module.exports = EntityCombiner;

/***/ },
/* 343 */
/***/ function(module, exports, __webpack_require__) {

	var FullscreenUtils = __webpack_require__(136);

	/**
	 * Fullscreen-related utilities
	 * @target-class FullscreenUtil FullscreenUtil constructor
	 * @require-pathvar FullscreenUtil = require('../../renderer/pass/FullscreenUtil');
	 * @group renderer/pass
	 * @deprecated Deprecated as of 0.14.x and scheduled for removal in 0.16.0; The class has been renamed to `goo/util/FullscreenUtils`
	 */
	module.exports = FullscreenUtils;

/***/ },
/* 344 */
/***/ function(module, exports, __webpack_require__) {

	var World = __webpack_require__(34);
	var Renderer = __webpack_require__(123);
	var TransformSystem = __webpack_require__(345);
	var RenderSystem = __webpack_require__(346);
	var BoundingUpdateSystem = __webpack_require__(307);
	var ScriptSystem = __webpack_require__(348);
	var LightingSystem = __webpack_require__(349);
	var CameraSystem = __webpack_require__(310);
	var ParticlesSystem = __webpack_require__(350);
	var Stats = __webpack_require__(351);
	var AudioContext = __webpack_require__(305);
	var SoundSystem = __webpack_require__(352);
	var TransformComponent = __webpack_require__(40);
	var MeshDataComponent = __webpack_require__(216);
	var MeshRendererComponent = __webpack_require__(215);
	var CameraComponent = __webpack_require__(308);
	var LightComponent = __webpack_require__(194);
	var ScriptComponent = __webpack_require__(353);
	var GameUtils = __webpack_require__(221);
	var Logo = __webpack_require__(354);
	var SystemBus = __webpack_require__(44);
	var Material = __webpack_require__(30);

	/**
	 * The main class that updates the world and calls the renderers.
	 * See [this engine overview article]{@link http://www.gootechnologies.com/learn/tutorials/engine/engine-overview/} for more info.
	 *
	 * @param {Object} [parameters] GooRunner settings passed in a JSON object
	 * @param {boolean} [parameters.alpha=false] Specifies if the canvas should have an alpha channel or not.
	 * @param {boolean} [parameters.premultipliedAlpha=true] Enables or disables premultiplication of color by alpha
	 * @param {boolean} [parameters.antialias=true] Specifies if antialiasing should be turned on or no
	 * @param {boolean} [parameters.stencil=false] Enables the stencil buffer
	 * @param {boolean} [parameters.preserveDrawingBuffer=false] By default the drawing buffer will be cleared after it is presented to the HTML compositor. Enable this option to not clear the drawing buffer
	 * @param {HTMLCanvasElement}  [parameters.canvas] If not supplied, Renderer will create a new canvas
	 * @param {boolean} [parameters.showStats=false] If enabled a small stats widget showing stats will be displayed
	 * @param {boolean} [parameters.useDevicePixelRatio=false] Take into account the device pixel ratio (for retina screens etc)
	 * @param {boolean} [parameters.manuallyStartGameLoop=false] By default the 'game loop' will start automatically. Enable this option to manually start the game loop at any time
	 * @param {(boolean | string | { position, color })} [parameters.logo='topright'] Specifies whether the Goo logo is visible or not and where should and be placed and what color should it have.
	 * If the parameter is not specified then the logo is placed in the top right corner.
	 * If no logo is desired then this parameter should have the 'false' value.
	 * If the supplied parameter is one of the following: 'topleft', 'topright', 'bottomleft', 'bottomright' then the logo will be positioned in the according corner
	 * If the parameter is of type object then the logo will be positioned according to the 'position' key and will be colored according to the 'color' key
	 * @param {boolean} [parameters.tpfSmoothingCount=10] Specifies the amount of previous frames to use when computing the 'time per frame'
	 * @param {boolean} [parameters.debugKeys=false] If enabled the hotkeys Shift+[1..6] will be enabled
	 * @param {boolean} [parameters.useTryCatch=true]
	 */
	function GooRunner(parameters) {
		parameters = parameters || {};

		GameUtils.initAllShims();

		/**
		 * The Goo world.
		 * @type {World}
		 */
		this.world = new World({
			gooRunner: this,
			tpfSmoothingCount: parameters.tpfSmoothingCount
		});

		/**
		 * Automatically created renderer.
		 * @type {Renderer}
		 */
		this.renderer = new Renderer(parameters);

		/**
		 * Set to true to run user-defined callbacks within try/catch statements. Errors will be printed to console.
		 * @type {boolean}
		 * @default true
		 */
		this.useTryCatch = parameters.useTryCatch !== undefined ? parameters.useTryCatch : true;

		this._setBaseSystems();
		this._registerBaseComponents();

		this.doProcess = true;
		this.doRender = true;

		if (parameters.showStats) {
			this.addStats();
		}
		if (parameters.logo === undefined || parameters.logo) {
			var logoDiv = this._buildLogo(parameters.logo);
			if (logoDiv) {
				document.body.appendChild(logoDiv);
			}
		}

		/**
		 * A list of callbacks to call every frame, before the world is processed.
		 * @type {Array<function (tpf: number)>}
		 */
		this.callbacksPreProcess = [];

		/**
		 * A list of callbacks to call every frame, after the world is processed and before the rendering is done.
		 * @type {Array<function (tpf: number)>}
		 */
		this.callbacksPreRender = [];

		/**
		 * A list of callbacks to call every frame, after the rendering is done.
		 * @type {Array<function (tpf: number)>}
		 */
		this.callbacks = [];

		/**
		 * A list of callbacks to call once, in the following frame, before the world is processed.
		 * @example-link http://code.gooengine.com/latest/visual-test/goo/entities/CallbacksNextFrame/CallbacksNextFrame-vtest.html Working example
		 * @type {Array<function (tpf: number)>}
		 */
		this.callbacksNextFrame = [];

		this._takeSnapshots = [];

		this.start = -1;

		this.animationId = 0;
		if (!parameters.manuallyStartGameLoop) {
			this.startGameLoop();
		}

		if (parameters.debugKeys) {
			this._addDebugKeys();
		}

		// Event stuff
		this._events = {
			click: null,
			mousedown: null,
			mouseup: null,
			mousemove: null,
			touchstart: null,
			touchend: null,
			touchmove: null
		};
		this._eventListeners = {
			click: [],
			mousedown: [],
			mouseup: [],
			mousemove: [],
			touchstart: [],
			touchend: [],
			touchmove: []
		};
		this._eventTriggered = {
			click: null,
			mousedown: null,
			mouseup: null,
			mousemove: null,
			touchstart: null,
			touchend: null,
			touchmove: null
		};

		GameUtils.addVisibilityChangeListener(function (paused) {
			if (paused) {
				this._stopGameLoop();
			} else {
				if (!this.manuallyPaused) {
					this._startGameLoop();
				}
			}
		}.bind(this));

		this._picking = {
			x: 0,
			y: 0,
			skipUpdateBuffer: false,
			doPick: false,
			pickingCallback: null,
			pickingStore: {},
			clearColorStore: [] //! AT: why is this an array and not a vector4?
		};

		this.manuallyPaused = !!parameters.manuallyStartGameLoop;

		this._setupContextLost();
	}

	GooRunner.prototype._setupContextLost = function () {
		SystemBus.addListener('goo.contextLost', function () {
			for (var i = 0; i < this.renderSystems.length; i++) {
				var renderSystem = this.renderSystems[i];
				if (renderSystem.invalidateHandles) {
					renderSystem.invalidateHandles(this.renderer);
				}
			}

			// invalidate shadow-related webgl resources
			var lightingSystem = this.world.getSystem('LightingSystem');
			if (lightingSystem) {
				lightingSystem.invalidateHandles(this.renderer);
			}

			if (this.renderer.shadowHandler) {
				this.renderer.shadowHandler.invalidateHandles(this.renderer);
			}

			this.renderer.invalidatePicking();

			this.stopGameLoop();
		}.bind(this));

		SystemBus.addListener('goo.contextRestored', function () {
			this.startGameLoop();
		}.bind(this));
	};

	/**
	 * Sets the base systems on the world.
	 * @private
	 */
	GooRunner.prototype._setBaseSystems = function () {
		this.world.setSystem(new ScriptSystem(this.world));
		this.world.setSystem(new TransformSystem());
		this.world.setSystem(new CameraSystem());
		this.world.setSystem(new ParticlesSystem());
		this.world.setSystem(new BoundingUpdateSystem());
		this.world.setSystem(new LightingSystem());

		if (AudioContext.isSupported()) {
			this.world.setSystem(new SoundSystem());
		}

		this.renderSystem = new RenderSystem();
		this.renderSystems = [this.renderSystem];
		this.world.setSystem(this.renderSystem);
	};

	/**
	 * Registers the base components so that methods like Entity.prototype.set can work.
	 * @private
	 */
	GooRunner.prototype._registerBaseComponents = function () {
		this.world.registerComponent(TransformComponent);
		this.world.registerComponent(MeshDataComponent);
		this.world.registerComponent(MeshRendererComponent);
		this.world.registerComponent(CameraComponent);
		this.world.registerComponent(LightComponent);
		this.world.registerComponent(ScriptComponent);
	};

	/**
	 * Wrapper function for _updateFrame; called by requestAnimationFrame
	 * @private
	 * @param time
	 */
	GooRunner.prototype.run = function (time) {
		if (this.useTryCatch) {
			this._callSafe(this._updateFrame, time);
		} else {
			this._updateFrame(time);
		}
	};

	/**
	 * Calls a function and catches any error
	 * @private
	 */
	GooRunner.prototype._callSafe = function (func) {
		try {
			func.apply(this, Array.prototype.slice.call(arguments, 1));
		} catch (error) {
			if (error instanceof Error) {
				console.error(error.stack);
			} else {
				console.log(error);
			}
		}
	};

	/**
	 * Add a render system to the world
	 * @private
	 * @param system
	 * @param idx
	 */
	//! AT: private until priorities get added to render systems as 'idx' is very unflexibile
	GooRunner.prototype.setRenderSystem = function (system, idx) {
		this.world.setSystem(system);
		if (idx !== undefined) {
			this.renderSystems.splice(idx, 0, system);
		} else {
			this.renderSystems.push(system);
		}
	};

	GooRunner.prototype._updateFrame = function (time) {
		if (this.start < 0) {
			this.start = time;
		}

		var tpf = (time - this.start) / 1000.0;

		if (tpf < 0) { // skip a loop - original start time probably bad.
			this.start = time;
			this.animationId = window.requestAnimationFrame(this.run.bind(this));
			return;
		}

		this.start = time;

		// execute callbacks
		//! AT: doing this to be able to schedule new callbacks from the existing callbacks
		if (this.callbacksNextFrame.length > 0) {
			var callbacksNextFrame = this.callbacksNextFrame;
			this.callbacksNextFrame = [];
			if (this.useTryCatch) {
				for (var i = 0; i < callbacksNextFrame.length; i++) {
					var callback = callbacksNextFrame[i];
					this._callSafe(callback, tpf);
				}
			} else {
				for (var i = 0; i < callbacksNextFrame.length; i++) {
					var callback = callbacksNextFrame[i];
					callback(tpf);
				}
			}
		}

		if (this.useTryCatch) {
			for (var i = 0; i < this.callbacksPreProcess.length; i++) {
				var callback = this.callbacksPreProcess[i];
				this._callSafe(callback, tpf);
			}
		} else {
			for (var i = 0; i < this.callbacksPreProcess.length; i++) {
				var callback = this.callbacksPreProcess[i];
				callback(tpf);
			}
		}

		// process the world
		if (this.doProcess) {
			this.world.update(tpf);
		}

		this.renderer.info.reset();

		if (this.doRender) {
			this.renderer.checkResize(Renderer.mainCamera);
			this.renderer.setRenderTarget();
			//this.renderer.clear();

			this.world.onPreRender();

			// run the prerender callbacks
			for (var i = 0; i < this.callbacksPreRender.length; i++) {
				this.callbacksPreRender[i](tpf);
			}

			// run all the renderers
			for (var i = 0; i < this.renderSystems.length; i++) {
				if (!this.renderSystems[i].passive) {
					this.renderSystems[i].render(this.renderer);
				}
			}
			// handle pick requests
			if (this._picking.doPick && Renderer.mainCamera) {
				var clearColor = this.renderer.clearColor;
				this._picking.clearColorStore[0] = clearColor.r;
				this._picking.clearColorStore[1] = clearColor.g;
				this._picking.clearColorStore[2] = clearColor.b;
				this._picking.clearColorStore[3] = clearColor.a;
				this.renderer.setClearColor(0, 0, 0, 1);

				for (var i = 0; i < this.renderSystems.length; i++) {
					if (this.renderSystems[i].renderToPick && !this.renderSystems[i].passive) {
						this.renderSystems[i].renderToPick(this.renderer, this._picking.skipUpdateBuffer);
					}
				}
				this.renderer.pick(this._picking.x, this._picking.y, this._picking.pickingStore, Renderer.mainCamera);
				if (this.useTryCatch) {
					this._callSafe(this._picking.pickingCallback, this._picking.pickingStore.id, this._picking.pickingStore.depth);
				} else {
					this._picking.pickingCallback(this._picking.pickingStore.id, this._picking.pickingStore.depth);
				}
				this._picking.doPick = false;

				this.renderer.setClearColor.apply(this.renderer, this._picking.clearColorStore);
			}

			this.world.onPostRender();
		}

		// run the post render callbacks
		if (this.useTryCatch) {
			for (var i = 0; i < this.callbacks.length; i++) {
				var callback = this.callbacks[i];
				this._callSafe(callback, tpf);
			}
		} else {
			for (var i = 0; i < this.callbacks.length; i++) {
				var callback = this.callbacks[i];
				callback(tpf);
			}
		}

		// update the stats if there are any
		if (this.stats) {
			this.stats.update(
				this.renderer.info.toString() + '<br>' +
				'Transforms: ' + this.world.getSystem('TransformSystem').numUpdates +
				'<br>Cached shaders: ' + this.renderer.rendererRecord.shaderCache.size
			);
		}

		// resolve any snapshot requests
		if (this._takeSnapshots.length) {
			var image = this.renderer.domElement.toDataURL();
			if (this.useTryCatch) {
				for (var i = this._takeSnapshots.length - 1; i >= 0; i--) {
					var callback = this._takeSnapshots[i];
					this._callSafe(callback, image);
				}
			} else {
				for (var i = this._takeSnapshots.length - 1; i >= 0; i--) {
					var callback = this._takeSnapshots[i];
					callback(image);
				}
			}
			this._takeSnapshots = [];
		}

		// schedule next frame
		if (this.animationId) {
			this.animationId = window.requestAnimationFrame(this.run.bind(this));
		}
	};

	//TODO: move this to Logo
	GooRunner.prototype._buildLogo = function (settings) {
		var div = document.createElement('div');

		var color = settings && settings.color ? settings.color : Logo.white;

		var svg = Logo.getLogo({
			width: '70px',
			height: '50px',
			color: color
		});
		if (svg === '') {
			return;
		}

		div.innerHTML = '<a style="text-decoration: none;" href="http://www.goocreate.com" target="_blank">' + svg + '</a>';
		div.style.position = 'absolute';
		div.style.zIndex = '2000';

		if (!settings) {
			div.style.top = '10px';
			div.style.right = '10px';
		} else if (settings === 'topright' || settings.position === 'topright') {
			div.style.top = '10px';
			div.style.right = '10px';
		} else if (settings === 'topleft' || settings.position === 'topleft') {
			div.style.top = '10px';
			div.style.left = '10px';
		} else if (settings === 'bottomright' || settings.position === 'bottomright') {
			div.style.bottom = '10px';
			div.style.right = '10px';
		} else {
			div.style.bottom = '10px';
			div.style.left = '10px';
		}

		div.id = 'goologo';
		div.style.webkitTouchCallout = 'none';
		div.style.webkitUserSelect = 'none';
		div.style.khtmlUserSelect = 'none';
		div.style.mozUserSelect = 'none';
		div.style.msUserSelect = 'none';
		div.style.userSelect = 'none';
		div.ondragstart = function () {
			return false;
		};

		return div;
	};

	/**
	 * Enable misc debug configurations for inspecting aspects of the scene on hotkeys.
	 * @private
	 */
	GooRunner.prototype._addDebugKeys = function () {
		// shift+space = toggle fullscreen
		// shift+enter = toggle mouselock
		// shift+1 = normal rendering
		// shift+2 = show normals
		// shift+3 = simple lit
		// shift+4 = color
		// shift+5 = wireframe
		// shift+6 = flat
		// shift+7 = textured
		// shift+8 = regular material + wireframe
		// shift+click = log picked entity
		var ACTIVE_KEY = 'shiftKey';

		var modesByKeyCode = {
			50: 'normals',
			222: 'normals',
			51: 'lit',
			52: 'color',
			53: 'wireframe',
			54: 'flat',
			55: 'texture',
			191: 'texture',
			56: '+wireframe'
		};

		document.addEventListener('keydown', function (event) {
			if (!event[ACTIVE_KEY]) { return; }

			switch (event.which) {
				case 32: // Space
					GameUtils.toggleFullScreen();
					break;
				case 13: // Enter
					GameUtils.togglePointerLock();
					break;
				case 49: // 1
					this.renderSystem.setDebugMaterial();
					break;
				default:
					if (modesByKeyCode[event.which]) {
						this.renderSystem.setDebugMaterial(modesByKeyCode[event.which]);
					}
			}
		}.bind(this), false);

		document.addEventListener('mousedown', function (event) {
			if (event[ACTIVE_KEY]) {
				var x = event.clientX;
				var y = event.clientY;
				this.pick(x, y, function (id, depth) {
					var entity = this.world.entityManager.getEntityById(id);
					console.log('Picked entity:', entity, 'At depth:', depth);
				}.bind(this));
			}
		}.bind(this), false);
	};

	/**
	 * Adds an event listener to the GooRunner.
	 * @example-link http://code.gooengine.com/latest/visual-test/goo/misc/PickingEvents/PickingEvents-vtest.html Working example
	 * @param {string} type Can currently be 'click', 'mousedown', 'mousemove', 'mouseup',
	 * 'touchstart', 'touchend' or 'touchmove'.
	 * @param  {function (event)} callback Callback function.
	 * @param {Entity} callback.event.entity Picked entity, undefined if no entity is picked.
	 * @param {Vector3} callback.event.intersection Point of pick ray intersection with scene.
	 * @param {number} callback.event.depth Depth of pick ray intersection.
	 * @param {number} callback.event.x Canvas x coordinate.
	 * @param {number} callback.event.y Canvas y coordinate.
	 * @param {string} callback.event.type Type of triggered event ('mousedown', 'touchstart', etc).
	 * @param {Event} callback.event.domEvent Original DOM event.
	 * @param {number} callback.event.id Entity pick ID. -1 if no entity was picked.
	 * @example
	 * gooRunner.addEventListener('mousedown', function (event) {
	 *   if (event.entity) {
	 *     console.log('clicked entity', event.entity.name);
	 *     console.log('clicked point', event.intersection);
	 *   }
	 * });
	 */
	GooRunner.prototype.addEventListener = function (type, callback) {
		if (!this._eventListeners[type] || this._eventListeners[type].indexOf(callback) > -1) {
			return;
		}

		if (typeof callback === 'function') {
			this._eventListeners[type].push(callback);
			if (this._eventListeners[type].length === 1) {
				this._enableEvent(type);
			}
		}
	};

	/**
	 * Removes an event listener from the GooRunner.
	 * @param {string} type Can currently be 'click', 'mousedown', 'mousemove', 'mouseup',
	 * 'touchstart', 'touchend' or 'touchmove'.
	 * @param {function (event)} callback Callback to remove from event listener.
	 */
	GooRunner.prototype.removeEventListener = function (type, callback) {
		if (!this._eventListeners[type]) {
			return;
		}
		var index = this._eventListeners[type].indexOf(callback);
		if (index > -1) {
			this._eventListeners[type].splice(index, 1);
		}
		if (this._eventListeners[type].length === 0) {
			this._disableEvent(type);
		}
	};

	/**
	 * Triggers an event on the GooRunner (force).
	 * @param {string} type Can currently be 'click', 'mousedown', 'mousemove', 'mouseup',
	 * 'touchstart', 'touchend' or 'touchmove'.
	 * @param {Object} evt The GooRunner-style event
	 * @param {Entity} evt.entity Event entity.
	 * @param {number} evt.x Event canvas X coordinate.
	 * @param {number} evt.y Event canvas Y coordinate.
	 * @param {Event} evt.domEvent The original DOM event.
	 */
	GooRunner.prototype.triggerEvent = function (type, evt) {
		evt.type = type;
		this._eventTriggered[type] = evt.domEvent;
		this._dispatchEvent(evt);
		SystemBus.emit('goo.trigger.' + type, evt);
	};


	GooRunner.prototype._dispatchEvent = function (evt) {
		var types = Object.keys(this._eventTriggered);
		for (var i = 0; i < types.length; i++) {
			var type = types[i];
			if (this._eventTriggered[type] && this._eventListeners[type]) {
				var e = {
					entity: evt.entity,
					depth: evt.depth,
					x: evt.x,
					y: evt.y,
					type: type,
					domEvent: this._eventTriggered[type],
					id: evt.id,
					intersection: evt.intersection
				};
				try {
					for (var j = 0; j < this._eventListeners[type].length; j++) {
						if (this._eventListeners[type][j](e) === false) {
							break;
						}
					}
				} catch (err) {
					console.error(err);
				}
				this._eventTriggered[type] = null;
			}
		}
	};

	/**
	 * Enables event listening on the GooRunner
	 * @param {string} type Can currently be 'click', 'mousedown', 'mousemove',
	 * 'touchstart', 'touchend' or 'touchmove'.
	 * @private
	 */
	GooRunner.prototype._enableEvent = function (type) {
		if (this._events[type]) {
			return;
		}
		var func = function (e) {
			var x, y;
			if (e.type === 'touchstart' || e.type === 'touchend' || e.type === 'touchmove') {
				x = e.changedTouches[0].pageX - e.changedTouches[0].target.getBoundingClientRect().left;
				y = e.changedTouches[0].pageY - e.changedTouches[0].target.getBoundingClientRect().top;
			} else {
				var target = e.target || e.srcElement;
				var rect = target.getBoundingClientRect();
				x = e.clientX - rect.left;
				y = e.clientY - rect.top;
			}
			this._eventTriggered[type] = e;
			this.pick(x, y, function (index, depth) {
				var dpx = this.renderer.devicePixelRatio;
				var entity = this.world.entityManager.getEntityByIndex(index);
				var intersection = Renderer.mainCamera.getWorldPosition(x * dpx, y * dpx, this.renderer.viewportWidth, this.renderer.viewportHeight, depth);
				this._dispatchEvent({
					entity: entity,
					depth: depth,
					x: x,
					y: y,
					id: index,
					intersection: intersection
				});
			}.bind(this));
		}.bind(this);
		this.renderer.domElement.addEventListener(type, func);
		this._events[type] = func;
	};

	/**
	 * Disables event listening on the GooRunner
	 * @param {string} type Can currently be 'click', 'mousedown', 'mousemove',
	 * 'touchstart', 'touchend' or 'touchmove'.
	 * @private
	 */
	GooRunner.prototype._disableEvent = function (type) {
		if (this._events[type]) {
			this.renderer.domElement.removeEventListener(type, this._events[type]);
		}
		this._events[type] = null;
	};

	/**
	 * The method that actually starts the game loop
	 * @private
	 */
	GooRunner.prototype._startGameLoop = function () {
		if (!this.animationId) {
			this.start = -1;
			this.animationId = window.requestAnimationFrame(this.run.bind(this));
		}
	};

	/**
	 * Starts the game loop (done through requestAnimationFrame).
	 */
	GooRunner.prototype.startGameLoop = function () {
		this.manuallyPaused = false;
		this._startGameLoop();
	};

	/**
	 * The method that actually stops the game loop
	 * @private
	 */
	GooRunner.prototype._stopGameLoop = function () {
		window.cancelAnimationFrame(this.animationId);
		this.animationId = 0;
	};

	/**
	 * Stops the game loop.
	 */
	GooRunner.prototype.stopGameLoop = function () {
		this.manuallyPaused = true;
		this._stopGameLoop();
	};

	/**
	 * Takes an image snapshot from the 3d scene at next render call.
	 * @param {Function} callback
	 */
	GooRunner.prototype.takeSnapshot = function (callback) {
		this._takeSnapshots.push(callback);
	};

	/**
	 * Requests a pick from screen space coordinates. A successful pick returns id and depth of the pick target.
	 *
	 * @param {number} x screen coordinate
	 * @param {number} y screen coordinate
	 * @param {Function} callback to handle the pick result
	 * @param {boolean} skipUpdateBuffer when true picking will be attempted against existing buffer
	 */
	GooRunner.prototype.pick = function (x, y, callback, skipUpdateBuffer) {
		this._picking.x = x;
		this._picking.y = y;
		this._picking.skipUpdateBuffer = skipUpdateBuffer === undefined ? false : skipUpdateBuffer;
		if (callback) {
			this._picking.pickingCallback = callback;
		}
		this._picking.doPick = true;
	};

	/**
	 * Pick, the synchronous method. Uses the same pickbuffer so it will affect asynch picking. Also goes only through the normal render system.
	 * @example-link http://code.gooengine.com/latest/visual-test/goo/misc/PickSync/PickSync-vtest.html Working example
	 * @param {number} x screen coordinate
	 * @param {number} y screen coordinate
	 * @param {boolean} skipUpdateBuffer when true picking will be attempted against existing buffer
	 */
	GooRunner.prototype.pickSync = function (x, y, skipUpdateBuffer) {
		// save the clear color
		var currentClearColor = this.renderer.clearColor;

		this._picking.skipUpdateBuffer = skipUpdateBuffer === undefined ? false : skipUpdateBuffer;

		var savedClearColor = currentClearColor.clone();

		// change the clear color
		this.renderer.setClearColor(0, 0, 0, 1);

		// render
		this.renderSystem.renderToPick(this.renderer, false);

		// restore the clear color
		this.renderer.setClearColor(savedClearColor.r, savedClearColor.g, savedClearColor.b, savedClearColor.a);

		// get the picking data from the buffer
		var pickingStore = {};
		this.renderer.pick(x, y, pickingStore, Renderer.mainCamera);
		return pickingStore;
	};

	/**
	 * Clears the GooRunner and anything associated with it. Once this method is called this instanceof of GooRunner is unusable.
	 */
	GooRunner.prototype.clear = function () {
		this.stopGameLoop();
		this.world.clear();

		// detach the canvas from the page
		var gooCanvas = this.renderer.domElement;
		if (gooCanvas.parentNode) {
			gooCanvas.parentNode.removeChild(gooCanvas);
		}

		// a lot of stuff may reside in here
		SystemBus.clear();

		// clearing cached materials
		Material.store = [];
		Material.hash = [];

		// this should never have existed in the first place
		Renderer.mainCamera = null;

		// clears out whatever visibility-change listeners were attached to document
		GameUtils.clearVisibilityChangeListeners();

		// severe some more connections
		this.world = null;
		this.renderer = null;
		this.renderSystem = null;
		this.renderSystems = null;

		// and forget any scheduled callbacks as they can hold references too
		this.callbacks = null;
		this.callbacksPreProcess = null;
		this.callbacksPreRender = null;
		this.callbacksNextFrame = null;
		this._takeSnapshots = null;
		this._events = null;
	};

	/**
	 * Adds a small stats widget showing fps, rendercalls, vertices, indices, transform updates and cached shaders
	 */
	GooRunner.prototype.addStats = function () {
		this.stats = new Stats();
		this.stats.domElement.style.position = 'absolute';
		this.stats.domElement.style.left = '10px';
		this.stats.domElement.style.top = '10px';
		document.body.appendChild(this.stats.domElement);
	};

	/**
	 * Removes stats widget
	 */
	GooRunner.prototype.removeStats = function () {
		if (this.stats) {
			this.stats.domElement.parentNode.removeChild(this.stats.domElement);
			this.stats = null;
		}
	};

	module.exports = GooRunner;

/***/ },
/* 345 */
/***/ function(module, exports, __webpack_require__) {

	var System = __webpack_require__(42);

	// has to stay here because it's used by traverseFunc below
	// it's pretty crappy how it's sprinkled over the code
	var numUpdates;

	/**
	 * Processes all entities with transform components, making sure they are up to date and valid according to the "scenegraph"
	 * @example-link http://code.gooengine.com/latest/visual-test/goo/entities/components/TransformComponent/TransformComponent-vtest.html Working example
	 * @extends System
	 */
	function TransformSystem() {
		System.call(this, 'TransformSystem', ['TransformComponent']);
		this.numUpdates = 0;
	}

	TransformSystem.prototype = Object.create(System.prototype);
	TransformSystem.prototype.constructor = TransformSystem;

	TransformSystem.prototype.process = function () {
		var entities = this._activeEntities;

		numUpdates = 0;
		var i, transformComponent;
		var l = entities.length;
		for (i = 0; i < l; i++) {
			transformComponent = entities[i].transformComponent;
			if (transformComponent._localTransformDirty) {
				transformComponent.updateTransform();
			}
		}

		// Traverse from root nodes and down, depth first
		for (i = 0; i < l; i++) {
			var entity = entities[i];
			transformComponent = entity.transformComponent;
			if (transformComponent.parent === null) {
				entity.traverse(traverseFunc);
			}
		}

		this.numUpdates = numUpdates;
	};

	function traverseFunc(entity) {
		if (entity.transformComponent._worldTransformDirty) {
			entity.transformComponent.updateWorldTransform();
			numUpdates++;
			// Set children to dirty
			var children = entity.transformComponent.children;
			for (var j = 0; j < children.length; j++) {
				children[j]._worldTransformDirty = true;
			}
		}
	}

	module.exports = TransformSystem;

/***/ },
/* 346 */
/***/ function(module, exports, __webpack_require__) {

	var System = __webpack_require__(42);
	var SystemBus = __webpack_require__(44);
	var SimplePartitioner = __webpack_require__(347);
	var Material = __webpack_require__(30);
	var ShaderLib = __webpack_require__(46);
	var ObjectUtils = __webpack_require__(6);

	/**
	 * Renders entities/renderables using a configurable partitioner for culling
	 * @property {boolean} doRender Only render if set to true
	 * @extends System
	 */
	function RenderSystem() {
		System.call(this, 'RenderSystem', ['MeshRendererComponent', 'MeshDataComponent']);

		this.entities = [];
		this.renderList = [];
		this.postRenderables = [];
		this.partitioner = new SimplePartitioner();
		this.preRenderers = [];
		this.composers = [];
		this._composersActive = true;
		this.doRender = true;

		this._debugMaterials = {};
		this.overrideMaterials = [];
		this.partitioningCamera = null;

		this.camera = null;
		this.lights = [];
		this.currentTpf = 0.0;

		SystemBus.addListener('goo.setCurrentCamera', function (newCam) {
			this.camera = newCam.camera;
		}.bind(this));

		SystemBus.addListener('goo.setLights', function (lights) {
			this.lights = lights;
		}.bind(this));

		this.picking = {
			doPick: false,
			x: 0,
			y: 0,
			pickingStore: {},
			pickingCallback: function (id, depth) {
				console.log(id, depth);
			},
			skipUpdateBuffer: false
		};
	}

	RenderSystem.prototype = Object.create(System.prototype);
	RenderSystem.prototype.constructor = RenderSystem;

	RenderSystem.prototype.pick = function (x, y, callback, skipUpdateBuffer) {
		this.picking.x = x;
		this.picking.y = y;
		this.picking.skipUpdateBuffer = skipUpdateBuffer === undefined ? false : skipUpdateBuffer;
		if (callback) {
			this.picking.pickingCallback = callback;
		}
		this.picking.doPick = true;
	};

	RenderSystem.prototype.inserted = function (entity) {
		if (this.partitioner) {
			this.partitioner.added(entity);
		}
	};

	RenderSystem.prototype.deleted = function (entity) {
		if (this.partitioner) {
			this.partitioner.removed(entity);
		}
	};

	RenderSystem.prototype.process = function (entities, tpf) {
		this.entities = entities;
		this.currentTpf = tpf;
	};

	RenderSystem.prototype.render = function (renderer) {
		if (!this.doRender) {
			return;
		}

		if (this.camera) {
			renderer.updateShadows(this.partitioner, this.entities, this.lights);

			for (var i = 0; i < this.preRenderers.length; i++) {
				var preRenderer = this.preRenderers[i];
				preRenderer.process(renderer, this.entities, this.partitioner, this.camera, this.lights);
			}

			if (this.partitioningCamera) {
				this.partitioner.process(this.partitioningCamera, this.entities, this.renderList);
			} else {
				this.partitioner.process(this.camera, this.entities, this.renderList);
			}

			if (this.composers.length > 0 && this._composersActive) {
				for (var i = 0; i < this.composers.length; i++) {
					var composer = this.composers[i];
					composer.render(renderer, this.currentTpf, this.camera, this.lights, null, true, this.overrideMaterials);
				}
			} else {
				renderer.render(this.renderList, this.camera, this.lights, null, true, this.overrideMaterials);
			}
		}
	};

	RenderSystem.prototype.renderToPick = function (renderer, skipUpdateBuffer) {
		renderer.renderToPick(this.renderList, this.camera, true, skipUpdateBuffer);
	};

	RenderSystem.prototype.enableComposers = function (activate) {
		this._composersActive = !!activate;
	};

	RenderSystem.prototype._createDebugMaterial = function (key) {
		if (key === '') {
			return;
		}
		var fshader;
		switch (key) {
			case 'wireframe':
			case 'color':
				fshader = ObjectUtils.deepClone(ShaderLib.simpleColored.fshader);
				break;
			case 'lit':
				fshader = ObjectUtils.deepClone(ShaderLib.simpleLit.fshader);
				break;
			case 'texture':
				fshader = ObjectUtils.deepClone(ShaderLib.textured.fshader);
				break;
			case 'normals':
				fshader = ObjectUtils.deepClone(ShaderLib.showNormals.fshader);
				break;
			case 'simple':
				fshader = ObjectUtils.deepClone(ShaderLib.simple.fshader);
				break;
		}
		var shaderDef = ObjectUtils.deepClone(ShaderLib.uber);
		shaderDef.fshader = fshader;
		if (key !== 'flat') {
			this._debugMaterials[key] = new Material(shaderDef, key);
			if (key === 'wireframe') {
				this._debugMaterials[key].wireframe = true;
			}
			if (key === 'lit') {
				this._debugMaterials[key]._textureMaps = {
					EMISSIVE_MAP: null,
					DIFFUSE_MAP: null,
					SPECULAR_MAP: null,
					NORMAL_MAP: null,
					AO_MAP: null,
					LIGHT_MAP: null,
					TRANSPARENCY_MAP: null
				};
			}
		} else {
			this._debugMaterials[key] = Material.createEmptyMaterial(null, key);
			this._debugMaterials[key].flat = true;
		}
	};

	RenderSystem.prototype.setDebugMaterial = function (key) {
		if (!key || key === '') {
			this.overrideMaterials = [];
			return;
		}
		var debugs = key.split('+');
		this.overrideMaterials = [];

		for (var i = 0; i < debugs.length; i++) {
			var key = debugs[i];
			if (!this._debugMaterials[key]) {
				this._createDebugMaterial(key);
			}
			if (key === '') {
				this.overrideMaterials.push(null);
			} else {
				this.overrideMaterials.push(this._debugMaterials[key]);
			}
		}
	};

	RenderSystem.prototype.invalidateHandles = function (renderer) {
		for (var i = 0; i < this.entities.length; i++) {
			var entity = this.entities[i];

			var materials = entity.meshRendererComponent.materials;
			for (var j = 0; j < materials.length; j++) {
				renderer.invalidateMaterial(materials[j]);
			}
			renderer.invalidateMeshData(entity.meshDataComponent.meshData);
		}

		for (var i = 0; i < this.composers.length; i++) {
			var composer = this.composers[i];
			renderer.invalidateComposer(composer);
		}

		renderer.rendererRecord = null; // might hold on to stuff
	};

	module.exports = RenderSystem;

/***/ },
/* 347 */
/***/ function(module, exports, __webpack_require__) {

	var Camera = __webpack_require__(120);

	/**
	 * Culls entities based on camera frustum and boundings
	 */
	function SimplePartitioner() {
	}

	SimplePartitioner.prototype.added = function () {
		// needed for things like quadtrees etc
	};

	SimplePartitioner.prototype.removed = function () {
		// needed for things like quadtrees etc
	};

	SimplePartitioner.prototype.process = function (camera, entities, renderList) {
		var index = 0;
		for (var i = 0; i < entities.length; i++) {
			var entity = entities[i];

			if (entity.skip || entity.meshRendererComponent.hidden) {
				entity.isVisible = false;
				continue;
			}

			if (entity.meshRendererComponent.cullMode === 'Never') {
				renderList[index++] = entity;
				entity.isVisible = true;
			} else {
				var bounds = entity.meshRendererComponent.worldBound;
				var result = camera.contains(bounds);
				if (result !== Camera.Outside) {
					renderList[index++] = entity;
					entity.isVisible = true;
				} else {
					entity.isVisible = false;
				}
			}
		}
		renderList.length = index;
	};

	module.exports = SimplePartitioner;

/***/ },
/* 348 */
/***/ function(module, exports, __webpack_require__) {

	var System = __webpack_require__(42);
	var SystemBus = __webpack_require__(44);

	/**
	 * Processes all entities with script components, running the scripts where applicable
	 * @extends System
	 */
	function ScriptSystem(world) {
		System.call(this, 'ScriptSystem', ['ScriptComponent']);

		//! AT: why this?
		this._world = world;

		var renderer = this._world.gooRunner.renderer;
		// General world environment
		this.context = {
			domElement: renderer.domElement,
			viewportWidth: renderer.viewportWidth,
			viewportHeight: renderer.viewportHeight,
			world: world,
			activeCameraEntity: null,
			worldData: {},
			playTime: 0
		};

		this._playing = true;

		SystemBus.addListener('goo.setCurrentCamera', function (data) {
			this.context.activeCameraEntity = data.entity;
		}.bind(this));

		SystemBus.addListener('goo.viewportResize', function (data) {
			this.context.viewportWidth = data.width;
			this.context.viewportHeight = data.height;
		}.bind(this));

		this.manualSetup = false;

		this.priority = 500;
	}

	ScriptSystem.prototype = Object.create(System.prototype);
	ScriptSystem.prototype.constructor = ScriptSystem;

	/*
	ScriptSystem.prototype.inserted = function (entity) {
		if (!this.manualSetup) {
			entity.scriptComponent.setup(entity);
		}
	};*/

	ScriptSystem.prototype.play = function () {
		this.context.playTime = 0;
		this._playing = true;
	};

	ScriptSystem.prototype.resume = function () {
		this._playing = true;
	};

	ScriptSystem.prototype.pause = function () {
		this._playing = false;
	};

	ScriptSystem.prototype.stop = ScriptSystem.prototype.pause;

	ScriptSystem.prototype.fixedUpdate = function (entities, fixedTpf) {
		// Update scripts
		for (var i = 0; i < entities.length; i++) {
			var scriptComponent = entities[i].scriptComponent;
			scriptComponent.fixedUpdate(entities[i], fixedTpf);
		}
	};

	ScriptSystem.prototype.process = function (entities, tpf) {
		// update play time
		if (this._playing) {
			this.context.playTime += tpf;
		}

		// Update scripts
		for (var i = 0; i < entities.length; i++) {
			var scriptComponent = entities[i].scriptComponent;
			scriptComponent.run(entities[i], tpf);
		}

		for (var i = 0; i < entities.length; i++) {
			var scriptComponent = entities[i].scriptComponent;
			scriptComponent.lateRun(entities[i], tpf);
		}
	};

	ScriptSystem.prototype.addedComponent = function (entity, component) {
		if (component.type === 'ScriptComponent' && !this.manualSetup) {
			component.setup(entity);
		}
	};

	ScriptSystem.prototype.removedComponent = function (entity, component) {
		if (component.type === 'ScriptComponent' && !this.manualSetup) {
			component.cleanup();
		}
	};

	/*
	ScriptSystem.prototype.deleted = function (entity) {
		if (entity.scriptComponent && !this.manualSetup) {
			entity.scriptComponent.cleanup();
		}
	};*/

	ScriptSystem.prototype.clear = function () {
		for (var i = 0; i < this._activeEntities.length; i++) {
			var entity = this._activeEntities[i];
			entity.scriptComponent.cleanup();
		}

		this._world = null;
		this.context = null;

		System.prototype.clear.call(this);
	};

	module.exports = ScriptSystem;

/***/ },
/* 349 */
/***/ function(module, exports, __webpack_require__) {

	var Capabilities = __webpack_require__(17);
	var System = __webpack_require__(42);
	var SystemBus = __webpack_require__(44);

	/**
	 * Processes all entities with a light component making sure that lights are placed according to its transforms<br>
	 * @example-link http://code.gooengine.com/latest/visual-test/goo/renderer/light/Lights-vtest.html Working example
	 * @extends System
	 */
	function LightingSystem() {
		System.call(this, 'LightingSystem', ['LightComponent', 'TransformComponent']);

		this.overrideLights = null;

		this.lights = [];

		this._needsUpdate = true;
	}

	LightingSystem.prototype = Object.create(System.prototype);
	LightingSystem.prototype.constructor = LightingSystem;

	/**
	 * Replaces the lights tracked by the system with custom ones.
	 * @param overrideLights
	 */
	LightingSystem.prototype.setOverrideLights = function (overrideLights) {
		this.overrideLights = overrideLights;
		SystemBus.emit('goo.setLights', this.overrideLights);
		this._needsUpdate = true;
	};

	/**
	 * Disables overriding of lights tracked by the system
	 */
	LightingSystem.prototype.clearOverrideLights = function () {
		this.overrideLights = undefined;
		this._needsUpdate = true;
	};

	LightingSystem.prototype.inserted = function (entity) {
		entity.lightComponent.updateLight(entity.transformComponent.sync().worldTransform);
	};

	LightingSystem.prototype.process = function (entities) {
		// do we use this anymore?
		// we used to have this feature for the early days of create
		if (!this.overrideLights) {
			this.lights.length = 0;

			for (var i = 0; i < entities.length; i++) {
				var entity = entities[i];
				var transformComponent = entity.transformComponent;
				var lightComponent = entity.lightComponent;

				transformComponent.sync();
				if (lightComponent._transformDirty || this._needsUpdate) {
					lightComponent.updateLight(transformComponent.worldTransform);
					lightComponent._transformDirty = false;
				}

				if (!lightComponent.hidden) {
					var light = lightComponent.light;
					light.shadowCaster = light.shadowCaster && Capabilities.TextureFloat; // Needs float texture for shadows (for now)
					this.lights.push(light);
				}
			}
			this._needsUpdate = false;
			SystemBus.emit('goo.setLights', this.lights);
		}
	};

	LightingSystem.prototype.invalidateHandles = function (renderer) {
		this._activeEntities.forEach(function (entity) {
			entity.lightComponent.light.invalidateHandles(renderer);
		});
	};

	module.exports = LightingSystem;

/***/ },
/* 350 */
/***/ function(module, exports, __webpack_require__) {

	var System = __webpack_require__(42);

	/**
	 * Manages and reacts to particle components on entities.
	 * @extends System
	 */
	function ParticlesSystem() {
		System.call(this, 'ParticlesSystem', ['TransformComponent', 'MeshRendererComponent', 'MeshDataComponent', 'ParticleComponent']);
		this.passive = false;
	}

	ParticlesSystem.prototype = Object.create(System.prototype);
	ParticlesSystem.prototype.constructor = ParticlesSystem;

	ParticlesSystem.prototype.process = function (entities, tpf) {
		if (tpf > 1) {
			return; // ignore, probably was out of focus
		}
		// go through each particle component and update
		for (var i = 0, max = entities.length; i < max; i++) {
			var entity = entities[i];
			var particleComponent = entity.particleComponent;

			if (particleComponent.enabled) {
				this.updateParticles(entity, particleComponent, tpf);
			}
		}
	};

	ParticlesSystem.prototype.updateParticles = function (particleEntity, particleComponent, tpf) {
		var particleIndex = 0;
		var emitterIndex = -1;
		var emitter;
		var needsUpdate = false;

		// step through our particles
		while (particleIndex < particleComponent.particleCount) {
			// watch for emitter changes
			while (emitter === undefined) {
				emitterIndex++;
				if (particleComponent.emitters.length > emitterIndex) {
					emitter = particleComponent.emitters[emitterIndex];

					// go through any influences and prepare them - we can use this to enable / disable the emitter
					if (emitter.influences.length) {
						for (var j = 0, max = emitter.influences.length; j < max; j++) {
							emitter.influences[j].prepare(particleEntity, emitter);
						}
					}

					// check if this emitter is enabled and bail out if not
					if (!emitter.enabled) {
						emitter = undefined;
						continue;
					}

					if (emitter.totalParticlesToSpawn !== 0) {
						// find out how many particles to create.
						emitter.particlesWaitingToRelease += emitter.releaseRatePerSecond * tpf;
						emitter.particlesWaitingToRelease = Math.max(emitter.particlesWaitingToRelease, 0);
					}

					// no particles to make this turn, so move on.
					if (emitter.particlesWaitingToRelease < 1) {
						emitter = undefined;
						continue;
					}
				} else {
					emitter = null;
				}
			}

			// pull the current particle
			var particle = particleComponent.particles[particleIndex];

			// if this particle is alive and we have influences, apply them
			if (particle.alive && particle.emitter && particle.emitter.influences.length) {
				for ( var j = 0, max = particle.emitter.influences.length; j < max; j++) {
					if (particle.emitter.influences[j].enabled) {
						particle.emitter.influences[j].apply(tpf, particle, particleIndex);
					}
				}
			}

			// if alive, update the particle along its lifetime - this may kill the particle
			if (particle.alive) {
				particle.update(tpf, particleEntity);
				needsUpdate = true;
			}

			// if not alive, see if we want to respawn it at the current emitter (if we have one)
			if (!particle.alive && emitter) {
				emitter.particlesWaitingToRelease--;
				if (emitter.totalParticlesToSpawn >= 1) {
					emitter.totalParticlesToSpawn--;
				}

				particle.respawnParticle(emitter);
				emitter.getEmissionPoint(particle, particleEntity);
				emitter.getEmissionVelocity(particle, particleEntity);

				if (emitter.particlesWaitingToRelease < 1 || emitter.totalParticlesToSpawn === 0) {
					// setup to pull next emitter, if any
					emitter = undefined;
				}
			}

			particleIndex++;
		}

		// tell particle meshdata we are updated.
		if (needsUpdate) {
			particleComponent.meshData.vertexData._dataNeedsRefresh = true;
			particleEntity.meshDataComponent.autoCompute = true;
		}
	};

	ParticlesSystem.prototype.play = function () {
		this.passive = false;
	};

	ParticlesSystem.prototype.pause = function () {
		this.passive = true;
	};

	ParticlesSystem.prototype.resume = ParticlesSystem.prototype.play;

	ParticlesSystem.prototype.stop = ParticlesSystem.prototype.pause;

	module.exports = ParticlesSystem;

/***/ },
/* 351 */
/***/ function(module, exports) {

	/**
	 * Shows render statistics
	 * @example
	 * this.stats = new Stats();
	 * document.body.appendChild(this.stats.domElement);
	 */
	function Stats() {
		var startTime = Date.now(), prevTime = startTime, prevTimeMs = startTime;
		var ms = 0, msMin = Infinity, msMax = 0;
		var fps = 0, fpsMin = Infinity, fpsMax = 0;
		var frames = 0, mode = 0;

		var container = document.createElement('div');
		container.id = 'stats';
		container.addEventListener('mousedown', function (event) {
			event.preventDefault();
			setModeP(++mode % 2);
		}, false);
		container.style.cssText = 'width:80px;cursor:pointer;z-index:1000;' +
			'-webkit-touch-callout: none;' +
			'-webkit-user-select: none;' +
			'-khtml-user-select: none;' +
			'-moz-user-select: none;' +
			'-ms-user-select: none;' +
			'user-select: none;';

		var fpsDiv = document.createElement('div');
		fpsDiv.id = 'fps';
		fpsDiv.style.cssText = 'padding:0 0 3px 3px;text-align:left;background-color:#002';
		container.appendChild(fpsDiv);

		var fpsText = document.createElement('div');
		fpsText.id = 'fpsText';
		fpsText.style.cssText = 'color:#0ff;font-family:Helvetica,Arial,sans-serif;font-size:8px;font-weight:bold;line-height:13px';
		fpsText.innerHTML = 'FPS';
		fpsDiv.appendChild(fpsText);

		var fpsGraph = document.createElement('div');
		fpsGraph.id = 'fpsGraph';
		fpsGraph.style.cssText = 'position:relative;width:74px;height:30px;background-color:#0ff';
		fpsDiv.appendChild(fpsGraph);

		while (fpsGraph.children.length < 74) {
			var bar = document.createElement('span');
			bar.style.cssText = 'width:1px;height:30px;float:left;background-color:#113';
			fpsGraph.appendChild(bar);
		}

		var msDiv = document.createElement('div');
		msDiv.id = 'ms';
		msDiv.style.cssText = 'padding:0 0 3px 3px;text-align:left;background-color:#020;display:none';
		container.appendChild(msDiv);

		var msText = document.createElement('div');
		msText.id = 'msText';
		msText.style.cssText = 'color:#0f0;font-family:Helvetica,Arial,sans-serif;font-size:8px;font-weight:bold;line-height:13px';
		msText.innerHTML = 'MS';
		msDiv.appendChild(msText);

		var msGraph = document.createElement('div');
		msGraph.id = 'msGraph';
		msGraph.style.cssText = 'position:relative;width:74px;height:30px;background-color:#0f0';
		msDiv.appendChild(msGraph);

		while (msGraph.children.length < 74) {
			var bar = document.createElement('span');
			bar.style.cssText = 'width:1px;height:30px;float:left;background-color:#131';
			msGraph.appendChild(bar);
		}

		var infoDiv = document.createElement('div');
		infoDiv.id = 'info';
		infoDiv.style.cssText = 'padding:0 0 3px 3px;text-align:left;background-color:#200';
		container.appendChild(infoDiv);

		var infoText = document.createElement('div');
		infoText.id = 'infoText';
		infoText.style.cssText = 'color:#f66;font-family:Helvetica,Arial,sans-serif;font-size:8px;font-weight:bold;line-height:13px';
		infoText.innerHTML = 'INFO';
		infoDiv.appendChild(infoText);

		var setModeP = function (value) {
			mode = value;
			switch (mode){
				case 0:
					fpsDiv.style.display = 'block';
					msDiv.style.display = 'none';
					break;
				case 1:
					fpsDiv.style.display = 'none';
					msDiv.style.display = 'block';
					break;
			}
		};

		var updateGraph = function (dom, value) {
			var child = dom.appendChild(dom.firstChild);
			child.style.height = value + 'px';
		};

		this.domElement = container;
		this.setMode = setModeP;
		this.begin = function () {
			startTime = Date.now();
		};

		this.end = function (info) {
			var time = Date.now();

			if (time > prevTimeMs + 100) {
				ms = time - startTime;
				msMin = Math.min(msMin, ms);
				msMax = Math.max(msMax, ms);

				msText.textContent = ms + ' MS (' + msMin + '-' + msMax + ')';
				updateGraph(msGraph, Math.min(30, 30 - (ms / 200) * 30));

				prevTimeMs = time;

				if (info) {
					infoText.innerHTML = info;
				}
			}

			frames++;

			if (time > prevTime + 1000) {
				fps = Math.round((frames * 1000) / (time - prevTime));
				fpsMin = Math.min(fpsMin, fps);
				fpsMax = Math.max(fpsMax, fps);

				fpsText.textContent = fps + ' FPS (' + fpsMin + '-' + fpsMax + ')';
				updateGraph(fpsGraph, Math.min(30, 30 - (fps / (Math.min(500, fpsMax) + 10)) * 30));

				prevTime = time;
				frames = 0;
			}

			return time;
		};

		this.update = function (info) {
			startTime = this.end(info);
		};
	}

	module.exports = Stats;

/***/ },
/* 352 */
/***/ function(module, exports, __webpack_require__) {

	var System = __webpack_require__(42);
	var AudioContext = __webpack_require__(305);
	var MathUtils = __webpack_require__(9);
	var SystemBus = __webpack_require__(44);
	var Matrix4 = __webpack_require__(33);

	/**
	 * System responsible for sound.
	 * @example-link http://code.gooengine.com/latest/visual-test/goo/addons/Sound/Sound-vtest.html Working example
	 * @extends System
	 */
	function SoundSystem() {
		this._isSupported = AudioContext.isSupported();
		if (!this._isSupported) {
			console.warn('Cannot create SoundSystem, WebAudio not supported');
			return;
		}
		System.call(this, 'SoundSystem', ['SoundComponent', 'TransformComponent']);

		this.entities = [];
		this._relativeTransform = new Matrix4();

		this._pausedSounds = {};

		this.initialized = false;

		/**
		 * @type {number}
		 * @readonly
		 */
		this.rolloffFactor = 0.4;

		/**
		 * @type {number}
		 * @readonly
		 */
		this.maxDistance = 100;

		/**
		 * @type {number}
		 * @readonly
		 */
		this.volume = 1;

		/**
		 * @type {number}
		 * @readonly
		 */
		this.reverb = 0;

		/**
		 * The muted state. To mute or unmute, see the mute() and unmute() methods.
		 * @type {boolean}
		 * @readonly
		 */
		this.muted = false;

		this.reverbAudioBuffer = null;

		this._reverbDirty = true;
		this._dirty = true;
		this._camera = null;

		var that = this;
		SystemBus.addListener('goo.setCurrentCamera', function (camConfig) {
			that._camera = camConfig.camera;
		});

		this._scheduledUpdates = [];
	}

	SoundSystem.prototype = Object.create(System.prototype);
	SoundSystem.prototype.constructor = SoundSystem;

	SoundSystem.prototype._initializeAudioNodes = function () {
		this._outNode = AudioContext.getContext().createGain();
		this._outNode.connect(AudioContext.getContext().destination);

		this._wetNode = AudioContext.getContext().createGain();
		this._wetNode.connect(this._outNode);
		this._wetNode.gain.value = 0.2;

		this._convolver = AudioContext.getContext().createConvolver();
		this._convolver.connect(this._wetNode);

		this._listener = AudioContext.getContext().listener;

		// Everything is relative to the camera
		this._listener.setPosition(0, 0, 0);
		this._listener.setOrientation(
			0, 0, -1, // Orientation
			0, 1, 0  // Up
		);

		this.initialized = true;
	};

	/**
	 * Connect sound components output nodes to sound system buses. Called by world.process()
	 * @param {Entity} entity
	 * @private
	 */
	SoundSystem.prototype.inserted = function (entity) {
		if (!this.initialized) { this._initializeAudioNodes(); }

		entity.soundComponent.connectTo({
			dry: this._outNode,
			wet: this._convolver
		});

		entity.soundComponent._system = this;
	};

	/**
	 * Be sure to stop all playing sounds when a component is removed. Called by world.process()
	 * Sometimes this has already been done by the loader
	 * @param {Entity} entity
	 * @private
	 */
	SoundSystem.prototype.deleted = function (entity) {
		if (entity.soundComponent) {
			var sounds = entity.soundComponent.sounds;
			for (var i = 0; i < sounds.length; i++) {
				sounds[i].stop();
			}
			entity.soundComponent.connectTo();
			entity.soundComponent._system = null;
		}
	};

	/**
	 * Update the environmental sound system properties. The settings are applied on the next process().
	 * @param {Object} [config]
	 * @param {number} [config.rolloffFactor] How fast the sound fades with distance.
	 * @param {number} [config.maxDistance] After this distance, sound will keep its volume.
	 * @param {number} [config.volume] Will be clamped between 0 and 1.
	 * @param {number} [config.reverb] Will be clamped between 0 and 1.
	 * @param {boolean} [config.muted]
	 */
	SoundSystem.prototype.updateConfig = function (config) {
		config = config || {};

		if (config.maxDistance !== undefined) {
			this.maxDistance = config.maxDistance;
		}
		if (config.rolloffFactor !== undefined) {
			this.rolloffFactor = config.rolloffFactor;
		}
		if (config.volume !== undefined) {
			this.volume = MathUtils.clamp(config.volume, 0, 1);
		}
		if (config.reverb !== undefined) {
			this.reverb = MathUtils.clamp(config.reverb, 0, 1);
		}
		if (config.muted !== undefined) {
			this.muted = config.muted;
		}

		this._dirty = true;
	};

	/**
	 * Set the reverb impulse response. The settings are not applied immediately.
	 * @param {?AudioBuffer} [audioBuffer] if empty will also empty existing reverb
	 */
	SoundSystem.prototype.setReverb = function (audioBuffer) {
		this.reverbAudioBuffer = audioBuffer;
		this._reverbDirty = true;
	};

	/**
	 * Pause the sound system and thereby all sounds in the scene
	 */
	SoundSystem.prototype.pause = function () {
		if (this._pausedSounds) { return; }
		this._pausedSounds = {};
		for (var i = 0; i < this.entities.length; i++) {
			var sounds = this.entities[i].soundComponent.sounds;
			for (var j = 0; j < sounds.length; j++) {
				var sound = sounds[j];
				if (sound.isPlaying()) {
					sound.pause();
					this._pausedSounds[sound.id] = true;
				}
			}
		}
	};

	/**
	 * Mute all sounds.
	 */
	SoundSystem.prototype.mute = function () {
		this.muted = true;
		this._dirty = true;
	};

	/**
	 * Unmute all sounds.
	 */
	SoundSystem.prototype.unmute = function () {
		this.muted = false;
		this._dirty = true;
	};

	/**
	 * Resumes playing of all sounds that were paused
	 */
	SoundSystem.prototype.resume = function () {
		if (!this._pausedSounds) { return; }

		for (var i = 0; i < this.entities.length; i++) {
			var sounds = this.entities[i].soundComponent.sounds;
			for (var j = 0; j < sounds.length; j++) {
				var sound = sounds[j];
				if (this._pausedSounds[sound.id]) {
					sound.play();
				}
			}
		}
		this._pausedSounds = null;
	};

	/**
	 * Resumes playing of all sounds that were paused.
	 */
	SoundSystem.prototype.play = function () {
		this.resume();
		this.passive = false;
	};

	/**
	 * Stopping the sound system and all sounds in scene
	 */
	SoundSystem.prototype.stop = function () {
		for (var i = 0; i < this.entities.length; i++) {
			var sounds = this.entities[i].soundComponent.sounds;
			for (var j = 0; j < sounds.length; j++) {
				var sound = sounds[j];
				sound.stop();
			}
		}
		this._pausedSounds = null;
		this.passive = true;
	};

	SoundSystem.prototype.process = function (entities, tpf) {
		if (!this._isSupported || entities.length === 0) {
			return;
		}

		if (!this.initialized) {
			this._initializeAudioNodes();
		}

		if (this._reverbDirty) {
			this._wetNode.disconnect();
			if (!this.reverbAudioBuffer && this._wetNode) {
				this._convolver.buffer = null;
			} else {
				this._convolver.buffer = this.reverbAudioBuffer;
				this._wetNode.connect(this._outNode);
			}
			this._reverbDirty = false;
		}

		if (this._dirty) {
			this._outNode.gain.value = this.muted ? 0 : this.volume;
			this._wetNode.gain.value = this.reverb;
			this._dirty = false;
		}

		this.entities = entities;
		var relativeTransform = this._relativeTransform;

		var viewMat;
		if (this._camera) {
			viewMat = this._camera.getViewMatrix();
		}

		for (var i = 0; i < entities.length; i++) {
			var e = entities[i];
			var component = e.soundComponent;

			component._attachedToCamera = !!(e.cameraComponent && e.cameraComponent.camera === this._camera);

			if (this._camera && !component._attachedToCamera) {
				// Give the transform relative to the camera
				relativeTransform.mul2(viewMat, e.transformComponent.sync().worldTransform.matrix);
				component.process(this, relativeTransform, tpf);
			} else {
				// Component is attached to camera.
				component.process(this, null, tpf);
			}
		}
	};

	module.exports = SoundSystem;

/***/ },
/* 353 */
/***/ function(module, exports, __webpack_require__) {

	var Component = __webpack_require__(20);
	var SystemBus = __webpack_require__(44);
	var ObjectUtils = __webpack_require__(6);

	function getGooClasses(){
		return (typeof window !== 'undefined' && window.goo) || {};
	}

	/**
	 * Contains scripts to be executed each frame when set on an active entity.
	 * @param {(Object|Array<Object>)} [scripts] A script-object or an array of script-objects to attach to the
	 * entity.
	 * The script-object needs to define the function <code>run({@link Entity} entity, number tpf)</code>,
	 * which runs on every frame update.
	 *
	 * The script object can also define the function <code>setup({@link Entity} entity)</code>, called upon script creation.
	 * @extends Component
	 */
	function ScriptComponent(scripts) {
		Component.apply(this, arguments);

		this.type = 'ScriptComponent';

		if (scripts instanceof Array) {
			this.scripts = scripts;
		} else if (scripts) {
			this.scripts = [scripts];
		} else {
			/**
			* Array of scripts tied to this script component. Scripts can be added to the component
			* using the constructor or by manually adding to the array.
			* @type {Array}
			* @example
			* // Add a script to script component
			* var scriptComponent = new ScriptComponent();
			* var controlScript = new WasdControlScript();
			* scriptComponent.scripts.push(controlScript);
			*/
			this.scripts = [];
		}

		// @ifdef DEBUG
		Object.seal(this);
		// @endif
	}

	ScriptComponent.type = 'ScriptComponent';

	ScriptComponent.prototype = Object.create(Component.prototype);
	ScriptComponent.prototype.constructor = ScriptComponent;

	/**
	 * Runs the .setup method on each script; called when the ScriptComponent is
	 * attached to the entity or when the entity is added to the world.
	 *
	 * @private
	 * @param entity
	 */
	ScriptComponent.prototype.setup = function (entity) {
		var systemContext = entity._world.getSystem('ScriptSystem').context;
		var componentContext = Object.create(systemContext);
		ObjectUtils.extend(componentContext, {
			entity: entity,
			entityData: {}
		});
		for (var i = 0; i < this.scripts.length; i++) {
			var script = this.scripts[i];
			if (!script.context) {
				script.context = Object.create(componentContext);

				if (script.parameters && script.parameters.enabled !== undefined) {
					script.enabled = script.parameters.enabled;
				} else {
					script.enabled = true;
				}

				if (script.setup && script.enabled) {
					try {
						script.setup(script.parameters, script.context, getGooClasses());
					} catch (e) {
						this._handleError(script, e, 'setup');
					}
				}
			}
		}
	};

	/**
	 * Called when script component is attached to entity.
	 * @private
	 * @type {setup}
	 */
	//ScriptComponent.prototype.attached = ScriptComponent.prototype.setup;

	/**
	 * Runs the update function on every script attached to this entity.
	 * @private
	 * @param entity {Entity}
	 */
	ScriptComponent.prototype.run = function (entity) {
		for (var i = 0; i < this.scripts.length; i++) {
			var script = this.scripts[i];
			if (script && script.run && (script.enabled === undefined || script.enabled)) {
				try {
					script.run(entity, entity._world.tpf, script.context, script.parameters);
				} catch (e) {
					this._handleError(script, e, 'run');
				}
			} else if (script.update && (script.enabled === undefined || script.enabled)) {
				try {
					script.update(script.parameters, script.context, getGooClasses());
				} catch (e) {
					this._handleError(script, e, 'update');
				}
			}
		}
	};

	/**
	 * Runs the lateUpdate function on every script attached to this entity.
	 * @private
	 */
	ScriptComponent.prototype.lateRun = function () {
		for (var i = 0; i < this.scripts.length; i++) {
			var script = this.scripts[i];
			if (script.lateUpdate && (script.enabled === undefined || script.enabled)) {
				try {
					script.lateUpdate(script.parameters, script.context, getGooClasses());
				} catch (e) {
					this._handleError(script, e, 'lateUpdate');
				}
			}
		}
	};

	/**
	 * Runs the lateUpdate function on every script attached to this entity.
	 * @private
	 */
	ScriptComponent.prototype.fixedUpdate = function () {
		for (var i = 0; i < this.scripts.length; i++) {
			var script = this.scripts[i];
			if (script.fixedUpdate && (script.enabled === undefined || script.enabled)) {
				try {
					script.fixedUpdate(script.parameters, script.context, getGooClasses());
				} catch (e) {
					this._handleError(script, e, 'lateUpdate');
				}
			}
		}
	};

	/**
	 * Reverts any changes done by setup; called when the entity loses its ScriptComponent or is removed from the world.
	 * @private
	 */
	ScriptComponent.prototype.cleanup = function () {
		for (var i = 0; i < this.scripts.length; i++) {
			var script = this.scripts[i];
			if (script.context) {
				if (script.cleanup &&
					(script.parameters && script.parameters.enabled !== undefined ?
						script.parameters.enabled :
						script.enabled)
				) {
					try {
						script.cleanup(script.parameters, script.context, getGooClasses());
					} catch (e) {
						this._handleError(script, e, 'cleanup');
					}
				}
				script.enabled = false;
				script.context = null;
			}
		}
	};

	/**
	 * Enables all the scripts that are in the component.
	 */
	ScriptComponent.prototype.startScripts = function () {
		this.scripts.forEach(function (script) {
			if (script.parameters && script.parameters.enabled === false) {
				script.enabled = false;
			} else {
				script.enabled = true;
			}
		});
	};

	/**
	 * Disables all the scripts that are in the component.
	 */
	ScriptComponent.prototype.stopScripts = function () {
		this.scripts.forEach(function (script) {
			script.enabled = false;
		});
	};

	/**
	 * Formats the error and sends it to the systembus
	 * @private
	 */
	ScriptComponent.prototype._handleError = function (script, error, phase) {
		script.enabled = false;
		var err = {
			id: script.id,
			errors: [{
				message: error.message || error,
				phase: phase
			}]
		};
		// TODO Test if this works across browsers
		/**/
		if (error instanceof Error) {
			var lineNumbers = error.stack.split('\n')[1].match(/(\d+):\d+\)$/);
			if (lineNumbers) {
				err.line = parseInt(lineNumbers[1], 10) - 1;
			}
		}
		/**/
		console.error(err.errors[0].message, err);
		SystemBus.emit('goo.scriptError', err);
	};

	/**
	 * Called when script component is detached from entity.
	 * @private
	 * @type {setup}
	 */
	//ScriptComponent.prototype.detached = ScriptComponent.prototype.cleanup;

	/**
	 * Attempts to add a script to an entity. The object can be a { run: Function } object or a Function. The entity is supposed to get a ScriptComponent with a script created out of the passed object
	 * @private
	 * @param obj {Function | { run: Function }}
	 * @param entity {Entity}
	 * @returns {boolean}
	 */
	ScriptComponent.applyOnEntity = function (obj, entity) {
		if (obj instanceof Function || (obj && obj.run instanceof Function) || (obj && obj.update instanceof Function)) {
			var scriptComponent;
			if (!entity.scriptComponent) {
				scriptComponent = new ScriptComponent();
				entity.setComponent(scriptComponent);
			} else {
				scriptComponent = entity.scriptComponent;
			}
			scriptComponent.scripts.push(obj.run instanceof Function || obj.update instanceof Function ? obj : { run: obj });

			return true;
		}
	};

	module.exports = ScriptComponent;


/***/ },
/* 354 */
/***/ function(module, exports) {

	/**
	 * Get logo svg in different formats
	 * Only used to define the class. Should never be instantiated.
	 */
	function Logo() {}

	/** @type {string} */
	Logo.blue = '#2A3276';
	/** @type {string} */
	Logo.white = '#FFFFFF';

	var defaults = {
		color: Logo.white,
		shadow: false
	};

	/**
	 * Get svg as string to add to html DOM
	 * @param {Object} properties
	 * @param {string} [properties.color=Logo.blue]
	 * @param {boolean} [properties.shadow=false]
	 * @param {string} [properties.width]
	 * @param {string} [properties.height]
	 */
	Logo.getLogo = function (properties) {
		properties = properties || {};
		for (var key in defaults) {
			if (properties[key] === undefined) {
				properties[key] = defaults[key];
			}
		}

		if (!document.createElementNS) { return ''; }

		var xmlns = 'http://www.w3.org/2000/svg';
		var svg = document.createElementNS(xmlns, 'svg');
		svg.setAttribute('version', '1.1');
		svg.setAttribute('xmlns', xmlns);
		svg.setAttribute('x', '0px');
		svg.setAttribute('y', '0px');
		svg.setAttribute('viewBox', '0 0 396.603 277.343');
		svg.setAttribute('enable-background', 'new 0 0 396.603 277.343');
		svg.setAttribute('xml:space', 'preserve');


		if (properties.width) {
			svg.setAttribute('width', properties.width);
		}
		if (properties.height) {
			svg.setAttribute('height', properties.height);
		}

		var g = document.createElementNS(xmlns, 'g');

		svg.appendChild(g);


		var shadowFilter = document.createElementNS(xmlns, 'filter');
		shadowFilter.setAttribute('id', 'insetShadow');

		var gauss = document.createElementNS(xmlns, 'feGaussianBlur');
		gauss.setAttribute('in', 'SourceAlpha');
		gauss.setAttribute('stdDeviation', '0');

		var offset = document.createElementNS(xmlns, 'feOffset');
		offset.setAttribute('dx', '0');
		offset.setAttribute('dy', '-5');
		offset.setAttribute('result', 'offsetblur');

		var compTransfer = document.createElementNS(xmlns, 'feComponentTransfer');
		var funcA = document.createElementNS(xmlns, 'feFuncA');
		funcA.setAttribute('type', 'linear');
		funcA.setAttribute('slope', '0.5');
		compTransfer.appendChild(funcA);

		var merge = document.createElementNS(xmlns, 'feMerge');
		var mn1 = document.createElementNS(xmlns, 'feMergeNode');
		var mn2 = document.createElementNS(xmlns, 'feMergeNode');
		mn2.setAttribute('in', 'SourceGraphic');
		merge.appendChild(mn1);
		merge.appendChild(mn2);

		shadowFilter.appendChild(gauss);
		shadowFilter.appendChild(offset);
		shadowFilter.appendChild(compTransfer);
		shadowFilter.appendChild(merge);

		g.appendChild(shadowFilter);
		var path = document.createElementNS(xmlns, 'path');
		path.setAttribute('d', 'M303.337,46.286c-13.578,0-25.784,5.744-34.396,14.998c-9.86,10.59-26.319,10.59-36.172,0' +
			'c-8.605-9.254-20.818-14.998-34.402-14.998c-25.936,0-46.971,21.034-46.971,46.978c0,25.936,21.035,46.972,46.971,46.972' +
			'c13.584,0,25.797-5.744,34.402-14.998c9.853-10.598,26.325-10.598,36.172,0c8.612,9.254,20.818,14.998,34.396,14.998' +
			'c25.941,0,46.977-21.036,46.977-46.972C350.313,67.32,329.278,46.286,303.337,46.286z M198.296,116.39' +
			'c-12.785,0-23.146-10.359-23.146-23.144s10.361-23.151,23.146-23.151c12.795,0,23.156,10.367,23.156,23.151' +
			'S211.091,116.39,198.296,116.39z M303.337,116.407c-12.785,0-23.146-10.36-23.146-23.144c0-12.784,10.36-23.151,23.146-23.151' +
			'c12.795,0,23.156,10.367,23.156,23.151C326.493,106.047,316.132,116.407,303.337,116.407z M156.18,138.347' +
			'c-14.087-3.23-22.316-17.482-18.068-31.305c3.704-12.072,2.568-25.511-4.22-37.256C120.927,47.323,92.22,39.63,69.766,52.587' +
			'C47.317,65.552,39.624,94.26,52.581,116.713c6.795,11.761,17.853,19.462,30.17,22.282c14.084,3.235,22.314,17.497,18.074,31.317' +
			'c-3.711,12.08-2.582,25.504,4.213,37.264c12.965,22.455,41.666,30.148,64.127,17.178c22.447-12.945,30.148-41.658,17.185-64.111' +
			'C179.554,148.881,168.497,141.181,156.18,138.347z M104.802,113.287c-11.064,6.387-25.219,2.599-31.604-8.474' +
			'c-6.397-11.07-2.604-25.225,8.474-31.609c11.057-6.398,25.22-2.598,31.611,8.46C119.673,92.741,115.872,106.897,104.802,113.287z' +
			' M145.687,207.256c-12.785,0-23.145-10.361-23.145-23.145s10.359-23.15,23.145-23.15c12.797,0,23.156,10.367,23.156,23.15' +
			'S158.483,207.256,145.687,207.256z');
		path.setAttribute('fill', properties.color);
		if (properties.shadow) {
			g.appendChild(shadowFilter);
			path.setAttribute('style', 'filter:url(#insetShadow)');
		}
		g.appendChild(path);

		var serializer = new XMLSerializer();
		var str = serializer.serializeToString(svg);
		return str;
	};

	module.exports = Logo;

/***/ },
/* 355 */
/***/ function(module, exports, __webpack_require__) {

	var MeshData = __webpack_require__(14);
	var ObjectUtils = __webpack_require__(6);

	/**
	 * MeshData for a Grid.
	 * @extends MeshData
	 * @param {number} [xSegments=10] Number of columns.
	 * @param {number} [ySegments=10] Number of rows.
	 * @param {number} [width=1] Total width of the Grid.
	 * @param {number} [height=1] Total height of the Grid.
	 * @example var meshData = new Grid( 10, 10, 10, 10);
	 */
	function Grid(xSegments, ySegments, width, height) {
		if (arguments.length === 1 && arguments[0] instanceof Object) {
			var props = arguments[0];
			xSegments = props.xSegments;
			ySegments = props.ySegments;
			width = props.width;
			height = props.height;
		}
		this.xSegments = xSegments || 10;
		this.ySegments = ySegments || 10;
		this.width = width || 1;
		this.height = height || 1;

		var attributeMap = MeshData.defaultMap([MeshData.POSITION]);
		var vertsCount = 4 + (this.xSegments - 1) * 2 + (this.ySegments - 1) * 2;
		var idcsCount = 8 + (this.xSegments - 1) * 2 + (this.ySegments - 1) * 2;
		MeshData.call(this, attributeMap, vertsCount, idcsCount);
		this.indexModes[0] = 'Lines';
		this.rebuild();
	}

	Grid.prototype = Object.create(MeshData.prototype);
	Grid.prototype.constructor = Grid;

	Grid.prototype.rebuild = function () {
		var xExtent = this.width / 2;
		var yExtent = this.height / 2;
		var verts = [];
		var indices = [];

		// Outer lines
		verts.push(
			-xExtent, -yExtent, 0,
			-xExtent, yExtent, 0,
			xExtent, yExtent, 0,
			xExtent, -yExtent, 0
		);
		// Connecting the corners
		indices.push(
			0, 1,
			1, 2,
			2, 3,
			3, 0
		);

		// X grid lines
		var xPos;
		var step = this.width / this.xSegments;
		for (var i = 1; i < this.xSegments; i++) {
			xPos = i * step - xExtent;
			verts.push(
				xPos, -yExtent, 0,
				xPos, yExtent, 0
			);
		}

		// Y grid lines
		var yPos;
		step = this.height / this.ySegments;
		for (var i = 1; i < this.ySegments; i++) {
			yPos = i * step - yExtent;
			verts.push(
				-xExtent, yPos, 0,
				xExtent, yPos, 0
			);
		}
		for (var i = indices.length / 2; i < verts.length / 3; i += 2) {
			indices.push(i, i + 1);
		}
		this.getAttributeBuffer(MeshData.POSITION).set(verts);
		this.getIndexBuffer().set(indices);
	};

	/**
	 * Returns a clone of this grid
	 * @returns {Grid}
	 */
	Grid.prototype.clone = function () {
		var options = ObjectUtils.shallowSelectiveClone(this, ['xSegments', 'ySegments', 'width', 'height']);

		return new Grid(options);
	};


	module.exports = Grid;

/***/ },
/* 356 */
/***/ function(module, exports, __webpack_require__) {

	var System = __webpack_require__(42);
	var SystemBus = __webpack_require__(44);
	var MeshData = __webpack_require__(14);
	var Material = __webpack_require__(30);
	var Shader = __webpack_require__(31);
	var Transform = __webpack_require__(41);
	var Grid = __webpack_require__(355);

	/**
	 * Renders entities/renderables using a configurable partitioner for culling
	 * @property {boolean} doRender Only render if set to true
	 * @extends System
	 */
	function GridRenderSystem() {
		System.call(this, 'GridRenderSystem', []);

		this.renderList = [];
		this.doRender = {
			grid: true
		};

		this.scale = 62.5;
		this.count = 100;

		this.camera = null;
		this.lights = [];
		this.transform1 = new Transform();
		this.transform1.rotation.rotateX(-Math.PI / 2);
		this.transform1.scale.setDirect(this.scale, this.scale, this.scale);
		this.transform1.update();

		this.transform2 = new Transform();
		this.transform2.rotation.rotateX(-Math.PI / 2);
		this.transform2.scale.setDirect(this.scale, this.scale, this.scale);
		this.transform2.update();

		var col = 0.2;
		var gridMaterial1 = new Material(gridShaderDef, 'Grid Material');
		gridMaterial1.blendState.blending = 'TransparencyBlending';
		gridMaterial1.uniforms.color = [col, col, col, 1];
		gridMaterial1.depthState.write = false;
		gridMaterial1.depthState.enabled = true;
		var gridMaterial2 = new Material(gridShaderDef, 'Grid Material');
		gridMaterial2.blendState.blending = 'TransparencyBlending';
		gridMaterial2.uniforms.color = [col, col, col, 1];
		gridMaterial2.depthState.write = false;
		gridMaterial2.depthState.enabled = true;

		var gridMesh = new Grid(this.count, this.count);
		this.grid1 = {
			meshData: gridMesh,
			materials: [gridMaterial1],
			transform: this.transform1
		};
		this.grid2 = {
			meshData: gridMesh,
			materials: [gridMaterial2],
			transform: this.transform2
		};

		this.oldHeightScale1 = 0;
		this.oldX1 = 0;
		this.oldZ1 = 0;
		this.oldHeightScale1 = 0;
		this.oldX1 = 0;
		this.oldZ1 = 0;

		// stop using this pattern - use instead .bind()
		var that = this;
		SystemBus.addListener('goo.setCurrentCamera', function (newCam) {
			that.camera = newCam.camera;
		});

		SystemBus.addListener('goo.setLights', function (lights) {
			that.lights = lights;
		});
	}

	GridRenderSystem.prototype = Object.create(System.prototype);
	GridRenderSystem.prototype.constructor = GridRenderSystem;

	GridRenderSystem.prototype.inserted = function (/*entity*/) {};

	GridRenderSystem.prototype.deleted = function (/*entity*/) {};

	function smoothstep(t, level) {
		for (var i = 0; i < level; ++i) {
			t = Math.pow(t, 2) * (3 - 2 * t);
		}
		return t;
	}

	GridRenderSystem.prototype.process = function (/*entities, tpf*/) {
		if (!this.doRender.grid) {
			return;
		}

		var y = Math.max(Math.abs(this.camera.translation.y) / 10, 0);

		var y1 = Math.pow(y, 0.15);
		var blender1 = 1 - Math.abs(y1 - Math.floor(y1) - 0.5) * 2;
		blender1 = Math.min(blender1 * 2, 1);
		var heightScale1 = Math.pow(2, Math.floor(y1) * 4 + 2) * this.scale;

		var y2 = Math.pow(y, 0.15) + 0.5;
		var blender2 = 1 - Math.abs(y2 - Math.floor(y2) - 0.5) * 2;
		blender2 = Math.min(blender2 * 2, 1);
		var heightScale2 = Math.pow(2, Math.floor(y2) * 4) * this.scale;

		blender1 = smoothstep(blender1, 1);
		blender2 = smoothstep(blender2, 1);

		this.grid1.materials[0].uniforms.scale = heightScale1;
		this.grid1.materials[0].uniforms.opacity = blender1;

		this.grid2.materials[0].uniforms.scale = heightScale2;
		this.grid2.materials[0].uniforms.opacity = blender2;

		var x = Math.floor(this.camera.translation.x * this.count / heightScale1);
		var z = Math.floor(this.camera.translation.z * this.count / heightScale1);
		if (heightScale1 !== this.oldHeightScale1 || x !== this.oldX1 || z !== this.oldZ1) {
			this.transform1.scale.setDirect(heightScale1, heightScale1, heightScale1);
			this.transform1.translation.x = x * heightScale1 / this.count;
			this.transform1.translation.z = z * heightScale1 / this.count;
			this.transform1.update();

			this.oldX1 = x;
			this.oldZ1 = z;
			this.oldHeightScale1 = heightScale1;
		}

		x = Math.floor(this.camera.translation.x * this.count / heightScale2);
		z = Math.floor(this.camera.translation.z * this.count / heightScale2);
		if (heightScale2 !== this.oldHeightScale2 || x !== this.oldX2 || z !== this.oldZ2) {
			this.transform2.scale.setDirect(heightScale2, heightScale2, heightScale2);
			this.transform2.translation.x = x * heightScale2 / this.count;
			this.transform2.translation.z = z * heightScale2 / this.count;
			this.transform2.update();

			this.oldX2 = x;
			this.oldZ2 = z;
			this.oldHeightScale2 = heightScale2;
		}

		if (blender1 > blender2) {
			this.renderList[0] = this.grid1;
			this.renderList[1] = this.grid2;
		} else {
			this.renderList[0] = this.grid2;
			this.renderList[1] = this.grid1;
		}
	};

	GridRenderSystem.prototype.render = function (renderer/*, picking*/) {
		renderer.checkResize(this.camera);

		if (this.camera && this.doRender.grid) {
			renderer.render(this.renderList, this.camera, this.lights, null, false);
		}
	};

	GridRenderSystem.prototype.invalidateHandles = function (renderer) {
		this.renderList.forEach(function (renderable) {
			renderable.materials.forEach(function (material) {
				renderer.invalidateMaterial(material);
			});
			renderer.invalidateMeshData(renderable.meshData);
		});
	};

	var gridShaderDef = {
		attributes: {
			vertexPosition: MeshData.POSITION
		},
		uniforms: {
			viewMatrix: Shader.VIEW_MATRIX,
			projectionMatrix: Shader.PROJECTION_MATRIX,
			worldMatrix: Shader.WORLD_MATRIX,
			color: [0.55, 0.55, 0.55, 1],
			fogNear: Shader.NEAR_PLANE,
			fogFar: Shader.FAR_PLANE,
			opacity: 1,
			scale: 1
		},
		vshader: [
			'attribute vec3 vertexPosition;',

			'uniform mat4 worldMatrix;',
			'uniform mat4 viewMatrix;',
			'uniform mat4 projectionMatrix;',

			'varying float depth;',

			'void main(void) {',
				'vec4 viewPosition = viewMatrix * worldMatrix * vec4(vertexPosition, 1.0);',

				'depth = -viewPosition.z;',

				'gl_Position = projectionMatrix * viewPosition;',
			'}'
		].join('\n'),
		fshader: [
			'precision mediump float;',

			'uniform vec4 color;',
			'uniform float fogNear;',
			'uniform float fogFar;',
			'uniform float opacity;',
			'uniform float scale;',

			'varying float depth;',

			'void main(void) {',
				'gl_FragColor = color;',
				'float lerpVal = 1.0 - clamp(depth * 3.0 / min(scale, fogFar * 3.0), 0.0, 1.0);',
				'gl_FragColor.a = opacity * lerpVal;',
			'}'
		].join('\n')
	};

	module.exports = GridRenderSystem;

/***/ },
/* 357 */
/***/ function(module, exports, __webpack_require__) {

	var System = __webpack_require__(42);
	var Renderer = __webpack_require__(123);
	var Vector3 = __webpack_require__(8);

	/**
	 * @extends System
	 * @example-link http://code.gooengine.com/latest/visual-test/goo/entities/components/HTMLComponent/HTMLComponent-vtest.html Working example
	 */
	function HtmlSystem(renderer) {
		System.call(this, 'HtmlSystem', ['TransformComponent', 'HtmlComponent']);
		this.renderer = renderer;

		this.styleCache = new Map();
	}

	HtmlSystem.prototype = Object.create(System.prototype);
	HtmlSystem.prototype.constructor = HtmlSystem;

	// Browsers implement z-index as signed 32bit int.
	// Overflowing pushes the element to the back.
	var MAX_Z_INDEX = 2147483647;
	var tmpVector = new Vector3();

	HtmlSystem.prototype.setStyle = function (element, property, style, doPrefix) {
		var elementCache = this.styleCache.get(element);
		if (!elementCache) {
			elementCache = new Map();
			this.styleCache.set(element, elementCache);
		}

		if (style !== elementCache.get(property)) {
			element.style[property] = style;
			if (doPrefix) {
				element.style['-webkit-' + property] = style;
			}

			elementCache.set(property, style);
		}
	};

	HtmlSystem.prototype.clearStyleCache = function (element) {
		this.styleCache.delete(element);
	};

	HtmlSystem.prototype.process = function (entities) {
		if (entities.length === 0) {
			return;
		}

		var camera = Renderer.mainCamera;
		var renderer = this.renderer;

		var screenWidth = renderer.viewportWidth;
		var screenHeight = renderer.viewportHeight;
		var offsetLeft = renderer.domElement.offsetLeft;
		var offsetTop = renderer.domElement.offsetTop;

		for (var i = 0; i < entities.length; i++) {
			var entity = entities[i];
			var component = entity.htmlComponent;

			// Always show if not using transform (if not hidden)
			if (!component.useTransformComponent) {
				this.setStyle(component.domElement, 'display', component.hidden ? 'none' : '');
				this.setStyle(component.domElement, 'transform', '');
				continue;
			}

			// Hidden
			if (component.hidden) {
				this.setStyle(component.domElement, 'display', 'none');
				continue;
			}

			// Behind camera
			tmpVector.set(camera.translation)
				.sub(entity.transformComponent.sync().worldTransform.translation);
			if (camera._direction.dot(tmpVector) > 0) {
				this.setStyle(component.domElement, 'display', 'none');
				continue;
			}

			// compute world position.
			camera.getScreenCoordinates(entity.transformComponent.sync().worldTransform.translation, screenWidth, screenHeight, tmpVector);
			// Behind near plane
			if (tmpVector.z < 0) {
				this.setStyle(component.domElement, 'display', 'none');
				continue;
			}
			// Else visible
			this.setStyle(component.domElement, 'display', '');

			var fx = tmpVector.x / renderer.devicePixelRatio;
			var fy = tmpVector.y / renderer.devicePixelRatio;

			if (component.pixelPerfect) {
				fx = Math.floor(fx);
				fy = Math.floor(fy);
			}

			this.setStyle(component.domElement, 'transform',
				'translate(-50%, -50%) ' +
				'translate(' + (fx + offsetLeft) + 'px, ' + (fy + offsetTop) + 'px)',
			true);

			this.setStyle(component.domElement, 'zIndex', MAX_Z_INDEX - Math.round(tmpVector.z * MAX_Z_INDEX));
		}
	};

	HtmlSystem.prototype.deleted = function (entity) {
		if (!entity || !entity.htmlComponent) {
			return;
		}

		var component = entity.htmlComponent;

		if (component.domElement.parentNode) {
			component.domElement.parentNode.removeChild(component.domElement);
		}

		component.domElement = null;
	};

	module.exports = HtmlSystem;

/***/ },
/* 358 */
/***/ function(module, exports, __webpack_require__) {

	var MathUtils = __webpack_require__(9);
	var Matrix = __webpack_require__(25);
	var ObjectUtils = __webpack_require__(6);

	/**
	 * Matrix with 2x2 components.
	 * @extends Matrix
	 * @param {number...} arguments Initial values for the matrix components.
	 */
	function Matrix2() {
		Matrix.call(this, 2, 2);

		if (arguments.length === 0) {
			this.data[0] = 1;
			this.data[3] = 1;
		} else if (arguments.length === 1 && typeof arguments[0] === 'object') {
			if (arguments[0] instanceof Matrix2) {
				this.copy(arguments[0]);
			} else {
				this.setArray(arguments[0]);
			}
		} else {
			for (var i = 0; i < arguments.length; i++) {
				this.data[i] = arguments[i];
			}
		}

		// @ifdef DEBUG
		Object.seal(this);
		// @endif
	}

	Matrix2.prototype = Object.create(Matrix.prototype);
	Matrix2.prototype.constructor = Matrix2;

	Matrix.setupAliases(Matrix2.prototype, [['e00'], ['e10'], ['e01'], ['e11']]);

	/* @type {Matrix2} */
	Matrix2.IDENTITY = new Matrix2(1, 0, 0, 1);

	/**
	 * Performs a component-wise addition.
	 * @param {Matrix2} rhs Matrix or scalar on the right-hand side.
	 * @returns {Matrix2} Self to allow chaining
	 */
	Matrix2.prototype.add = function (rhs) {
		var thisData = this.data;
		var rhsData = rhs.data;

		thisData[0] += rhsData[0];
		thisData[1] += rhsData[1];
		thisData[2] += rhsData[2];
		thisData[3] += rhsData[3];

		return this;
	};

	/**
	 * Performs a component-wise subtraction.
	 * @param {Matrix2} rhs Matrix or scalar on the right-hand side.
	 * @returns {Matrix2} Self to allow chaining
	 */
	Matrix2.prototype.sub = function (rhs) {
		var thisData = this.data;
		var rhsData = rhs.data;

		thisData[0] -= rhsData[0];
		thisData[1] -= rhsData[1];
		thisData[2] -= rhsData[2];
		thisData[3] -= rhsData[3];

		return this;
	};

	/**
	 * Multiplies this matrix with a scalar
	 * @param {number} scalar
	 * @returns {Matrix2} Self to allow chaining
	 */
	Matrix2.prototype.scale = function (scalar) {
		var data = this.data;

		data[0] *= scalar;
		data[1] *= scalar;
		data[2] *= scalar;
		data[3] *= scalar;

		return this;
	};

	/**
	 * Multiplies this matrix with another matrix
	 * @param {Matrix2} rhs Matrix on the left-hand side
	 * @returns {Matrix2} Self to allow chaining
	 */
	Matrix2.prototype.mul = function (rhs) {
		var s1d = rhs.data;
		var m00 = s1d[0], m01 = s1d[2],
			m10 = s1d[1], m11 = s1d[3];

		var s2d = this.data;
		var n00 = s2d[0], n01 = s2d[2],
			n10 = s2d[1], n11 = s2d[3];

		var rd = this.data;

		rd[0] = m00 * n00 + m01 * n10;
		rd[2] = m00 * n10 + m01 * n11;

		rd[1] = m10 * n00 + m11 * n10;
		rd[3] = m10 * n01 + m11 * n11;

		return this;
	};

	/**
	 * Multiplies two matrices and stores the result in this matrix
	 * @param {Matrix2} lhs Matrix on the left-hand side
	 * @param {Matrix2} rhs Matrix on the right-hand side
	 * @returns {Matrix2} Self to allow chaining
	 */
	Matrix2.prototype.mul2 = function (lhs, rhs) {
		var s1d = lhs.data;
		var m00 = s1d[0], m01 = s1d[2],
			m10 = s1d[1], m11 = s1d[3];

		var s2d = rhs.data;
		var n00 = s2d[0], n01 = s2d[2],
			n10 = s2d[1], n11 = s2d[3];

		var rd = this.data;

		rd[0] = m00 * n00 + m01 * n10;
		rd[2] = m00 * n10 + m01 * n11;

		rd[1] = m10 * n00 + m11 * n10;
		rd[3] = m10 * n01 + m11 * n11;

		return this;
	};

	/**
	 * Transposes a matrix (exchanges rows and columns).
	 * @returns {Matrix2} Self to allow chaining
	 */
	Matrix2.prototype.transpose = function () {
		var data = this.data;

		var e10 = data[1];
		data[1] = data[2];
		data[2] = e10;

		return this;
	};

	/**
	 * Computes the analytical inverse and stores the result in a separate matrix.
	 * @param {Matrix2} source Source matrix.
	 * @param {Matrix2} [target] Target matrix.
	 * @returns {Matrix2} A new matrix if the target matrix is omitted, else the target matrix.
	 */
	Matrix2.invert = function (source, target) {
		if (!target) {
			target = new Matrix2();
		}

		if (target === source) {
			return target.copy(Matrix2.invert(source));
		}

		var det = source.determinant();

		if (Math.abs(det) < MathUtils.EPSILON) {
			return target;
		}

		det = 1.0 / det;

		target.e00 = source.e11 * det;
		target.e10 = 0.0 - source.e10 * det;
		target.e01 = 0.0 - source.e01 * det;
		target.e11 = source.e00 * det;

		return target;
	};

	/**
	 * Computes the analytical inverse and stores the result locally.
	 * @returns {Matrix2} Self for chaining.
	 */
	Matrix2.prototype.invert = function () {
		return Matrix2.invert(this, this);
	};

	/**
	 * Tests if the matrix is orthogonal.
	 * @returns {boolean} True if orthogonal.
	 */
	Matrix2.prototype.isOrthogonal = function () {
		var dot;

		dot = this.e00 * this.e01 + this.e10 * this.e11;

		if (Math.abs(dot) > MathUtils.EPSILON) {
			return false;
		}

		return true;
	};

	/**
	 * Tests if the matrix is normal.
	 * @returns {boolean} True if normal.
	 */
	Matrix2.prototype.isNormal = function () {
		var l;

		l = this.e00 * this.e00 + this.e10 * this.e10;

		if (Math.abs(l - 1.0) > MathUtils.EPSILON) {
			return false;
		}

		l = this.e01 * this.e01 + this.e11 * this.e11;

		//! AT: why wrap the condition in an if?!
		if (Math.abs(l - 1.0) > MathUtils.EPSILON) {
			return false;
		}

		return true;
	};

	/**
	 * Tests if the matrix is orthonormal.
	 * @returns {boolean} True if orthonormal.
	 */
	Matrix2.prototype.isOrthonormal = function () {
		return this.isOrthogonal() && this.isNormal();
	};

	/**
	 * Computes the determinant of the matrix.
	 * @returns {number} Determinant of matrix.
	 */
	Matrix2.prototype.determinant = function () {
		return this.e00 * this.e11 - this.e01 * this.e10;
	};

	/**
	 * Sets the matrix to identity.
	 * @returns {Matrix2} Self for chaining.
	 */
	Matrix2.prototype.setIdentity = function () {
		this.set(Matrix2.IDENTITY);
		return this;
	};

	/**
	 * Compares two matrices for approximate equality
	 * @param {Matrix2} rhs The matrix to compare against
	 * @returns {boolean}
	 */
	Matrix2.prototype.equals = function (rhs) {
		var thisData = this.data;
		var rhsData = rhs.data;

		return (Math.abs(thisData[0] - rhsData[0]) <= MathUtils.EPSILON) &&
			(Math.abs(thisData[1] - rhsData[1]) <= MathUtils.EPSILON) &&
			(Math.abs(thisData[2] - rhsData[2]) <= MathUtils.EPSILON) &&
			(Math.abs(thisData[3] - rhsData[3]) <= MathUtils.EPSILON);
	};

	/**
	 * Copies component values from another matrix to this matrix
	 * @param {Matrix2} rhs Source matrix
	 * @returns {Matrix2} Self to allow chaining
	 */
	Matrix2.prototype.copy = function (rhs) {
		var thisData = this.data;
		var rhsData = rhs.data;

		thisData[0] = rhsData[0];
		thisData[1] = rhsData[1];
		thisData[2] = rhsData[2];
		thisData[3] = rhsData[3];

		return this;
	};

	/**
	 * Sets matrix values from an array.
	 * @param {Array<number>} rhsData Array source
	 * @returns {Matrix2} Self for chaining.
	 */
	Matrix2.prototype.setArray = function (rhsData) {
		var thisData = this.data;

		thisData[0] = rhsData[0];
		thisData[1] = rhsData[1];
		thisData[2] = rhsData[2];
		thisData[3] = rhsData[3];

		return this;
	};

	/**
	 * Sets the matrix's values from another matrix's values; an alias for .copy
	 * @param {Matrix2} source Source matrix
	 * @returns {Matrix2} Self to allow chaining
	 */
	Matrix2.prototype.set = Matrix2.prototype.copy;

	/**
	 * Returns a new matrix with the same values as the existing one
	 * @returns {Matrix2} The new matrix
	 */
	Matrix2.prototype.clone = function () {
		return new Matrix2().copy(this);
	};

	// @ifdef DEBUG
	Matrix.addPostChecks(Matrix2.prototype, [
		'add', 'sub', 'scale', 'transpose', 'invert',
		'isOrthogonal', 'determinant',
		'copy'
	]);
	// @endif

	// SHIM START
	/**
	 * @hidden
	 * @deprecated
	 */
	Matrix2.add = ObjectUtils.warnOnce(
		'Matrix2.add is deprecated. Use Matrix2.prototype.add instead.',
		function (lhs, rhs, target) {
			if (!target) {
				target = new Matrix2();
			}

			if (rhs instanceof Matrix2) {
				target.e00 = lhs.e00 + rhs.e00;
				target.e10 = lhs.e10 + rhs.e10;
				target.e01 = lhs.e01 + rhs.e01;
				target.e11 = lhs.e11 + rhs.e11;
			} else {
				target.e00 = lhs.e00 + rhs;
				target.e10 = lhs.e10 + rhs;
				target.e01 = lhs.e01 + rhs;
				target.e11 = lhs.e11 + rhs;
			}

			return target;
		}
	);

	/**
	 * @hidden
	 * @deprecated
	 */
	Matrix2.combine = ObjectUtils.warnOnce(
		'Matrix2.combine is deprecated. Use Matrix2.prototype.multiply instead.',
		function (lhs, rhs, target) {
			if (!target) {
				target = new Matrix2();
			}

			if (target === lhs || target === rhs) {
				return Matrix.copy(Matrix2.combine(lhs, rhs), target);
			}

			target.e00 = lhs.e00 * rhs.e00 + lhs.e01 * rhs.e10;
			target.e10 = lhs.e10 * rhs.e00 + lhs.e11 * rhs.e10;
			target.e01 = lhs.e00 * rhs.e01 + lhs.e01 * rhs.e11;
			target.e11 = lhs.e10 * rhs.e01 + lhs.e11 * rhs.e11;

			return target;
		}
	);

	/**
	 * @hidden
	 * @deprecated
	 */
	Matrix2.div = ObjectUtils.warnOnce(
		'Matrix2.div is deprecated. Use Matrix2.prototype.div instead.',
		function (lhs, rhs, target) {
			if (!target) {
				target = new Matrix2();
			}

			if (rhs instanceof Matrix2) {
				target.e00 = lhs.e00 / rhs.e00;
				target.e10 = lhs.e10 / rhs.e10;
				target.e01 = lhs.e01 / rhs.e01;
				target.e11 = lhs.e11 / rhs.e11;
			} else {
				rhs = 1.0 / rhs;

				target.e00 = lhs.e00 * rhs;
				target.e10 = lhs.e10 * rhs;
				target.e01 = lhs.e01 * rhs;
				target.e11 = lhs.e11 * rhs;
			}

			return target;
		}
	);

	/**
	 * @hidden
	 * @deprecated
	 */
	Matrix2.mul = ObjectUtils.warnOnce(
		'Matrix2.mul is deprecated. Use Matrix2.prototype.mul instead.',
		function (lhs, rhs, target) {
			if (!target) {
				target = new Matrix2();
			}

			if (rhs instanceof Matrix2) {
				target.e00 = lhs.e00 * rhs.e00;
				target.e10 = lhs.e10 * rhs.e10;
				target.e01 = lhs.e01 * rhs.e01;
				target.e11 = lhs.e11 * rhs.e11;
			} else {
				target.e00 = lhs.e00 * rhs;
				target.e10 = lhs.e10 * rhs;
				target.e01 = lhs.e01 * rhs;
				target.e11 = lhs.e11 * rhs;
			}

			return target;
		}
	);

	/**
	 * @hidden
	 * @deprecated
	 */
	Matrix2.transpose = ObjectUtils.warnOnce(
		'Matrix2.transpose is deprecated. Use Matrix2.prototype.transpose instead.',
		function (source, target) {
			if (!target) {
				target = new Matrix2();
			}

			if (target === source) {
				return Matrix.copy(Matrix2.transpose(source), target);
			}

			target.e00 = source.e00;
			target.e10 = source.e01;
			target.e01 = source.e10;
			target.e11 = source.e11;

			return target;
		}
	);

	/**
	 * @hidden
	 * @deprecated
	 */
	Matrix2.sub = ObjectUtils.warnOnce(
		'Matrix2.sub is deprecated. Use Matrix2.prototype.sub instead.',
		function (lhs, rhs, target) {
			if (!target) {
				target = new Matrix2();
			}

			if (rhs instanceof Matrix2) {
				target.e00 = lhs.e00 - rhs.e00;
				target.e10 = lhs.e10 - rhs.e10;
				target.e01 = lhs.e01 - rhs.e01;
				target.e11 = lhs.e11 - rhs.e11;
			} else {
				target.e00 = lhs.e00 - rhs;
				target.e10 = lhs.e10 - rhs;
				target.e01 = lhs.e01 - rhs;
				target.e11 = lhs.e11 - rhs;
			}

			return target;
		}
	);

	/**
	 * @hidden
	 * @deprecated
	 */
	Matrix2.prototype.combine = ObjectUtils.warnOnce(
		'Matrix2.prototype.combine is deprecated. Use Matrix2.prototype.mul or Matrix2.prototype.mul2 instead.',
		function (rhs) {
			return Matrix2.combine(this, rhs, this);
		}
	);

	/**
	 * @hidden
	 * @deprecated
	 */
	Matrix2.prototype.div = ObjectUtils.warnOnce(
		'Matrix2.prototype.div is deprecated.',
		function (rhs) {
			return Matrix2.div(this, rhs, this);
		}
	);
	// SHIM END

	module.exports = Matrix2;


/***/ },
/* 359 */
/***/ function(module, exports, __webpack_require__) {

	var Matrix2 = __webpack_require__(358);
	var ObjectUtils = __webpack_require__(6);

	var Matrix2x2 = ObjectUtils.warnOnce(
		'Matrix2x2 has been renamed to Matrix2.',
		function () {
			Matrix2.apply(this, arguments);
		}
	);

	Matrix2x2.prototype = Object.create(Matrix2.prototype);
	Matrix2x2.prototype.constructor = Matrix2x2;
	for (var x in Matrix2) {
		Matrix2x2[x] = Matrix2[x];
	}

	module.exports = Matrix2x2;


/***/ },
/* 360 */
/***/ function(module, exports, __webpack_require__) {

	var Matrix3 = __webpack_require__(24);
	var ObjectUtils = __webpack_require__(6);

	var Matrix3x3 = ObjectUtils.warnOnce(
		'Matrix3x3 has been renamed to Matrix3.',
		function () {
			Matrix3.apply(this, arguments);
		}
	);

	Matrix3x3.prototype = Object.create(Matrix3.prototype);
	Matrix3x3.prototype.constructor = Matrix3x3;
	for (var x in Matrix3) {
		Matrix3x3[x] = Matrix3[x];
	}

	module.exports = Matrix3x3;


/***/ },
/* 361 */
/***/ function(module, exports, __webpack_require__) {

	var Matrix4 = __webpack_require__(33);
	var ObjectUtils = __webpack_require__(6);

	var Matrix4x4 = ObjectUtils.warnOnce(
		'Matrix4x4 has been renamed to Matrix4.',
		function () {
			Matrix4.apply(this, arguments);
		}
	);

	Matrix4x4.prototype = Object.create(Matrix4.prototype);
	Matrix4x4.prototype.constructor = Matrix4x4;
	for (var x in Matrix4) {
		Matrix4x4[x] = Matrix4[x];
	}

	module.exports = Matrix4x4;


/***/ },
/* 362 */
/***/ function(module, exports, __webpack_require__) {

	var Vector3 = __webpack_require__(8);
	var Component = __webpack_require__(20);

	/**
	 * Holds the movement parameters of an entity.
	 * Typically useful for anything which has a speed and/or
	 * rotation.
	 * @extends Component
	 */
	function MovementComponent() {
		Component.apply(this, arguments);

		this.type = 'MovementComponent';
		this.velocity = new Vector3();
		this.rotationVelocity = new Vector3();

		// @ifdef DEBUG
		Object.seal(this);
		// @endif
	}

	MovementComponent.type = 'MovementComponent';

	MovementComponent.prototype = Object.create(Component.prototype);
	MovementComponent.prototype.constructor = MovementComponent;

	/**
	 * Adds velocity to movement. Typically useful for things such as gravity and slingshots.
	 * @param {Vector3} vec3 velocity impulse vector.
	 */
	MovementComponent.prototype.addVelocity = function (vec3) {
		this.velocity.add(vec3);
	};

	/**
	 * Adds velocity to movement. Typically useful for things such as gravity and slingshots.
	 * @param {Vector3} vec3 velocity impulse vector.
	 */

	MovementComponent.prototype.setVelocity = function (vec3) {
		this.velocity.set(vec3);
	};

	/**
	 * Reads the movement velocity vector
	 * @returns {Vector3} velocity vector
	 */

	MovementComponent.prototype.getVelocity = function () {
		return this.velocity;
	};

	/**
	 * Adds rotational velocity to movement. Typically useful for spinning or turning things.
	 * @param {Vector3} vec3 rotational velocity impulse vector.
	 */

	MovementComponent.prototype.addRotationVelocity = function (vec3) {
		this.rotationVelocity.add(vec3);
	};
	/**
	 * Sets rotational velocity of the movement.
	 * @param {Vector3} vec3 rotational velocity vector.
	 */

	MovementComponent.prototype.setRotationVelocity = function (vec3) {
		this.rotationVelocity.set(vec3);
	};

	/**
	 * Read the rotational velocity of movement
	 * @returns {Vector3} the rotational velocity
	 */

	MovementComponent.prototype.getRotationVelocity = function () {
		return this.rotationVelocity;
	};

	module.exports = MovementComponent;


/***/ },
/* 363 */
/***/ function(module, exports, __webpack_require__) {

	var System = __webpack_require__(42);

	//! AT: unused; should be removed
	/**
	 * Processes all entities with movement components.
	 * This system applies movement vectors for translation and rotation
	 * to the transform of the entity which has it every frame.
	 * @extends System
	 */
	function MovementSystem() {
		System.call(this, 'MovementSystem', ['MovementComponent']);
	}

	MovementSystem.prototype = Object.create(System.prototype);
	MovementSystem.prototype.constructor = MovementSystem;

	MovementSystem.prototype.addVelocityToTransform = function (vel, transform, tpf) {
		transform.translation.addDirect(vel.x * tpf, vel.y * tpf, vel.z * tpf);
	};

	MovementSystem.prototype.addRotToTransform = function (rotVel, transform, tpf) {
		transform.rotation.rotateX(rotVel.x * tpf);
		transform.rotation.rotateY(rotVel.y * tpf);
		transform.rotation.rotateZ(rotVel.z * tpf);
	};

	MovementSystem.prototype.applyMovementToEntity = function (entity) {
		var tpf = entity._world.tpf;
		var rotVel = entity.movementComponent.getRotationVelocity();
		var velocity = entity.movementComponent.getVelocity();
		var transform = entity.transformComponent.transform;
		this.addVelocityToTransform(velocity, transform, tpf);
		this.addRotToTransform(rotVel, transform, tpf);
		entity.transformComponent.setUpdated();
	};

	MovementSystem.prototype.process = function (entities) {
		for (var i = 0; i < entities.length; i++) {
			this.applyMovementToEntity(entities[i]);
		}
	};

	module.exports = MovementSystem;

/***/ },
/* 364 */
/***/ function(module, exports, __webpack_require__) {

	var MathUtils = __webpack_require__(9);

	/**
	 * A base class for procedural noise functions.
	 * Only used to define the class. Should never be instantiated.
	 */
	function Noise() {}

	Noise.shifter = [
		0x25, 0x5B, 0x0C, 0x80, 0xD8, 0x60, 0x33, 0x99, 0x27, 0xE7, 0xDF, 0xB4, 0xA0, 0x9D, 0x87, 0xB3,
		0x4A, 0x32, 0xCD, 0x97, 0x04, 0xD5, 0xC4, 0x3A, 0xD4, 0x78, 0x35, 0x2D, 0x0A, 0xC3, 0x89, 0x9F,
		0x67, 0x90, 0x6D, 0xAA, 0xCA, 0x30, 0x79, 0x0D, 0xF5, 0x44, 0xE8, 0x1C, 0xD2, 0xAE, 0xC5, 0x50,
		0x6B, 0xCE, 0x9C, 0x74, 0x9B, 0xF0, 0xA2, 0x4F, 0x29, 0x3B, 0x93, 0x75, 0x00, 0xF2, 0x76, 0xA4,
		0x81, 0x65, 0x62, 0x7E, 0xD6, 0x69, 0x59, 0x1A, 0x82, 0xFE, 0x55, 0xC7, 0x08, 0xA5, 0x4C, 0x4B,
		0xBB, 0xA6, 0x40, 0x8F, 0xD9, 0x95, 0x4E, 0x07, 0xAC, 0xE6, 0x57, 0x77, 0x2A, 0xF7, 0x54, 0x8B,
		0x10, 0x8D, 0x86, 0x56, 0x9A, 0x47, 0xFD, 0x3C, 0x63, 0xEB, 0xA8, 0x1E, 0x22, 0x37, 0x71, 0x8C,
		0xBF, 0x45, 0x1F, 0x6A, 0x28, 0x52, 0x49, 0x21, 0x51, 0x0E, 0xEA, 0x83, 0xFF, 0x58, 0xA9, 0x88,
		0xF8, 0x94, 0xDC, 0x8A, 0xDB, 0x66, 0x2C, 0x7F, 0x24, 0xC8, 0x5F, 0xD0, 0x36, 0x98, 0x2F, 0x14,
		0x17, 0x0F, 0x34, 0x7B, 0xB1, 0xE0, 0x7A, 0xAB, 0xD7, 0xAD, 0xD3, 0xBC, 0xBE, 0x85, 0xF4, 0xA7,
		0xEC, 0x23, 0x3F, 0x91, 0xDD, 0x68, 0x41, 0x18, 0x46, 0x64, 0x38, 0x96, 0x31, 0x4D, 0x6E, 0xE4,
		0x70, 0xD1, 0xC6, 0x01, 0xED, 0xB9, 0xFA, 0xE1, 0x5D, 0xC9, 0x7C, 0x6C, 0xDA, 0x48, 0xF3, 0x15,
		0x16, 0x06, 0x72, 0x26, 0x7D, 0x1D, 0x42, 0xF9, 0xDE, 0x6F, 0xF1, 0x0B, 0xBA, 0x3D, 0xB0, 0xB7,
		0x11, 0xA3, 0xE5, 0xA1, 0x39, 0xEE, 0xE3, 0x84, 0x43, 0x53, 0xCF, 0xE2, 0x2E, 0xBD, 0x73, 0xC1,
		0xC2, 0xE9, 0xB6, 0xC0, 0x12, 0x1B, 0x19, 0x02, 0x03, 0xFC, 0x61, 0x3E, 0xB8, 0xEF, 0xAF, 0x5C,
		0xF6, 0x8E, 0xFB, 0xCC, 0xCB, 0x20, 0x92, 0x5A, 0x13, 0x09, 0xB2, 0x9E, 0xB5, 0x5E, 0x2B, 0x05
	];

	/**
	 * Splits a real-valued number into a record for use in smooth interpolation.
	 * @hidden
	 * @param {Float} x Input value.
	 * @returns {Object} Object containing 'i0', 'i1', 'f0' and 'f1' members. (Integer, Integer, Float, Float)
	 */
	Noise.split = function (x) {
		var i = Math.floor(x);
		var f = MathUtils.scurve5(x - i);

		return { 'i0': i + 0, 'i1': i + 1, 'f0': 1.0 - f, 'f1': 0.0 + f };
	};

	/**
	 * Evaluates a one-dimensional fractal noise function at a specific position.
	 * @param {Float} x Evaluation position x.
	 * @param {Float} scale Base scale. Greater scale values will pull the sources (hills and valleys) further apart.
	 * @param {Integer} octaves Number of octaves.
	 * @param {Float} persistance Amplitude persistance between octaves.
	 * @param {Float} lacunarity Frequency scale between octaves.
	 * @param {Noise} type Name of noise class extending from Noise.
	 * @returns {Float} Noise value.
	 */
	Noise.fractal1d = function (x, scale, octaves, persistance, lacunarity, type) {
		var result = 0.0;
		var amplitude = 1.0;
		var normalizer = 0.0;

		for (var i = 0; i < octaves; i++) {
			result += amplitude * type.evaluate1d(x, scale);
			normalizer += amplitude;
			amplitude *= persistance;
			x *= lacunarity;
		}

		return result / normalizer;
	};

	/**
	 * Evaluates a two-dimensional fractal noise function at a specific position.
	 * @param {Float} x Evaluation position x.
	 * @param {Float} y Evaluation position y.
	 * @param {Float} scale Base scale. Greater scale values will pull the sources (hills and valleys) further apart.
	 * @param {Integer} octaves Number of octaves.
	 * @param {Float} persistance Amplitude persistance between octaves.
	 * @param {Float} lacunarity Frequency scale between octaves.
	 * @param {Noise} type Name of noise class extending from Noise.
	 * @returns {Float} Noise value.
	 */
	Noise.fractal2d = function (x, y, scale, octaves, persistance, lacunarity, type) {
		var result = 0.0;
		var amplitude = 1.0;
		var normalizer = 0.0;

		for (var i = 0; i < octaves; i++) {
			result += amplitude * type.evaluate2d(x, y, scale);
			normalizer += amplitude;
			amplitude *= persistance;
			x *= lacunarity;
			y *= lacunarity;
		}

		return result / normalizer;
	};

	/**
	 * Evaluates a three-dimensional fractal noise function at a specific position.
	 * @param {Float} x Evaluation position x.
	 * @param {Float} y Evaluation position y.
	 * @param {Float} z Evaluation position z.
	 * @param {Float} scale Base scale. Greater scale values will pull the sources (hills and valleys) further apart.
	 * @param {Integer} octaves Number of octaves.
	 * @param {Float} persistance Amplitude persistance between octaves.
	 * @param {Float} lacunarity Frequency scale between octaves.
	 * @param {Noise} type Name of noise class extending from Noise.
	 * @returns {Float} Noise value.
	 */
	Noise.fractal3d = function (x, y, z, scale, octaves, persistance, lacunarity, type) {
		var result = 0.0;
		var amplitude = 1.0;
		var normalizer = 0.0;

		for (var i = 0; i < octaves; i++) {
			result += amplitude * type.evaluate3d(x, y, z, scale);
			normalizer += amplitude;
			amplitude *= persistance;
			x *= lacunarity;
			y *= lacunarity;
			z *= lacunarity;
		}

		return result / normalizer;
	};

	/**
	 * Evaluates a four-dimensional fractal noise function at a specific position.
	 * @param {Float} x Evaluation position x.
	 * @param {Float} y Evaluation position y.
	 * @param {Float} z Evaluation position z.
	 * @param {Float} w Evaluation position w.
	 * @param {Float} scale Base scale. Greater scale values will pull the sources (hills and valleys) further apart.
	 * @param {Integer} octaves Number of octaves.
	 * @param {Float} persistance Amplitude persistance between octaves.
	 * @param {Float} lacunarity Frequency scale between octaves.
	 * @param {Noise} type Name of noise class extending from Noise.
	 * @returns {Float} Noise value.
	 */
	Noise.fractal4d = function (x, y, z, w, scale, octaves, persistance, lacunarity, type) {
		var result = 0.0;
		var amplitude = 1.0;
		var normalizer = 0.0;

		for (var i = 0; i < octaves; i++) {
			result += amplitude * type.evaluate4d(x, y, z, w, scale);
			normalizer += amplitude;
			amplitude *= persistance;
			x *= lacunarity;
			y *= lacunarity;
			z *= lacunarity;
			w *= lacunarity;
		}

		return result / normalizer;
	};

	module.exports = Noise;


/***/ },
/* 365 */
/***/ function(module, exports, __webpack_require__) {

	var Vector3 = __webpack_require__(8);
	var Vector2 = __webpack_require__(19);
	var MathUtils = __webpack_require__(9);
	var Camera = __webpack_require__(120);
	var SystemBus = __webpack_require__(44);

	var ZOOM_DISTANCE_FACTOR = 0.035;
	var EPSILON = 1e-6;

	/**
	 * @param {Object} args
	 * @param {boolean} args.whenUsed When current entity is the camera in use
	 * @param {string} args.dragButton Can be 'Any', 'Left', 'Middle', 'Right', 'None'. None disables dragging
	 * @param {number} args.orbitSpeed
	 * @param {number} args.zoomSpeed
	 * @param {number} args.drag The inertia
	 * @param {number} args.smoothness
	 * @param {number} args.minZoomDistance
	 * @param {number} args.maxZoomDistance
	 * @param {number} args.minAscent in degrees
	 * @param {number} args.maxAscent in degrees
	 * @param {number} args.minAzimuth in degrees
	 * @param {number} args.maxAzimuth in degress
	 * @param {boolean} args.clampAzimuth If true, min and max azimuth are used.
	 * @param {number} args.lookAtDistance distance to the lookatpoint
	 * @param {number[3]} args.lookAtPoint the point in space to look
	 * @deprecated
	 * @param {number[3]} args.spherical The start position of the camera in [radius, azimuth, ascent] form, where 0 azimuth looks to -X
	 * @deprecated
	 */
	function setup(args, ctx) {
		ctx.dirty = true;
		ctx.timeSamples = [0, 0, 0, 0, 0];
		ctx.xSamples = [0, 0, 0, 0, 0];
		ctx.ySamples = [0, 0, 0, 0, 0];
		ctx.sample = 0;
		ctx.velocity = new Vector2();
		ctx.cartesian = new Vector3();
		ctx.worldUpVector = Vector3.UNIT_Y.clone();
		ctx.maxSampleTimeMS = 200;

		ctx.mouseState = {
			buttonDown: false,
			lastX: NaN,
			lastY: NaN
		};

		argsUpdated(args, ctx);

		var spherical;
		if (args.lookAtDistance) {
			// Getting script angles from transform
			var angles = ctx.entity.getRotation();
			spherical = ctx.spherical = new Vector3(
				args.lookAtDistance,
				-angles.y + Math.PI / 2,
				-angles.x
			);
		} else if (args.spherical instanceof Array) {
			var spherical = ctx.spherical = new Vector3(
				args.spherical[0],
				args.spherical[1] * MathUtils.DEG_TO_RAD,
				args.spherical[2] * MathUtils.DEG_TO_RAD
			);
		} else if (args.spherical) {
			var spherical = ctx.spherical = new Vector3(
				args.spherical.x,
				args.spherical.y * MathUtils.DEG_TO_RAD,
				args.spherical.z * MathUtils.DEG_TO_RAD
			);
		} else {
			var spherical = ctx.spherical = new Vector3(15, 0, 0); // Just something so the script won't crash
		}
		ctx.targetSpherical = spherical.clone();

		if (args.lookAtDistance) {
			// Setting look at point at a distance forward
			var rotation = ctx.entity.transformComponent.transform.rotation;
			ctx.lookAtPoint = new Vector3(0, 0, -args.lookAtDistance);
			ctx.lookAtPoint.applyPost(rotation);
			ctx.lookAtPoint.add(ctx.entity.getTranslation());
		} else if (args.lookAtPoint) {
			ctx.lookAtPoint = args.lookAtPoint instanceof Array ? Vector3.fromArray(args.lookAtPoint) : args.lookAtPoint.clone();
		} else {
			ctx.lookAtPoint = new Vector3();
		}
		ctx.goingToLookAt = ctx.lookAtPoint.clone();

		// Parallel camera size
		updateFrustumSize(1, ctx);

		setupMouseControls(args, ctx);
	}

	function updateButtonState(buttonIndex, down, args, ctx) {
		/*if (ctx.domElement !== document) {
			ctx.domElement.focus();
		}*/
		var dragButton = ctx.dragButton;
		var mouseState = ctx.mouseState;
		if (dragButton === -1 || dragButton === buttonIndex || down === false) {
			mouseState.buttonDown = down;
			if (down) {
				mouseState.lastX = NaN;
				mouseState.lastY = NaN;
				ctx.velocity.setDirect(0, 0);
				ctx.spherical.y = MathUtils.moduloPositive(ctx.spherical.y, MathUtils.TWO_PI);
				ctx.targetSpherical.set(ctx.spherical);
			} else {
				applyReleaseDrift(args, ctx);
			}
		}
	}

	function updateDeltas(mouseX, mouseY, args, ctx) {
		var dx = 0, dy = 0;
		var mouseState = ctx.mouseState;
		if (isNaN(mouseState.lastX) || isNaN(mouseState.lastY)) {
			mouseState.lastX = mouseX;
			mouseState.lastY = mouseY;
		} else {
			dx = -(mouseX - mouseState.lastX);
			dy = mouseY - mouseState.lastY;
			mouseState.lastX = mouseX;
			mouseState.lastY = mouseY;
		}

		if (!mouseState.buttonDown || dx === 0 && dy === 0) {
			return;
		}

		// Release velocity samples
		ctx.timeSamples[ctx.sample] = Date.now();
		ctx.xSamples[ctx.sample] = dx;
		ctx.ySamples[ctx.sample] = dy;

		ctx.sample++;
		if (ctx.sample > ctx.timeSamples.length - 1) {
			ctx.sample = 0;
		}

		ctx.velocity.setDirect(0, 0);
		move(args.orbitSpeed * dx, args.orbitSpeed * dy, args, ctx);
	}

	function move(azimuthAccel, thetaAccel, args, ctx) {
		var td = ctx.targetSpherical;

		// update our master spherical coords, using x and y movement
		if (args.clampAzimuth) {
			var minAzimuth = args.minAzimuth * MathUtils.DEG_TO_RAD;
			var maxAzimuth = args.maxAzimuth * MathUtils.DEG_TO_RAD;
			td.y = MathUtils.radialClamp(td.y - azimuthAccel, minAzimuth, maxAzimuth);
		} else {
			td.y -= azimuthAccel;
		}
		var minAscent = args.minAscent * MathUtils.DEG_TO_RAD;
		var maxAscent = args.maxAscent * MathUtils.DEG_TO_RAD;
		td.z = MathUtils.clamp(td.z + thetaAccel, minAscent, maxAscent);

		ctx.dirty = true;
	}

	function updateFrustumSize(delta, ctx) {
		if (!ctx.entity.cameraComponent) {
			return;
		}
		var camera = ctx.entity.cameraComponent.camera;
		if (camera.projectionMode === Camera.Parallel) {
			ctx.size = camera.top;
			ctx.size /= delta;
			var size = ctx.size;
			camera.setFrustum(null, null, -size, size, size, -size);
		}
	}

	function applyWheel(e, args, ctx) {
		var delta = Math.max(-1, Math.min(1, -e.wheelDelta || e.detail));
		delta *= ZOOM_DISTANCE_FACTOR * ctx.targetSpherical.x;

		var td = ctx.targetSpherical;
		td.x = MathUtils.clamp(
			td.x + args.zoomSpeed * delta,
			args.minZoomDistance,
			args.maxZoomDistance
		);
		ctx.dirty = true;
	}

	function applyReleaseDrift(args, ctx) {
		var timeSamples = ctx.timeSamples;
		var now = Date.now();
		var dx = 0, dy = 0;
		var found = false;
		for (var i = 0, max = timeSamples.length; i < max; i++) {
			if (now - timeSamples[i] < ctx.maxSampleTimeMS) {
				dx += ctx.xSamples[i];
				dy += ctx.ySamples[i];
				found = true;
			}
		}
		if (found) {
			ctx.velocity.setDirect(
				dx * args.orbitSpeed / timeSamples.length,
				dy * args.orbitSpeed / timeSamples.length
			);
		} else {
			ctx.velocity.setDirect(0, 0);
		}
	}

	function setupMouseControls(args, ctx) {
		var oldDistance = 0;
		var isAndroid = !!navigator.userAgent.match(/Android/i);
		var fakeEvent = {
			wheelDelta: 0
		};

		ctx.listeners = {
			mousedown: function (event) {
				if (!args.whenUsed || ctx.entity === ctx.activeCameraEntity) {
					var button = event.button;
					if (button === 0) {
						if (event.altKey) {
							button = 2;
						} else if (event.shiftKey) {
							button = 1;
						}
					}
					updateButtonState(button, true, args, ctx);
				}
			},
			mouseup: function (event) {
				var button = event.button;
				if (button === 0) {
					if (event.altKey) {
						button = 2;
					} else if (event.shiftKey) {
						button = 1;
					}
				}
				updateButtonState(button, false, args, ctx);
			},
			mousemove: function (event) {
				if (!args.whenUsed || ctx.entity === ctx.activeCameraEntity) {
					updateDeltas(event.clientX, event.clientY, args, ctx);
				}
			},
			mouseleave: function (event) {
				ctx.orbitListeners.mouseup(event);
			},
			mousewheel: function (event) {
				if (!args.whenUsed || ctx.entity === ctx.activeCameraEntity) {
					applyWheel(event, args, ctx);
				}
			},
			touchstart: function (event) {
				if (!args.whenUsed || ctx.entity === ctx.activeCameraEntity) {
					updateButtonState(ctx.dragButton, event.targetTouches.length === 1, args, ctx);
				}
				// fix Android bug that stops touchmove events, unless prevented
				// https://code.google.com/p/android/issues/detail?id=5491
				if (isAndroid) {
					event.preventDefault();
				}
			},
			touchend: function (/*event*/) {
				updateButtonState(ctx.dragButton, false, args, ctx);
				oldDistance = 0;
			},
			touchmove: function (event) {
				if (!args.whenUsed || ctx.entity === ctx.activeCameraEntity) {
					var cx, cy, distance;
					var touches = event.targetTouches;
					var x1 = touches[0].clientX;
					var y1 = touches[0].clientY;
					if (touches.length === 2) {
						var x2 = touches[1].clientX;
						var y2 = touches[1].clientY;
						distance = (x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2);
					} else {
						cx = x1;
						cy = y1;
						updateDeltas(cx, cy, args, ctx);
					}
					var scale = (distance - oldDistance) / Math.max(ctx.domElement.offsetHeight, ctx.domElement.offsetWidth);
					scale /= 3;
					if (oldDistance === 0) {
						oldDistance = distance;
					} else if (touches.length === 2 && Math.abs(scale) > 0.3) {
						fakeEvent.wheelDelta = scale;
						applyWheel(fakeEvent, args, ctx);
						oldDistance = distance;
					}
				}
			}
		};
		ctx.listeners.DOMMouseScroll = ctx.listeners.mousewheel;
		ctx.listeners.mouseleave = ctx.listeners.mouseup;

		for (var event in ctx.listeners) {
			ctx.domElement.addEventListener(event, ctx.listeners[event]);
		}

		// Avoid missing the mouseup event because of Chrome bug:
		// https://code.google.com/p/chromium/issues/detail?id=244289
		// seems solved
		/*
		args.domElement.addEventListener('dragstart', function (event) {
			preventDefault();
		}, false);
		*/
		ctx.domElement.oncontextmenu = function () { return false; };
	}

	function updateVelocity(time, args, ctx) {
		if (ctx.velocity.lengthSquared() > EPSILON) {
			move(ctx.velocity.x, ctx.velocity.y, args, ctx);
			var rate = MathUtils.lerp(ctx.inertia, 0, 1 - time / ctx.inertia);
			ctx.velocity.scale(rate);
		} else {
			ctx.velocity.setDirect(0, 0, 0);
		}
	}

	function update(args, ctx/*, goo*/) {
		if (!ctx.dirty) {
			return; //
		}
		var spherical = ctx.spherical;
		var targetSpherical = ctx.targetSpherical;
		var lookAtPoint = ctx.lookAtPoint;
		var goingToLookAt = ctx.goingToLookAt;
		var cartesian = ctx.cartesian;

		var entity = ctx.entity;
		var transformComponent = entity.transformComponent;
		var transform = transformComponent.transform;

		var delta = MathUtils.lerp(ctx.smoothness, 1, ctx.world.tpf);

		if (goingToLookAt.distanceSquared(lookAtPoint) < EPSILON) {
			lookAtPoint.set(goingToLookAt);
		} else {
			lookAtPoint.lerp(goingToLookAt, delta);
		}

		if (ctx.inertia > 0) {
			updateVelocity(entity._world.tpf, args, ctx);
		}


		//var delta = MathUtils.clamp(args.interpolationSpeed * ctx.world.tpf, 0.0, 1.0);
		var sd = spherical;
		var tsd = targetSpherical;

		// Move azimuth to target
		sd.y = MathUtils.lerp(delta, sd.y, tsd.y);
		// Move ascent to target
		sd.z = MathUtils.lerp(delta, sd.z, tsd.z);

		// Move distance to target
		var deltaX = sd.x;
		sd.x = MathUtils.lerp(delta, sd.x, tsd.x);
		deltaX /= sd.x;
		updateFrustumSize(deltaX, ctx);

		MathUtils.sphericalToCartesian(sd.x, sd.y, sd.z, cartesian);

		transform.translation.set(cartesian.add(lookAtPoint));
		if (!transform.translation.equals(lookAtPoint)) {
			transform.lookAt(lookAtPoint, ctx.worldUpVector);
		}

		if (spherical.distanceSquared(targetSpherical) < EPSILON && ctx.lookAtPoint.equals(ctx.goingToLookAt)) {
			sd.y = MathUtils.moduloPositive(sd.y, MathUtils.TWO_PI);
			targetSpherical.set(spherical);
			ctx.dirty = false;
		}

		// set our component updated.
		transformComponent.setUpdated();
		if (ctx.entity.cameraComponent) {
			SystemBus.emit('goo.cameraPositionChanged', {
				spherical: ctx.spherical.toArray(),
				translation: transform.translation.toArray(),
				lookAtPoint: ctx.lookAtPoint.toArray(),
				id: entity.id
			});
		}
	}

	function cleanup(args, ctx) {
		for (var event in ctx.listeners) {
			ctx.domElement.removeEventListener(event, ctx.listeners[event]);
		}
	}

	function argsUpdated(args, ctx) {

		// Making more linear perception
		ctx.smoothness = Math.pow(MathUtils.clamp(args.smoothness, 0, 1), 0.3);
		ctx.inertia = Math.pow(MathUtils.clamp(args.drag, 0, 1), 0.3);

		ctx.dragButton = ['Any', 'Left', 'Middle', 'Right', 'None'].indexOf(args.dragButton) - 1;
		if (ctx.dragButton < -1) {
			ctx.dragButton = -1;
		} else if (ctx.dragButton === 4) {
			ctx.dragButton = null;
		}

		ctx.dirty = true;
	}

	function OrbitCamControlScript() {
		return {
			setup: setup,
			update: update,
			cleanup: cleanup,
			argsUpdated: argsUpdated
		};
	}

	OrbitCamControlScript.externals = {
		key: 'OrbitCamControlScript',
		name: 'OrbitCamera Control',
		description: 'Enables camera to orbit around a point in 3D space using the mouse',
		parameters: [{
			key: 'whenUsed',
			'default': true,
			name: 'When Camera Used',
			description: 'Script only runs when the camera to which it is added is being used.',
			type: 'boolean'
		}, {
			key: 'dragButton',
			description: 'Button to enable dragging',
			'default': 'Any',
			options: ['Any', 'Left', 'Middle', 'Right', 'None'],
			type: 'string',
			control: 'select'
		}, {
			key: 'orbitSpeed',
			'default': 0.005,
			type: 'float',
			scale: 0.001,
			decimals: 3
		}, {
			key: 'zoomSpeed',
			'default': 1.0,
			type: 'float',
			scale: 0.1
		}, {
			key: 'drag',
			name: 'Inertia',
			'default': 0.9,
			type: 'float',
			control: 'slider',
			min: 0,
			max: 1.0
		}, {
			key: 'smoothness',
			'default': 0.4,
			type: 'float',
			min: 0,
			max: 1,
			control: 'slider'
		}, {
			key: 'minZoomDistance',
			'default': 1,
			type: 'float',
			min: 0.01
		}, {
			key: 'maxZoomDistance',
			'default': 1000,
			type: 'float',
			min: 1
		}, {
			key: 'minAscent',
			description: 'Maximum arc the camera can reach below the target point',
			'default': -89.99,
			type: 'float',
			control: 'slider',
			min: -89.99,
			max: 89.99
		}, {
			key: 'maxAscent',
			description: 'Maximum arc the camera can reach above the target point',
			'default': 89.99,
			type: 'float',
			control: 'slider',
			min: -89.99,
			max: 89.99
		}, {
			key: 'clampAzimuth',
			'default': false,
			type: 'boolean'
		}, {
			key: 'minAzimuth',
			description: 'Maximum arc the camera can reach clockwise of the target point',
			'default': 90,
			type: 'int',
			control: 'slider',
			min: 0,
			max: 360
		}, {
			key: 'maxAzimuth',
			description: 'Maximum arc the camera can reach counter-clockwise of the target point',
			'default': 270,
			type: 'int',
			control: 'slider',
			min: 0,
			max: 360
		}, {
			key: 'lookAtDistance',
			description: 'The point to orbit around',
			'default': 15,
			type: 'float',
			min: 0.001
		}]
	};

	module.exports = OrbitCamControlScript;

/***/ },
/* 366 */
/***/ function(module, exports, __webpack_require__) {

	var AudioContext = __webpack_require__(305);
	var MathUtils = __webpack_require__(9);

	function OscillatorSound() {
		// Settings
		this.id = null;
		this._volume = 1.0;
		this._frequency = 440;
		this._type = 'sine';

		// Nodes
		this._outNode = AudioContext.getContext().createGain();

		this.connectTo();
	}

	OscillatorSound.prototype.stop = function () {
		this._oscNode.stop();
		this._oscNode = null;
	};

	OscillatorSound.prototype.play = function () {
		this._oscNode = AudioContext.getContext().createOscillator();
		this._oscNode.connect(this._outNode);
		this._oscNode.frequency.value = this._frequency;
		this._oscNode.type = this._type;

		this._oscNode.start();
	};

	OscillatorSound.prototype.update = function (config) {
		if (config.volume !== undefined) {
			this._volume = MathUtils.clamp(config.volume, 0, 1);
			this._outNode.gain.value = this._volume;
		}
		if (config.frequency !== undefined) {
			this._frequency = config.frequency;
			if (this._oscNode) {
				this._oscNode.frequency.value = this._frequency;
			}
		}
		if (config.type !== undefined && OscillatorSound.TYPES.indexOf(config.type) !== -1) {
			this._type = config.type;
			if (this._oscNode) {
				this._oscNode.type = this._type;
			}
		}
	};

	/**
	 * Connect output of sound to audionodes
	 * @param {(Array<AudioNode> | AudioNode)} nodes
	 */
	OscillatorSound.prototype.connectTo = function (nodes) {
		if (!AudioContext.isSupported()) {
			console.warn('WebAudio not supported');
			return;
		}
		this._outNode.disconnect();
		if (!nodes) {
			return;
		}
		if (!(nodes instanceof Array)) {
			nodes = [nodes];
		}
		for (var i = 0; i < nodes.length; i++) {
			this._outNode.connect(nodes[i]);
		}
	};

	OscillatorSound.TYPES = [
		'sine',
		'square',
		'sawtooth',
		'triangle',
		'custom'
	];

	module.exports = OscillatorSound;

/***/ },
/* 367 */
/***/ function(module, exports) {

	/**
	 * A Particle influence modifies particles in some way over time.
	 * @param {Object} [settings]
	 * @param {Function} [settings.prepare] <code>prepare({@link Entity} particleEntity, {@link ParticleEmitter} emitter)</code>.
	 * @param {Function} [settings.apply] <code>apply(number tpf, {@link Particle} particle, number particleIndex)</code>.
	 * @param {boolean} [settings.enabled=true]
	 * @example-link http://code.gooengine.com/latest/visual-test/goo/particles/ParticleInfluence-vtest.html Working example
	 */
	function ParticleInfluence(settings) {
		settings = settings || {};

		/**
		 * Function for preparing to apply this particle influence. Useful for expensive operations that should only need computing once per frame.
		 * @type {Function}
		 * @param {Entity} [particleEntity] The Entity on which the ParticleComponent is attached to.
		 * @param {ParticleEmitter} [emitter] The ParticleEmitter on which this ParticleInfluence is attached to.
		 */
		this.prepare = settings.prepare ? settings.prepare : function () {};

		/**
		 * Function for applying this particle influence
		 * @type {Function}
		 * @param {number} [tpf] Time since last frame.
		 * @param {Particle} [particle] The Particle object this function is applyed with.
		 * @param {number} [index] The particle's index in the ParticleComponents.particles array.
		 */
		this.apply = settings.apply ? settings.apply : function () {};

		/**
		 * Specifies whether this influence should be applied to particles. Prepare is called regardless
		 * @type {boolean}
		 */
		this.enabled = settings.enabled !== undefined ? settings.enabled === true : true;
	}

	module.exports = ParticleInfluence;

/***/ },
/* 368 */
/***/ function(module, exports, __webpack_require__) {

	var System = __webpack_require__(42);

	/**
	 * Helps gather pickable entities
	 * @extends System
	 */
	function PickingSystem(settings) {
		System.call(this, 'PickingSystem', ['MeshRendererComponent', 'TransformComponent']);
		this.passive = true;
		this.pickRay = null;
		this.onPick = null;

		settings = settings || {};

		this.setPickLogic(settings.pickLogic || null);
	}

	PickingSystem.prototype = Object.create(System.prototype);
	PickingSystem.prototype.constructor = PickingSystem;

	PickingSystem.prototype.setPickLogic = function (pickLogic) {
		this.pickLogic = pickLogic;
		if (pickLogic) {
			if (this.interests.indexOf('MeshDataComponent') === -1) {
				this.interests.push('MeshDataComponent');
			}
		}
	};

	PickingSystem.prototype.inserted = function (entity) {
		if (entity.meshRendererComponent.isPickable && this.pickLogic) {
			this.pickLogic.added(entity);
		}
	};

	PickingSystem.prototype.deleted = function (entity) {
		if (this.pickLogic) {
			this.pickLogic.removed(entity);
		}
	};

	PickingSystem.prototype.process = function (entities) {
		if (!this.pickRay || !this.onPick) {
			return;
		}
		var pickList = [];
		for ( var i = 0; i < entities.length; i++) {
			var entity = entities[i];
			var meshRendererComponent = entity.meshRendererComponent;

			if (!meshRendererComponent.isPickable) {
				continue;
			}

			// If we have custom pickLogic, use that.
			if (this.pickLogic) {
				if (!this.pickLogic.isConstructed(entity)) {
					this.pickLogic.added(entity);
				}

				var result = this.pickLogic.getPickResult(this.pickRay, entity);
				if (result && result.distances && result.distances.length) {
					pickList.push({
						'entity': entity,
						'intersection': result
					});
				}
			}
			// just use bounding pick instead... first must have a world bound
			else if (meshRendererComponent.worldBound) {
				// pick ray must intersect world bound
				var result = meshRendererComponent.worldBound.intersectsRayWhere(this.pickRay);
				if (result && result.distances.length) {
					pickList.push({
						'entity': entity,
						'intersection': result
					});
				}
			}
		}

		pickList.sort(function (a, b) {
			return a.intersection.distances[0] - b.intersection.distances[0];
		});

		this.onPick(pickList);
	};

	module.exports = PickingSystem;

/***/ },
/* 369 */
/***/ function(module, exports, __webpack_require__) {

	var System = __webpack_require__(42);
	var SystemBus = __webpack_require__(44);
	var MeshData = __webpack_require__(14);
	var Shader = __webpack_require__(31);
	var Quad = __webpack_require__(28);
	var RenderTarget = __webpack_require__(133);
	var Material = __webpack_require__(30);
	var ShaderLib = __webpack_require__(46);
	var FullscreenPass = __webpack_require__(135);
	var FullscreenUtils = __webpack_require__(136);

	/**
	 * Renders transform gizmos<br>
	 * @example-link http://code.gooengine.com/latest/visual-test/goo/util/TransformGizmos/TransformGizmos-vtest.html Working example
	 * @property {boolean} doRender Only render if set to true
	 * @extends System
	 */
	function PipRenderSystem(renderSystem) {
		System.call(this, 'PipRenderSystem', null);

		this.renderSystem = renderSystem;

		this.target = new RenderTarget(512, 512);

		this.outPass = new FullscreenPass(ShaderLib.copy);
		var that = this;
		this.outPass.render = function (renderer, writeBuffer, readBuffer) {
			this.material.setTexture('DIFFUSE_MAP', readBuffer);
			renderer.render(this.renderable, FullscreenUtils.camera, [], that.target, true);
		};

		var material = new Material(renderPipQuad);
		material.setTexture('DIFFUSE_MAP', this.target);
		this.quad = new Quad(1, 1);
		this.aspect = null;
		this.width = null;
		this.height = null;
		this.renderableQuad = {
			meshData: this.quad,
			materials: [material]
		};

		this.renderList = [];
		this.usePostEffects = false;
		this.camera = null;
		this.size = null;
		this.dirty = false;

		SystemBus.addListener('goo.setPipCamera', function (newCam) {
			this.camera = newCam.camera;
			this.usePostEffects = newCam.usePostEffects !== undefined ? newCam.usePostEffects : false;
			this.dirty = true;
		}.bind(this));

		this._viewportResizeHandler = function (size) {
			this.size = size;
			this.dirty = true;
		}.bind(this);

		SystemBus.addListener('goo.viewportResize', this._viewportResizeHandler, true);
	}

	PipRenderSystem.prototype = Object.create(System.prototype);
	PipRenderSystem.prototype.constructor = PipRenderSystem;

	PipRenderSystem.prototype.updateQuad = function (quad, x, y, width, height) {
		quad.getAttributeBuffer(MeshData.POSITION).set([
			x, y, 0,
			x, y + height, 0,
			x + width, y + height, 0,
			x + width, y, 0
		]);
		quad.setVertexDataUpdated();
	};

	PipRenderSystem.prototype.render = function (renderer) {
		if (!this.camera || !this.size) {
			return;
		}

		this.renderer = renderer;

		if (this.dirty) {
			this.dirty = false;
			renderer.checkResize(this.camera, true);
		}

		var aspect = this.camera.aspect;
		var height = this.size.height * 0.2;
		var width = height * aspect;

		if (aspect !== this.aspect || width !== this.width || height !== this.height) {
			this.aspect = aspect;
			this.width = width;
			this.height = height;

			this.updateQuad(this.quad, 10, 10, width, height);
		}

		renderer.updateShadows(this.renderSystem.partitioner, this.renderSystem.entities, this.renderSystem.lights);

		for (var i = 0; i < this.renderSystem.preRenderers.length; i++) {
			var preRenderer = this.renderSystem.preRenderers[i];
			preRenderer.process(renderer, this.renderSystem.entities, this.renderSystem.partitioner, this.camera, this.renderSystem.lights);
		}

		this.renderSystem.partitioner.process(this.camera, this.renderSystem.entities, this.renderList);

		if (this.usePostEffects && this.renderSystem.composers.length > 0) {
			var composer = this.renderSystem.composers[0];

			var index = composer.passes.length - 1;

			var savedPass = composer.passes[index];
			composer.passes[index] = this.outPass;

			composer.render(renderer, this.renderSystem.currentTpf, this.camera, this.renderSystem.lights, null, true);

			composer.passes[index] = savedPass;
		} else {
			var overrideMaterial = null;
			renderer.render(this.renderList, this.camera, this.renderSystem.lights, this.target, true, overrideMaterial);
		}

		renderer.render(this.renderableQuad, FullscreenUtils.camera, [], null, false);
	};

	var renderPipQuad = {
		defines: {
			EDGE: true
		},
		attributes: {
			vertexPosition: MeshData.POSITION,
			vertexUV0: MeshData.TEXCOORD0
		},
		uniforms: {
			viewProjectionMatrix: Shader.VIEW_PROJECTION_MATRIX,
			worldMatrix: Shader.WORLD_MATRIX,
			diffuseMap: Shader.DIFFUSE_MAP,
			resolution: Shader.RESOLUTION
		},
		vshader: [
			'attribute vec3 vertexPosition;',
			'attribute vec2 vertexUV0;',

			'uniform mat4 viewProjectionMatrix;',
			'uniform mat4 worldMatrix;',
			'uniform vec2 resolution;',

			'varying vec2 texCoord0;',

			'void main(void) {',
			'  texCoord0 = vertexUV0;',

			'  gl_Position = vec4(',
			'    2.0 * vertexPosition.x / resolution.x - 1.0,',
			'    2.0 * vertexPosition.y / resolution.y - 1.0,',
			'    -1.0,',
			'    1.0',
			'  );',
			'}'
		].join('\n'),
		fshader: [
			'uniform sampler2D diffuseMap;',
			'uniform vec2 resolution;',

			'varying vec2 texCoord0;',
			'const vec4 edgeCol = vec4(0.2, 0.2, 0.2, 1.0);',

			'void main(void) {',
			'  vec4 color = texture2D(diffuseMap, texCoord0);',
			'  #ifdef EDGE',
			'  float edge = step(10.0 / resolution.x, min(texCoord0.x, 1.0 - texCoord0.x)) * step(10.0 / resolution.y, min(texCoord0.y, 1.0 - texCoord0.y));',
			'  gl_FragColor = mix(edgeCol, color, edge);',
			'  #else',
			'  gl_FragColor = color;',
			'  #endif',
			'}'
		].join('\n')
	};

	module.exports = PipRenderSystem;


/***/ },
/* 370 */
/***/ function(module, exports, __webpack_require__) {

	var BoundingTree = __webpack_require__(306);
	var Ray = __webpack_require__(122);
	var Matrix4 = __webpack_require__(33);

	/**
	 * Primitive pick logic
	 */
	function PrimitivePickLogic() {
		this.invRay = new Ray();
		this.invMatrix = new Matrix4();
	}

	PrimitivePickLogic.prototype.getPickResult = function (pickRay, entity) {
		// look in pick tree for intersection
		var tree = entity.meshDataComponent.meshData.__boundingTree;
		if (!tree) {
			return null;
		}

		var worldTransform = entity.transformComponent.sync().worldTransform;
		this.invMatrix.copy(worldTransform.matrix).invert();
		this.invRay.origin.set(pickRay.origin).applyPostPoint(this.invMatrix);
		this.invRay.direction.set(pickRay.direction).applyPostVector(this.invMatrix);

		var result = tree.findPick(this.invRay, entity);

		var rebuildResult = {};
		if (result.length > 0) {
			result.sort(function (a, b) {
				return a.distance - b.distance;
			});
			rebuildResult.distances = [];
			rebuildResult.points = [];
			rebuildResult.vertices = [];
			result.forEach(function (value) {
				rebuildResult.distances.push(value.distance);
				rebuildResult.points.push(value.point);
				rebuildResult.vertices.push(value.vertices);
			});
		}
		return rebuildResult;
	};

	PrimitivePickLogic.prototype.added = function (entity) {
		// Build boundingtree if not existing
		if (!this.isConstructed(entity)) {
			this.rebuild(entity);
		}
	};

	PrimitivePickLogic.prototype.removed = function (entity) {
		// clear bounding tree
		if ( entity.meshDataComponent && entity.meshDataComponent.meshData) {
			entity.meshDataComponent.meshData.__boundingTree = null;
		}
	};

	PrimitivePickLogic.prototype.isConstructed = function (entity) {
		return !!entity.meshDataComponent.meshData.__boundingTree;
	};

	PrimitivePickLogic.prototype.rebuild = function (entity) {
		// build bounding tree
		entity.meshDataComponent.meshData.__boundingTree = new BoundingTree();

		// calculate bounding tree.
		entity.meshDataComponent.meshData.__boundingTree.construct(entity);
	};

	module.exports = PrimitivePickLogic;

/***/ },
/* 371 */
/***/ function(module, exports) {

	/**
	 * Rc4 random generator with seeding
	 */
	function Rc4Random(seed) {
		var keySchedule = [];
		var keySchedule_i = 0;
		var keySchedule_j = 0;

		this.init = function (seed) {
			for (var i = 0; i < 256; i++) {
				keySchedule[i] = i;
			}

			var j = 0;
			for (var i = 0; i < 256; i++) {
				j = (j + keySchedule[i] + seed.charCodeAt(i % seed.length)) % 256;

				var t = keySchedule[i];
				keySchedule[i] = keySchedule[j];
				keySchedule[j] = t;
			}
		};
		this.init(seed);

		function getRandomByte() {
			keySchedule_i = (keySchedule_i + 1) % 256;
			keySchedule_j = (keySchedule_j + keySchedule[keySchedule_i]) % 256;

			var t = keySchedule[keySchedule_i];
			keySchedule[keySchedule_i] = keySchedule[keySchedule_j];
			keySchedule[keySchedule_j] = t;

			return keySchedule[(keySchedule[keySchedule_i] + keySchedule[keySchedule_j]) % 256];
		}

		this.getRandomNumber = function () {
			var number = 0;
			var multiplier = 1;
			for (var i = 0; i < 8; i++) {
				number += getRandomByte() * multiplier;
				multiplier *= 256;
			}
			return number / 18446744073709551616;
		};
	}

	module.exports = Rc4Random;

/***/ },
/* 372 */
/***/ function(module, exports, __webpack_require__) {

	var Renderer = __webpack_require__(123);
	var Pass = __webpack_require__(137);
	var Vector4 = __webpack_require__(11);

	/**
	 * A pass that renders provided renderlist to the rendertarget or screen
	 */
	function RenderPass(renderList, filter) {
		this.renderList = renderList;
		this.filter = filter;

		this.clearColor = new Vector4(0.0, 0.0, 0.0, 0.0);
		this.oldClearColor = new Vector4();
		this.renderToScreen = false;

		this.overrideMaterial = null;

		this.enabled = true;
		this.clear = true;
		this.needsSwap = false;
		this.viewportSize = undefined;
	}

	RenderPass.prototype = Object.create(Pass.prototype);
	RenderPass.prototype.constructor = RenderPass;

	// RenderPasses may have a fourth additional parameter called delta
	RenderPass.prototype.render = function (renderer, writeBuffer, readBuffer, delta, maskActive, camera, lights, clearColor) {
		camera = camera || Renderer.mainCamera;

		if (!camera) {
			return;
		}

		lights = lights || [];
		if (clearColor && false) {
			this.oldClearColor.set(renderer.clearColor);
			renderer.setClearColor(clearColor[0], clearColor[1], clearColor[2], clearColor[3]);
		}

		var renderList;
		if (this.filter) {
			renderList = this.renderList.filter(this.filter);
		} else {
			renderList = this.renderList;
		}
		if (this.renderToScreen) {
			renderer.render(renderList, camera, lights, null, this.clear, this.overrideMaterial);
		} else {
			renderer.render(renderList, camera, lights, readBuffer, this.clear, this.overrideMaterial);
		}

		if (this.clearColor && false) {
			renderer.setClearColor(this.oldClearColor.x, this.oldClearColor.y, this.oldClearColor.z, this.oldClearColor.w);
		}
	};

	module.exports = RenderPass;

/***/ },
/* 373 */
/***/ function(module, exports, __webpack_require__) {

	var MeshData = __webpack_require__(14);

	/**
	 * An axis-aligned rectangular prism defined by a center point and x-, y- and z-extents (radii) from that center.
	 * @extends MeshData
	 * @param {number} [width=1] Total width of box.
	 * @param {number} [height=1] Total height of box.
	 * @param {number} [length=1] Total length of box.
	 */
	function SimpleBox(width, height, length) {
		if (arguments.length === 1 && arguments[0] instanceof Object) {
			var props = arguments[0];
			width = props.width;
			height = props.height;
			length = props.length;
		}

		this.xExtent = width !== undefined ? width * 0.5 : 0.5;
		this.yExtent = height !== undefined ? height * 0.5 : 0.5;
		this.zExtent = length !== undefined ? length * 0.5 : 0.5;

		var attributeMap = MeshData.defaultMap([MeshData.POSITION]);
		MeshData.call(this, attributeMap, 8, 36);

		this.rebuild();
	}

	SimpleBox.prototype = Object.create(MeshData.prototype);
	SimpleBox.prototype.constructor = SimpleBox;

	/**
	 * Builds or rebuilds the mesh data.
	 * @returns {SimpleBox} Self for chaining.
	 */
	SimpleBox.prototype.rebuild = function () {
		var xExtent = this.xExtent;
		var yExtent = this.yExtent;
		var zExtent = this.zExtent;

		this.getAttributeBuffer(MeshData.POSITION).set([
			-xExtent, -yExtent, -zExtent,
			xExtent, -yExtent, -zExtent,
			xExtent,  yExtent, -zExtent,
			-xExtent,  yExtent, -zExtent,

			-xExtent, -yExtent,  zExtent,
			xExtent, -yExtent,  zExtent,
			xExtent,  yExtent,  zExtent,
			-xExtent,  yExtent,  zExtent
		]);

		this.getIndexBuffer().set([
			//front
			2, 1, 0, 0, 3, 2,
			//back
			5, 6, 7, 7, 4, 5,
			//left
			7, 3, 0, 0, 4, 7,
			//right
			1, 2, 6, 6, 5, 1,
			//top
			6, 2, 3, 3, 7, 6,
			//bottom
			0, 1, 5, 5, 4, 0
		]);

		return this;
	};

	/**
	 * Returns a clone of this quad
	 * @returns {SimpleBox}
	 */
	SimpleBox.prototype.clone = function () {
		var options = {
			width: this.xExtent * 2,
			height: this.yExtent * 2,
			length: this.zExtent * 2
		};

		return new SimpleBox(options);
	};

	module.exports = SimpleBox;

/***/ },
/* 374 */
/***/ function(module, exports, __webpack_require__) {

	var SoundHandler = __webpack_require__(334);
	var AudioContext = __webpack_require__(305);
	var Ajax = __webpack_require__(132);
	var StringUtils = __webpack_require__(36);
	var PromiseUtils = __webpack_require__(54);

	/**
	 * Provides a simple way to load sounds
	 */
	function SoundCreator() {
		var ajax = this.ajax = new Ajax();

		this.soundHandler = new SoundHandler(
			{},
			function (ref, options) {
				return ajax.load(ref, options ? options.noCache : false);
			},
			function () {},
			function (ref, options) {
				return ajax.load(ref, options ? options.noCache : false);
			}
		);
	}

	/**
	 * Releases any references to cached objects
	 */
	SoundCreator.prototype.clear = function () {
		this.ajax.clear();
		this.soundHandler.clear();
	};

	/**
	 * Load a sound.
	 * @param  {string}   url
	 * @param  {Object}   settings
	 * @returns {RSVP.Promise}
	 */
	SoundCreator.prototype.loadSound = function (url, settings) {
		if (!AudioContext.isSupported()) {
			return PromiseUtils.reject(new Error('AudioContext is not supported!'));
		}

		var id = StringUtils.createUniqueId('sound');
		settings = settings || {};
		settings.audioRefs = {};

		var fileExtension = StringUtils.getAfterLast(url, '.');
		settings.audioRefs[fileExtension] = url;

		var sound = this.soundHandler._create();
		this.soundHandler._objects.set(id, sound);

		return this.soundHandler.update(id, settings, {});
	};

	module.exports = SoundCreator;


/***/ },
/* 375 */
/***/ function(module, exports, __webpack_require__) {

	var Vector2 = __webpack_require__(19);
	var Vector3 = __webpack_require__(8);
	var Vector4 = __webpack_require__(11);

	/**
	 * Describes a cubic spline
	 * @param {Array<Vector>} controlPoints
	 */
	function Spline(controlPoints) {
		// array of any sort of Vector
		this.controlPoints = controlPoints;
		this.segments = (this.controlPoints.length - 1) / 3;
	}

	(function () {
		// should be of the same type as p0, p1, p2
		var term0_v4 = new Vector4();
		var term1_v4 = new Vector4();
		var term2_v4 = new Vector4();

		var term0_v3 = new Vector3();
		var term1_v3 = new Vector3();
		var term2_v3 = new Vector3();

		var term0_v2 = new Vector2();
		var term1_v2 = new Vector2();
		var term2_v2 = new Vector2();

		/**
		 * Interpolate on a quadratic Bezier curve
		 * @param {Vector} p0 First control point
		 * @param {Vector} p1 Second control point
		 * @param {Vector} p2 Third control point
		 * @param {number} t Takes values between 0 and 1
		 * @param {Vector} store Vector to store the result to
		 */
		Spline.quadraticInterpolation = function (p0, p1, p2, t, store) {
			// B(t) =
			// (1 - t)^2 * P0 +
			// 2 * (1 - t) * t * P1 +
			// t^2 * P2

			var t2 = t * t;

			var it = 1 - t;
			var it2 = it * it;

			if (store instanceof Vector4) {
				p0.copyTo(term0_v4);
				term0_v4.scale(it2);

				p1.copyTo(term1_v4);
				term1_v4.scale(it * t * 2);

				p2.copyTo(term2_v4);
				term2_v4.scale(t2);

				store.set(term0_v4).add(term1_v4).add(term2_v4);
			} else if (store instanceof Vector3) {
				p0.copyTo(term0_v3);
				term0_v3.scale(it2);

				p1.copyTo(term1_v3);
				term1_v3.scale(it * t * 2);

				p2.copyTo(term2_v3);
				term2_v3.scale(t2);

				store.set(term0_v3).add(term1_v3).add(term2_v3);
			} else if (store instanceof Vector2) {
				p0.copyTo(term0_v2);
				term0_v2.scale(it2);

				p1.copyTo(term1_v2);
				term1_v2.scale(it * t * 2);

				p2.copyTo(term2_v2);
				term2_v2.scale(t2);

				store.set(term0_v2).add(term1_v2).add(term2_v2);
			}
		};
	})();

	(function () {
		// should be of the same type as p0, p1, p2, p3
		var term0_v4 = new Vector4();
		var term1_v4 = new Vector4();
		var term2_v4 = new Vector4();
		var term3_v4 = new Vector4();

		var term0_v3 = new Vector3();
		var term1_v3 = new Vector3();
		var term2_v3 = new Vector3();
		var term3_v3 = new Vector3();

		var term0_v2 = new Vector2();
		var term1_v2 = new Vector2();
		var term2_v2 = new Vector2();
		var term3_v2 = new Vector2();

		/**
		 * Interpolate on a quadratic Bezier curve
		 * @param {Vector} p0 First control point
		 * @param {Vector} p1 Second control point
		 * @param {Vector} p2 Third control point
		 * @param {Vector} p3 Fourth control point
		 * @param {number} t Takes values between 0 and 1
		 * @param {Vector} store Vector to store the result to
		 */
		Spline.cubicInterpolation = function (p0, p1, p2, p3, t, store) {
			// B(t) =
			// (1 - t)^3 * P0 +
			// 3 * (1 - t)^2 * t * P1 +
			// 3 * (1 - t) * t^2 * P2 +
			// t^3 * P3

			var t2 = t * t;
			var t3 = t2 * t;

			var it = 1 - t;
			var it2 = it * it;
			var it3 = it2 * it;

			if (store instanceof Vector4) {
				p0.copyTo(term0_v4);
				term0_v4.scale(it3);

				p1.copyTo(term1_v4);
				term1_v4.scale(it2 * t * 3);

				p2.copyTo(term2_v4);
				term2_v4.scale(it * t2 * 3);

				p3.copyTo(term3_v4);
				term3_v4.scale(t3);

				store.set(term0_v4).add(term1_v4).add(term2_v4).add(term3_v4);
			} else if (store instanceof Vector3) {
				p0.copyTo(term0_v3);
				term0_v3.scale(it3);

				p1.copyTo(term1_v3);
				term1_v3.scale(it2 * t * 3);

				p2.copyTo(term2_v3);
				term2_v3.scale(it * t2 * 3);

				p3.copyTo(term3_v3);
				term3_v3.scale(t3);

				store.set(term0_v3).add(term1_v3).add(term2_v3).add(term3_v3);
			} else if (store instanceof Vector2) {
				p0.copyTo(term0_v2);
				term0_v2.scale(it3);

				p1.copyTo(term1_v2);
				term1_v2.scale(it2 * t * 3);

				p2.copyTo(term2_v2);
				term2_v2.scale(it * t2 * 3);

				p3.copyTo(term3_v2);
				term3_v2.scale(t3);

				store.set(term0_v2).add(term1_v2).add(term2_v2).add(term3_v2);
			}
		};
	})();

	/**
	 * Stores the coordinates of the point on the spline at a given t
	 * @param {number} t Takes values between 0 and 1
	 * @param {Vector} store A vector to store the result in
	 */
	Spline.prototype.getPoint = function (t, store) {
		if (t <= 0) {
			store.set(this.controlPoints[0]);
			return;
		} else if (t >= 1) {
			store.set(this.controlPoints[this.controlPoints.length - 1]);
			return;
		}

		var point = this.segments * t;
		var index = Math.floor(point);
		var fraction = point - index;

		var p0 = this.controlPoints[index * 3 + 0];
		var p1 = this.controlPoints[index * 3 + 1];
		var p2 = this.controlPoints[index * 3 + 2];
		var p3 = this.controlPoints[index * 3 + 3];

		Spline.cubicInterpolation(p0, p1, p2, p3, fraction, store);
	};

	module.exports = Spline;


/***/ },
/* 376 */
/***/ function(module, exports, __webpack_require__) {

	var Spline = __webpack_require__(375);

	/**
	 * Provides a way to interpolate on a spline with constant speed
	 * @param {Spline} spline Spline to interpolate across
	 * @param {number} [substepSize=0.01] substepSize The size of the substep used to approximate movement across the spline.
	 * Small values of this parameter lead to more substeps and better precision (at the cost of more computations).
	 * @example-link http://code.gooengine.com/latest/visual-test/./SplineWalker/SplineWalker-vtest.html Comparison or normal interpolation vs using the SplineWalker
	 */
	function SplineWalker(spline, substepSize) {
		this.substepSize = substepSize || 0.01;
		this._spline = spline;
		this._segment = 0;
		this._localT = 0;
		this._pointer = spline.controlPoints[0].clone();
	}

	/**
	 * Performs interpolation according to the internal state
	 * @private
	 * @param {Vector} store
	 */
	SplineWalker.prototype._localInterpolation = function (store) {
		var p0 = this._spline.controlPoints[this._segment * 3 + 0];
		var p1 = this._spline.controlPoints[this._segment * 3 + 1];
		var p2 = this._spline.controlPoints[this._segment * 3 + 2];
		var p3 = this._spline.controlPoints[this._segment * 3 + 3];
		Spline.cubicInterpolation(p0, p1, p2, p3, this._localT, store);
	};

	/**
	 * Performs a step and updates the internal state
	 * @private
	 * @param {Vector} stepSize
	 * @param {Vector} store
	 */
	SplineWalker.prototype._step = function (stepSize, store) {
		this._localT += stepSize;

		if (this._localT > 1) {
			this._localT -= 1;
			this._segment++;

			if (this._segment >= this._spline.segments) {
				store.copy(this._spline.controlPoints[this._spline.controlPoints.length - 1]);
				return;
			}
		}

		this._localInterpolation(store);
	};

	/**
	 * Advances the walker by the provided distance and store the new location in the second parameter
	 * @param {number} distance Distance to "walk" on the spline; must be positive
	 * @param {Vector} store The vector to use to store the resulting position; must have the same type as the control points of the spline
	 */
	SplineWalker.prototype.advance = function (distance, store) {
		var walkedSoFar = 0;
		while (walkedSoFar < distance && this._segment < this._spline.segments) {
			this._step(this.substepSize, store);
			walkedSoFar += this._pointer.distance(store);
			this._pointer.copy(store);
		}
	};

	/**
	 * Returns whether the walker can still advance on the spline
	 * @returns {boolean}
	 */
	SplineWalker.prototype.canWalk = function () {
		return this._segment < this._spline.segments;
	};

	module.exports = SplineWalker;


/***/ },
/* 377 */
/***/ function(module, exports, __webpack_require__) {

	var StringUtils = __webpack_require__(36);

	/**
	 * String-related utilities
	 * @target-class StringUtil StringUtil constructor
	 * @require-pathvar StringUtil = require('../util/StringUtil');
	 * @group util
	 * @deprecated Deprecated as of 0.14.x and scheduled for removal in 0.16.0; The class has been renamed to `goo/util/StringUtils`
	 */
	module.exports = StringUtils;

/***/ },
/* 378 */
/***/ function(module, exports, __webpack_require__) {

	var Component = __webpack_require__(20);

	/**
	 * Provides ways for the entity to display text
	 * @extends Component
	 * @example-link http://code.gooengine.com/latest/visual-test/goo/entities/components/TextComponent/TextComponent-vtest.html Working example
	 */
	function TextComponent(text) {
		Component.apply(this, arguments);

		this.type = 'TextComponent';

		this.text = text || '';
		this.dirty = true;

		// @ifdef DEBUG
		Object.seal(this);
		// @endif
	}

	TextComponent.type = 'TextComponent';

	TextComponent.prototype = Object.create(Component.prototype);
	TextComponent.prototype.constructor = TextComponent;

	/**
	 * Text to update to
	 * @param {string} text
	 * @returns {TextComponent} Self for chaining
	 */
	TextComponent.prototype.setText = function (text) {
		if (this.text !== text) {
			this.text = text;
			this.dirty = true;
		}
		return this;
	};

	module.exports = TextComponent;

/***/ },
/* 379 */
/***/ function(module, exports, __webpack_require__) {

	var System = __webpack_require__(42);
	var TextureGrid = __webpack_require__(380);
	var MeshDataComponent = __webpack_require__(216);

	/**
	 * Processes all entities with a text component<br>
	 * @example-link http://code.gooengine.com/latest/visual-test/goo/entities/components/TextComponent/TextComponent-vtest.html Working example
	 * @extends System
	 */
	function TextSystem() {
		System.call(this, 'TextSystem', ['TextComponent']);
	}

	TextSystem.prototype = Object.create(System.prototype);
	TextSystem.prototype.constructor = TextSystem;

	TextSystem.prototype.process = function (entities) {
		for (var i = 0; i < entities.length; i++) {
			var entity = entities[i];
			var textComponent = entity.textComponent;
			if (textComponent.dirty) {
				if (entity.hasComponent('MeshDataComponent')) {
					entity.getComponent('MeshDataComponent').meshData = TextureGrid.fromString(textComponent.text);
				}
				else {
					var meshData = TextureGrid.fromString(textComponent.text);
					var meshDataComponent = new MeshDataComponent(meshData);
					entity.setComponent(meshDataComponent);
				}
				this.dirty = false;
			}
		}
	};

	module.exports = TextSystem;

/***/ },
/* 380 */
/***/ function(module, exports, __webpack_require__) {

	var MeshData = __webpack_require__(14);
	var ObjectUtils = __webpack_require__(6);

	/**
	 * Meshdata for a grid; useful for displaying tiles
	 * @extends MeshData
	 * @param matrix
	 * @param textureUnitsPerLine
	 */
	function TextureGrid(matrix, textureUnitsPerLine) {
		this.matrix = matrix;
		this.textureUnitsPerLine = textureUnitsPerLine || 8;

		var attributeMap = MeshData.defaultMap([MeshData.POSITION, MeshData.NORMAL, MeshData.TEXCOORD0]);
		var nCells = countCells(matrix);
		MeshData.call(this, attributeMap, nCells * 4, nCells * 6);

		this.rebuild();
	}

	TextureGrid.prototype = Object.create(MeshData.prototype);
	TextureGrid.prototype.constructor = TextureGrid;

	function countCells(matrix) {
		var count = 0;
		for (var i = 0; i < matrix.length; i++) {
			count += matrix[i].length;
		}
		return count;
	}

	/**
	 * Builds or rebuilds the mesh data.
	 * @returns {TextureGrid} Self for chaining.
	 */
	TextureGrid.prototype.rebuild = function () {
		var verts = [];
		var norms = [];
		var indices = [];
		var tex = [];

		var indexCounter = 0;
		var halfHeight = this.matrix.length / 2;
		for (var i = 0; i < this.matrix.length; i++) {
			var halfWidth = this.matrix[i].length / 2;
			for (var j = 0; j < this.matrix[i].length; j++) {
				verts.push(
					j - halfWidth, -i - 1 + halfHeight, 0,
					j - halfWidth, -i + halfHeight, 0,
					j + 1 - halfWidth, -i + halfHeight, 0,
					j + 1 - halfWidth, -i - 1 + halfHeight, 0
				);

				norms.push(
					0, 0, 1,
					0, 0, 1,
					0, 0, 1,
					0, 0, 1
				);

				var texX = (this.matrix[i][j] % this.textureUnitsPerLine) / this.textureUnitsPerLine;
				var texY = Math.floor(this.matrix[i][j] / this.textureUnitsPerLine) / this.textureUnitsPerLine;
				texY = 1 - texY;

				tex.push(
					texX, texY - 1 / this.textureUnitsPerLine,
					texX, texY,
					texX + 1 / this.textureUnitsPerLine, texY,
					texX + 1 / this.textureUnitsPerLine, texY - 1 / this.textureUnitsPerLine
				);

				indices.push(
					indexCounter + 3, indexCounter + 1, indexCounter + 0,
					indexCounter + 2, indexCounter + 1, indexCounter + 3
				);

				indexCounter += 4;
			}
		}

		this.getAttributeBuffer(MeshData.POSITION).set(verts);
		this.getAttributeBuffer(MeshData.NORMAL).set(norms);
		this.getAttributeBuffer(MeshData.TEXCOORD0).set(tex);

		this.getIndexBuffer().set(indices);

		return this;
	};

	/**
	 * Returns a clone of this texture grid
	 * @returns {TextureGrid}
	 */
	TextureGrid.prototype.clone = function () {
		var options = ObjectUtils.shallowSelectiveClone(this, ['matrix', 'textureUnitsPerLine']);

		return new TextureGrid(options);
	};

	function stringToMatrix(str) {
		var matrix = [];
		var lineAr = str.split('\n');
		lineAr.forEach(function (line) {
			var charAr = line.split('');
			var matrixLine = charAr.map(function (ch) {
				return ch.charCodeAt(0);
			});
			matrix.push(matrixLine);
		});
		return matrix;
	}

	TextureGrid.fromString = function (str) {
		return new TextureGrid(stringToMatrix(str), 16);
	};

	module.exports = TextureGrid;

/***/ },
/* 381 */
/***/ function(module, exports, __webpack_require__) {

	var Noise = __webpack_require__(364);

	/**
	 * Value noise is simpler and computationally lighter than Perlin noise yet produce visually similar results when used in fractals.
	 *  Only used to define the class. Should never be instantiated.
	 */
	function ValueNoise() {
		Noise.call(this);
	}

	ValueNoise.prototype = Object.create(Noise.prototype);
	ValueNoise.prototype.constructor = ValueNoise;

	ValueNoise.sources = [
		0.0 / 15.0, 1.0 / 15.0, 2.0 / 15.0, 3.0 / 15.0, 4.0 / 15.0,
		5.0 / 15.0, 6.0 / 15.0, 7.0 / 15.0, 8.0 / 15.0, 9.0 / 15.0,
		10.0 / 15.0, 11.0 / 15.0, 12.0 / 15.0, 13.0 / 15.0, 14.0 / 15.0,
		15.0 / 15.0
	];

	/**
	 * Evaluates the one-dimensional value noise function at a specific position.
	 * @param {Float} px Evaluation position x.
	 * @param {Float} scale Base scale. Greater scale values will pull the sources (hills and valleys) further apart.
	 * @returns {Float} Noise value.
	 */
	ValueNoise.evaluate1d = function (px, scale) {
		var x = Noise.split(px / scale);

		var i0000 = Noise.shifter[x.i0 & 0xFF] & 0x0F;
		var i0001 = Noise.shifter[x.i1 & 0xFF] & 0x0F;

		var result = 0.0;

		result += x.f0 * ValueNoise.sources[i0000];
		result += x.f1 * ValueNoise.sources[i0001];

		return result;
	};

	/**
	 * Evaluates the two-dimensional value noise function at a specific position.
	 * @param {Float} px Evaluation position x.
	 * @param {Float} py Evaluation position y.
	 * @param {Float} scale Base scale. Greater scale values will pull the sources (hills and valleys) further apart.
	 * @returns {Float} Noise value.
	 */
	ValueNoise.evaluate2d = function (px, py, scale) {
		var x = Noise.split(px / scale);
		var y = Noise.split(py / scale);

		var i0000 = Noise.shifter[Noise.shifter[y.i0 & 0xFF] + x.i0 & 0xFF] & 0x0F;
		var i0001 = Noise.shifter[Noise.shifter[y.i0 & 0xFF] + x.i1 & 0xFF] & 0x0F;
		var i0010 = Noise.shifter[Noise.shifter[y.i1 & 0xFF] + x.i0 & 0xFF] & 0x0F;
		var i0011 = Noise.shifter[Noise.shifter[y.i1 & 0xFF] + x.i1 & 0xFF] & 0x0F;

		var result = 0.0;

		result += y.f0 * x.f0 * ValueNoise.sources[i0000];
		result += y.f0 * x.f1 * ValueNoise.sources[i0001];
		result += y.f1 * x.f0 * ValueNoise.sources[i0010];
		result += y.f1 * x.f1 * ValueNoise.sources[i0011];

		return result;
	};

	/**
	 * Evaluates the three-dimensional value noise function at a specific position.
	 * @param {Float} px Evaluation position x.
	 * @param {Float} py Evaluation position y.
	 * @param {Float} pz Evaluation position z.
	 * @param {Float} scale Base scale. Greater scale values will pull the sources (hills and valleys) further apart.
	 * @returns {Float} Noise value.
	 */
	ValueNoise.evaluate3d = function (px, py, pz, scale) {
		var x = Noise.split(px / scale);
		var y = Noise.split(py / scale);
		var z = Noise.split(pz / scale);

		var i0000 = Noise.shifter[Noise.shifter[Noise.shifter[z.i0 & 0xFF] + y.i0 & 0xFF] + x.i0 & 0xFF] & 0x0F;
		var i0001 = Noise.shifter[Noise.shifter[Noise.shifter[z.i0 & 0xFF] + y.i0 & 0xFF] + x.i1 & 0xFF] & 0x0F;
		var i0010 = Noise.shifter[Noise.shifter[Noise.shifter[z.i0 & 0xFF] + y.i1 & 0xFF] + x.i0 & 0xFF] & 0x0F;
		var i0011 = Noise.shifter[Noise.shifter[Noise.shifter[z.i0 & 0xFF] + y.i1 & 0xFF] + x.i1 & 0xFF] & 0x0F;
		var i0100 = Noise.shifter[Noise.shifter[Noise.shifter[z.i1 & 0xFF] + y.i0 & 0xFF] + x.i0 & 0xFF] & 0x0F;
		var i0101 = Noise.shifter[Noise.shifter[Noise.shifter[z.i1 & 0xFF] + y.i0 & 0xFF] + x.i1 & 0xFF] & 0x0F;
		var i0110 = Noise.shifter[Noise.shifter[Noise.shifter[z.i1 & 0xFF] + y.i1 & 0xFF] + x.i0 & 0xFF] & 0x0F;
		var i0111 = Noise.shifter[Noise.shifter[Noise.shifter[z.i1 & 0xFF] + y.i1 & 0xFF] + x.i1 & 0xFF] & 0x0F;

		var result = 0.0;

		result += z.f0 * y.f0 * x.f0 * ValueNoise.sources[i0000];
		result += z.f0 * y.f0 * x.f1 * ValueNoise.sources[i0001];
		result += z.f0 * y.f1 * x.f0 * ValueNoise.sources[i0010];
		result += z.f0 * y.f1 * x.f1 * ValueNoise.sources[i0011];
		result += z.f1 * y.f0 * x.f0 * ValueNoise.sources[i0100];
		result += z.f1 * y.f0 * x.f1 * ValueNoise.sources[i0101];
		result += z.f1 * y.f1 * x.f0 * ValueNoise.sources[i0110];
		result += z.f1 * y.f1 * x.f1 * ValueNoise.sources[i0111];

		return result;
	};

	/**
	 * Evaluates the four-dimensional value noise function at a specific position.
	 * @param {Float} px Evaluation position x.
	 * @param {Float} py Evaluation position y.
	 * @param {Float} pz Evaluation position z.
	 * @param {Float} pw Evaluation position w.
	 * @param {Float} scale Base scale. Greater scale values will pull the sources (hills and valleys) further apart.
	 * @returns {Float} Noise value.
	 */
	ValueNoise.evaluate4d = function (px, py, pz, pw, scale) {
		var x = Noise.split(px / scale);
		var y = Noise.split(py / scale);
		var z = Noise.split(pz / scale);
		var w = Noise.split(pw / scale);

		var i0000 = Noise.shifter[Noise.shifter[Noise.shifter[Noise.shifter[w.i0 & 0xFF] + z.i0 & 0xFF] + y.i0 & 0xFF] + x.i0 & 0xFF] & 0x0F;
		var i0001 = Noise.shifter[Noise.shifter[Noise.shifter[Noise.shifter[w.i0 & 0xFF] + z.i0 & 0xFF] + y.i0 & 0xFF] + x.i1 & 0xFF] & 0x0F;
		var i0010 = Noise.shifter[Noise.shifter[Noise.shifter[Noise.shifter[w.i0 & 0xFF] + z.i0 & 0xFF] + y.i1 & 0xFF] + x.i0 & 0xFF] & 0x0F;
		var i0011 = Noise.shifter[Noise.shifter[Noise.shifter[Noise.shifter[w.i0 & 0xFF] + z.i0 & 0xFF] + y.i1 & 0xFF] + x.i1 & 0xFF] & 0x0F;
		var i0100 = Noise.shifter[Noise.shifter[Noise.shifter[Noise.shifter[w.i0 & 0xFF] + z.i1 & 0xFF] + y.i0 & 0xFF] + x.i0 & 0xFF] & 0x0F;
		var i0101 = Noise.shifter[Noise.shifter[Noise.shifter[Noise.shifter[w.i0 & 0xFF] + z.i1 & 0xFF] + y.i0 & 0xFF] + x.i1 & 0xFF] & 0x0F;
		var i0110 = Noise.shifter[Noise.shifter[Noise.shifter[Noise.shifter[w.i0 & 0xFF] + z.i1 & 0xFF] + y.i1 & 0xFF] + x.i0 & 0xFF] & 0x0F;
		var i0111 = Noise.shifter[Noise.shifter[Noise.shifter[Noise.shifter[w.i0 & 0xFF] + z.i1 & 0xFF] + y.i1 & 0xFF] + x.i1 & 0xFF] & 0x0F;
		var i1000 = Noise.shifter[Noise.shifter[Noise.shifter[Noise.shifter[w.i1 & 0xFF] + z.i0 & 0xFF] + y.i0 & 0xFF] + x.i0 & 0xFF] & 0x0F;
		var i1001 = Noise.shifter[Noise.shifter[Noise.shifter[Noise.shifter[w.i1 & 0xFF] + z.i0 & 0xFF] + y.i0 & 0xFF] + x.i1 & 0xFF] & 0x0F;
		var i1010 = Noise.shifter[Noise.shifter[Noise.shifter[Noise.shifter[w.i1 & 0xFF] + z.i0 & 0xFF] + y.i1 & 0xFF] + x.i0 & 0xFF] & 0x0F;
		var i1011 = Noise.shifter[Noise.shifter[Noise.shifter[Noise.shifter[w.i1 & 0xFF] + z.i0 & 0xFF] + y.i1 & 0xFF] + x.i1 & 0xFF] & 0x0F;
		var i1100 = Noise.shifter[Noise.shifter[Noise.shifter[Noise.shifter[w.i1 & 0xFF] + z.i1 & 0xFF] + y.i0 & 0xFF] + x.i0 & 0xFF] & 0x0F;
		var i1101 = Noise.shifter[Noise.shifter[Noise.shifter[Noise.shifter[w.i1 & 0xFF] + z.i1 & 0xFF] + y.i0 & 0xFF] + x.i1 & 0xFF] & 0x0F;
		var i1110 = Noise.shifter[Noise.shifter[Noise.shifter[Noise.shifter[w.i1 & 0xFF] + z.i1 & 0xFF] + y.i1 & 0xFF] + x.i0 & 0xFF] & 0x0F;
		var i1111 = Noise.shifter[Noise.shifter[Noise.shifter[Noise.shifter[w.i1 & 0xFF] + z.i1 & 0xFF] + y.i1 & 0xFF] + x.i1 & 0xFF] & 0x0F;

		var result = 0.0;

		result += w.f0 * z.f0 * y.f0 * x.f0 * ValueNoise.sources[i0000];
		result += w.f0 * z.f0 * y.f0 * x.f1 * ValueNoise.sources[i0001];
		result += w.f0 * z.f0 * y.f1 * x.f0 * ValueNoise.sources[i0010];
		result += w.f0 * z.f0 * y.f1 * x.f1 * ValueNoise.sources[i0011];
		result += w.f0 * z.f1 * y.f0 * x.f0 * ValueNoise.sources[i0100];
		result += w.f0 * z.f1 * y.f0 * x.f1 * ValueNoise.sources[i0101];
		result += w.f0 * z.f1 * y.f1 * x.f0 * ValueNoise.sources[i0110];
		result += w.f0 * z.f1 * y.f1 * x.f1 * ValueNoise.sources[i0111];
		result += w.f1 * z.f0 * y.f0 * x.f0 * ValueNoise.sources[i1000];
		result += w.f1 * z.f0 * y.f0 * x.f1 * ValueNoise.sources[i1001];
		result += w.f1 * z.f0 * y.f1 * x.f0 * ValueNoise.sources[i1010];
		result += w.f1 * z.f0 * y.f1 * x.f1 * ValueNoise.sources[i1011];
		result += w.f1 * z.f1 * y.f0 * x.f0 * ValueNoise.sources[i1100];
		result += w.f1 * z.f1 * y.f0 * x.f1 * ValueNoise.sources[i1101];
		result += w.f1 * z.f1 * y.f1 * x.f0 * ValueNoise.sources[i1110];
		result += w.f1 * z.f1 * y.f1 * x.f1 * ValueNoise.sources[i1111];

		return result;
	};

	module.exports = ValueNoise;


/***/ }
/******/ ]);
